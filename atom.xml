<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>dev and dev</title>
  
  <subtitle>내가 볼려고 만든 깃헙 블로그</subtitle>
  <link href="https://joontae-kim.github.io/atom.xml" rel="self"/>
  
  <link href="https://joontae-kim.github.io/"/>
  <updated>2021-08-06T12:13:15.408Z</updated>
  <id>https://joontae-kim.github.io/</id>
  
  <author>
    <name>Joontae Kim</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>프론트엔드 면접 질문 리스트 - JS</title>
    <link href="https://joontae-kim.github.io/2021/07/22/interview-question-js-2/"/>
    <id>https://joontae-kim.github.io/2021/07/22/interview-question-js-2/</id>
    <published>2021-07-22T07:17:30.000Z</published>
    <updated>2021-08-06T12:13:15.408Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/job_thumbnail.jpeg" alt="면접!"></p><h2 id="프론트엔드-면접-준비를-위한-질문-리스트-정리"><a href="#프론트엔드-면접-준비를-위한-질문-리스트-정리" class="headerlink" title="프론트엔드 면접 준비를 위한 질문 리스트 정리"></a>프론트엔드 면접 준비를 위한 질문 리스트 정리</h2><h3 id="Javascript"><a href="#Javascript" class="headerlink" title="Javascript"></a>Javascript</h3><p>아래질문 리스트를 기반으로 면접 질문 &amp; 답변 목록을 작성할 예정이고, 지속적으로 보충 or 보수할 계획입니다.</p><p>업데이트 날짜</p><ul><li>2020-10-26</li><li>2021-07-02<ul><li>질문 목록 수정</li></ul></li><li>2021-07-22</li><li>2021-07-26</li><li>2021-07-27<ul><li>질문 목록 및 답변 수정</li></ul></li></ul><h3 id="질문-목록"><a href="#질문-목록" class="headerlink" title="질문 목록"></a>질문 목록</h3><ol><li><p>ES6</p><ul><li>ES6 이상의 버전을 브라우저에서 인식하지 못한다면 어떻게 해결해야 하는지?</li><li>ES6 에서 추가된 스펙에 대해 아는대로 다 말해달라</li><li>Babel이란? babel은 컴파일러 인가 ? 트랜스파일러인가</li><li>Class 는 무엇이고, Prototype, fucntion의 ES5 스펙만으로 Class를 구현할수 있는가</li></ul></li><li><p>ES6에서 화살표 함수와 일반 함수의 차이는 무엇인가</p></li><li><p>구조 분해 할당(destructuring) 이란 무엇인가</p></li><li><p>spread 문법과 장점과 rest 문법은 무엇이며 차이점은 무엇인가</p></li><li><p>Javascript의 디자인 패턴에 대해 아는대로 설명해주세요.</p></li><li><p>모듈 패턴과 전통적 상속, 각각의 장단점을 설명해보시오.</p></li><li><p>호스트 객체(Host Objects)와 네이티브 객체(Native Objects)의 차이점은 무엇인가요?</p></li><li><p>이벤트 버블링, 이벤트 위임(delegation)에 대해서 설명해달라</p><ul><li>DOM (Document Object Model) 이벤트에 대한 질문</li></ul><ol start="9"><li>``document.write()` 는 언제 사용하나요 ?</li></ol></li><li><p>왜 <code>load</code> 이벤트와 같은 것을 사용하나요? 이 이벤트에는 단점이 있나요? 다른 대안을 알고 있나요? 알고 있다면 왜 그것을 사용할 건가요?</p><ul><li>document load event와 DOMContentLoaded event의 차이</li></ul></li><li><p>attribute와 property</p></li><li><p>use strict 은 무엇이고, 사용했을 때 장단점에 관해서 설명해주세요.</p></li><li><p>Functional Programming 이란 무엇인지 설명해주세요</p></li><li><p>고차함수 (High-Order Function)란 무엇인지 설명해주세요.</p></li><li><p>자바스크립트의 배열(Array)이 실제 자료구조 배열이 아닌데 그 이유는? </p></li><li><p>자바스크립트의 순환참조란? 어떤게 문제이고 해결방법은?</p></li><li><p>자바스크립트와 관련한 same-origin 정책에 대해 설명</p></li></ol><hr><h3 id="1-ES6"><a href="#1-ES6" class="headerlink" title="1. ES6"></a>1. ES6</h3><h4 id="ES6-이상의-버전을-브라우저에서-인식하지-못한다면-어떻게-해결해야-하는지"><a href="#ES6-이상의-버전을-브라우저에서-인식하지-못한다면-어떻게-해결해야-하는지" class="headerlink" title="ES6 이상의 버전을 브라우저에서 인식하지 못한다면 어떻게 해결해야 하는지?"></a>ES6 이상의 버전을 브라우저에서 인식하지 못한다면 어떻게 해결해야 하는지?</h4><blockquote><p> <em>최신 자바스크립트의 호환성 문제를 해결하는 방법에 대한 질문</em> </p></blockquote><p>브라우저 별로 구동원리 또는 JS엔진 등의 차이가 있기 때문에 브라우저 호환성 이슈가 발생하는데, 이러한 차이를 최소화해 런타임 환경에 맞게 최적화 하는 작업을 크로스 브라우징이라고 하는데, Javascript의 호환성에 따른 충돌이나 부작용을 줄이기 위한 방법으로는 Babel이라는 도구를 사용하면 됩니다. 바벨은 주로 ES5 이상 버전의 코드를 현재 및 과거의 브라우저와 같은 환경에서 호환되는 버전으로 변환하는데 사용되는 도구로, IE나 다른 브라우저에서 동일한 기능을 제공하고 side-effect를 최소한으로 줄일수 있습니다.</p><blockquote><p>바벨 공식 웹사이트에서는 바벨을 다음과 같이 정의한다.</p><p><strong><em>Babel is a toolchain that is mainly used to convert ECMAScript 2015+ code into a backwards compatible version of JavaScript in current and older browsers or environments.</em></strong> </p><p>바벨은 주로 ECMAScript 2015+ 코드를 현재 및 과거의 브라우저와 같은 환경에서 호환되는 버전으로 변환하는데 주로 사용되는 도구입니다.</p></blockquote><h4 id="babel은-컴파일러-인가-트랜스파일러인가"><a href="#babel은-컴파일러-인가-트랜스파일러인가" class="headerlink" title="babel은 컴파일러 인가 ? 트랜스파일러인가"></a>babel은 컴파일러 인가 ? 트랜스파일러인가</h4><p>Babel은 빌드 단계에서 Javascript를 다른 언어로 변환하는 것이 아닌 어플리케이션에서 설정된 환경에 맞게 또는 현재 사용하고 있는 대중적인 브라우저 스펙 또는 호환성에 맞는 하위 버전의 Javascript로 변환한다는 의미에서 Babel은 트랜스파일러라고 할 수 있습니다. </p><p>컴파일러와 트랜스파일러에 대해 설명하자면, </p><ul><li><p><strong>컴파일러</strong> 의 경우에는 한 언어도 작성된 코드를 다른 언어로 변환하는 것으로 C 코드로 개발된 코드를 Assembly 코드로 변환하는 것과 같고</p></li><li><p><strong>트랜스파일러</strong> 란 한 언어로 작성된 소스 코드를 비슷한 수준의 추상화를 가진 언어로 변환하는 것을 의미합니다.</p></li></ul><p>바벨의 빌드 단계를 설명하자면, 파싱, 변환, 출력의 단계로 코드를 변환하는데,</p><ol><li><strong>파싱</strong>: 코드를 읽고, 추상 구문 트리(AST)로 변환하는 단계</li><li><strong>변환</strong>: 추상 구문 트리(AST)를 변경</li><li><strong>출력</strong>:  변경된 결과물을 출력</li></ol><p>위와 같은 빌드 단계를 통해 Babel은 Javascript의 호환성 이슈를 해결합니다.</p><h4 id="그렇다면-바벨에서-코드를-변환하기-위한-규칙은-어떻게-설정하나"><a href="#그렇다면-바벨에서-코드를-변환하기-위한-규칙은-어떻게-설정하나" class="headerlink" title="그렇다면 바벨에서 코드를 변환하기 위한 규칙은 어떻게 설정하나"></a>그렇다면 바벨에서 코드를 변환하기 위한 규칙은 어떻게 설정하나</h4><p>바벨을 사용한다고 코드를 변환할 수 있다고 할수는 없으며 변환하기 위한 규칙이나 브라우저 버전을 설정해야 하는데 이 작업은 <strong>바벨 플러그인</strong> 이 담당합니다. <strong>바벨 플러그인</strong> 이란, 바벨이 변환할 코드에 대한 규칙으로 custom으로 Javascript의 기능에 따라 각각 설정하기에는 까다롭고 매우 많기 때문에,  <strong>preset</strong> 이라는 플러그인을 사용해 손쉽게 변환규칙을 설정해줄 수 있습니다. <strong>preset</strong> 이란 필요한 플러그인들을 목적에 따라 세트로 묶여 있는 플러그인으로 대표적인 프리셋 플러그인으로 <strong>preset-env</strong> 이 있으며 프로젝트가 지원하고자 하는 환경에 기반해 빌드 타임에 동적으로 결정하는 프리셋으로 ES6 이상의 코드를 변환합니다.</p><h4 id="크로스-브라우징-이슈를-해결하기-위해-플러그인을-설정해-호환가능한-버전으로-변환하지만-빌트인-메서드나-JS-기능이-없는-경우에는-어떻게-해결할-수-있는가"><a href="#크로스-브라우징-이슈를-해결하기-위해-플러그인을-설정해-호환가능한-버전으로-변환하지만-빌트인-메서드나-JS-기능이-없는-경우에는-어떻게-해결할-수-있는가" class="headerlink" title="크로스 브라우징 이슈를 해결하기 위해 플러그인을 설정해 호환가능한 버전으로 변환하지만 빌트인 메서드나 JS 기능이 없는 경우에는 어떻게 해결할 수 있는가?"></a>크로스 브라우징 이슈를 해결하기 위해 플러그인을 설정해 호환가능한 버전으로 변환하지만 빌트인 메서드나 JS 기능이 없는 경우에는 어떻게 해결할 수 있는가?</h4><p>빌드 과정에서 Babel을 통해 트랜스파일링 과정을 거쳤더라도 <code>Promise</code>와 같은 빌트인 또는 <code>Array.prototype.includes</code> 등의 인스턴스 메소드가 코드에 남아있을 수 있다. 해당 빌트인 또는 메서드를 지원하지 않는 환경에서는 에러를 유발하거나 어플리케이션이 멈추는 이슈가 발생하는데, 이를 해결하기 위한 기술이 <strong>폴리필 (Polyfill)</strong> 입니다. Babel 설정에서 폴리필을 설정하면, 최신 ECMAScript 환경을 만들기 위해 코드가 실행되는 환경에 존재하지 않는 빌트인 메서드 등을 추가해줍니다.</p><p>폴리필 전체를 빌드에 포함하면 번들 사이즈가 너무 커질수 있기 때문에, <strong>preset-env</strong> 의  <a href="https://babeljs.io/docs/en/babel-preset-env#usebuiltins"><code>useBuiltIns</code></a> 옵션을 사용하면 빌드 타임에 <code>babel-polyfill</code> import를 <em>꼭 필요한 폴리필 import로 대체해</em> 번들의 사이즈를 줄일 수 있습니다.</p><h4 id="ES6-에서-추가된-스펙에-대해-아는대로-다-말해달라"><a href="#ES6-에서-추가된-스펙에-대해-아는대로-다-말해달라" class="headerlink" title="ES6 에서 추가된 스펙에 대해 아는대로 다 말해달라"></a>ES6 에서 추가된 스펙에 대해 아는대로 다 말해달라</h4><ul><li><strong>ES5 (2009)</strong><ul><li>일반적으로 (구형 브라우저를 제외한) 모든 런타임에서 지원한다고 가정할 수 있는 Javascript의 기본 버전</li><li>Added <code>forEach, map, filter, reduce, some, every</code>  in Array Methods</li><li>Object getter &amp; setter</li><li>Added stricter standards to <code>strict mode</code></li><li>JSON</li></ul></li><li><strong>ES6 / ES2015</strong><ul><li>Standard Modules — <code>import</code> and <code>export</code></li><li>Standardised Promises</li><li>Classes &amp; Inheritance</li><li>Block-scoped variables — <code>let</code>and <code>const</code></li><li>Template Literals</li><li>Object destructing into variables</li><li>Generator functions</li><li>Map and Set data structures</li><li>Internationalisation for Strings, Numbers and Dates via <code>Intl</code> API</li><li>Arrow Function</li></ul></li><li><strong>ES7 / ES2016</strong><ul><li>Array.prototype.includes()</li><li>Numeric exponent (power of) operator <code>**</code></li></ul></li><li><strong>ES8 / ES2017</strong><ul><li>Async / Await Functions</li><li>Object.entries, Object.values Methods</li><li>String padding functions</li><li>Allow Trailing commas to function expression arguement</li></ul></li><li><strong>ES9 / ES2018</strong><ul><li>Object Rest/Spread <code>const obj = &#123; ...props &#125;;</code></li><li>Asynchronous Iteration <code>for await (...) &#123;</code></li><li>Promise <code>finally()</code> function</li><li>Regular expression enhancements (lookbehind, named groups)</li></ul></li><li><strong>ES10 / ES2019</strong><ul><li>Object.fromEntries</li><li>flat, flatMap</li><li>Symbol.description</li><li>optional catch</li></ul></li></ul><p><strong>ES2015/ES6</strong> 를 기준으로 수많은 편리한 메서드와 문법들이 추가되었고 개발자들은 보다 점차 높은 수준의 Javascript를 구사할 수 있게 되었으며 사용자들 또한 높은 수준의 기능들을 경험할 수 있게 되었다. </p><h4 id="Class-는-무엇이고-Prototype-fucntion의-ES5-스펙만으로-Class를-구현할수-있는가"><a href="#Class-는-무엇이고-Prototype-fucntion의-ES5-스펙만으로-Class를-구현할수-있는가" class="headerlink" title="Class 는 무엇이고, Prototype, fucntion의 ES5 스펙만으로 Class를 구현할수 있는가"></a>Class 는 무엇이고, Prototype, fucntion의 ES5 스펙만으로 Class를 구현할수 있는가</h4><p><em>둘 다 생성자 역할을 하지만 상속을 구현하는 방법에서 큰 차이가 있다.</em></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ES5 Function Constructor</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ES6 Class</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(name) &#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>아래는 상속을 구현한 코드. ES5 문법이 훨씬 더 길고 복잡하며 클래스 문법을 사용하면 간단하다.</p><p>ES5에서는 생성자 함수를 상속받기 위해서 prototype에 새 객체를 복사하는 등 여러가지 작업이 필요하지만 클래스는 그런 과정이 필요없다. <code>extends</code> 키워드로 상속받을 함수를 명시하고, <code>constructor</code> 메소드에서 <code>super(this)</code> 만 추가하면 된다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ES5 Function Constructor</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Student</span>(<span class="params">name, studentId</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// Call constructor of superclass to initialize superclass-derived members.</span></span><br><span class="line">  Person.call(<span class="built_in">this</span>, name);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Initialize subclass&#x27;s own members.</span></span><br><span class="line">  <span class="built_in">this</span>.studentId = studentId;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Student.prototype = <span class="built_in">Object</span>.create(Person.prototype);</span><br><span class="line">Student.prototype.constructor = Student;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ES6 Class</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">extends</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(name, studentId) &#123;</span><br><span class="line">    <span class="built_in">super</span>(name);</span><br><span class="line">    <span class="built_in">this</span>.studentId = studentId;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-ES6에서-화살표-함수와-일반-함수의-차이는-무엇인가"><a href="#2-ES6에서-화살표-함수와-일반-함수의-차이는-무엇인가" class="headerlink" title="2. ES6에서 화살표 함수와 일반 함수의 차이는 무엇인가"></a>2. ES6에서 화살표 함수와 일반 함수의 차이는 무엇인가</h3><ul><li><strong>일반 함수</strong> 는 함수를 선언할 때 <code>this</code> 에 바인딩할 객체가 정적으로 결정되는 것이 아니고, 함수를 호출할 때 함수가 어떻게 호출되었는지에 따라 <code>this</code> 에 바인딩할 객체가 동적으로 결정된다. </li><li><strong>화살표 함수</strong> 는 함수를 선언할 때 <code>this</code> 에 바인딩할 객체가 정적으로 결정된다. 화살표 함수 안에서의 <code>this</code> 는 화살표 함수를 포함한 스코프의 <code>this</code>를 가리킨다.</li></ul><h3 id="3-구조-분해-할당-destructuring-이란-무엇인가"><a href="#3-구조-분해-할당-destructuring-이란-무엇인가" class="headerlink" title="3. 구조 분해 할당(destructuring) 이란 무엇인가"></a>3. 구조 분해 할당(destructuring) 이란 무엇인가</h3><p><em>ES6에서 도입된 객체, 배열의 값을 추출해서 변수에 바로 할당할 수 있는 편리한 문법입니다</em></p><h4 id="디스트럭처링-destructuring-할당이란-무엇인가요"><a href="#디스트럭처링-destructuring-할당이란-무엇인가요" class="headerlink" title="디스트럭처링(destructuring) 할당이란 무엇인가요?"></a>디스트럭처링(destructuring) 할당이란 무엇인가요?</h4><p>디스트럭처링을 이용하면 배열의 요소나 객체의 속성을 배열 리터럴(literal)이나 객체 리터럴과 비슷한 문법을 이용해서 변수에 할당할 수 있습니다. 아주 간결한 문법입니다. 그러면서도 훨씬 더 명확합니다.</p><h4 id="배열-Destructuring"><a href="#배열-Destructuring" class="headerlink" title="배열 Destructuring"></a>배열 Destructuring</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 배열 내 요소의 직접 접근 변수 할당</span></span><br><span class="line"><span class="keyword">var</span> first = someArray[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">var</span> second = someArray[<span class="number">1</span>];</span><br><span class="line"><span class="keyword">var</span> third = someArray[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 디스트럭처링을 이용한 변수 할당</span></span><br><span class="line"><span class="keyword">var</span> [first, second, third] = someArray;</span><br></pre></td></tr></table></figure><p>위와 같이 배열의 각 요소를 외부 변수에 할당할 수 있으며 <strong>배열과 이터러블(iterable)</strong> 을 이용해 디스트럭처링을 하면 특정 멤버 이외의 멤버들은 하나의 변수에 할당할 수도 있으며 또는 마지막 멤버만을 외부 변수에 할당할 수도 있습니다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> [ first, second, ...others ] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"><span class="comment">// first: 1</span></span><br><span class="line"><span class="comment">// second: 2</span></span><br><span class="line"><span class="comment">// others: 3, 4, 5</span></span><br><span class="line"><span class="keyword">var</span> [,,third] = [<span class="string">&quot;foo&quot;</span>, <span class="string">&quot;bar&quot;</span>, <span class="string">&quot;baz&quot;</span>];</span><br><span class="line"><span class="built_in">console</span>.log(third);</span><br><span class="line"><span class="comment">// &quot;baz&quot;</span></span><br></pre></td></tr></table></figure><h4 id="객체-Destructuring"><a href="#객체-Destructuring" class="headerlink" title="객체 Destructuring"></a>객체 Destructuring</h4><p>객체를 디스트럭처링하면 변수에 객체의 속성값을 할당할 수 있습니다. 할당할 속성을 지정하고 그 속성값을 할당할 변수를 지정합니다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 기본 객체 디스트럭처링</span></span><br><span class="line"><span class="keyword">var</span> robotA = &#123; <span class="attr">name</span>: <span class="string">&quot;Bender&quot;</span> &#125;;</span><br><span class="line"><span class="keyword">var</span> robotB = &#123; <span class="attr">name</span>: <span class="string">&quot;Flexo&quot;</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> &#123; <span class="attr">name</span>: nameA &#125; = robotA;</span><br><span class="line"><span class="keyword">var</span> &#123; <span class="attr">name</span>: nameB &#125; = robotB;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(nameA, nameB);</span><br><span class="line"><span class="comment">// &quot;Bender&quot;, &quot;Flexo&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 중첩 객체 디스트럭처링</span></span><br><span class="line"><span class="keyword">var</span> complicatedObj = &#123;</span><br><span class="line">  arrayProp: [</span><br><span class="line">    <span class="string">&quot;Zapp&quot;</span>,</span><br><span class="line">    &#123; <span class="attr">second</span>: <span class="string">&quot;Brannigan&quot;</span> &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> &#123; <span class="attr">arrayProp</span>: [first, &#123; second &#125;] &#125; = complicatedObj;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(first, second);</span><br><span class="line"><span class="comment">// &quot;Zapp&quot;, &quot;Brannigan&quot;</span></span><br></pre></td></tr></table></figure><p>한가지 주의할 것은 객체를 디스트럭처링해서 선언되지 않은 변수에 할당하는 경우입니다 (<code>let</code>, <code>const</code>, 또는 <code>var</code>를 함께 쓰지 않는 경우입니다).</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#123; blowUp &#125; = &#123; <span class="attr">blowUp</span>: <span class="number">10</span> &#125;;</span><br><span class="line"><span class="comment">// Syntax error</span></span><br></pre></td></tr></table></figure><p>이 구문이 에러를 일으키는 이유는 JavaScript 문법에 따라 엔진이 <code>&#123;</code>로 시작하는 모든 구문을 블록(block) 구문으로 해석하기 때문입니다. (예를 들어, <code>&#123; console &#125;</code> 은 유효한 블록 구문입니다). 구문 에러를 해결하는 방법은 문장 전체를 괄호로 감싸는 것입니다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(&#123; safe &#125; = &#123;&#125;);</span><br><span class="line"><span class="comment">// No errors</span></span><br></pre></td></tr></table></figure><h4 id="사용사례"><a href="#사용사례" class="headerlink" title="사용사례"></a>사용사례</h4><ul><li>함수의 인자 정의</li><li>설정 객체의 파라메터</li><li>다중 결과값을 반환하기</li></ul><p><strong>함수의 인자 정의</strong></p><p>개발자로서 API를 만들 때, 여러개의 속성을 가진 객체를 파라메터로 전달 받는 것이 좀 더 나은 접근입니다. 디스트럭처링을 이용하면 API 함수 안에서 파라메터 속성을 참조할 때마다 파라메터 객체를 반복해서 사용하는 것을 피할 수 있습니다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">removeBreakpoint</span>(<span class="params">&#123; url, line, column &#125;</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>설정 객체의 파라메터</strong></p><p>디스트럭처링하려는 객체의 속성에 디폴트 값을 줄 수도 있습니다. 이것은 설정값을 관리하는 객체가 있고, 각 설정값에 적절한 디폴트 값이 존재할 때 특히 도움이 됩니다. </p><p><strong>다중 결과값을 반환하기</strong></p><p>비록 여러개의 값을 리턴하는 기능이 랭귀지에 추가되지는 않았지만, 배열을 리턴하고 그 결과를 디스트럭처링할 수 있기 때문에 여러개의 값을 리턴하는 기능을 대신할 수 있습니다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">returnMultipleValues</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> [<span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> [foo, bar] = returnMultipleValues();</span><br><span class="line"><span class="comment">// foo: 1, bar: 2</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">returnMultipleValues</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    foo: <span class="number">3</span>,</span><br><span class="line">    bar: <span class="number">4</span></span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> &#123; foo, bar &#125; = returnMultipleValues();</span><br><span class="line"><span class="comment">// foo: 3, bar: 4</span></span><br></pre></td></tr></table></figure><h3 id="4-spread-문법과-장점과-rest-문법은-무엇이며-차이점은-무엇인가"><a href="#4-spread-문법과-장점과-rest-문법은-무엇이며-차이점은-무엇인가" class="headerlink" title="4. spread 문법과 장점과 rest 문법은 무엇이며 차이점은 무엇인가"></a>4. spread 문법과 장점과 rest 문법은 무엇이며 차이점은 무엇인가</h3><p><em>spread ⇒ 데이터를 풀어놓는다, rest ⇒ 전달받은 데이터를 배열, 객체 안에 채워넣는다</em></p><p>ES6의 전개(spread) 문법은 함수형 패러다임으로 코드를 작성할 때 매우 유용하다. 배열이나 객체의 복제본을 <code>Object.create</code> 나 <code>Array.prototype.slice</code> , 또는 라이브러리 함수를 사용하지 않고도 간단하게 만들 수 있기 때문이다. 이 문법은 Redux나 RxJS 를 사용하는 프로젝트에서 자주 사용된다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">putDookieInAnyArray</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> [...arr, <span class="string">&quot;dookie&quot;</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> result = putDookieInAnyArray([<span class="string">&quot;I&quot;</span>, <span class="string">&quot;really&quot;</span>, <span class="string">&quot;don&#x27;t&quot;</span>, <span class="string">&quot;like&quot;</span>]);</span><br><span class="line"><span class="comment">// [&quot;I&quot;, &quot;really&quot;, &quot;don&#x27;t&quot;, &quot;like&quot;, &quot;dookie&quot;]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> person = &#123;</span><br><span class="line">  name: <span class="string">&quot;Todd&quot;</span>,</span><br><span class="line">  age: <span class="number">29</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> copyOfTodd = &#123; ...person &#125;;</span><br><span class="line"><span class="comment">// &#123;name: &quot;Todd&quot;, age: 29&#125;</span></span><br></pre></td></tr></table></figure><p>ES6의 rest 문법은 함수에 전달된 파라미터를 배열로 만들 수 있는 간단한 문법이다. 이것은 마치 spread 문법을 반대로 해놓은 것 같다. <strong>spread가 배열 안에 있는 데이터를 펼쳐놓는다면, rest 문법은 데이터를 받아서 배열에 채워넣기 때문이다.</strong></p><p>이 문법은 함수 파라미터, 배열와 객체 destructuring에도 사용할 수 있다. destructuring에서 배열 데이터는 새로운 배열로, 객체 데이터는 새로운 객체로 만들어진다.</p><h3 id="5-Javascript의-디자인-패턴에-대해-아는대로-설명해주세요"><a href="#5-Javascript의-디자인-패턴에-대해-아는대로-설명해주세요" class="headerlink" title="5. Javascript의 디자인 패턴에 대해 아는대로 설명해주세요."></a>5. Javascript의 디자인 패턴에 대해 아는대로 설명해주세요.</h3><h4 id="디자인-패턴"><a href="#디자인-패턴" class="headerlink" title="디자인 패턴"></a>디자인 패턴</h4><p>디자인 패턴이란 무엇일까? 소프트웨어 개발을 하면서 발생하는 다양한 이슈들을 해결하는데 도움을 주는 일종의 증명된 기술들이다. 이미 많은 개발자들이 자바스크립트를 개발하면서 겪은 다양한 경험들을 바탕으로 만들어진 것들이다. 즉, 이런 상황에서는 이런 패턴을 사용하면 좋을거라는 일종의 방향성을 제시해준다. 패턴들은 정확한 해결책을 제공해주는 것이 아니다. 프레임워크나 라이브러리, 패턴 등은 그저 우리가 자바스크립트로 개발하는데 있어서 도움을 주는 도구일 뿐이고 이 패턴들을 어떻게 활용해서 어떤 식으로 개발한 것인지는 순전히 개발자의 역량에 달려있는 것이다.</p><h4 id="디자인-패턴-종류"><a href="#디자인-패턴-종류" class="headerlink" title="디자인 패턴 종류"></a>디자인 패턴 종류</h4><p>모듈 패턴, 싱글톤 패턴, 팩토리 패턴, Iterator 패턴, Decorator 패턴</p><h3 id="6-모듈-패턴과-전통적-상속-각각의-장단점을-설명해보시오"><a href="#6-모듈-패턴과-전통적-상속-각각의-장단점을-설명해보시오" class="headerlink" title="6. 모듈 패턴과 전통적 상속, 각각의 장단점을 설명해보시오."></a>6. 모듈 패턴과 전통적 상속, 각각의 장단점을 설명해보시오.</h3><h4 id="모듈-패턴"><a href="#모듈-패턴" class="headerlink" title="모듈 패턴"></a>모듈 패턴</h4><p>모듈 패턴(Module pattern)은 Javascript 디자인 패턴 중 하나로, <strong>클로저</strong> 개념을 이용해 구현할 수 있으며 객체를 <strong>public/private 개념으로 나누는 캡슐화 및 은닉화가 핵심</strong> 이다. 매우 기본적인 방법으로는 모든 코드를 익명함수로 감싸 내부 스코프를 생성하고, private method는 코드 접근을 제한할 수 있을뿐만 아니라 추가적인 자바스크립트가 다른 스크립트와 이름이 충돌하는 것을 막을 수 있다.</p><p>하지만 이렇게 하면 코드를 재사용하기 불편해지기 때문에 별도의 <strong>네임스페이스(namespace)</strong> 를 적용해야 한다. 이는 global 영역에 객체 고유의 영역을 지정하고 변수와 함수 할당에 해당 네임스페이스(namespace)의 하위에 둬 중복된 name으로 인한 오류를 피할 수 있다.</p><p>모듈 패턴을 작성함에 있어서 return 구문을 이용하여 공개/비공개 영역과 내부적으로 처리할 영역을 구분하여 공개여부를 선택할 수 있습니다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// namespace 패턴</span></span><br><span class="line"><span class="keyword">var</span> myApp = myApp || &#123;&#125;; <span class="comment">// 네임 스페이스 선언</span></span><br><span class="line"></span><br><span class="line">myApp.insanehong = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;insanehong&#x27;</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">myApp.helloworld = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;hello world&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 모듈 페턴</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> Messages = &#123;<span class="attr">h</span> : <span class="string">&#x27;hello&#x27;</span>, <span class="attr">w</span> : <span class="string">&#x27;world&#x27;</span>, <span class="attr">insane</span>:<span class="string">&#x27;insanehong&#x27;</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> myApp = (<span class="function"><span class="keyword">function</span>(<span class="params">msg</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> helloworld = msg.h+<span class="string">&#x27;  &#x27;</span>+msg.w;</span><br><span class="line">  <span class="keyword">var</span> helloinsanehong = msg.h+<span class="string">&#x27; &#x27;</span>+msg.insane;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> printInsane = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">     <span class="keyword">return</span> helloinsanehong;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> printhello = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> helloworld;</span><br><span class="line">  &#125;;  </span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    foo1 : printInsane,</span><br><span class="line">    foo2 : printhello</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">&#125;)(Messages);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(myApp.foo1());</span><br><span class="line">&gt; hello insanehong</span><br><span class="line"><span class="built_in">console</span>.log(myApp.helloworld);</span><br><span class="line">&gt; <span class="literal">undefined</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>모듈 패턴은 전역 영역에서 특정 변수영역을 보호하기 위해 단일 객체 안의 public/private의 변수를 포함할 수 있는 각 클래스 형식의 개념을 구현하는데 사용된다. 이 패턴으로 추가적인 자바스크립트 객체가 다른 스크립트의 객체와 충돌하는 것을 줄여줄 수 있다.</p><p><em>Before module pattern</em></p><ul><li>모듈 패턴을 사용하지 않으면 해당 객체가 모두 전역에서 인스턴스화 되어 다른 코드와 충돌 가능성이 높아진다.</li><li>객체 간의 연관성을 알기 어려워 코드관리가 어려우며 가용성이 떨어진다.</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> count = <span class="number">3</span></span><br><span class="line"><span class="keyword">const</span> publicMethod = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;Public Method : &#x27;</span>, count);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> publicMethod2 = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;Public Method2 : &#x27;</span>, count);</span><br><span class="line">&#125;</span><br><span class="line">publicMethod();</span><br><span class="line">publicMethod2();</span><br></pre></td></tr></table></figure><p><em>After module pattern</em></p><ul><li>은닉화, 다형성, 상속을 통해 객체지향적으로 코드를 구성할 수 있다.</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Module</span> </span>&#123;</span><br><span class="line">    private count: number = <span class="number">3</span></span><br><span class="line">    private privateMethod() &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;Private Method : &#x27;</span>, <span class="built_in">this</span>.count);</span><br><span class="line">    &#125;</span><br><span class="line">    publicMethod() &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;Public Method : &#x27;</span>, <span class="built_in">this</span>.count);</span><br><span class="line">    &#125;</span><br><span class="line">    public publicMethod2() &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;Public Method2 : &#x27;</span>, <span class="built_in">this</span>.count);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> mod = <span class="keyword">new</span> Module();</span><br><span class="line"><span class="comment">// mod.privateMethod(); // coudn&#x27;t access</span></span><br><span class="line">mod.publicMethod();</span><br><span class="line">mod.publicMethod2();</span><br></pre></td></tr></table></figure><h3 id="7-네이티브-객체-Native-Objects-호스트-객체-Host-Objects-Built-in-객체의-차이점은-무엇인가요"><a href="#7-네이티브-객체-Native-Objects-호스트-객체-Host-Objects-Built-in-객체의-차이점은-무엇인가요" class="headerlink" title="7. 네이티브 객체(Native Objects), 호스트 객체(Host Objects), Built-in 객체의 차이점은 무엇인가요?"></a>7. 네이티브 객체(Native Objects), 호스트 객체(Host Objects), Built-in 객체의 차이점은 무엇인가요?</h3><ul><li><p><strong>네이티브 객체</strong> 는 ECMAScript 명세에 정의된 브라우저 혹은 구동 엔진에 내장되어 있는 자바스크립트의 모든 엔진에 구현된 표준객체이다. 네이티브 객체는 built-in 객체와 달리 자바스크립트 엔진이 구성하고 있는 기본객체라고 하기보단 브라우저 혹은 사용되는 자바스크립트 엔진에 영향을 많이 받게 된다. BOM 이라는 브라우저 객체 모델과 DOM 이라는 문서 객체 모델이 네이티브 객체에 포함되는데 이 객체의 사용성이 이를 구현한 구동엔진에 따라 각기 다르게 존재하는 경우가 있기 때문에 크로스 브라우징에 문제를 발생시키기도 한다.</p></li><li><p><strong>호스트 객체</strong> 는 빌트인 객체와 네이티브객체에 포함되지 않은 사용자에 의해 생성된 객체를 의미한다. 자바스크립트 엔진은 빌트인 객체와 네이티브 객체를 구성한 이후 호스트객체를 해석하게 된다.</p></li><li><p><strong>Built-in</strong> 객체는 자바스크립트 엔진을 구성하는 기본 객체들을 포함한다. <code>Number</code>, <code>String</code>, <code>Array</code>, <code>Date</code> 등의 내장객체들이 있다</p></li></ul><h4 id="요약"><a href="#요약" class="headerlink" title="요약"></a>요약</h4><ul><li>네이티브 객체 : 브라우저 혹은 구동 엔진에 내장되어 있는 객체 DOM이 이에 해당 ⇒ 구동앤잔 별 사용성이 달라서 크로스 브라우징 문제를 바랭시키기도 함  </li><li>호스트 객체 : 빌트인 또는 네이티브 객체에 포함되지 않은 사용자에 의해 생성된 객체 ⇒ js는 빌트인 및 네이티브 객체 구성 후 호스트 객체를 해석</li></ul><h3 id="8-이벤트-버블링-이벤트-캡쳐링-이벤트-위임-delegation-딜리게이션-에-대해서-설명해달라"><a href="#8-이벤트-버블링-이벤트-캡쳐링-이벤트-위임-delegation-딜리게이션-에-대해서-설명해달라" class="headerlink" title="8. 이벤트 버블링, 이벤트 캡쳐링, 이벤트 위임(delegation, 딜리게이션)에 대해서 설명해달라"></a>8. 이벤트 버블링, 이벤트 캡쳐링, 이벤트 위임(delegation, 딜리게이션)에 대해서 설명해달라</h3><ul><li><strong>이벤트 버블링</strong>은 특정 화면 요소에서 이벤트가 발생했을 때 더 상위 요소들로 전달되어 가는 특성을 의미합니다.</li><li><strong>이벤트 캡처링</strong>은 이벤트 버블링과 반대로 상위 요소에서 하위 요소로 탐색하며 이벤트를 전파하는 방식입니다.</li><li><strong>이벤트 위임</strong>은 이벤트 리스너를 하위 요소에 추가하는 대신 상위 요소에 추가하는 기법입니다. 리스너는 DOM의 event bubbling으로 인해 하위 요소에서 이벤트가 발생될 때마다 실행됩니다. 이 기술의 이점은 다음과 같습니다.<ul><li>이 방법은 동적인 요소들에 대한 처리가 수월하며</li><li>이벤트 핸들러를 더 적게 등록해 주기 때문에 메모리도 절약할 수 있다.</li><li>각 하위 항목에 이벤트 핸들러를 연결하지 않고, 상위 요소에 하나의 단일 핸들러만 필요하기 때문에 제거된 요소에서 핸들러를 해제하고 새 요소에 대해 이벤트를 바인딩할 필요가 없습니다.</li></ul></li></ul><h4 id="이벤트-전파-방식"><a href="#이벤트-전파-방식" class="headerlink" title="이벤트 전파 방식"></a>이벤트 전파 방식</h4><ol><li>이벤트 발생(사용자 이벤트 혹은 강제 이벤트 할당:trigger)</li><li>이벤트 발생 객체를 찾기 위하여 하위 탐색(캡쳐)</li><li>이벤트 발생 객체 도달</li><li>하위 탐색의 역순으로 복귀(버블링)</li></ol><p>IE의 경우 위와 같은 탐색에서 캡션단계를 지원하지 않음으로 이벤트 핸들링은 버블링을 기준으로 작성되어야 한다.</p><p>어찌 되었건 이벤트가 발생한 타겟에서 시작하여 상위로 해당 이벤트가 계속 해서 전파되어 버린다. 이를 버블링이라하며 이와 같은 버블링으로 인한 오작동을 방지 하기 위해서는 <code>stopPropagation()</code> 을 이용하여 이벤트 전파를 차단해 주어야 한다.</p><h4 id="이벤트-흐름-Event-flow"><a href="#이벤트-흐름-Event-flow" class="headerlink" title="이벤트 흐름(Event flow)"></a>이벤트 흐름(Event flow)</h4><p>HTML 요소가 다른 요소의 내부에 중첩되어 있을 때 자식 요소를 클릭하면 부모 요소를 클릭한 셈이 된다. 이처럼 이벤트는 흐름을 가지고 있으며, 이것을 이벤트 흐름이라고 부른다. 이벤트 흐름에는 두 가지 방식이 있다. 먼저 이벤트 버블링(Event bubbling)은 이벤트가 직접적으로 발생한 노드로부터 시작해 바깥 노드로 이벤트가 퍼져 나가는 방식을 말한다. 대부분의 브라우저가 기본적으로 이 방식을 지원한다. 반대로 이벤트 캡쳐링(Event capturing)은 바깥 노드부터 시작해서 안쪽으로 퍼지는 방식이다. IE8 혹은 그 이전 버전에서는 지원되지 않는다.</p><h4 id="이벤트-위임-Case"><a href="#이벤트-위임-Case" class="headerlink" title="이벤트 위임 Case"></a>이벤트 위임 Case</h4><p>IE까지 고려한 코드다. 하나의 이벤트 리스너로 요소 3개를 제어하고 있다다. jQuery는 보다 편하게 이벤트를 바인딩할 수 있도록 <a href="http://api.jquery.com/delegate/"><code>.delegate()</code></a> 메소드를 제공하고 있다.</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span> <span class="attr">id</span>=<span class="string">&quot;todoList&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>TODO: A<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>TODO: B<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>TODO: C<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getTarget</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(!e) &#123; <span class="comment">// event 객체가 존재하지 않으면</span></span><br><span class="line">    e = <span class="built_in">window</span>.event; <span class="comment">// IE의 event 객체를 사용</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> e.target || e.srcElement; <span class="comment">// 이벤트가 발생한 요소를 가져옴</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">itemDone</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> elTarget, elParent;</span><br><span class="line"></span><br><span class="line">  elTarget = getTarget(e); <span class="comment">// 이벤트가 발생한 요소 가져옴 (li)</span></span><br><span class="line">  elParent = target.parentNode; <span class="comment">// 해당 요소의 부모 요소를 가져옴 (ul)</span></span><br><span class="line">  elParent.removeChild(elTarget); <span class="comment">// 이벤트가 발생한 요소를 제거함 (li)</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> el = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;todoList&#x27;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(el.addEventListener) &#123; <span class="comment">// 이벤트 리스너가 지원되면</span></span><br><span class="line">    el.addEventListener(<span class="string">&#x27;click&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123; <span class="comment">// 클릭 이벤트에 리스너를 지정</span></span><br><span class="line">      itemDone(e);</span><br><span class="line">    &#125;, <span class="literal">false</span>); <span class="comment">// 이벤트 버블링을 사용</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123; <span class="comment">// 이벤트 리스너가 지원되지 않으면</span></span><br><span class="line">    el.attachEvent(<span class="string">&#x27;onclick&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123; <span class="comment">// IE의 onclick 이벤트를 사용</span></span><br><span class="line">      itemDone(e);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure><h3 id="9-document-write-는-언제-사용하나요"><a href="#9-document-write-는-언제-사용하나요" class="headerlink" title="9. document.write() 는 언제 사용하나요 ?"></a>9. <code>document.write()</code> 는 언제 사용하나요 ?</h3><p><code>document.write()</code>는 <code>document.open()</code>에 의해 열린 문서 스트림에 텍스트 문자열을 씁니다. 페이지가 로드된 후에 <code>document.write()</code>가 실행되면 <code>document.open</code>을 호출하여 문서 전체를 지우고 (<code>&lt;head&gt;</code>와 <code>&lt;body&gt;</code>를 지웁니다!). 문자열로 주어진 매개 변수 값으로 대체합니다. 그러므로 일반적으로 위험하고 오용되기 쉽습니다.</p><p><code>document.write()</code>가 코드분석이나 <a href="https://www.quirksmode.org/blog/archives/2005/06/three_javascrip_1.html">JavaScript가 활성화된 경우에만 작동하는 스타일을 포함하고 싶을 때</a> 사용되는 경우를 설명하는 온라인 답변이 몇 가지 있습니다. 심지어 HTML5 보일러 플레이트에서 <a href="https://github.com/paulirish/html5-boilerplate/wiki/Script-Loading-Techniques#documentwrite-script-tag">스크립트를 병렬로 로드하고 실행 순서를 보존</a>할 때도 사용됩니다! 그러나, 저는 그 이유가 시대에 뒤떨어진 것으로 생각하고 있으며, 현재는 <code>document.write()</code>를 사용하지 않고도 할 수 있습니다.</p><h3 id="10-왜-load-이벤트와-같은-것을-사용하나요-이-이벤트에는-단점이-있나요-다른-대안을-알고-있나요-알고-있다면-왜-그것을-사용할-건가요"><a href="#10-왜-load-이벤트와-같은-것을-사용하나요-이-이벤트에는-단점이-있나요-다른-대안을-알고-있나요-알고-있다면-왜-그것을-사용할-건가요" class="headerlink" title="10. 왜 load 이벤트와 같은 것을 사용하나요? 이 이벤트에는 단점이 있나요? 다른 대안을 알고 있나요? 알고 있다면 왜 그것을 사용할 건가요?"></a>10. 왜 <code>load</code> 이벤트와 같은 것을 사용하나요? 이 이벤트에는 단점이 있나요? 다른 대안을 알고 있나요? 알고 있다면 왜 그것을 사용할 건가요?</h3><ul><li><code>document load event</code>와 <code>DOMContentLoaded event</code>에 대한 질문</li></ul><p>두 Event 모두 DOM 을 다루기 위한 이벤트 이다. 하지만 두 이벤트에는 큰 차이가 있다. DOM을 제어하는 스크립트는 마크업의 모든 요소에 대한 처리가 끝난 뒤에 로드되어야 한다. 그래서 보통 <code>&lt;body&gt;</code> 태그 최하단에서 스크립트를 불러오도록한다. 또 다른 방법은 이벤트를 이용하는 것이다.</p><h4 id="document-load-event"><a href="#document-load-event" class="headerlink" title="document load event"></a><code>document load event</code></h4><ul><li><p>페이지의 모든 리소스가 로드된 이후에 실행된다.</p></li><li><p>이 시점에서 문서의 모든 객체가 DOM에 있고, 모든 이미지, 스크립트, 링크 및 하위 프레임로딩이 완료됩니다.</p></li><li><p>때문에 구동이 지연되어 사용자 경험을 저하할 수 있다.</p></li></ul><h4 id="DOMContentLoaded-event"><a href="#DOMContentLoaded-event" class="headerlink" title="DOMContentLoaded event"></a><code>DOMContentLoaded event</code></h4><ul><li><p>스크립트 로드를 마치고 실행이 가능한 시점에 바로 실행된다.</p></li><li><p>DOM 이벤트 <code>DOMContentLoaded</code>는 페이지의 DOM이 생성된 후에 발생하지만 다른 리소스가 로딩되기를 기다리지 않습니다.</p></li><li><p>이것은 초기화되기 전에 전체 페이지가 로드될 필요가 없는 경우에 선호됩니다.</p></li></ul><h3 id="11-attribute와-property"><a href="#11-attribute와-property" class="headerlink" title="11. attribute와 property"></a>11. attribute와 property</h3><ul><li>attribute : HTML 마크업에서 정의</li><li>property : DOM에서 정의</li></ul><h4 id="Attributes"><a href="#Attributes" class="headerlink" title="Attributes"></a>Attributes</h4><p>HTML 요소의 추가적인 정보를 전달하고 이름=“값” 이렇게 쌍으로 온다. 예를 들어 <code>&lt;div class=&quot;my-class&quot;&gt;&lt;/div&gt;</code> 를 보면 div 태그가 class 라는 값이 ‘my-class’인 attribute를 가지고 있다.</p><h4 id="Property"><a href="#Property" class="headerlink" title="Property"></a>Property</h4><p>attribute에 대한 HTML DOM 트리안에서의 표현이다. 그래서 위 예시에서 attribute는 값이 ‘my-class’이며 이름이 ‘className’인 property를 가진다.</p><h4 id="attribute-와-property의-차이는-무엇인가"><a href="#attribute-와-property의-차이는-무엇인가" class="headerlink" title="attribute 와 property의 차이는 무엇인가?"></a>attribute 와 property의 차이는 무엇인가?</h4><p>Attributes는 HTML 텍스트 문서에 있는 것이고 properties는 HTML DOM 트리에 있는 것이다. 이것은 attribute는 변하지 않고 초기 (default)값을 전달한다는 것은 의미한다. 반면에 HTML properties는 변할 수 있다. 예를 들어 사용자가 체크박스를 체크했거나 input 박스에 텍스트를 넣었거나 JavaScript로 값을 변경하면 property의 값은 변한다.</p><p>Input 박스에 value를 타이핑한다는 시나리오를 예로 들면, property는 DOM안에 존재하고 동적이기 때문에 property의 값만 변경되었다. 그러나 attribute는 HTML 문서안에 존재하고 결코 변하지 않는다.</p><h3 id="12-use-strict-은-무엇이고-사용했을-때-장단점에-관해서-설명해주세요"><a href="#12-use-strict-은-무엇이고-사용했을-때-장단점에-관해서-설명해주세요" class="headerlink" title="12. use strict 은 무엇이고, 사용했을 때 장단점에 관해서 설명해주세요."></a>12. use strict 은 무엇이고, 사용했을 때 장단점에 관해서 설명해주세요.</h3><p>‘use strict’는 전체 스크립트나 개별 함수에 엄격 모드를 사용하는데 사용되는 명령문입니다. Strict 모드는 JavaScript 다양한 자바스크립트를 제한하는 방법입니다.</p><p>장점:</p><ul><li>실수로 전역변수를 만드는 것이 불가능합니다.</li><li>암묵적으로 실패한 예외를 throw하지 못하는 할당을 만듭니다.</li><li>삭제할 수 없는 속성을 삭제하려고 시도합니다. (시도 효과가 없을 때까지)</li><li>함수의 매개변수 이름은 고유해야합니다.</li><li><code>this</code>는 전역 컨텍스트에서 undefined입니다.</li><li>예외를 발생시키는 몇 가지 일반적인 코딩을 잡아냅니다.</li><li>헷갈리거나 잘 모르는 기능을 사용할 수 없게 합니다.</li></ul><p>단점:</p><ul><li>일부 개발자는 익숙하지 않은 기능이 많습니다.</li><li><code>function.caller</code>와 <code>function.arguments</code>에 더 이상 접근할 수 없습니다.</li><li>서로 다른 엄격한 모드로 작성된 스크립트를 병합하면 문제가 발생할 수 있습니다.</li></ul><p>전반적으로 장점이 단점보다 중요하다고 생각합니다. 엄격 모드가 차단하는 기능에 의존하지 않아도 됩니다. 엄격한 모드를 사용하는 것을 추천합니다.</p><h3 id="13-Functional-Programming-이란-무엇인지-설명해주세요"><a href="#13-Functional-Programming-이란-무엇인지-설명해주세요" class="headerlink" title="13. Functional Programming 이란 무엇인지 설명해주세요"></a>13. Functional Programming 이란 무엇인지 설명해주세요</h3><p>객체 지향 프로그래밍에서는 멤버변수의 상태를 공유하고, 상태를 변경함으로써 예상치 못한 버그를 일으킬 수 있습니다. 이를 보안한 함수형 프로그래밍은 <strong>불변성</strong> 으로 선언한 값을 복사해 변경하므로, 반환되는 값이 예측이 가능하다는 장점이 있습니다. 또한, 상태를 공유하기보다는 반환되는 값을 이용해 함수를 사용하기에 프로그램의 실행에 있어 영향을 끼치지 않습니다.<br>이것을 <strong>고차 함수(High-Order Function)</strong>, <strong>순수 함수(Pure Function)</strong> 라고 합니다. <strong>고차 함수</strong>는 <strong>1급 함수</strong>의 부분집합입니다. 따라서 함수를 변수에 할당할 수 있으며, 매개변수로 전달 할 수 있고 함수를 반환할 수도 있습니다. 이처럼 <em>어떤 방법</em> 으로 해야하는지를 나타내기보다 <em>무엇</em> 과 같은지 생각하는 것을 우리는 <strong>선언형</strong> 이라고 합니다.</p><h3 id="14-고차함수-High-Order-Function-란-무엇인지-설명해주세요"><a href="#14-고차함수-High-Order-Function-란-무엇인지-설명해주세요" class="headerlink" title="14. 고차함수 (High-Order Function)란 무엇인지 설명해주세요."></a>14. 고차함수 (High-Order Function)란 무엇인지 설명해주세요.</h3><p>고차 함수는 함수를 파라미터로 받거나 함수를 리턴하는 함수를 말한다. 반복적으로 실행되는 어떤 작업을 추상화시키는 수단으로 사용한다.</p><p>고차 함수의 고전적인 예제는 <code>Array.prototype.map</code> 함수다. 배열을 기반으로 새로운 배열을 만들 때 사용하는데, 이런저런 과정을 생략하고 맵핑 로직만 전달하면 되기 때문에 코드가 무척 간결해진다.</p><p>배열에 문자열로 구성되어 있고, 모든 요소에 <code>toUpperCase</code>를 적용해서 새 배열을 만들어야 한다고 하자. map 없이 구현하려면 아래와 같지만</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> names = [<span class="string">&quot;irish&quot;</span>, <span class="string">&quot;daisy&quot;</span>, <span class="string">&quot;anna&quot;</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> transformNamesToUppercase = <span class="function"><span class="keyword">function</span> (<span class="params">names</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> results = [];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; names.length; i++) &#123;</span><br><span class="line">    results.push(names[i].toUpperCase());</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> results;</span><br><span class="line">&#125;;</span><br><span class="line">transformNamesToUppercase(names); <span class="comment">// [&#x27;IRISH&#x27;, &#x27;DAISY&#x27;, &#x27;ANNA&#x27;]</span></span><br></pre></td></tr></table></figure><p><code>.map(transformerFn)</code> 함수를 사용한다면 무척 간단해진다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> transformNamesToUppercase = <span class="function"><span class="keyword">function</span> (<span class="params">names</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> names.map(<span class="function">(<span class="params">name</span>) =&gt;</span> name.toUpperCase());</span><br><span class="line">&#125;;</span><br><span class="line">transformNamesToUppercase(names); <span class="comment">// [&#x27;IRISH&#x27;, &#x27;DAISY&#x27;, &#x27;ANNA&#x27;]</span></span><br></pre></td></tr></table></figure><p>Array의 <code>forEach</code>, <code>filter</code>, <code>reduce</code> 등도 모두 고차 함수다.</p><h3 id="15-자바스크립트의-배열-Array-이-실제-자료구조-배열이-아닌데-그-이유는"><a href="#15-자바스크립트의-배열-Array-이-실제-자료구조-배열이-아닌데-그-이유는" class="headerlink" title="15. 자바스크립트의 배열(Array)이 실제 자료구조 배열이 아닌데 그 이유는?"></a>15. 자바스크립트의 배열(Array)이 실제 자료구조 배열이 아닌데 그 이유는?</h3><p>참조: 자바스크립트 배열은 배열이 아니다 (<a href="https://poiemaweb.com/js-array-is-not-arrray">https://poiemaweb.com/js-array-is-not-arrray</a>)</p><h3 id="16-자바스크립트의-순환참조란-어떤게-문제이고-해결방법은"><a href="#16-자바스크립트의-순환참조란-어떤게-문제이고-해결방법은" class="headerlink" title="16. 자바스크립트의 순환참조란? 어떤게 문제이고 해결방법은?"></a>16. 자바스크립트의 순환참조란? 어떤게 문제이고 해결방법은?</h3><p>참조: 순환 참조 (<a href="https://jeonghwan-kim.github.io/dev/2020/03/24/circular-dependancy.html">https://jeonghwan-kim.github.io/dev/2020/03/24/circular-dependancy.html</a>)</p><h3 id="17-자바스크립트와-관련한-same-origin-정책에-대해-설명해달라"><a href="#17-자바스크립트와-관련한-same-origin-정책에-대해-설명해달라" class="headerlink" title="17. 자바스크립트와 관련한 same-origin 정책에 대해 설명해달라"></a>17. 자바스크립트와 관련한 same-origin 정책에 대해 설명해달라</h3><ul><li><em>다른 도메인의 스크립트를 사용한 해킹 방지</em></li></ul><p>**동일 출처 원칙(same-origin policy)**는 자바스크립트가 서로 다른 도메인 사이에 리퀘스트를 날리는 것을 방지한다. origin은 URI 스키마, 호스트네임, 그리고 포트 번호로 정의된다. <em>이 정책은 다른 도메인의 악의적인 스크립트가 타겟 웹페이지에서 DOM을 통해 민감한 정보를 가져가는 것을 방지한다.</em></p><hr><h2 id="참조"><a href="#참조" class="headerlink" title="참조"></a>참조</h2><ul><li><a href="https://ahnheejong.name/articles/frontend-birds-eye-view-babel/">프론트엔드 기술 조감도 : Babel - ahnheejong님 블로그</a></li><li><a href="https://devowen.com/293">Babel이란 무엇인가 - devowen님 블로그</a></li><li><a href="http://insanehong.kr/post/front-end-developer-interview-javascript/">front-end 개발자 인터뷰 문제 - javascript 영역 - Insanehong님 블로그</a></li><li><a href="https://parksb.github.io/article/0.html#fouc(flash-of-unstyled-content)">📋 프론트엔드 개발자를 위한 토막상식 - parksb님 블로그</a></li><li><a href="https://im-developer.tistory.com/141">[JS/Pattern] 대표적인 자바스크립트, 디자인 패턴 정리 (Javascript, Design Pattern)</a> </li><li><a href="https://jeongwooahn.medium.com/html-attribute%EC%99%80-property-%EC%9D%98-%EC%B0%A8%EC%9D%B4-d3c172cebc41">HTML : attribute와 property 의 차이</a></li><li><a href="https://velog.io/@chris/front-end-interview-handbook-js-3">💻 프론트엔드 면접 질문 - JS #3 - @chris님 블로그 </a></li><li><a href="https://velog.io/@heumheum2/%EA%B8%B0%EC%88%A0%EB%A9%B4%EC%A0%91-%EC%A4%80%EB%B9%84%ED%95%98%EA%B8%B0-2">기술면접 준비하기 2 - @heumheum2님 블로그</a></li><li><a href="https://blog.rhostem.com/posts/2020-04-14-fe-interview-handbook-js-3">프론트엔드 면접 핸드북 - 자바스크립트(3) - rhostem님 블로그</a></li><li><a href="http://hacks.mozilla.or.kr/2015/09/es6-in-depth-destructuring/">ES6 In Depth: 디스트럭처링(Destructuring)</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;/images/job_thumbnail.jpeg&quot; alt=&quot;면접!&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;프론트엔드-면접-준비를-위한-질문-리스트-정리&quot;&gt;&lt;a href=&quot;#프론트엔드-면접-준비를-위한-질문-리스트-정리&quot; class=&quot;heade</summary>
      
    
    
    
    <category term="Blog" scheme="https://joontae-kim.github.io/categories/Blog/"/>
    
    <category term="Job" scheme="https://joontae-kim.github.io/categories/Blog/Job/"/>
    
    
    <category term="Front-end" scheme="https://joontae-kim.github.io/tags/Front-end/"/>
    
    <category term="Interview" scheme="https://joontae-kim.github.io/tags/Interview/"/>
    
    <category term="Job" scheme="https://joontae-kim.github.io/tags/Job/"/>
    
    <category term="Javascript" scheme="https://joontae-kim.github.io/tags/Javascript/"/>
    
  </entry>
  
  <entry>
    <title>Nuxt의 Data Fetching</title>
    <link href="https://joontae-kim.github.io/2021/05/10/nuxt-data-fetching/"/>
    <id>https://joontae-kim.github.io/2021/05/10/nuxt-data-fetching/</id>
    <published>2021-05-09T15:54:26.000Z</published>
    <updated>2021-05-10T07:33:59.719Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/nuxt.png" alt="Nuxt.js"></p><p>Nuxt는 Vue.js의 서버사이드 렌더링을 지원하기 위한 프레임워크로써, Vue.js SPA에서 데이터를 호출하는 방식과 다르게 비동기 데이터 호출을 위한 Hook이 따로 존재합니다. 이번 포스트에서는 그 Hook인 <code>fetch</code>와 <code>asyncData</code> Hook에 대해 살펴보겠습니다.</p><h2 id="fetch-amp-asyncData"><a href="#fetch-amp-asyncData" class="headerlink" title="fetch &amp; asyncData"></a>fetch &amp; asyncData</h2><p>일단 공식문서의 간략한 설명을 번역하면 아래와 같다.</p><blockquote><ul><li><code>fetch</code> hook (Nuxt 2.12+)은 모든 컴포넌트에서 사용할 수 있고, (client-side 렌더링 중) 렌더링이 진행중인 상태와 에러에 대한 참조(shortcuts)를 제공합니다.</li><li><code>asyncData</code>은 오직 <strong>page</strong> 컴포넌트에서만 사용할 수 있습니다. <code>fetch</code>와 다르게 client-side 렌더링 중 로딩 placeholder를 표시할 수 없습니다: 대신에, 이 hook이 완료될때까지 route navigation을 막으며 실패했을 경우 페이지에 에러를 표시합니다.</li></ul></blockquote><p>아직 두개의 hook에 대해 너무나도 간략한 설명이기에 더 자세히 해보겠습니다.</p><h2 id="fetch"><a href="#fetch" class="headerlink" title="fetch"></a>fetch</h2><p><code>fetch</code>는 컴포넌트 인스턴스가 생성된 후 server-side 렌더링 동안 또는 client-side에서 네비게이션 되는 동안 호출되는 hook으로, 비동기 데이터 호출이 완료되었을때 (<code>async/await</code>를 사용) promise를 반환합니다.</p><ul><li>초기 페이지가 렌더링 될때 서버사이드에서 호출</li><li>컴포넌트가 <code>mounted</code> 된 후 클라이언트에서 호출</li></ul><p><code>fetch</code> hook은 컴포넌트 레벨에서 아래의 property와 함께 <code>$fetchState</code>와 함께 노출됩니다.</p><ul><li><code>pending</code>은 <code>Boolean</code> 값으로 <em>client-side</em> 에서 <code>fetch</code> hook이 호출되었을때 placeholder를 표시하도록 해줍니다.</li><li><code>error</code>는 <code>null</code> 또는 fetch hook이 반환한 <code>Error</code>입니다.</li><li><code>timestamp</code>는 최신 fetch의 timestamp로써, <a href="https://ko.nuxtjs.org/docs/2.x/features/data-fetching#caching"><code>keep-alive</code>으로 caching</a> 하는 것에 유용합니다.</li></ul><p>Nuxt에 의해 fetch가 호출되는 것이외에도 컴포넌트에서 수동으로 <code>this.$fetch()</code>를 호출해 fetch를 사용할 수도 있습니다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;p v-if&#x3D;&quot;$fetchState.pending&quot;&gt;Fetching mountains...&lt;&#x2F;p&gt;</span><br><span class="line">  &lt;p v-else-if&#x3D;&quot;$fetchState.error&quot;&gt;An error occurred :(&lt;&#x2F;p&gt;</span><br><span class="line">  &lt;div v-else&gt;</span><br><span class="line">    &lt;h1&gt;Nuxt Mountains&lt;&#x2F;h1&gt;</span><br><span class="line">    &lt;ul&gt;</span><br><span class="line">      &lt;li v-for&#x3D;&quot;mountain of mountains&quot;&gt;&#123;&#123; mountain.title &#125;&#125;&lt;&#x2F;li&gt;</span><br><span class="line">    &lt;&#x2F;ul&gt;</span><br><span class="line">    &lt;button @click&#x3D;&quot;$fetch&quot;&gt;Refresh&lt;&#x2F;button&gt;</span><br><span class="line">  &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">  export default &#123;</span><br><span class="line">    data() &#123;</span><br><span class="line">      return &#123;</span><br><span class="line">        mountains: []</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    async fetch() &#123;</span><br><span class="line">      this.mountains &#x3D; await fetch(</span><br><span class="line">        &#39;https:&#x2F;&#x2F;api.nuxtjs.dev&#x2F;mountains&#39;</span><br><span class="line">      ).then(res &#x3D;&gt; res.json())</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="Option"><a href="#Option" class="headerlink" title="Option"></a>Option</h3><ul><li><code>fetchOnServer</code>: <code>Boolean</code> or <code>Function</code> (기본값: <code>true</code>)이며 server-rendering 중에 <code>fetch()</code>를 호출할지 설정할 수 있습니다.</li><li><code>fetchDelay</code>: <code>Integer</code> (기본값: <code>200</code>)이며 millisecond 단위로 최소 실행시간을 설정할 수 있습니다.</li></ul><p><code>fetchOnServer</code>가 <code>false</code> 또는 <code>false</code>를 반환할 경우, <code>fetch</code>는 오직 client-side에서만 호출될 것이며 <code>$fetchState.pending</code>은 컴포넌트가 server-rendering일때 <code>true</code>를 반환할 것입니다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">export default &#123;</span><br><span class="line">  data() &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      posts: []</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  async fetch() &#123;</span><br><span class="line">    this.posts &#x3D; await fetch(&#39;https:&#x2F;&#x2F;api.nuxtjs.dev&#x2F;posts&#39;).then(res &#x3D;&gt;</span><br><span class="line">      res.json()</span><br><span class="line">    )</span><br><span class="line">  &#125;,</span><br><span class="line">  &#x2F;&#x2F; call fetch only on client-side</span><br><span class="line">  fetchOnServer: false</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="querystring-변경-감지하기"><a href="#querystring-변경-감지하기" class="headerlink" title="querystring 변경 감지하기"></a>querystring 변경 감지하기</h3><p><code>fetch</code> hook은 기본적으로 querystring 변경시 호출되지 않는다. 이를 위해 <code>$route.query</code>를 관찰해 <code>$fetch</code>를 호출해야합니다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">export default &#123;</span><br><span class="line">  watch: &#123;</span><br><span class="line">    &#39;$route.query&#39;: &#39;$fetch&#39;</span><br><span class="line">  &#125;,</span><br><span class="line">  async fetch() &#123;</span><br><span class="line">    &#x2F;&#x2F; Called also on query changes</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="캐싱"><a href="#캐싱" class="headerlink" title="캐싱"></a>캐싱</h3><p><code>&lt;nuxt/&gt;</code>과 <code>&lt;nuxt-child/&gt;</code> 컴포넌트에서 이미 방문했던 페이지의 <code>fetch</code> 호출을 절약하기 위해 <code>keep-alive</code> 디렉티브를 사용할 수 있습니다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;nuxt keep-alive &#x2F;&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br></pre></td></tr></table></figure><p>또한, <code>&lt;nuxt&gt;</code> 컴포넌트에 <code>keep-alive-props</code> prop을 전달함으로써 <code>&lt;keep-alive&gt;</code>에 전달될 <a href="https://vuejs.org/v2/api/#keep-alive">props</a>를 명시할 수 있습니다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;nuxt keep-alive :keep-alive-props&#x3D;&quot;&#123; max: 10 &#125;&quot; &#x2F;&gt;</span><br></pre></td></tr></table></figure><p>메모리상 오직 10개 페이지 컴포넌트만 유지할 수 있습니다.</p><h3 id="activated-hook-사용하기"><a href="#activated-hook-사용하기" class="headerlink" title="activated hook 사용하기"></a><code>activated</code> hook 사용하기</h3><p>Nuxt는 (ssr을 포함한) 가장 최신의 <code>fetch</code> 호출에 대한 <code>this.$fetchstate.timestamp</code>를 직접 채웁니다. <code>fetch</code>에 30초 캐시를 추가하기 위해 <code>activated</code> hook을 혼합해 <code>fetch</code> property를 사용할 수 있습니다. </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt; ... &lt;&#x2F;template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">  export default &#123;</span><br><span class="line">    data() &#123;</span><br><span class="line">      return &#123;</span><br><span class="line">        posts: []</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    activated() &#123;</span><br><span class="line">      &#x2F;&#x2F; Call fetch again if last fetch more than 30 sec ago</span><br><span class="line">      if (this.$fetchState.timestamp &lt;&#x3D; Date.now() - 30000) &#123;</span><br><span class="line">        this.$fetch()</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    async fetch() &#123;</span><br><span class="line">      this.posts &#x3D; await fetch(&#39;https:&#x2F;&#x2F;api.nuxtjs.dev&#x2F;posts&#39;).then(res &#x3D;&gt;</span><br><span class="line">        res.json()</span><br><span class="line">      )</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure><p>마지막 <code>fetch</code> 호출이 30초 전이었다면, 동일 페이지 내 navigation은 <code>fetch</code>를 호출하지 않을 것입니다.</p><h2 id="Async-Data"><a href="#Async-Data" class="headerlink" title="Async Data"></a>Async Data</h2><blockquote><p><code>asyncData</code>는 오직 <a href="https://ko.nuxtjs.org/docs/2.x/directory-structure/pages">pages</a> 안에서만 사용가능하고 이 hook 안에서는 <code>this</code> 객체에 접근할 수 없습니다.</p></blockquote><p><code>asyncData</code>는 universal nuxt app의 비동기 데이터 호출을 위한 또 다른 hook으로, <code>fetch</code>와 다르게 컴포넌트 인스턴스에서 비동기 state를 저장하기 위한 property를 설정해줘야 합니다(또는 Vuex actions의 dispatch). <code>asyncData</code>는 간단하게 컴포넌트의 지역 state에 반환된 값을 병합(merge)합니다. </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;h1&gt;&#123;&#123; post.title &#125;&#125;&lt;&#x2F;h1&gt;</span><br><span class="line">    &lt;p&gt;&#123;&#123; post.description &#125;&#125;&lt;&#x2F;p&gt;</span><br><span class="line">  &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">  export default &#123;</span><br><span class="line">    async asyncData(&#123; params, $http &#125;) &#123;</span><br><span class="line">      const post &#x3D; await $http.$get(&#96;https:&#x2F;&#x2F;api.nuxtjs.dev&#x2F;posts&#x2F;$&#123;params.id&#125;&#96;)</span><br><span class="line">      return &#123; post &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure><p><code>fetch</code>와 다르게 <em>route transition 동안</em> <code>asyncData</code>가 완료되고 promise를 반환합니다. 이것이 의미하는 바는 client-side transitions 동안에는 로딩 placeholder(loading placeholder)는 보여지지 않는다는 것입니다 (비록 유저에게 진행상태를 알려주기 위해 <a href="https://nuxtjs.org/guides/features/loading/">진행바</a>를 사용할 수 있을지라도). 대신에 Nuxt는 다음 페이지로 navigation 되기 전 완료되거나 <a href="https://nuxtjs.org/docs/2.x/directory-structure/layouts#error-page">에러 페이지</a>를 보여줄때까지 <code>asyncData</code> hook을 기다립니다.</p><p><code>asyncData</code> hook은 오직 page-level 컴포넌트에서 사용할 수 있습니다. <code>fetch</code>와 다르게 <code>asyncData</code> hook은 컴포넌트 인스턴스(<code>this</code>)에 접근할 수 없지만, 인자(argument)로써 <a href="https://nuxtjs.org/docs/2.x/concepts/context-helpers">context</a>를 받으며 데이터를 호출하기 위해 사용할 있고, Nuxt.js는 자동으로 컴포넌트의 data와 반환된 객체를 병합합니다.</p><h3 id="컴포넌트에서-Async-data"><a href="#컴포넌트에서-Async-data" class="headerlink" title="컴포넌트에서 Async data"></a>컴포넌트에서 Async data</h3><p>컴포넌트들은 <code>asyncData</code> 메서드를 가지고 있지 않기때문에 컴포넌트 내에서 server-side 비동기 데이터 호출을 할 수 없습니다. 이러한 제약사항에 관해서 3개의 옵션이 있습니다.</p><ol><li>버전 2.12+ 또는 최신 버전의 Nuxt에서 <a href="https://nuxtjs.org/docs/2.x/features/data-fetching#the-fetch-hook">new fetch</a> hook 사용하기</li><li><code>mounted</code> hook에서 API 호출 만들고, 로드 되었을때 data property를 설정합니다. <em>부작용: server side rendering에서 작동하지 않습니다.</em></li><li>page 컴포넌트의 <code>asyncData</code> 메서드에서 API 호출 만들고 sub 컴포넌트에 props로 data 전달해줍니다. Server rendering은 잘 작동합니다. <em>부작용: 페이지의 <code>asyncData</code>는 다른 컴포넌트에 대한 data를 불러오기 때문에 덜 합리적일 수도 있습니다.</em></li></ol><h3 id="querystring-변경-감지하기-1"><a href="#querystring-변경-감지하기-1" class="headerlink" title="querystring 변경 감지하기"></a>querystring 변경 감지하기</h3><p><code>asyncData</code> 메서드는 기본적으로 querystring의 변경시 호출되지 않습니다. 만약 호출을 원한다면, 예를 들어 pagination 컴포넌트를 개발할때, page 컴포넌트의 <code>watchQuery</code> property에서 감지할 수 있는 매개변수를 설정할 수 있습니다.</p><p><em>(공식 홈페이지  <a href="https://nuxtjs.org/docs/2.x/components-glossary/pages-watchquery">The watchQuery Property 챕터</a> 참조)</em></p><h2 id="요약"><a href="#요약" class="headerlink" title="요약"></a>요약</h2><p>지금부터는 공식 홈페이지에서 <code>fetch</code>와 <code>asyncData</code>에 대한 spec에 대해 알아봤으나 난해한 개념을 보충하기 위한 몇 개 사이트의 내용을 요약해보겠습니다.</p><blockquote><p>즉, 아래와 같이 목적을 구분할 수 있다.</p><ul><li><code>asyncData</code>는 컴포넌트가 랜더링 되기전에 컴포넌트 데이터를 구성하는 것에 목적</li><li><code>fetch</code>는 컴포넌트가 랜더링 되기전에 비동기 로직을 호출하는 것에 목적</li></ul></blockquote><h3 id="Difference-between-Asyncdata-vs-Fetch"><a href="#Difference-between-Asyncdata-vs-Fetch" class="headerlink" title="Difference between Asyncdata vs Fetch"></a>Difference between Asyncdata vs Fetch</h3><blockquote><p>출처: <a href="https://stackoverflow.com/questions/49251437/difference-between-asyncdata-vs-fetch">https://stackoverflow.com/questions/49251437/difference-between-asyncdata-vs-fetch</a></p></blockquote><ul><li><code>asyncData</code>는 컴포넌트 레벨에서 설정 가능하며 Vuex store에서 접근 가능합니다.</li><li><code>fetch</code>는 컴포넌트 레벨에서 설정할 수 없으며 Vuex store에서 접근할 수 없습니다.</li><li><code>asyncData</code>와 <code>fetch</code> 둘다 server-side의 초기 렌더링에서 호출됩니다.</li><li>초기 로딩 이후에, <code>asyncData</code>와 <code>fetch</code>는 page의 route가 변경되었을때 호출됩니다.</li></ul><ol><li>만약 Nuxt 어플리케이션에서,</li></ol><ul><li>Vuex store를 (데이터) 중앙 저장소로 이용하고,</li><li>어플리케이션 전체에서 Vuex store로 데이터를 접근할 경우</li></ul><blockquote><p><code>fetch</code>를 사용</p></blockquote><ol start="2"><li>만약 Nuxt 어플리케이션에서,</li></ol><ul><li>Vuex store를 (데이터) 중앙 저장소로 이용하고,</li><li>컴포넌트 레벨에서 설정한 옵션을 가지고 있고,</li><li>특정 route에서 가져온 data가 오직 1개의 컴포넌트에서 사용될 경우,</li><li>Vuex store 또는 컴포넌트 레벨에 대한 권한을 가질수 있는 유연성이 필요한 경우, </li></ul><blockquote><p><code>asyncData</code> 사용</p></blockquote><h2 id="기타-블로그"><a href="#기타-블로그" class="headerlink" title="기타 블로그"></a>기타 블로그</h2><h3 id="fetch-1"><a href="#fetch-1" class="headerlink" title="fetch"></a>fetch</h3><ul><li>컴포넌트를 로드하기 전에 호출</li><li><strong>모든 컴포넌트</strong> 에서 사용 가능</li><li><code>Nuxt.js</code>는 컴포넌트가 렌더링되기 전 <code>fetch</code> promise가 종료될 때까지 대기함</li><li><code>fetch</code>는 Vuex store의 data를 접근해 사용할때 사용</li><li>첫 번째 인자로 <code>context</code>를 받으며 <code>store</code>와 <code>params</code>를 사용할 수 있음</li><li>서버 사이드 렌더링을 위해 서버에서 화면을 구성할 때 컴포넌트가 생성되고 나서 실행됨</li><li>브라우저에서 URL 주소를 변경해서 페이지를 이동할 때</li></ul><h3 id="asyncData"><a href="#asyncData" class="headerlink" title="asyncData"></a>asyncData</h3><ul><li><p>컴포넌트를 로드하기 전에 호출</p></li><li><p><strong>page 컴포넌트</strong> 에서만 사용 가능</p></li><li><p><code>asyncData</code>로 생성한 데이터는 data로 생성한 데이터와 머지되어 사용하는 입장에서는 asyncData와 data는 차이가 없다. <em>단지 초기화시키는 데이터가 동기적으로 실행되는지 비동기적으로 실행되는지에 대한 차이가 있을 뿐이다.</em></p></li><li><p>첫 번째 인자로 <code>context</code>를 받으며 url의 <code>params</code>나 <code>query</code>를 사용할 수 있음</p></li><li><p>redirect나 error를 활용하여 원하는 페이지로 리다이렉트 시키거나 에러 페이지를 띄워줄 수 있음</p></li><li><p>만일 vuex가 설정되었다면, store를 사용 가능</p></li></ul><blockquote><p><code>asyncData</code>는 컴포넌트를 초기화 하기 전에 실행되기 때문에 메서드 내부에서는 this를 통해 컴포넌트 인스턴스에 접근할 수 없다.</p></blockquote><hr><h2 id="참조"><a href="#참조" class="headerlink" title="참조"></a>참조</h2><ul><li><a href="https://nuxtjs.org/docs/2.x/features/data-fetching">data fetching</a></li><li><a href="https://stackoverflow.com/questions/49251437/difference-between-asyncdata-vs-fetch">Difference between Asyncdata vs Fetch</a></li><li><a href="https://webdoli.tistory.com/62">nuxt.js 활용하기</a></li><li><a href="https://velog.io/@bongjoki/Nuxt.js-asyncData">Nuxt.js - asyncData(),fetch()</a></li><li><a href="https://joshua1988.github.io/vue-camp/nuxt/data-fetching.html#%EC%8B%B1%EA%B8%80-%ED%8E%98%EC%9D%B4%EC%A7%80-%EC%95%A0%ED%94%8C%EB%A6%AC%EC%BC%80%EC%9D%B4%EC%85%98%EA%B3%BC-%EB%8B%A4%EB%A5%B8-%EC%A0%90">https://joshua1988.github.io/vue-camp/nuxt/data-fetching.html#%EC%8B%B1%EA%B8%80-%ED%8E%98%EC%9D%B4%EC%A7%80-%EC%95%A0%ED%94%8C%EB%A6%AC%EC%BC%80%EC%9D%B4%EC%85%98%EA%B3%BC-%EB%8B%A4%EB%A5%B8-%EC%A0%90</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;/images/nuxt.png&quot; alt=&quot;Nuxt.js&quot;&gt;&lt;/p&gt;
&lt;p&gt;Nuxt는 Vue.js의 서버사이드 렌더링을 지원하기 위한 프레임워크로써, Vue.js SPA에서 데이터를 호출하는 방식과 다르게 비동기 데이터 호출을 위한</summary>
      
    
    
    
    <category term="Programming" scheme="https://joontae-kim.github.io/categories/Programming/"/>
    
    <category term="nuxt" scheme="https://joontae-kim.github.io/categories/Programming/nuxt/"/>
    
    
    <category term="vue.js" scheme="https://joontae-kim.github.io/tags/vue-js/"/>
    
    <category term="nuxt.js" scheme="https://joontae-kim.github.io/tags/nuxt-js/"/>
    
    <category term="nuxt" scheme="https://joontae-kim.github.io/tags/nuxt/"/>
    
    <category term="data fetching" scheme="https://joontae-kim.github.io/tags/data-fetching/"/>
    
  </entry>
  
  <entry>
    <title>Nuxt와 Bootstrap4 기반의 Dashboard 만들기</title>
    <link href="https://joontae-kim.github.io/2021/05/05/nuxt-bootstrap-dashboard-layout/"/>
    <id>https://joontae-kim.github.io/2021/05/05/nuxt-bootstrap-dashboard-layout/</id>
    <published>2021-05-05T14:53:27.000Z</published>
    <updated>2021-05-07T19:11:37.922Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/nuxt.png" alt="Nuxt.js"></p><p>오늘의 포스트는 <strong><em>Nuxt와 Bootstrap4 기반의 Dashboard 만들기</em></strong> 의 여섯번째 포스트로 <strong>Page &amp; UI 개발</strong>에 대해 작성해보겠습니다.</p><p>지난 포스트에서는 <a href="/2021/05/01/nuxt-bootstrap-dashboard-5/">Bootstrap &amp; Bootstrap-vue 환경구성</a>에 대해 작업해봤습니다. 본 포스트에서는 <strong>Page &amp; UI 개발</strong>에 대해 다뤄보겠습니다.</p><h2 id="개발-순서"><a href="#개발-순서" class="headerlink" title="개발 순서"></a>개발 순서</h2><ol><li><a href="/2021/04/28/nuxt-bootstrap-dashboard-1/">프로젝트 생성 및 Github Repository 환경구성</a></li><li><a href="/2021/04/28/nuxt-bootstrap-dashboard-2/">Heroku 배포 환경구성</a></li><li><a href="/2021/04/29/nuxt-bootstrap-dashboard-3/">Nuxt &amp; Express API 환경구성</a></li><li><a href="/2021/04/30/nuxt-bootstrap-dashboard-4/">Axios</a></li><li><a href="/2021/05/01/nuxt-bootstrap-dashboard-5/">Bootstrap &amp; Bootstrap-vue 환경구성</a></li><li>Page &amp; UI 개발</li></ol><h2 id="Layout"><a href="#Layout" class="headerlink" title="Layout"></a>Layout</h2><p><img src="https://ko.nuxtjs.org/docs/2.x/views.png" alt="Nuxt Views Architecture"></p><p>Layout은 Nuxt Views 구성 중 하나로, 이번 포스트에서 다룰 Layout은 Nuxt의 View 계층 중 상위 레벨에 속하며 header, footer 또는 sidebar와 같은 반복되는 UI 컴포넌트들을 특정 기준으로 그룹화해 특정 페이지등에 공통된 UI를 렌더링 할 수 있도록 합니다. 각 레이아웃에는 Vue 기반의 UI Component와 middleware 및 head 태그 옵션들을 property로 지정할 수 있습니다.</p><h3 id="Default-Layout"><a href="#Default-Layout" class="headerlink" title="Default Layout"></a>Default Layout</h3><p>기본 레이아웃은 메인 레이아웃으로 확장할 수 있으며 <code>layout</code> property를 설정하지 않은 모든 페이지에서 사용가능하도록 설정됩니다. 페이지 구성요소에 포함되는 Layout을 만들때 가장 중요한 것은 <code>&lt;/Nuxt&gt;</code> 태그를 추가하는 것이며 Layout에 필요한 가장 기본적인 코드는 page 컴포넌트에 렌더링하는 아래의 세줄의 코드 입니다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; layouts&#x2F;default.vue</span><br><span class="line"></span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;Nuxt &#x2F;&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br></pre></td></tr></table></figure><p>또한, Navigation, Header 그리고 Footer 등의 더 많은 Component를 추가할 수도 있습니다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; layouts&#x2F;default.vue</span><br><span class="line"></span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;TheHeader &#x2F;&gt;</span><br><span class="line">    &lt;Nuxt &#x2F;&gt;</span><br><span class="line">    &lt;TheFooter &#x2F;&gt;</span><br><span class="line">  &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br></pre></td></tr></table></figure><h3 id="Custom-Layout"><a href="#Custom-Layout" class="headerlink" title="Custom Layout"></a>Custom Layout</h3><p><code>layouts</code> 디렉토리의 <em>top-level</em> 수준의 모든 파일은 page 컴포넌트에서 <code>layout</code> property로 접근 가능한 custom Layout을 만듭니다. </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; layouts&#x2F;blog.vue</span><br><span class="line"></span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;div&gt;My blog navigation bar here&lt;&#x2F;div&gt;</span><br><span class="line">    &lt;Nuxt &#x2F;&gt;</span><br><span class="line">  &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br></pre></td></tr></table></figure><p>예를 들어, blog 레이아웃을 만들기 위해 <code>layouts</code> 디렉토리에 <code>blog.vue</code> 레이아웃(<code>layouts/blog.vue</code>)을 생성했고 <code>pages/posts.vue</code>에서 <strong>blog</strong> 레이아웃을 사용하길 원한다면 pages/posts.vue의 <code>layout</code> property에서 아래와 같이 설정해 사용하면 됩니다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">pages&#x2F;posts.vue</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  layout: &#39;blog&#39;,</span><br><span class="line">  &#x2F;&#x2F; OR</span><br><span class="line">  layout (context) &#123;</span><br><span class="line">    return &#39;blog&#39;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure><h3 id="Error-Page"><a href="#Error-Page" class="headerlink" title="Error Page"></a>Error Page</h3><p>에러 페이지는 에러가 발생했을때 반드시 볼 수 있는 page 컴포넌트로써, 비로 <code>layouts</code> 폴더에 배치되었지만, 페이지와 같이 다뤄야합니다. Layout이자 Page인 Error Page는 template에서 <code>&lt;Nuxt&gt;</code>를 포함하지 않는데 그 이유는 <code>404</code>, <code>500</code> 과 같은 에러가 발생했을때 Component로 Error Page를 보여줄 것이기 때문입니다. 다른 page 컴포넌트와 비슷하게 동일한 방법으로 Error Page에 대한 custom layout을 설정할 수 있습니다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; layouts&#x2F;error.vue</span><br><span class="line"></span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div class&#x3D;&quot;container&quot;&gt;</span><br><span class="line">    &lt;h1 v-if&#x3D;&quot;error.statusCode &#x3D;&#x3D;&#x3D; 404&quot;&gt;Page not found&lt;&#x2F;h1&gt;</span><br><span class="line">    &lt;h1 v-else&gt;An error occurred&lt;&#x2F;h1&gt;</span><br><span class="line">    &lt;NuxtLink to&#x3D;&quot;&#x2F;&quot;&gt;Home page&lt;&#x2F;NuxtLink&gt;</span><br><span class="line">  &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  props: [&#39;error&#39;],</span><br><span class="line">  layout: &#39;blog&#39; &#x2F;&#x2F; you can set a custom layout for the error page</span><br><span class="line">&#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure><h2 id="Component"><a href="#Component" class="headerlink" title="Component"></a>Component</h2><p>기존의 Vue.js에 익숙한 개발자라면 알고 있듯이 페이지 또는 layout에 반복되는 재사용 가능한 UI Component로써, <code>/components</code> 디렉토리에서 생성해 불러올 수 있습니다. 또한, Component에서 특정 데이터가 필요한 경우 API에서 비동기 데이터에 접근하기 위해 Nuxt의 <code>fetch()</code> hook을 사용할 수 있습니다.</p><p><code>v2.13</code> 버전부터 Nuxt는 템플릿에서 사용할때 <code>nuxt.config.js</code>에서 아래와 같이 <code>components: true</code>를 설정하면 Component를 자동으로 가져올 수 있도록 활성화할 수 있습니다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; nuxt.config.js</span><br><span class="line"></span><br><span class="line">export default &#123;</span><br><span class="line">  components: true</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>아래와 같이 <code>components/</code> 디렉토리에 <code>TheHeader</code>와 <code>TheFooter</code> 컴포넌트를 생성하면 <code>layouts/default.vue</code>이라는 기본 레이아웃에서 바로 가져올 수 있습니다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">components&#x2F;</span><br><span class="line">  TheHeader.vue</span><br><span class="line">  TheFooter.vue</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; layouts&#x2F;default.vue</span><br><span class="line"></span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;TheHeader &#x2F;&gt;</span><br><span class="line">    &lt;Nuxt &#x2F;&gt;</span><br><span class="line">    &lt;TheFooter &#x2F;&gt;</span><br><span class="line">  &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br></pre></td></tr></table></figure><h3 id="Dynamic-Imports"><a href="#Dynamic-Imports" class="headerlink" title="Dynamic Imports"></a>Dynamic Imports</h3><p>Component의 Dynamic Imports는 <strong>lazy loading</strong>을 통해 구현할 수 있으며 template에서 Component 태그 이름에 <code>Lazy</code> prefix를 추가해주면 됩니다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; layouts&#x2F;default.vue</span><br><span class="line"></span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;TheHeader &#x2F;&gt;</span><br><span class="line">    &lt;Nuxt &#x2F;&gt;</span><br><span class="line">    &lt;LazyTheFooter &#x2F;&gt;</span><br><span class="line">  &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br></pre></td></tr></table></figure><p><code>Lazy</code> prefix가 추가된 Component는 이벤트가 발생했을때 동적으로 불러올 수 있습니다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; pages&#x2F;index.vue</span><br><span class="line"></span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;h1&gt;Mountains&lt;&#x2F;h1&gt;</span><br><span class="line">    &lt;LazyMountainsList v-if&#x3D;&quot;show&quot; &#x2F;&gt;</span><br><span class="line">    &lt;button v-if&#x3D;&quot;!show&quot; @click&#x3D;&quot;showList&quot;&gt;Show List&lt;&#x2F;button&gt;</span><br><span class="line">  &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">  export default &#123;</span><br><span class="line">    data() &#123;</span><br><span class="line">      return &#123;</span><br><span class="line">        show: false</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    methods: &#123;</span><br><span class="line">      showList() &#123;</span><br><span class="line">        this.show &#x3D; true</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure><h3 id="Nested-Directories"><a href="#Nested-Directories" class="headerlink" title="Nested Directories"></a>Nested Directories</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">components&#x2F;</span><br><span class="line">  base&#x2F;</span><br><span class="line">      foo&#x2F;</span><br><span class="line">         Button.vue</span><br></pre></td></tr></table></figure><p>만약 컴포넌트가 위와 같은 중접 디렉토리(Nested Directories)에 있다면, Component의 이름은 Component가 속한 디렉토리의 경로와 파일이름이 되어야 합니다. 따라서 위 <code>Button</code> Component를 template에서 사용하려면 <code>&lt;BaseFooButton /&gt;</code>와 같이 사용해야 합니다. 그러나 만약 디렉토리 구조를 Component의 이름으로 사용하지 않길 원한다면 <code>nuxt.config.js</code>에 Component가 속한 특정 디렉토리의 경로를 명시해야 하며 다음과 같은 <code>&lt;FooButton /&gt;</code> Component 태그이름을 사용할 수 있습니다. </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; nuxt.config.js</span><br><span class="line"></span><br><span class="line">components: &#123;</span><br><span class="line">  dirs: [</span><br><span class="line">    &#39;~&#x2F;components&#39;,</span><br><span class="line">    &#39;~&#x2F;components&#x2F;base&#39;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Layout-및-Component-설계"><a href="#Layout-및-Component-설계" class="headerlink" title="Layout 및 Component 설계"></a>Layout 및 Component 설계</h2><p>위에서 간략하게 Nuxt의 Layout과 Component 개념에 대해 알아봤으므로 프로젝트에 필요한 설계를 시작해보겠습니다. 이번 프로젝트는 제목에서도 알 수 있듯이 관리자 대시보드 프로젝트로써 필요한 Layout과 Component는 아래와 같습니다.</p><h3 id="Layout-1"><a href="#Layout-1" class="headerlink" title="Layout"></a>Layout</h3><ol><li>기본 Dashboard 페이지 레이아웃 <em>(for pages of needed authenticated)</em></li><li>비서비스 페이지 레이아웃 <em>(for pages of not needed authenticated)</em></li><li>에러 레이아웃 <em>(페이지)</em></li></ol><h3 id="Component-1"><a href="#Component-1" class="headerlink" title="Component"></a>Component</h3><h4 id="1-기본-Dashboard-페이지-레이아웃"><a href="#1-기본-Dashboard-페이지-레이아웃" class="headerlink" title="1. 기본 Dashboard 페이지 레이아웃"></a>1. 기본 Dashboard 페이지 레이아웃</h4><p><em>(for pages of needed authenticated)</em></p><ol><li>Header</li><li>Sidebar</li><li>Main content area (for dashboard)</li></ol><h4 id="2-비서비스-페이지-레이아웃"><a href="#2-비서비스-페이지-레이아웃" class="headerlink" title="2. 비서비스 페이지 레이아웃"></a>2. 비서비스 페이지 레이아웃</h4><p><em>(for pages of not needed authenticated)</em></p><ol><li>Header</li><li>Main content area (for each page content)</li></ol><h4 id="3-에러-레이아웃"><a href="#3-에러-레이아웃" class="headerlink" title="3. 에러 레이아웃"></a>3. 에러 레이아웃</h4><ol><li>Icon depending on Error Status</li><li>Error Message</li><li>Action Button area</li></ol><h2 id="Layout-구현"><a href="#Layout-구현" class="headerlink" title="Layout 구현"></a>Layout 구현</h2><p>위에서 설계한 Layout을 차례대로 구현해보기전에 각 Layout에 중복되는 Component 이름이 있으므로 <code>Component</code> 디렉토리 구조를 아래와 같이 구성했습니다.</p><ul><li>기본 Dashboard 페이지 레이아웃: <code>components/dashboard</code></li><li>비서비스 페이지 레이아웃: <code>components/base</code></li><li>에러 레이아웃: <code>components/error</code></li></ul><h3 id="기본-Dashboard-페이지-레이아웃"><a href="#기본-Dashboard-페이지-레이아웃" class="headerlink" title="기본 Dashboard 페이지 레이아웃"></a>기본 Dashboard 페이지 레이아웃</h3><p>기본 Dashboard 페이지 레이아웃의 경우 아래와 같은 구조로 개발하려고 합니다. <code>Sidebar</code>와 <code>Content</code>로 구조를 단순화 하고, <code>Content</code> 영역 내부에서 <code>Header</code>와 <code>Main content Area</code> 영역을 구분지어 각 대시보드 페이지의 페이지를 렌더링할 수 있는 영역을 남겨놓도록 기획했습니다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">(root)</span><br><span class="line">  ├─ Sidebar</span><br><span class="line">  └─ Content</span><br><span class="line">        ├─ Header</span><br><span class="line">        └─ Main content Area</span><br><span class="line">  </span><br></pre></td></tr></table></figure><h3 id="비서비스-페이지-레이아웃"><a href="#비서비스-페이지-레이아웃" class="headerlink" title="비서비스 페이지 레이아웃"></a>비서비스 페이지 레이아웃</h3><p>비서비스 페이지 레이아웃의 경우 아래와 같은 구조로 개발하려고 합니다. <code>Header</code>와 <code>Main content Area</code>로 구조를 단순화 하고, <code>Main content Area</code> 영역에서 추가로 레이아웃을 나눌수 있도록 했으며 각 페이지를 렌더링할 수 있는 영역을 남겨놓도록 기획했습니다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(root)</span><br><span class="line">  ├─ Header</span><br><span class="line">  └─ Main content Area</span><br><span class="line">  </span><br></pre></td></tr></table></figure><h3 id="에러-레이아웃"><a href="#에러-레이아웃" class="headerlink" title="에러 레이아웃"></a>에러 레이아웃</h3><p>비서비스 페이지 레이아웃의 경우 아래와 같은 구조로 개발하려고 합니다. <code>Header</code>와 <code>Main content Area</code>로 구조를 단순화 하고, <code>Main content Area</code> 영역에서 추가로 레이아웃을 나눌수 있도록 했으며 각 페이지를 렌더링할 수 있는 영역을 남겨놓도록 기획했습니다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">(root)</span><br><span class="line">  ├─ Error Message</span><br><span class="line">  │  ├─ Error Icon (Status Code)</span><br><span class="line">  │  └─ Error Message</span><br><span class="line">  └─ Main content Area</span><br><span class="line">  </span><br></pre></td></tr></table></figure><h2 id="마치며"><a href="#마치며" class="headerlink" title="마치며"></a>마치며</h2><!-- Vue.js에 익숙한 개발자라면 Nuxt.js 기반의 SSR 또는 SPA 앱 또한 쉽게 적응하고 개발할 수 있을거라 생각했지만  --><p>본 포스트에서는 Nuxt.js의 Views 컨셉과 그 요소인 Page, Layout 그리고 Component에 대해 알아보았고, 이번 프로젝트에서 필요한 Layout에 대한 설계와 Component에 대해 정의내려봤습니다. 앞으로는 페이지를 구현할 것이며 중간중간 Layout 또는 Layout에서 사용할 Component가 변경될 수 있을거 같습니다. 다음 포스트에서는 Dashboard 페이지의 첫번째 페이지인 <strong>Overview</strong> 페이지를 개발해보겠습니다. 감사합니다.</p><hr><h2 id="참고"><a href="#참고" class="headerlink" title="참고"></a>참고</h2><ul><li><a href="https://nuxtjs.org/docs/2.x/concepts/views">Views</a></li><li><a href="https://nuxtjs.org/docs/2.x/concepts/views#pages">views - pages</a></li><li><a href="https://nuxtjs.org/docs/2.x/concepts/views#layouts">views - layouts</a></li><li><a href="https://nuxtjs.org/docs/2.x/concepts/views#error-page">views - error-page</a></li><li><a href="https://nuxtjs.org/docs/2.x/directory-structure/pages">directory-structure - pages</a></li><li><a href="https://nuxtjs.org/docs/2.x/directory-structure/layouts">directory-structure - layouts</a></li><li><a href="https://nuxtjs.org/docs/2.x/directory-structure/components">directory-structure - components</a></li><li><a href="https://nuxtjs.org/docs/2.x/directory-structure/nuxt-config">directory-structure - nuxt-config</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;/images/nuxt.png&quot; alt=&quot;Nuxt.js&quot;&gt;&lt;/p&gt;
&lt;p&gt;오늘의 포스트는 &lt;strong&gt;&lt;em&gt;Nuxt와 Bootstrap4 기반의 Dashboard 만들기&lt;/em&gt;&lt;/strong&gt; 의 여섯번째 포스트로 &lt;stro</summary>
      
    
    
    
    <category term="Programming" scheme="https://joontae-kim.github.io/categories/Programming/"/>
    
    <category term="nuxt" scheme="https://joontae-kim.github.io/categories/Programming/nuxt/"/>
    
    
    <category term="vue.js" scheme="https://joontae-kim.github.io/tags/vue-js/"/>
    
    <category term="nuxt.js" scheme="https://joontae-kim.github.io/tags/nuxt-js/"/>
    
    <category term="vue" scheme="https://joontae-kim.github.io/tags/vue/"/>
    
    <category term="nuxt" scheme="https://joontae-kim.github.io/tags/nuxt/"/>
    
    <category term="project" scheme="https://joontae-kim.github.io/tags/project/"/>
    
    <category term="portfolio" scheme="https://joontae-kim.github.io/tags/portfolio/"/>
    
    <category term="bootstrap" scheme="https://joontae-kim.github.io/tags/bootstrap/"/>
    
    <category term="bootstrap-vue" scheme="https://joontae-kim.github.io/tags/bootstrap-vue/"/>
    
    <category term="layout" scheme="https://joontae-kim.github.io/tags/layout/"/>
    
  </entry>
  
  <entry>
    <title>Nuxt와 Bootstrap4 기반의 Dashboard 만들기</title>
    <link href="https://joontae-kim.github.io/2021/05/01/nuxt-bootstrap-dashboard-5/"/>
    <id>https://joontae-kim.github.io/2021/05/01/nuxt-bootstrap-dashboard-5/</id>
    <published>2021-05-01T09:30:28.000Z</published>
    <updated>2021-05-05T14:47:58.392Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/nuxt.png" alt="Nuxt.js"></p><p>오늘의 포스트는 <strong><em>Nuxt와 Bootstrap4 기반의 Dashboard 만들기</em></strong> 의 다섯번째 포스트로 <strong>Bootstrap &amp; Bootstrap-vue 환경구성</strong>에 대해 작성해보겠습니다.</p><p>지난 포스트에서는 <a href="/2021/04/30/nuxt-bootstrap-dashboard-4/">Axios</a> 환경구성에 대해 작업해봤습니다. 본 포스트에서는 Bootstrap 설치와 환경세팅에 대해 다뤄보겠습니다.</p><h2 id="개발-순서"><a href="#개발-순서" class="headerlink" title="개발 순서"></a>개발 순서</h2><ol><li><a href="/2021/04/28/nuxt-bootstrap-dashboard-1/">프로젝트 생성 및 Github Repository 환경구성</a></li><li><a href="/2021/04/28/nuxt-bootstrap-dashboard-2/">Heroku 배포 환경구성</a></li><li><a href="/2021/04/29/nuxt-bootstrap-dashboard-3/">Nuxt &amp; Express API 환경구성</a></li><li><a href="/2021/04/30/nuxt-bootstrap-dashboard-4/">Axios</a></li><li>Bootstrap &amp; Bootstrap-vue 환경구성</li><li>Page &amp; UI 개발</li></ol><h2 id="Bootstrap-amp-Bootstrap-vue"><a href="#Bootstrap-amp-Bootstrap-vue" class="headerlink" title="Bootstrap &amp; Bootstrap-vue"></a>Bootstrap &amp; Bootstrap-vue</h2><p>Bootstrap은 세계적으로 유명한 UI component library로 웹사이트를 <em>mobile-first</em> &amp; <em>responsive</em> 기능을 지원하는 Sass 기반의 프레임워크이다.</p><blockquote><p>Featuring Sass variables and mixins, responsive grid system, extensive prebuilt components, and powerful JavaScript plugins.</p></blockquote><p>Bootstrap-vue는 Bootstrap의 다양한 기능들을 Vue.js에 맞게 최적환된 UI 프레임워크로써, 이번 프로젝트에서 사용할것입니다.</p><h2 id="설치"><a href="#설치" class="headerlink" title="설치"></a>설치</h2><p>Nuxt에서 Bootstrap-vue를 설치하는 방법은 총 두가지로, 첫번째는 Nuxt CLI를 통한 앱 생성시 UI Component 옵션에서 선택하는 방법과 두번째로는 직접 선택하는 방법입니다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># With npm</span><br><span class="line">npm install bootstrap-vue</span><br><span class="line"></span><br><span class="line"># With yarn</span><br><span class="line">yarn add bootstrap-vue</span><br></pre></td></tr></table></figure><p>설치 후 아래와 같이 <code>nuxt.config.js</code> 파일의 module 프로퍼티에 <code>bootstrap-vue/nuxt</code>를 추가해주면 된다. 이러게 하면 <code>bootstrap.css</code>와 <code>bootstrap-vue.css</code>의 pre-compiled 된 기본 CSS를 포함합니다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">module.exports &#x3D; &#123;</span><br><span class="line">  modules: [&#39;bootstrap-vue&#x2F;nuxt&#39;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>주의할 점은 위와 같은 설치는 Icons 컴포넌트를 설치하지는 않는다는 것입니다. Nuxt.js 모듈에 아이콘을 포함하는 방법은 <a href="https://bootstrap-vue.org/docs#icons">Bootstrap-vue의 Icons 섹션</a>을 참고하는 것으로 대체하겠습니다.</p><h2 id="CSS-최적화-SCSS-모듈-최적화"><a href="#CSS-최적화-SCSS-모듈-최적화" class="headerlink" title="CSS 최적화; SCSS 모듈 최적화"></a>CSS 최적화; SCSS 모듈 최적화</h2><p>설치가 끝나면 <code>nuxt.config.js</code>의 <code>modules</code> property에 추가해주면 bootstrap-vue를 사용할 준비는 모두 끝났다. 그러나… 이렇게 사용할 경우 가장 큰 이슈는 불필요한 SCSS 모듈까지 포함되어 앱의 빌드속도와 렌더링 성능에 이슈가 발생한다. 이와 같은 이슈를 해결하기 위해 공홈의 <a href="https://bootstrap-vue.org/docs"><strong>Using custom Bootstrap SCSS</strong></a> 섹션과 개인적으로 최적화를 위해 사용하는 방법을 적용하고 소개해드리려고 합니다.</p><p>CSS 최적화의 큰 순서는 먼저 pre-compiled 된 CSS 파일의 자동포함을 비활성화하고, 프로젝트에서 사용할 Bootstrap 및 BootstrapVue의 CSS의 사용자 지정 SCSS 파일을 생성해 <code>import</code> 하는 것입니다.</p><h3 id="pre-compiled-된-CSS-파일의-자동포함-비활성화"><a href="#pre-compiled-된-CSS-파일의-자동포함-비활성화" class="headerlink" title="pre-compiled 된 CSS 파일의 자동포함 비활성화"></a>pre-compiled 된 CSS 파일의 자동포함 비활성화</h3><p>Bootstrap SCSS 커스터마이징을 사용하는 경우 아래의 옵션을 <code>false</code>로 설정하여 Bootstrap 및 BootstrapVue pre-compiled 된 CSS 파일의 자동 포함을 비활성화해야 합니다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">module.exports &#x3D; &#123;</span><br><span class="line">  modules: [&#39;bootstrap-vue&#x2F;nuxt&#39;],</span><br><span class="line">  bootstrapVue: &#123;</span><br><span class="line">    bootstrapCSS: false, &#x2F;&#x2F; Or &#96;css: false&#96;</span><br><span class="line">    bootstrapVueCSS: false &#x2F;&#x2F; Or &#96;bvCSS: false&#96;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Bootstrap-SCSS-커스터마이징-with-일반판-Official"><a href="#Bootstrap-SCSS-커스터마이징-with-일반판-Official" class="headerlink" title="Bootstrap SCSS 커스터마이징 with 일반판(Official)"></a>Bootstrap SCSS 커스터마이징 with 일반판(Official)</h3><p>BootstrapVue의 커스터마이징된 SCSS는 Bootstrap SCSS 변수 및 믹스인과 사용자가 설정한 변수 재정의에 의존하며 프로젝트의 사용자 지정 SCSS 파일에 Bootstrap 및 BootstrapVue SCSS를 포함 할 수 있습니다.</p><p>먼저 Bootstrap 및 BootstrapVue의 SCSS 환경을 커스터마이징할 <code>custom.scss</code>을 <strong>assets/styles</strong> 디렉토리에 생성하고, 아래의 코드를 적습니다. <em>(프로젝트의 root에 styles 디렉토리를 생성하셔도 되고, assets 디렉토리에 생성하셔도 됩니다)</em></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Custom Bootstrap variable overrides go first</span><br><span class="line">$grid-breakpoints: (</span><br><span class="line">  xs: 0,</span><br><span class="line">  sm: 480px,</span><br><span class="line">  md: 640px,</span><br><span class="line">  lg: 992px,</span><br><span class="line">  xl: 1300px</span><br><span class="line">);</span><br><span class="line">$enable-rounded: false;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Then include the following</span><br><span class="line">@import &#39;bootstrap&#x2F;scss&#x2F;bootstrap.scss&#39;;</span><br><span class="line">@import &#39;bootstrap-vue&#x2F;src&#x2F;index.scss&#39;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; And define any of your custom or additional CSS&#x2F;SCSS here,</span><br><span class="line">&#x2F;&#x2F; or via an @import</span><br></pre></td></tr></table></figure><p>그런 다음 <code>nuxt.config.js</code> 파일의 <code>css</code> Property에 <code>custom.scss</code> 추가해줍니다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">css: [</span><br><span class="line">  &#39;~&#x2F;assets&#x2F;styles&#x2F;app.scss&#39;</span><br><span class="line">  &#x2F;&#x2F; or</span><br><span class="line">  &#x2F;&#x2F; &#39;~&#x2F;assets&#x2F;app.scss&#39;</span><br><span class="line">],</span><br></pre></td></tr></table></figure><h3 id="Bootstrap-SCSS-커스터마이징-with-확장판"><a href="#Bootstrap-SCSS-커스터마이징-with-확장판" class="headerlink" title="Bootstrap SCSS 커스터마이징 with 확장판"></a>Bootstrap SCSS 커스터마이징 with 확장판</h3><p>지금부터는 제가 Bootstrap과 같은 Component UI 라이브러리를 사용할때 빌드 사이즈를 줄이기 위한 커스터마이징 입니다. 실제 프로젝트에서 제가 사용하는 기법을 바탕으로 설명해드리겠습니다.</p><h4 id="프로젝트-Style-구조화하기"><a href="#프로젝트-Style-구조화하기" class="headerlink" title="프로젝트 Style 구조화하기"></a>프로젝트 Style 구조화하기</h4><p>구조화에 앞서 먼저 해야할 것은 커스터마이징 할 SCSSS 모듈 구조를 파악하는 것입니다. 이번 프로젝트에서는 Bootstrap &amp; BootstrapVue를 사용하며 이 둘의 모듈 구조는 <strong><em>Bootstrap SCSS 커스터마이징 with 일반판(Official)</em></strong> 섹션에서 소개했던 <code>custom.scss</code>의 아래 코드 입니다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Then include the following</span><br><span class="line">@import &#39;bootstrap&#x2F;scss&#x2F;bootstrap.scss&#39;;</span><br><span class="line">@import &#39;bootstrap-vue&#x2F;src&#x2F;index.scss&#39;;</span><br></pre></td></tr></table></figure><p>위 코드에서 알 수 있듯이 <strong>bootstrap</strong>, <strong>bootstrap-vue</strong> 디렉토리의 <em>SCSS 파일</em> 를 참고하고 있으며, 이제부터는 UI Component의 모든 style을 <code>node_modules/</code>로부터 직접 참조하는 구조가 아닌 프로젝트의 style 디렉토리 내에서 <em>필요한 SCSS 모듈만 import해 사용하는 방식으로</em> 구조화 해보겠습니다.</p><p><img src="/images/nuxt-dashboard-style-directory.png" alt="프로젝트 스타일 디렉토리 구조"></p><p>위 이미지에서 볼 수 있듯이 <code>assets/styles</code> 디렉토리는 <code>library</code> 디렉토리와 <code>custom</code> 디렉토리로 구성되어 있으며 <code>library</code> 디렉토리 내에는 <strong>/bootstrap</strong> 과 <strong>/bootstrapVue</strong> 디렉토리로 각자의 SCSS 모듈을 관리하게 될 것입니다.</p><ul><li><code>library</code> 디렉토리: UI Component Library의 SCSS 모듈을 관리</li><li><code>custom</code> 디렉토리: 직접 작성한 SCSS를 관리</li></ul><h4 id="Bootstrap-스타일-커스터마이징"><a href="#Bootstrap-스타일-커스터마이징" class="headerlink" title="Bootstrap 스타일 커스터마이징"></a>Bootstrap 스타일 커스터마이징</h4><p>Bootstrap SCSS 모듈을 커스터마이징 하는 이유는 우리가 프로젝트를 개발할떄 모든 UI 컴포넌트를 사용하지 않을테고, 그럼에도 불구하고 모든 스타일 SCSS 파일들을 빌드한다면 앱의 빌드속도는 물론 앱의 전체 및 페이지 사이즈가 커져 로드 속도 또한 느려지기 때문입니다. 커스터마이징의 시작은 Bootstrap SCSS 파일 구조를 파악하는 것입니다.</p><p>아래 이미지의 좌측 탭은 <code>node_modules/bootstrap/scss/bootstrap.scss</code> 파일을 <code>/library/bootstrap</code> 디렉터리에 복사한 것으로, import된 모듈 경로를 수정해준후 필요한 컴포넌트의 스타일만 쓸수 있도록 설정해줍니다.</p><p><img src="/images/nuxt-dashboard-style-directory-3.png" alt="Bootstrap SCSS 모듈 최적화"></p><p>그리고 다음으로 커스터마이징이 필요한 파일은 아래와 같으며 <code>_bootstrap.scss</code>을 복사 및 작업했던 순서로 반복작업을 해줍니다.</p><ul><li><code>node_modules/bootstrap/scss/_variables.scss</code>: <ul><li>bootstrap과 bootstrapVue에서 공통으로 쓰이는 SCSS 변수 파일로 </li><li>특정 Component의 border-radius 값이나 color 값을 변경할 수 있음</li></ul></li><li><code>node_modules/bootstrap/scss/_mixins.scss</code>: <ul><li>bootstrap과 bootstrapVue에서 공통으로 쓰이는 SCSS mixin 파일로 </li><li><code>_bootstrap.scss</code>에서 비활성화된 컴포넌트와 관련된 <strong>mixin</strong> 모듈을 비활성화할 수 있음</li></ul></li></ul><p><strong>bootstrap</strong> 에 필요한 모듈 커스터마이징을 완료했다면 다음으로는 <strong>bootstrapVue</strong> 를 <em>bootstrap</em> 과 같은 방식으로 커스터마이징 해주면 되며 모듈 최적화한 디렉토리는 아래와 같다.</p><p><img src="/images/nuxt-dashboard-style-directory-4.png" alt="Bootstrap 및 BootstrapVue SCSS 모듈 최적화"></p><h2 id="마치며"><a href="#마치며" class="headerlink" title="마치며"></a>마치며</h2><p>프론트엔드 UI를 개발하면서 Custom Style를 직접 개발할 수 있지만 최근에는 워낙 UI Library가 잘 개발되어 있으며 다양한 플랫폼에 맞게 그리고 다양한 디자인 트렌드에 맞게 구성되어 있습니다. 따라서 UI Library를 사용할 경우 위와 같은 커스터마이징을 통해 앱의 불필요한 스타일을 비포함할 수 있으며 특정 UI의 스타일을 수정해 사용할때도 적용할 수 있는 방법입니다.</p><p>다음으로는 대망의 페이지 개발입니다. 페이지 개발의 첫번째 순서로, <strong>레이아웃 설계</strong> 에 대해 포스팅해보겠습니다.</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;/images/nuxt.png&quot; alt=&quot;Nuxt.js&quot;&gt;&lt;/p&gt;
&lt;p&gt;오늘의 포스트는 &lt;strong&gt;&lt;em&gt;Nuxt와 Bootstrap4 기반의 Dashboard 만들기&lt;/em&gt;&lt;/strong&gt; 의 다섯번째 포스트로 &lt;stro</summary>
      
    
    
    
    <category term="Programming" scheme="https://joontae-kim.github.io/categories/Programming/"/>
    
    <category term="nuxt" scheme="https://joontae-kim.github.io/categories/Programming/nuxt/"/>
    
    
    <category term="vue.js" scheme="https://joontae-kim.github.io/tags/vue-js/"/>
    
    <category term="nuxt.js" scheme="https://joontae-kim.github.io/tags/nuxt-js/"/>
    
    <category term="vue" scheme="https://joontae-kim.github.io/tags/vue/"/>
    
    <category term="nuxt" scheme="https://joontae-kim.github.io/tags/nuxt/"/>
    
    <category term="project" scheme="https://joontae-kim.github.io/tags/project/"/>
    
    <category term="portfolio" scheme="https://joontae-kim.github.io/tags/portfolio/"/>
    
    <category term="bootstrap" scheme="https://joontae-kim.github.io/tags/bootstrap/"/>
    
    <category term="bootstrap-vue" scheme="https://joontae-kim.github.io/tags/bootstrap-vue/"/>
    
  </entry>
  
  <entry>
    <title>Nuxt와 Bootstrap4 기반의 Dashboard 만들기</title>
    <link href="https://joontae-kim.github.io/2021/04/30/nuxt-bootstrap-dashboard-4/"/>
    <id>https://joontae-kim.github.io/2021/04/30/nuxt-bootstrap-dashboard-4/</id>
    <published>2021-04-29T18:28:32.000Z</published>
    <updated>2021-04-30T17:32:33.111Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/nuxt.png" alt="Nuxt.js"></p><p>오늘의 포스트는 <strong><em>Nuxt와 Bootstrap4 기반의 Dashboard 만들기</em></strong> 의 네번째 포스트로 <strong>Axios</strong>에 대해 작성해보겠습니다.</p><p>지난 포스트에서는 Nuxt &amp; Express API 환경구성에 대해 작업해봤습니다. 본 포스트에서는 Nuxt에서 Axios를 사용하기 위한 환경세팅과 사용예제까지 다뤄보겠습니다.</p><h2 id="개발-순서"><a href="#개발-순서" class="headerlink" title="개발 순서"></a>개발 순서</h2><ol><li><a href="/2021/04/28/nuxt-bootstrap-dashboard-1/">프로젝트 생성 및 Github Repository 환경구성</a></li><li><a href="/2021/04/28/nuxt-bootstrap-dashboard-2/">Heroku 배포 환경구성</a></li><li><a href="/2021/04/29/nuxt-bootstrap-dashboard-3/">Nuxt &amp; Express API 환경구성</a></li><li><a href="/2021/04/30/nuxt-bootstrap-dashboard-4/">Axios</a></li><li>Bootstrap &amp; Bootstrap-vue 환경구성</li><li>Page &amp; UI 개발</li></ol><h2 id="Axios"><a href="#Axios" class="headerlink" title="Axios"></a>Axios</h2><p>Axios는 browser와 node.js 기반 어플리케이션을 위한 promise 기반의 HTTP client로, 서버 사이드에서는 native node.js <code>http</code> 모듈을 사용하고, 클라이언드 사이드에서는 XMLHttpRequests 기반으로 작동한다. Axios에 대한 자세한 사항은 <a href="https://axios-http.com/docs/intro">Axios 공식 문서</a>를 참고해주시고, 이번 포스트에서는 Nuxt에서 사용하기 위한 Axios에 대한 부분만 다뤄보도록 하겠습니다.</p><h2 id="Axios-with-Nuxt"><a href="#Axios-with-Nuxt" class="headerlink" title="Axios with Nuxt"></a>Axios with Nuxt</h2><p><img src="/images/nuxt-axios.png" alt="nuxt/axios"></p><p>Nuxt에서 Axios를 사용하기 위해서는 우리가 아는 axios가 아닌 Nuxt에 통합 및 최적화된 <strong><em>nuxt/axios</em></strong> 를 설치해 사용해야한다.</p><h3 id="기능"><a href="#기능" class="headerlink" title="기능"></a>기능</h3><ul><li>Automatically set base URL for client &amp; server side</li><li>Exposes <code>setToken</code> function to <code>$axios</code> so we can easily and globally set authentication tokens</li><li>Automatically enables <code>withCredentials</code> when requesting to base URL</li><li>Proxy request headers in SSR</li><li>Fetch Style requests</li><li>Integrated with Nuxt progress bar</li><li>Integrated with Proxy Module</li><li>Auto retry requests with axios-retry</li></ul><h2 id="설치"><a href="#설치" class="headerlink" title="설치"></a>설치</h2><p>설치하는 방법은 두 가지가 있다. 첫째는 Nuxt CLI로 앱 생성시 <code>Nuxt.js modules</code> 선택 옵션에서 설치하는 방법과 두번째는 일반적인 node package 설치 방법이다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Install by yarn</span><br><span class="line">yarn add @nuxtjs&#x2F;axios</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Install by npm</span><br><span class="line">npm install @nuxtjs&#x2F;axios</span><br></pre></td></tr></table></figure><h2 id="환경구성"><a href="#환경구성" class="headerlink" title="환경구성"></a>환경구성</h2><p>설치가 완료되면 root 디렉토리에 위치한 <code>nuxt.config.js</code> 파일의 <code>modules</code> 프로퍼티에 아래와 같이 <code>&#39;@nuxtjs/axios&#39;</code>를 추가해주면 Axios를 통한 모든 요청에 동일한 설정을 적용할 수 있습니다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">export default &#123;</span><br><span class="line">  modules: [&#39;@nuxtjs&#x2F;axios&#39;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>이제 Nuxt app에서 <code>$axios</code>를 사용할 수 있습니다. ✨</p><h2 id="옵션s"><a href="#옵션s" class="headerlink" title="옵션s"></a>옵션s</h2><p>nuxt에서 설정할 수 있는 옵션은 아래와 같다.</p><ul><li>Runtile Config</li><li>prfix, host and port</li><li>baseURL</li><li>browserBaseURL</li><li>https</li><li>progress</li><li>proxy</li><li>retry</li><li>credentials</li><li>debug</li><li>proxyHeaders</li><li>proxyHeaersIgnore</li><li>headers</li></ul><p>하지만… 위 옵션들을 다 하기에는 너무 많으므로 현재 필요한 <code>baseURL</code>만 다뤄봤기 때문에 이 옵션만 다루고 나머지는 추후 포스팅 해보겠습니다. </p><h4 id="baseURL"><a href="#baseURL" class="headerlink" title="baseURL"></a>baseURL</h4><p><code>baseURL</code>는 서버측 request를 작성하기 위해 사용되는 URL의 기본주소를 정의하는 옵션으로 <code>nuxt.config.js</code>에 아래와 같이 <code>axios</code> property에 <code>baseURL</code>을 지정해주면 된다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Axios module configuration</span><br><span class="line">&#x2F;&#x2F; See https:&#x2F;&#x2F;axios.nuxtjs.org&#x2F;options</span><br><span class="line">axios: &#123;</span><br><span class="line">  baseURL: process.env.baseURL || &#39;http:&#x2F;&#x2F;localhost:3000&#39;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>process.env.baseURL</code>은 전역 환경변수에 baseURL을 정의한 전역 환경변수로써, <code>process.env.API_URL</code>을 사용할 경우 <code>baseURL</code>을 덮어쓸수 있다(<em>override</em>). 주의할 점은 <code>baseURL</code>과 <code>proxy</code>를 동시에 사용할 수 없으며 <code>proxy</code> 옵션을 사용하고 싶으면 <code>baseURL</code> 대신에 <code>prefix</code>에 정의할 필요가 있다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Option: Proxy</span><br><span class="line">axios: &#123;</span><br><span class="line">  proxy: true &#x2F;&#x2F; Can be also an object with default options</span><br><span class="line">&#125;,</span><br><span class="line"></span><br><span class="line">proxy: &#123;</span><br><span class="line">  &#39;&#x2F;api&#x2F;&#39;: &#39;http:&#x2F;&#x2F;api.example.com&#39;,</span><br><span class="line">  &#39;&#x2F;api2&#x2F;&#39;: &#39;http:&#x2F;&#x2F;api.another-website.com&#39;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>일반적으로 요청할 full adresss를 입력해야 하지만 아래와 같이 <code>baseURL</code> 옵션을 설정하면 특정 API route의 경로만 입력해도 된다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; &#96;baseURL&#96; 미지정</span><br><span class="line">await $axios.$get(&#39;http:&#x2F;&#x2F;localhost:3000&#x2F;api&#x2F;something&#39;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; &#96;baseURL&#96; 지정</span><br><span class="line">await $axios.$get(&#39;&#x2F;api&#x2F;something&#39;)</span><br></pre></td></tr></table></figure><h2 id="Extension"><a href="#Extension" class="headerlink" title="Extension"></a>Extension</h2><p>공식적으로 지원하는 확장 기능은 아래와 같다.</p><ul><li>Adding Interceptors</li><li>New Axios instance</li></ul><p>이번에도 내가 필요한건 <strong>Interceptors</strong> 기능이므로 이것만 해보겠습니다.</p><h3 id="Interceptors-with-Axios"><a href="#Interceptors-with-Axios" class="headerlink" title="Interceptors with Axios"></a>Interceptors with Axios</h3><p>Interceptors 기능은 요청 또는 응답 전에 API 통신 error 등을 handling 할 수 있는 기능들을 axios의 전역 환경에 적용할 수 있는 기능입니다.</p><p>먼저, <code>plugins/axios.js</code>를 생성해 아래의 코드를 입력 후 <code>nuxt.config.js</code> 파일에 <code>plugin</code>을 등록해줍니다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; plugins&#x2F;axios.js</span><br><span class="line"></span><br><span class="line">export default function (&#123; $axios, redirect &#125;) &#123;</span><br><span class="line">  $axios.onRequest(config &#x3D;&gt; &#123;</span><br><span class="line">    console.log(&#39;Making request to &#39; + config.url)</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  $axios.onError(error &#x3D;&gt; &#123;</span><br><span class="line">    const code &#x3D; parseInt(error.response &amp;&amp; error.response.status)</span><br><span class="line">    if (code &#x3D;&#x3D;&#x3D; 400) &#123;</span><br><span class="line">      redirect(&#39;&#x2F;400&#39;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; nuxt.config.js</span><br><span class="line"></span><br><span class="line">export default &#123;</span><br><span class="line">  plugins: [</span><br><span class="line">    &#39;~&#x2F;plugins&#x2F;axios&#39;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Helpers"><a href="#Helpers" class="headerlink" title="Helpers"></a>Helpers</h2><p>nuxt/axios는 <strong>Interceptors</strong> 기능을 확장할 수 있는 Helpers API를 가지고 있습니다.</p><h3 id="Interceptors"><a href="#Interceptors" class="headerlink" title="Interceptors"></a>Interceptors</h3><p>Axios plugin은 Interceptors를 쉽고 빠르게 등록할 수 있도록 도와주며 아래의 함수들은 기본적으로 그 어떠한 값도 반환하지 않습니다.</p><ul><li><code>onRequest(config)</code></li><li><code>onResponse(response)</code></li><li><code>onError(err)</code></li><li><code>onRequestError(err)</code></li><li><code>onResponseError(err)</code></li></ul><p>예시: (<code>plugins/axios.js</code>)</p><p>error에 대해 인터셉트(intercept)할 경우, 오류 전파를 방지하기 위해 resolved promise를 반환합니다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">export default function (&#123; $axios, error: nuxtError &#125;) &#123;</span><br><span class="line">  $axios.onError(error &#x3D;&gt; &#123;</span><br><span class="line">    nuxtError(&#123;</span><br><span class="line">      statusCode: error.response.status,</span><br><span class="line">      message: error.message,</span><br><span class="line">    &#125;);</span><br><span class="line">    return Promise.resolve(false);</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="사용예제-Axios-Interceptors-Helpers"><a href="#사용예제-Axios-Interceptors-Helpers" class="headerlink" title="사용예제: Axios, Interceptors, Helpers"></a>사용예제: Axios, Interceptors, Helpers</h2><p>간단하게, Axios를 확장해보는 예제를 진행해보겠습니다.</p><h3 id="에러-핸들링-시나리오"><a href="#에러-핸들링-시나리오" class="headerlink" title="에러 핸들링 시나리오"></a>에러 핸들링 시나리오</h3><ol><li><code>404</code> 에러: redirect(<code>404</code>) </li><li><code>500</code> 에러: redirect(<code>500</code>) </li><li>이외 에러: Promise.reject({ statusCode, message })</li></ol><p>위 시나리오는 RestAPI 통신시 <code>404</code>, <code>500</code> 에러가 왔을때 <code>/404</code>, <code>/500</code> 페이지로 redirect하고, 이외의 에러는 <code>return Promise.reject(error)</code>으로 원래의 HTTP error를 return 하려고 한다. 구현 코드는 아래와 같다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; plugin&#x2F;axios.js</span><br><span class="line"></span><br><span class="line">export default function (&#123; $axios, redirect &#125;) &#123;</span><br><span class="line">  &#x2F;&#x2F; Set baseURL</span><br><span class="line">  $axios.setBaseURL(process.env.baseURL || &#39;http:&#x2F;&#x2F;localhost:3000&#39;)</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; Add Interceptor</span><br><span class="line">  $axios.onError((error) &#x3D;&gt; &#123;</span><br><span class="line">    if (error.response.status &#x3D;&#x3D;&#x3D; 500) &#123;</span><br><span class="line">      redirect(&#39;&#x2F;500&#39;)</span><br><span class="line">    &#125; else if (error.response.status &#x3D;&#x3D;&#x3D; 404) &#123;</span><br><span class="line">      redirect(&#39;&#x2F;404&#39;)</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      return Promise.reject(error)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>그리고 구현된 axios 플러그인을 <code>nuxt.config.js</code>에 등록해줍니다. axios 관련 설정은 아래와 같습니다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; baseURL 의 경우, nuxt.config.js 또는 plugin&#x2F;axios.js 중 한 곳에서 설정해주면 됩니다.</span><br><span class="line">export default &#123;</span><br><span class="line">  &#x2F;&#x2F; Plugins to run before rendering page: https:&#x2F;&#x2F;go.nuxtjs.dev&#x2F;config-plugins</span><br><span class="line">  plugins: [</span><br><span class="line">    &#39;~&#x2F;plugins&#x2F;axios&#39;</span><br><span class="line">  ],</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; Modules: https:&#x2F;&#x2F;go.nuxtjs.dev&#x2F;config-modules</span><br><span class="line">  modules: [</span><br><span class="line">    &#39;@nuxtjs&#x2F;axios&#39;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="마치며"><a href="#마치며" class="headerlink" title="마치며"></a>마치며</h2><p>지금까지 Nuxt에서 Axios 설치, 옵션 세팅 및 확장기능에 대해 다뤄봤습니다. 설치 및 사용하기 위한 옵션들이 기존의 SPA 앱을 만들기 위한 Vue.js에서와 많은 차이점이 있었고, Helper API, Extension 등의 내용을 살펴보면서 Nuxt 기반의 Axios는 어떻게 기능 확장을 할 수 있는지도 연습해봤습니다. </p><p>다음 포스팅에서는 본 프로젝트에서 사용할 UI Component인 <strong>Boostrap &amp; Boostrap-vue</strong> 에 대해 다뤄보겠습니다. 수고 많으셨습니다!</p><hr><h2 id="참고"><a href="#참고" class="headerlink" title="참고"></a>참고</h2><ul><li><a href="https://axios.nuxtjs.org/">the official for nuxt/axios</a></li><li><a href="https://nuxtjs.org/docs/2.x/directory-structure/modules">directory-structure/modules</a></li><li><a href="https://nuxtjs.org/docs/2.x/directory-structure/plugins">directory-structure/plugins</a></li><li><a href="https://nuxtjs.org/docs/2.x/directory-structure/nuxt-config">directory-structure/nuxt-config</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;/images/nuxt.png&quot; alt=&quot;Nuxt.js&quot;&gt;&lt;/p&gt;
&lt;p&gt;오늘의 포스트는 &lt;strong&gt;&lt;em&gt;Nuxt와 Bootstrap4 기반의 Dashboard 만들기&lt;/em&gt;&lt;/strong&gt; 의 네번째 포스트로 &lt;stron</summary>
      
    
    
    
    <category term="Programming" scheme="https://joontae-kim.github.io/categories/Programming/"/>
    
    <category term="nuxt" scheme="https://joontae-kim.github.io/categories/Programming/nuxt/"/>
    
    
    <category term="vue.js" scheme="https://joontae-kim.github.io/tags/vue-js/"/>
    
    <category term="nuxt.js" scheme="https://joontae-kim.github.io/tags/nuxt-js/"/>
    
    <category term="vue" scheme="https://joontae-kim.github.io/tags/vue/"/>
    
    <category term="nuxt" scheme="https://joontae-kim.github.io/tags/nuxt/"/>
    
    <category term="project" scheme="https://joontae-kim.github.io/tags/project/"/>
    
    <category term="portfolio" scheme="https://joontae-kim.github.io/tags/portfolio/"/>
    
  </entry>
  
  <entry>
    <title>Nuxt와 Bootstrap4 기반의 Dashboard 만들기</title>
    <link href="https://joontae-kim.github.io/2021/04/29/nuxt-bootstrap-dashboard-3/"/>
    <id>https://joontae-kim.github.io/2021/04/29/nuxt-bootstrap-dashboard-3/</id>
    <published>2021-04-29T07:18:23.000Z</published>
    <updated>2021-04-29T16:47:19.941Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/nuxt.png" alt="Nuxt.js"></p><p>오늘의 포스트는 <strong><em>Nuxt와 Bootstrap4 기반의 Dashboard 만들기</em></strong> 의 세번째 포스트로 <strong>Nuxt &amp; Express API 환경구성</strong>에 대해 작성해보겠습니다.</p><p>지난 포스트에서는 Heroku에 Nuxt SSR 앱을 배포하기 위한 환경설정과 배포가 되는 과정에 대해 작업해봤습니다. 본 포스트에서는 Nuxt 앱에 Express 기반의 API 생성과 Nuxt 앱에 API를 연결하는 부분까지 다뤄보겠습니다.</p><h2 id="개발-순서"><a href="#개발-순서" class="headerlink" title="개발 순서"></a>개발 순서</h2><ol><li><a href="/2021/04/28/nuxt-bootstrap-dashboard-1/">프로젝트 생성 및 Github Repository 환경구성</a></li><li><a href="/2021/04/28/nuxt-bootstrap-dashboard-2/">Heroku 배포 환경구성</a></li><li><a href="/2021/04/29/nuxt-bootstrap-dashboard-3/">Nuxt &amp; Express API 환경구성</a></li><li>Axios</li><li>Bootstrap &amp; Bootstrap-vue 환경구성</li><li>Page &amp; UI 개발</li></ol><h2 id="들어가며…"><a href="#들어가며…" class="headerlink" title="들어가며…"></a>들어가며…</h2><p>Nuxt 앱으로 샘플을 만들때 가장 고민했던 부분이 API 설계였다. 이유인 즉슨, API 설계를 고려하니 개발의 바운더리를 어디까지 정해야 할지 고민이 많이 됐기 때문이다. 정식으로 Database 붙이고, 설계하고, 에러 처리하고 등등 해야할 작업이 많기 때문이다. 그래서 이번 프로젝트는 포폴용이기 때문에 Back-end에서 Database없이 Sample Data로 대체하고 API 설계는 하던데로 controller와 route 설계 및 개발을 하기로 결정했다.</p><h2 id="Express-with-my-nuxt-app"><a href="#Express-with-my-nuxt-app" class="headerlink" title="Express with my nuxt app?"></a>Express with my nuxt app?</h2><p>Nuxt CLI를 통해 Nuxt App을 생성할때 <strong>Use a custom server framework</strong> 질문이 나오면 그때 express를 선택해 Server Template이 생성된 Nuxt app을 생성할 수 있다고 다른 블로그에서 많이 봤는데 CLI로 아무리 생성해봐도 custom server framework에 관한 질문은 나오지 않았다… 그래서 Nuxt의 공식 Github 저장소에 들어가서 issue를 뒤지던 중 2020년까지 넘어가니 아래와 같은 Issue를 찾을 수 있었고, 요약하자면 <strong>“deprecated”</strong> 되었다고 한다.</p><p><img src="/images/nuxt-express-not-support.png" alt="not-support"><br><img src="/images/nuxt-express-not-support-message.png" alt="not-support 이유"></p><p>뭐… 아무튼… 잘못 사용하는 개발자들이 있었고 <strong><em>“not a good practice for most use cases”</em></strong> 가 있어서 CLI를 통한 앱 생성 질문에서 제거했다는 말이고, 대체 방법으로 API 라우트를 위해 <code>express</code>를 사용하는 방법으로 <a href="https://nuxtjs.org/api/configuration-servermiddleware">servermiddleware</a>를 대체 방법으로 추천한다고 한다.</p><blockquote><p>The current alternative recommended approach is using a serverMiddleware to use express for API routes (supports HMR as well) or using separate server or serverless functions.</p></blockquote><p>그렇다고 아예 방법이 없는 것이 아니었다. custom backend templates가 있지만 <em>maybe outdated</em> 상태라고 기재해놔서 express template을 사용할까말까 고민하다가 그래도 추천 방법으로 직접 세팅해보는 방법을 선택했다. 아래는 custom backend templates 링크 목록이다.</p><ul><li>Express: <a href="https://github.com/nuxt-community/express-template">https://github.com/nuxt-community/express-template</a></li><li>Koa: <a href="https://github.com/nuxt-community/koa-template">https://github.com/nuxt-community/koa-template</a></li><li>Addonis: <a href="https://github.com/nuxt-community/adonuxt-template">https://github.com/nuxt-community/adonuxt-template</a></li><li>Hapi (deprecated): <a href="https://github.com/nuxt-community/hapi-nuxt">https://github.com/nuxt-community/hapi-nuxt</a></li></ul><h2 id="serverMiddleware"><a href="#serverMiddleware" class="headerlink" title="serverMiddleware"></a>serverMiddleware</h2><blockquote><p>The current alternative recommended approach is using a serverMiddleware to use express for API routes (supports HMR as well) or using separate server or serverless functions. - from <a href="https://github.com/nuxt/create-nuxt-app/issues/563#issuecomment-656611288">https://github.com/nuxt/create-nuxt-app/issues/563#issuecomment-656611288</a></p></blockquote><p>현재는 공식적으로 추천하는 방법은 <code>serverMiddleware</code>를 사용하는 것이다.</p><p>Nuxt.js에 대한 <a href="https://nuxtjs.org/docs/2.x/configuration-glossary/configuration-servermiddleware">serverMiddleware에 대한 공식 블로그 설명</a>을 참고해보면 아래와 같습니다.</p><blockquote><p>Nuxt는 사용자 지정 미들웨어를 추가할 수 있는 <a href="https://github.com/senchalabs/connect">connet</a> 인스턴스를 내부적으로 생성합니다. 이를 통해 <strong>외부 서버없이</strong> 추가 경로 (일반적으로 <code>/api</code> 경로)를 등록 할 수 있습니다. connect 자체가 미들웨어이기 때문에 등록된 미들웨어는 <code>nuxt start</code>와 함께 작동 할뿐만 아니라 <a href="https://github.com/nuxt-community/express-template">express-template</a>과 같은 프로그래밍 방식으로 사용되는 미들웨어로 사용될 때도 작동합니다. Nuxt <a href="https://nuxtjs.org/docs/2.x/directory-structure/modules">모듈</a>은 <a href="https://nuxtjs.org/docs/2.x/internals-glossary/internals-module-container#addservermiddleware-middleware">this.addServerMiddleware()</a>를 사용하여 <code>serverMiddleware</code>를 제공 할 수도 있습니다.</p></blockquote><p>예) </p><ul><li>Server middleware path: <code>/server-middleware</code></li><li>Router base: <code>/admin</code></li><li>With <code>prefix: true</code> (default): <code>/admin/server-middleware</code></li><li>With <code>prefix: false</code>: <code>/server-middleware</code></li></ul><h2 id="Test-Case"><a href="#Test-Case" class="headerlink" title="Test Case"></a>Test Case</h2><p>Custom API endpoint 생성전 먼저 <code>express</code>를 설치해야한다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i -S express</span><br></pre></td></tr></table></figure><h3 id="Custom-API-endpoint"><a href="#Custom-API-endpoint" class="headerlink" title="Custom API endpoint"></a>Custom API endpoint</h3><p>Custom API endpoint를 생성해보자. 프로젝트 디렉토리의 root 위치에서 <code>api</code> 디렉터리를 생성하고 API endpoint의 Test Case로 <code>test.js</code>을 생성 및 작성해보자.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">import express from &#39;express&#39;;</span><br><span class="line">const app &#x3D; express()</span><br><span class="line"></span><br><span class="line">app.get(&#39;&#x2F;&#39;, (req, res) &#x3D;&gt; &#123;</span><br><span class="line">  console.log(&#39;&#x2F;api&#x2F;test&#39;);</span><br><span class="line">  res.send(&#39;&#x2F;api&#x2F;test&#39;);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">module.exports &#x3D; app</span><br></pre></td></tr></table></figure><h3 id="serverMiddleware-설정"><a href="#serverMiddleware-설정" class="headerlink" title="serverMiddleware 설정"></a>serverMiddleware 설정</h3><p>Test Case로 작성한 <code>test.js</code> Endpoint를 <code>nuxt.config.js</code>의 <code>serverMiddleware</code> property에 추가해주자.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">serverMiddleware: [</span><br><span class="line">  &#123; path: &#39;&#x2F;test&#39;, handler: &#39;~&#x2F;api&#x2F;test.js&#39; &#125;</span><br><span class="line">],</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 또는</span><br><span class="line">&#x2F;&#x2F; serverMiddleware: [</span><br><span class="line">&#x2F;&#x2F;  &#123; &#39;&#x2F;test&#39;: &#39;~&#x2F;api&#x2F;test.js&#39; &#125;</span><br><span class="line">&#x2F;&#x2F; ],</span><br></pre></td></tr></table></figure><p><code>serverMiddleware</code>는 Array 형태로 위와 같이 API endpoint를 추가할 수 있으며 각 요소는 <code>path</code>와 <code>handler</code>를 맵핑하는 구조이다.</p><ul><li><code>path</code>: client에서 호출할 주소 또는 경로</li><li><code>handler</code>: API endpoint의 함수 목록</li></ul><h3 id="API-호출"><a href="#API-호출" class="headerlink" title="API 호출"></a>API 호출</h3><p><code>serverMiddleware</code> 까지 완료되었다면 이젠 호출을 해보자. 현재 가지고 있는 Page는 아무 페이지에서 호출 테스트를 진행해보자. 본인은 현재 <code>pages/index.vue</code>만 있기 때문에 아래와 같이 작성헸고, 페이지를 reload하면..</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">export default &#123;</span><br><span class="line">  async created () &#123;</span><br><span class="line">    await this.callAPITest()</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    async callAPITest () &#123;</span><br><span class="line">      try &#123;</span><br><span class="line">        console.log(&#39;callAPITest ~ &#39;)</span><br><span class="line">        &#x2F;&#x2F; console.log(&#96;            ~ &#96;)</span><br><span class="line">        const res &#x3D; await this.$axios.$get(&#39;&#x2F;test&#x2F;&#39;)</span><br><span class="line">        console.log(&#39;            ~ res &#x3D;&gt; &#39;, res)</span><br><span class="line">      &#125; catch (e) &#123;</span><br><span class="line">        console.log(&#39;            ~ e &#x3D;&gt; &#39;, e)</span><br><span class="line">        console.log(&#39;            ~ e.response &#x3D;&gt; &#39;, e.response)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>성공!!!</p><p><img src="/images/nuxt-express-response.png" alt="console.log"></p><h2 id="마치며"><a href="#마치며" class="headerlink" title="마치며"></a>마치며</h2><p>간단한거 같지만 Nuxt CLI에서 <strong>custom server template</strong> 에 대한 옵션을 <em>deprecated</em> 하면서 다소 빙글빙글 돌아간 느낌이 적지 않지만 그래서 Nuxt의 깃허브 공식 레포지터리에서 원하는 정보를 찾은 후로는 괜찮은 블로그를 많이 찾아 다행이었습니다.<br>이번 포스팅에서 해봤던 구조는 단순한 것으로 더 많은 기능들이 추가되면 최적화 또는 여타 보완해야할 점들이 많을 것으로 추측되며 위와 같은 구조로 Rest API를 연동하면 된다는 소개 정도로 이해하셨으면 좋겠습니다.</p><p>다음 포스팅에서는 API 통신을 위한 HTTP 모듈인 Axios에 대해 다뤄보겠습니다. 수고 많으셨습니다!</p><h2 id="참고"><a href="#참고" class="headerlink" title="참고"></a>참고</h2><ul><li><a href="https://www.youtube.com/watch?v=nngsKhTb2BA">Nuxt Universal SSR Deployment to Heroku — includes connecting to an API and debugging Vuetify</a></li><li><a href="https://github.com/nuxt/create-nuxt-app/issues/563">Express with my nuxt app? #563</a></li><li><a href="https://nuxtjs.org/docs/2.x/configuration-glossary/configuration-dev">configuration glossary/configuration dev</a></li><li><a href="https://bithacker.dev/use-express-with-nuxt-js">use express with nuxt.js</a></li><li><a href="https://blog.lichter.io/posts/nuxt-with-an-api/#using-nuxt-programmatically">nuxt with an api/#using-nuxt-programmatically</a></li><li><a href="https://minu0807.tistory.com/75?category=938310">[VueJS] NuxtJS안에 express 적용하기</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;/images/nuxt.png&quot; alt=&quot;Nuxt.js&quot;&gt;&lt;/p&gt;
&lt;p&gt;오늘의 포스트는 &lt;strong&gt;&lt;em&gt;Nuxt와 Bootstrap4 기반의 Dashboard 만들기&lt;/em&gt;&lt;/strong&gt; 의 세번째 포스트로 &lt;stron</summary>
      
    
    
    
    <category term="Programming" scheme="https://joontae-kim.github.io/categories/Programming/"/>
    
    <category term="nuxt" scheme="https://joontae-kim.github.io/categories/Programming/nuxt/"/>
    
    
    <category term="vue.js" scheme="https://joontae-kim.github.io/tags/vue-js/"/>
    
    <category term="nuxt.js" scheme="https://joontae-kim.github.io/tags/nuxt-js/"/>
    
    <category term="vue" scheme="https://joontae-kim.github.io/tags/vue/"/>
    
    <category term="nuxt" scheme="https://joontae-kim.github.io/tags/nuxt/"/>
    
    <category term="project" scheme="https://joontae-kim.github.io/tags/project/"/>
    
    <category term="portfolio" scheme="https://joontae-kim.github.io/tags/portfolio/"/>
    
  </entry>
  
  <entry>
    <title>Nuxt와 Bootstrap4 기반의 Dashboard 만들기</title>
    <link href="https://joontae-kim.github.io/2021/04/28/nuxt-bootstrap-dashboard-2/"/>
    <id>https://joontae-kim.github.io/2021/04/28/nuxt-bootstrap-dashboard-2/</id>
    <published>2021-04-28T11:47:24.000Z</published>
    <updated>2021-04-29T07:40:27.282Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/nuxt.png" alt="Nuxt.js"></p><p>오늘의 포스트는 <strong><em>Nuxt와 Bootstrap4 기반의 Dashboard 만들기</em></strong>의 두번째 포스트로 <strong>Heroku 배포 환경구성</strong> 에 대해 작성해보겠습니다.</p><p>지난 포스트에서 Nuxt 프로젝트 생성과 Github Repository 환경구성을 해보았습니다. Nuxt 앱을 생성하기 위한 첫 시작부터 생성과정 그리고 버전관리를 위한 Github Repository를 생성하고 프로젝트에 연결했습니다.</p><p>본 포스트에서는 배포전략과 그에 따른 Heroku 서버 생성하기 및 배포 환경설정까지 다뤄보겠습니다.</p><h2 id="개발-순서"><a href="#개발-순서" class="headerlink" title="개발 순서"></a>개발 순서</h2><ol><li><a href="/2021/04/28/nuxt-bootstrap-dashboard-1/">프로젝트 생성 및 Github Repository 환경구성</a></li><li><a href="/2021/04/28/nuxt-bootstrap-dashboard-2/">Heroku 배포 환경구성</a></li><li>Nuxt &amp; Express API 환경구성</li><li>Axios</li><li>Bootstrap &amp; Bootstrap-vue 환경구성</li><li>Page &amp; UI 개발</li></ol><h2 id="Heroku-란…"><a href="#Heroku-란…" class="headerlink" title="Heroku 란…"></a>Heroku 란…</h2><p><img src="/images/heroku-about.png" alt="Heroku"></p><p>Heroku란 컨테이너 기반의 클라우드 플랫폼으로 Paas 서비스로써, Java, Node.js, Python등 여러 언어를 지원하며 Heroku에서 지원하는 Interface에 따라 별도의 인프라 설정없이 손쉽게 앱을 배포할 수 있도록 지원해준다.</p><p><strong><em>회원가입이나 Heroku의 회원가입 및 배포 방법에 대한 정보는 다른 블로그를 참고하시길 바랍니다.</em></strong></p><h3 id="프로젝트-배포-전략"><a href="#프로젝트-배포-전략" class="headerlink" title="프로젝트 배포 전략"></a>프로젝트 배포 전략</h3><p>Heroku에서 App을 생성하기 전에 먼저, 프로젝트의 배포 전략을 수립해야합니다. 왜냐하면, 배포 전략에 따라 <strong>review</strong>, <strong>staging</strong>, <strong>production</strong> 환경의 서버가 필요할수 있기 때문이다.</p><p>본 프로젝트에서는 Git workflow를 아래의 branch와 같이 운용할 계획이며 배포전략은 <em>master</em> 브랜치를 <strong>production</strong> 서버로, <em>develop</em> 브랜치를 <strong>staging</strong> 서버로 계획했다.</p><ul><li>master</li><li>develop</li><li>hotfix</li><li>release</li><li>feature</li></ul><h2 id="배포전략에-따른-Heroku-App-생성하기"><a href="#배포전략에-따른-Heroku-App-생성하기" class="headerlink" title="배포전략에 따른 Heroku App 생성하기"></a>배포전략에 따른 Heroku App 생성하기</h2><p>위에서 필요한 배포 서버가 정해졌으므로 <strong>production</strong>, <strong>staging</strong> 서버를 생성 및 코드 배포를 위한 환경설정을 진행해보겠습니다.</p><h3 id="staging-서버-생성-및-배포-환경설정"><a href="#staging-서버-생성-및-배포-환경설정" class="headerlink" title="staging 서버 생성 및 배포 환경설정"></a>staging 서버 생성 및 배포 환경설정</h3><p><strong>staging</strong> 서버는 production 서버에 배포하기 전 테스트와 기능점검을 하기 위한 서버로써 Github 원격 Repository의 <strong>develop</strong> 브랜치 코드가 운영될 것입니다.</p><p><img src="/images/nuxt-dashboard-create-project-stage.png" alt="staging 서버 생성"></p><p>위 이미지는 <strong>staging</strong> 서버를 생성하는 이미지로, 서버 이름은 <strong><em>nuxt-bootstrap-dashboard-stage</em></strong>로 설정한 후 화면 하단의 <code>Create APP</code> 버튼을 클릭해줍니다.</p><p>앱 생성을 완료하면 아래 앱이 비어었는 초기화 상태로 배포방법을 설정하는 화면으로 이동합니다. 아래 <strong>staging 서버 배포 설정 1</strong> 이미지와 같이 Heroku에서 코드를 배포하는 방식은 총 3가지로,</p><p><img src="/images/nuxt-dashboard-heroku-intergrate-github-develop-1.png" alt="staging 서버 배포 설정 1"></p><p>아래 <strong>staging 서버 배포 설정 2</strong> 이미지와 같이 Github Repository를 연결한 후 배포할 branch를 설정한 후 해당 branch에 Merge Request가 완료되면 자동으로 배포되도록 설정했습니다.</p><p><img src="/images/nuxt-dashboard-heroku-intergrate-github-develop-2.png" alt="staging 서버 배포 설정 2"></p><p>이제 <strong>staging</strong> 서버에 배포하기 위한 설정을 완료했습니다. <strong>production</strong> 서버 또한 위와 같이 생성 및 배포환경 설정을 완료해주면 됩니다.</p><p><img src="/images/nuxt-dashboard-create-project-prod.png" alt="production 서버 생성"><br><img src="/images/nuxt-dashboard-heroku-integrate-github.png" alt="production 서버 배포 설정"></p><h3 id="서버-환경설정"><a href="#서버-환경설정" class="headerlink" title="서버 환경설정"></a>서버 환경설정</h3><p>위에서 우리는 두개의 서버를 생성 및 배포환경 설정을 완료했습니다. 이번 단계에서는 각 서버의 환경변수를 설정해주겠습니다. Heroku에서는 환경설정하는 방법이 두가지로 첫번째는 Heroku CLI 이고, 두번째는 Heroku에서 각 앱의 대시보드에서 설정해주는 것입니다. 여기서는 두 번째 방법을 통해 설정해주겠습니다.</p><p>서버의 환경변수로 설정할 값들은 아래와 같으며 Heroku에서는 각 앱의 <strong>Settings</strong> 페이지에 접속하면 화면 중간에 <strong><em>Config Vars</em></strong> 섹션이 있고 <strong>Reveal Config Vars</strong> 버튼을 클릭하면 서버의 환경변수를 입력할 수 있는 입력폼이 노출됩니다. </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">heroku config:set HOST&#x3D;0.0.0.0</span><br><span class="line">heroku config:set NODE_ENV&#x3D;production &#x2F;&#x2F; or Staging</span><br></pre></td></tr></table></figure><p>아래 이미지와 같이 위 변수를 설정해주면 서버 환경설정에 대한 것들은 완료한 상태이며 <strong>staging</strong>, <strong>production</strong> 서버 모두 같은 방식으로 설정하면 됩니다.</p><p><img src="/images/nuxt-dashboard-heroku-config-vars.png" alt="서버 환경변수 설정"></p><hr><h2 id="쉬는-시간"><a href="#쉬는-시간" class="headerlink" title="쉬는 시간!"></a>쉬는 시간!</h2><p>자, 이제 중간지점 까지 왔습니다! Heroku에서 앞으로 필요할 2개의 앱을 생성했고, 자동 배포를 위한 서버 배포설정 그리고 환경변수 설정까지 완료했습니다. 다음으로는 Heroku에서 앱을 가동시키기 위해 코드상에서 설정을 할 차례입니다.</p><hr><h2 id="Procfile-작성하기"><a href="#Procfile-작성하기" class="headerlink" title="Procfile 작성하기"></a>Procfile 작성하기</h2><p><strong>Procfile</strong>이란 짧게 설명하자면 Heroku에서 앱을 실행시키기 위해 필요한 명령어의 순서를 명세한 파일로, Procfile 파일 생성 후 아래의 명령어를 작성한 후 Github 원격 저장소로 commit &amp; push 하면 Heroku <strong>staging</strong> 서버에서 변경사항을 배포합니다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">web: nuxt start</span><br></pre></td></tr></table></figure><p>사실 Heroku + Nuxt에 대한 자료가 많지 않아서 하라는데로는 하는데 배포 Process에 대한 설명은 없어서 Build Log를 살펴봤습니다. 궁금한 것만 살펴보면 <strong>Build</strong> 과정이 시작되면 아래와 <strong>Line 5</strong> 와 같이  <code>nuxt build</code> npm script를 실행해 빌드 Process를 시작해 <em>Client</em>, <em>Server</em>를 차례로 컴파일을 진행합니다. (<code>Compiling Client</code>: <strong>Line 14</strong>, <code>Compiling CliServerent</code>: <strong>Line 17</strong>)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">-----&gt; Build</span><br><span class="line">       Running build</span><br><span class="line">       </span><br><span class="line">       &gt; nuxt-bootstrap-dashboard@1.0.0 build &#x2F;tmp&#x2F;build_1cf41942</span><br><span class="line">       &gt; nuxt build</span><br><span class="line">       </span><br><span class="line">       ℹ Production build</span><br><span class="line">       ℹ Bundling for server and client side</span><br><span class="line">       ℹ Target: server</span><br><span class="line">       ℹ Using components loader to optimize imports</span><br><span class="line">       ℹ Discovered Components: .nuxt&#x2F;components&#x2F;readme.md</span><br><span class="line">       ✔ Builder initialized</span><br><span class="line">       ✔ Nuxt files generated</span><br><span class="line">       ℹ Compiling Client</span><br><span class="line"> ERROR  [BABEL] Note: The code generator has deoptimised the styling of &#x2F;tmp&#x2F;build_1cf41942&#x2F;node_modules&#x2F;bootstrap-vue&#x2F;src&#x2F;icons&#x2F;icons.js as it exceeds the max of 500KB.</span><br><span class="line">       ✔ Client: Compiled successfully in 36.58s</span><br><span class="line">       ℹ Compiling Server</span><br><span class="line">       ✔ Server: Compiled successfully in 3.03s</span><br><span class="line">Hash: e8c131655dbf5ab4f08d</span><br><span class="line">Version: webpack 4.46.0</span><br><span class="line">Time: 36579ms</span><br><span class="line">Built at: 04&#x2F;28&#x2F;2021 7:23:00 PM</span><br><span class="line">                         Asset      Size  Chunks                                Chunk Names</span><br><span class="line">..&#x2F;server&#x2F;client.manifest.json  19.2 KiB          [emitted]                     </span><br><span class="line">                    4a71c2b.js   642 KiB       5  [emitted] [immutable]  [big]  vendors&#x2F;app</span><br><span class="line">                    6535929.js   206 KiB       1  [emitted] [immutable]         commons&#x2F;app</span><br><span class="line">                    93a6776.js  3.04 KiB    3, 2  [emitted] [immutable]         pages&#x2F;index</span><br><span class="line">                    98766dc.js  46.1 KiB       0  [emitted] [immutable]         app</span><br><span class="line">                      LICENSES  1.95 KiB          [emitted]                     </span><br><span class="line">                    b6f428a.js   2.3 KiB       4  [emitted] [immutable]         runtime</span><br><span class="line">                    bef1150.js  1.43 KiB       2  [emitted] [immutable]         components&#x2F;logo</span><br><span class="line"> + 2 hidden assets</span><br><span class="line">Entrypoint app &#x3D; b6f428a.js 6535929.js 4a71c2b.js 98766dc.js</span><br><span class="line">WARNING in asset size limit: The following asset(s) exceed the recommended size limit (244 KiB).</span><br><span class="line">This can impact web performance.</span><br><span class="line">Assets: </span><br><span class="line">  4a71c2b.js (642 KiB)</span><br><span class="line">Hash: 0b8712d7140280abc02b</span><br><span class="line">Version: webpack 4.46.0</span><br><span class="line">Time: 3034ms</span><br><span class="line">Built at: 04&#x2F;28&#x2F;2021 7:23:03 PM</span><br><span class="line">               Asset       Size  Chunks             Chunk Names</span><br><span class="line">  components&#x2F;logo.js   5.41 KiB       1  [emitted]  components&#x2F;logo</span><br><span class="line">      pages&#x2F;index.js   11.5 KiB    2, 1  [emitted]  pages&#x2F;index</span><br><span class="line">           server.js    299 KiB       0  [emitted]  app</span><br><span class="line">server.manifest.json  307 bytes          [emitted]  </span><br><span class="line"> + 3 hidden assets</span><br><span class="line">Entrypoint app &#x3D; server.js server.js.map</span><br><span class="line">       ℹ Ready to run nuxt start</span><br><span class="line">       </span><br><span class="line">-----&gt; Caching build</span><br><span class="line">       - node_modules</span><br><span class="line">       </span><br><span class="line">-----&gt; Pruning devDependencies</span><br><span class="line">       Skipping because NODE_ENV is not &#39;production&#39;</span><br><span class="line">       </span><br><span class="line">-----&gt; Build succeeded!</span><br></pre></td></tr></table></figure><p>빌드가 완료되면 앱을 실행시킬 준비가 되었다고 <strong>Line 49</strong> 와 같이 <code>Ready to run nuxt start</code>가 출력되는데 이는 우리가 <strong>Procfile</strong> 파일에 작성한 <code>web: npm start</code>에 의해 실행되는 것입니다.</p><p>그럼…<br>이제 배포를 시도한 앱의 사이트에 접속해보면….<br>짜잔!!! 배포에 성공했습니다!</p><p><img src="/images/nuxt-dashboard-heroku-deployed.png" alt="배포 성공!!"></p><h2 id="마치며"><a href="#마치며" class="headerlink" title="마치며"></a>마치며</h2><p>지금까지 Heroku에 Nuxt 기반의 앱을 배포하기 위한 배포전략과 그에 따른 Heroku 앱 생성 및 Procfile 생성과 Github 연동으로 배포 자동화와 같은 설정을 완료했습니다. 배포는 성공했지만 Nuxt와 Heroku에 대한 많은 자료가 있지 않아 궁금한 사항들에 대해 제대로 설명하지 못한 부분들이 있어 블로그를 쓰면서도 아쉬운 부분이 있습니다. 그러한 사항들을 앞으로 추후 포스팅하겠습니다.</p><p>다음 포스팅으로는 <strong>Nuxt &amp; Express 환경구성</strong> 에 대해 다뤄보겠습니다. 모두들 수고 많으셨습니다!</p><h2 id="참고"><a href="#참고" class="headerlink" title="참고"></a>참고</h2><ul><li><a href="https://ko.nuxtjs.org/docs/2.x/deployment/heroku-deployment/">Deploy Nuxt on Heroku</a></li><li><a href="https://www.youtube.com/watch?v=nngsKhTb2BA">Nuxt Universal SSR Deployment to Heroku — includes connecting to an API and debugging Vuetify</a></li><li><a href="https://blog.logrocket.com/free-services-deploy-node-js-app/">3 services to deploy your Node.js app for free</a></li><li><a href="https://vueschool.io/lessons/how-to-deploy-nuxtjs-to-heroku">How to Deploy Nuxt.js to Heroku</a></li><li><a href="https://masteringnuxt.com/blog/nuxt-server-side-rendering-vs-pre-rendering">Nuxt Server Side Rendering vs Pre-rendering</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;/images/nuxt.png&quot; alt=&quot;Nuxt.js&quot;&gt;&lt;/p&gt;
&lt;p&gt;오늘의 포스트는 &lt;strong&gt;&lt;em&gt;Nuxt와 Bootstrap4 기반의 Dashboard 만들기&lt;/em&gt;&lt;/strong&gt;의 두번째 포스트로 &lt;strong</summary>
      
    
    
    
    <category term="Programming" scheme="https://joontae-kim.github.io/categories/Programming/"/>
    
    <category term="nuxt" scheme="https://joontae-kim.github.io/categories/Programming/nuxt/"/>
    
    
    <category term="vue.js" scheme="https://joontae-kim.github.io/tags/vue-js/"/>
    
    <category term="nuxt.js" scheme="https://joontae-kim.github.io/tags/nuxt-js/"/>
    
    <category term="vue" scheme="https://joontae-kim.github.io/tags/vue/"/>
    
    <category term="nuxt" scheme="https://joontae-kim.github.io/tags/nuxt/"/>
    
    <category term="project" scheme="https://joontae-kim.github.io/tags/project/"/>
    
    <category term="portfolio" scheme="https://joontae-kim.github.io/tags/portfolio/"/>
    
  </entry>
  
  <entry>
    <title>Nuxt와 Bootstrap4 기반의 Dashboard 만들기</title>
    <link href="https://joontae-kim.github.io/2021/04/28/nuxt-bootstrap-dashboard-1/"/>
    <id>https://joontae-kim.github.io/2021/04/28/nuxt-bootstrap-dashboard-1/</id>
    <published>2021-04-28T07:55:51.000Z</published>
    <updated>2021-04-29T07:21:39.248Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/nuxt.png" alt="Nuxt.js"></p><p>오늘의 포스트는 <a href="/2021/04/26/nuxt-boostrap-dashboard-0/">Nuxt와 Bootstrap4 기반의 Dashboard 만들기</a>의 첫 시작으로 <strong>프로젝트 생성 및 Github 환경구성</strong> 에 대해 작성해보겠습니다.</p><p>지난 포스트에서 Dashboard 개발에 관한 전반적인 사항들을 설계해봤습니다. 그럼 개발을 시작하기 전에 Nuxt 프로젝트 생성과 Github Repository 환경구성을 해보겠습니다.</p><h2 id="개발-순서"><a href="#개발-순서" class="headerlink" title="개발 순서"></a>개발 순서</h2><ol><li><a href="/2021/04/28/nuxt-bootstrap-dashboard-1/">프로젝트 생성 및 Github Repository 환경구성</a></li><li>Heroku 배포 환경구성</li><li>Nuxt &amp; Express API 환경구성</li><li>Axios</li><li>Bootstrap &amp; Bootstrap-vue 환경구성</li><li>Page &amp; UI 개발</li></ol><h2 id="Nuxt-프로젝트-생성"><a href="#Nuxt-프로젝트-생성" class="headerlink" title="Nuxt 프로젝트 생성"></a>Nuxt 프로젝트 생성</h2><p>Nuxt는 Vue.js의 Server-Side Rendering을 지원하기 위한 프레임워크로, SSR 뿐만 아니라 Static Site 그리고 SPA 또한 지원한다. (<em>Nuxt에 대한 소개는 추후 다른 포스트에서 계속하기로 하고…</em>) 이제 Nuxt 프로젝트를 생성해보자!!!</p><p>Nuxt를 생성하기 위한 명령어로는 아래와 같으며</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; yarn</span><br><span class="line">yarn create nuxt-app &lt;project-name&gt;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; npx</span><br><span class="line">npx create-nuxt-app &lt;project-name&gt;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; npm</span><br><span class="line">npm init nuxt-app &lt;project-name&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>저는 두번째 <strong>npx</strong> CLI를 통해 생성해보겠습니다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npx create-nuxt-app nuxt-bootstrap-dashboard</span><br></pre></td></tr></table></figure><p>위 명령어를 실행하면 nuxt 앱을 생성하기 위한 다양한 옵션이 있으며 프로젝트에 맞는 옵션을 선택해주면 프로젝트 초기부터 구조가 잡힌 상태로 생성되면 그렇지 않다고 해서 개발 도중에 환경구성을 추가로 할 수 있다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">create-nuxt-app v3.6.0</span><br><span class="line">? Project name: nuxt-bootstrap-dashboard</span><br><span class="line">? Programming language: (Use arrow keys)</span><br><span class="line">❯ JavaScript </span><br><span class="line">  TypeScript</span><br><span class="line">? Package manager: (Use arrow keys)</span><br><span class="line">  Yarn </span><br><span class="line">❯ Npm</span><br><span class="line">? UI framework: (Use arrow keys)</span><br><span class="line">  None </span><br><span class="line">  Ant Design Vue </span><br><span class="line">  BalmUI </span><br><span class="line">❯ Bootstrap Vue </span><br><span class="line">  Buefy </span><br><span class="line">  Chakra UI </span><br><span class="line">  Element </span><br><span class="line">  Framevuerk </span><br><span class="line">  Oruga </span><br><span class="line">  Tachyons </span><br><span class="line">  Tailwind CSS </span><br><span class="line">  Windi CSS </span><br><span class="line">  Vant </span><br><span class="line">  View UI </span><br><span class="line">  Vuesax </span><br><span class="line">(Move up and down to reveal more choices)</span><br><span class="line">? Nuxt.js modules: (Press &lt;space&gt; to select, &lt;a&gt; to toggle all, &lt;i&gt; to invert selection)</span><br><span class="line">❯◉ Axios - Promise based HTTP client</span><br><span class="line"> ◯ Progressive Web App (PWA)</span><br><span class="line"> ◯ Content - Git-based headless CMS</span><br><span class="line">? Linting tools: </span><br><span class="line">❯◉ ESLint</span><br><span class="line"> ◯ Prettier</span><br><span class="line"> ◯ Lint staged files</span><br><span class="line"> ◯ StyleLint</span><br><span class="line"> ◯ Commitlint</span><br><span class="line">? Testing framework: </span><br><span class="line">  None </span><br><span class="line">❯ Jest </span><br><span class="line">  AVA </span><br><span class="line">  WebdriverIO </span><br><span class="line">  Nightwatch </span><br><span class="line">? Rendering mode: (Use arrow keys)</span><br><span class="line">❯ Universal (SSR &#x2F; SSG) </span><br><span class="line">  Single Page App </span><br><span class="line">? Deployment target: (Use arrow keys)</span><br><span class="line">❯ Server (Node.js hosting) </span><br><span class="line">  Static (Static&#x2F;Jamstack hosting) </span><br><span class="line">❯◉ jsconfig.json (Recommended for VS Code if you&#39;re not using typescript)</span><br><span class="line"> ◯ Semantic Pull Requests</span><br><span class="line"> ◯ Dependabot (For auto-updating dependencies, GitHub only)</span><br><span class="line"> Version control system: (Use arrow keys)</span><br><span class="line">? Continuous integration: None</span><br><span class="line">❯ None</span><br><span class="line">  GitHub Actions</span><br><span class="line">  Circle ci</span><br><span class="line">  ...</span><br><span class="line">? Version control system: (Use arrow keys)</span><br><span class="line">❯ Git </span><br><span class="line">  None </span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 설치 시작</span><br><span class="line">⠸ Installing packages with npm</span><br></pre></td></tr></table></figure><p>아래는 선택한 옵션 목록입니다. 몇 가지 설명을 부연하자면, 이번 프로젝트에서는 <strong>UI Component</strong> 옵션에서는 <em>Bootstrap Vue</em> 를, <strong>Nuxt.js modules</strong> 옵션에서는 <em>Axios</em> 를 선택했습니다. 사실 이 둘은 나중에 설치 및 환경구성을 해줘도 되지만 그렇게 되면 환경구성에 대해 직접 해줘야해서 다소 번거로워 되도록이면 프로젝트 생성과정에서 설치해주는게 이득인거 같습니다. 그리고 이외의 <strong>Linting tools</strong>, <strong>Testing framework</strong>, <strong>Rendering mode</strong> 와 같은 부분은 Nuxt 어플리케이션 skeleton을 잡기 위한 프로젝트 옵션으로써 앱 생성 옵션 선택에서 해주는 것이 중요합니다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">✨  Generating Nuxt.js project in nuxt-bootstrap-dashboard</span><br><span class="line">? Project name: nuxt-bootstrap-dashboard</span><br><span class="line">? Programming language: JavaScript</span><br><span class="line">? Package manager: Npm</span><br><span class="line">? UI framework: Bootstrap Vue</span><br><span class="line">? Nuxt.js modules: (Press &lt;space&gt; to select, &lt;a&gt; to toggle all, &lt;i&gt; to invert selection)</span><br><span class="line">? Linting tools: (Press &lt;space&gt; to select, &lt;a&gt; to toggle all, &lt;i&gt; to invert selection)</span><br><span class="line">? Testing framework: Jest</span><br><span class="line">? Rendering mode: Universal (SSR &#x2F; SSG)</span><br><span class="line">? Deployment target: Server (Node.js hosting)</span><br><span class="line">? Development tools: (Press &lt;space&gt; to select, &lt;a&gt; to toggle all, &lt;i&gt; to invert selection)</span><br><span class="line">? Continuous integration: None</span><br><span class="line">? Version control system: Git</span><br></pre></td></tr></table></figure><p>생성된 프로젝트의 디렉토리는 아래 이미지와 같습니다.</p><p><img src="/images/nuxt-dashboard-directory-initial.png" alt="Nuxt Bootstrap Dashboard 디렉토리 - 생성 초기"></p><p>생성이 완료되면 Command 창에 앱을 구동하기 위한 <strong>npm script</strong> 로 추후에 <strong>개발 환경변수</strong> 및 <strong>RestAPI</strong>를 개발하면서 수정할 예정입니다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">🎉  Successfully created project nuxt-bootstrap-dashboard</span><br><span class="line"></span><br><span class="line">  To get started:</span><br><span class="line"></span><br><span class="line">cd nuxt-bootstrap-dashboard</span><br><span class="line">npm run dev</span><br><span class="line"></span><br><span class="line">  To build &amp; start for production:</span><br><span class="line"></span><br><span class="line">cd nuxt-bootstrap-dashboard</span><br><span class="line">npm run build</span><br><span class="line">npm run start</span><br><span class="line"></span><br><span class="line">  To test:</span><br><span class="line"></span><br><span class="line">cd nuxt-bootstrap-dashboard</span><br><span class="line">npm run test</span><br></pre></td></tr></table></figure><h2 id="Github-Repository-환경구성"><a href="#Github-Repository-환경구성" class="headerlink" title="Github Repository 환경구성"></a>Github Repository 환경구성</h2><h3 id="Repository-생성-및-프로젝트-연결"><a href="#Repository-생성-및-프로젝트-연결" class="headerlink" title="Repository 생성 및 프로젝트 연결"></a>Repository 생성 및 프로젝트 연결</h3><p><img src="/images/nuxt-dashboard-github-connection.png" alt="깃허브 원격 레포지터리 생성"></p><p>자, 이제 Skeleton을 생성했으니 프로젝트 버전관리를 위해서 Github에 Repository를 생성해 연결해보겠습니다. Github 페이지에서 원격 저장소를 생성하면 아래와 같은 저장소 화면으로 이동하며 우리는 이미 프로젝트를 생성한 후 원격 저장소를 연결하는 것이기 때문에 <strong>existing repository from the command line</strong> 방법을 따릅니다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 해당 디렉토리의 저장소 초기화</span><br><span class="line">git init</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 로컬 파일 추가 및 커밋</span><br><span class="line">git add .</span><br><span class="line">git commit -m &quot;Initial Commit&quot;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 원격 저장소 주소 설정</span><br><span class="line">git remote add origin https:&#x2F;&#x2F;github.com&#x2F;Joontae-Kim&#x2F;Nuxt-Bootstrap-Dashboard.git</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 원격 저장소로 commit한 파일 push</span><br><span class="line">git push origin master</span><br></pre></td></tr></table></figure><p><img src="/images/nuxt-dashboard-connect-github.png" alt="깃허브 원격 레포지터리 연결"></p><h3 id="Develop-브랜치-생성하기"><a href="#Develop-브랜치-생성하기" class="headerlink" title="Develop 브랜치 생성하기"></a>Develop 브랜치 생성하기</h3><p><img src="/images/nuxt-dashboard-github-branch-develop.png" alt="default 브랜치 Develop 브랜치로 변경하기"></p><p>프로젝트의 버전관리를 위해 <a href="https://gmlwjd9405.github.io/2018/05/12/how-to-collaborate-on-GitHub-3.html">Gitflow Workflow</a>를 따를 것이고, Default Branch를 <strong>develop</strong> 브랜치로 변경 후 아래의 브랜치들을 가지고 Workflow를 수행할 것입니다.</p><ul><li><strong>master</strong>: 제품으로 출시될 수 있는 브랜치</li><li><strong>develop</strong>: 다음 출시 버전을 개발하는 브랜치</li><li><strong>feature</strong>: 기능을 개발하는 브랜치</li><li><strong>release</strong> : 이번 출시 버전을 준비하는 브랜치</li><li><strong>hotfix</strong> : 출시 버전에서 발생한 버그를 수정 하는 브랜치</li></ul><h3 id="참고"><a href="#참고" class="headerlink" title="참고"></a>참고</h3><p>Gitflow Workflow에 대해서는 아래의 참고 URL로 대체합니다.</p><ul><li><a href="https://woowabros.github.io/experience/2017/10/30/baemin-mobile-git-branch-strategy.html">우린 Git-flow를 사용하고 있어요</a></li><li><a href="https://k39335.tistory.com/82">Gitflow로 branch를 관리하자</a></li><li><a href="https://medium.com/android-news/gitflow-with-github-c675aa4f606a">GitFlow with GitHub</a></li><li><a href="https://gist.github.com/RyanJeong/47867bbacce197e8e7b76f17ae7e434d">Git Flow</a></li></ul><h2 id="마치며"><a href="#마치며" class="headerlink" title="마치며"></a>마치며</h2><p>이상으로 이번 포스트의 주제인 <strong><em>1. 프로젝트 생성 및 Github Repository 환경구성</em></strong> 에 대해서 다뤄봤습니다. 일전에도 Git Flow 기반의 프로젝트 개발을 진행해봤었지만 아직도 햇갈리는 부분도 있고, 실수도 있습니다. 그러나 대규모 프로젝트에 참여해 개발을 진행할땐 팀내 협업을 위해서는 필수적이며 체계적인 배포 버전관리와 기능개발을 위해서도 개발자라면 혼자서라도 한번쯤은 연습 또는 실습해봐야할 개발 환경입니다. 추후에 <em>Git Flow 기반의 프로젝트 개발</em>에 대한 포스트를 작성해보겠습니다.</p><p>다음 포스트로는 <strong><em>2. Heroku 환경구성</em></strong> 에 대해 다뤄보겠습니다. </p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;/images/nuxt.png&quot; alt=&quot;Nuxt.js&quot;&gt;&lt;/p&gt;
&lt;p&gt;오늘의 포스트는 &lt;a href=&quot;/2021/04/26/nuxt-boostrap-dashboard-0/&quot;&gt;Nuxt와 Bootstrap4 기반의 Dashboar</summary>
      
    
    
    
    <category term="Programming" scheme="https://joontae-kim.github.io/categories/Programming/"/>
    
    <category term="nuxt" scheme="https://joontae-kim.github.io/categories/Programming/nuxt/"/>
    
    
    <category term="vue.js" scheme="https://joontae-kim.github.io/tags/vue-js/"/>
    
    <category term="nuxt.js" scheme="https://joontae-kim.github.io/tags/nuxt-js/"/>
    
    <category term="vue" scheme="https://joontae-kim.github.io/tags/vue/"/>
    
    <category term="nuxt" scheme="https://joontae-kim.github.io/tags/nuxt/"/>
    
    <category term="project" scheme="https://joontae-kim.github.io/tags/project/"/>
    
    <category term="portfolio" scheme="https://joontae-kim.github.io/tags/portfolio/"/>
    
  </entry>
  
  <entry>
    <title>Nuxt와 Bootstrap4 기반의 Dashboard 만들기</title>
    <link href="https://joontae-kim.github.io/2021/04/26/nuxt-bootstrap-dashboard-0/"/>
    <id>https://joontae-kim.github.io/2021/04/26/nuxt-bootstrap-dashboard-0/</id>
    <published>2021-04-26T09:33:09.000Z</published>
    <updated>2021-04-29T07:21:50.904Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/nuxt.png" alt="Nuxt.js"></p><p>최근들어 공부하고 블로그 쓰고, 공부하고 블로그 쓰는 코드를 잘 안 쓰는 나날들이 계속되다 보니깐 손가락이 굳어가는 느낌과 살짝 지루하다는 생각이 들어서 공부한걸 써보면서 실습해보는 기회로 Nuxt 기반의 Bootstrap4를 사용한 Dashboard를 만들어보려고 합니다.</p><h2 id="왜-Dashboard를-만드나"><a href="#왜-Dashboard를-만드나" class="headerlink" title="왜 Dashboard를 만드나?"></a>왜 Dashboard를 만드나?</h2><!-- Dashboard는 이전에 외주나 개인 프로젝트에서도 만들어봤었지만  --><p>일반 사이트가 아닌 Dashboard를 선택한 이유는 일반 사이트를 개발하는 것보다 Javascript를 통해 개발해야할 기술적 요소들이 더 많다고 생각했기 때문이다. 일반 페이지의 경우에는 <strong><em>디자인 + CSS</em></strong> 이 더 집중되어 있다면, 대시보드의 경우에는 <strong><em>기능 + Javascript</em></strong> 에 더 집중되어 있고 여기에 <strong><em>디자인</em></strong> 을 MSG로 첨가할 수도 있기 때문이다. <em>물론 일반 페이지도 기능을 끼워넣으면 되긴 하지만… 대시보드는 이미 기능이 거기서 거기이기 때문에 기능설계에 대한 힘을 덜 수 있다.</em></p><h2 id="Dashboard-구상"><a href="#Dashboard-구상" class="headerlink" title="Dashboard 구상"></a>Dashboard 구상</h2><p>Dashboard는 음… 이전에 외주나 개인 프로젝트에서도 만들어봤었지만 큰 차이는 없었다. </p><h3 id="Dashboard를-만들기-위한-Resource"><a href="#Dashboard를-만들기-위한-Resource" class="headerlink" title="Dashboard를 만들기 위한 Resource"></a>Dashboard를 만들기 위한 Resource</h3><p>Dashboard 템플릿을 만드는 것은 아니니 일단 무엇을 관리하고 어떤 Resource를 관리할지에 대한 시나리오가 있어야 한다. 상상해본것들을 대략 정리해보자면 Resource는 아래와 같다.</p><ul><li>User</li><li>Event</li><li>Admin</li><li>Traffic</li><li>Account</li><li>Transaction</li></ul><h3 id="Dashboard-페이지-구상"><a href="#Dashboard-페이지-구상" class="headerlink" title="Dashboard 페이지 구상"></a>Dashboard 페이지 구상</h3><p>위에서 정리한 Resource를 기반으로 아래와 같이 구상해봤다. </p><ul><li>Overview</li><li>Traffic &amp; Engagement</li><li>User List </li><li>Event Management</li><li>Profile</li><li>Sign-in</li></ul><h2 id="페이지-상세-정의"><a href="#페이지-상세-정의" class="headerlink" title="페이지 상세 정의"></a>페이지 상세 정의</h2><p>일단 페이지 구상이 끝났으니 페이지의 컨텐츠를 채워보자.</p><h3 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h3><ol><li>Total Visitor<ul><li>상단</li><li>3</li><li>Index</li><li>전월대비 지수 (%)</li></ul></li><li>New Visitors &amp; Users<ul><li>상단</li><li>3</li><li>Index</li><li>전월대비 지수 (%)</li></ul></li><li>Traffic Share <ul><li>상단</li><li>3</li><li>Index</li><li>Share Type: Desktop, Mobile</li><li>Unit (%)</li></ul></li><li>Views Per Minute<ul><li>상단</li><li>3</li><li>Pie Chart</li><li>전주대비 지수 (%)</li></ul></li><li>Channels<ul><li>중단</li><li>3</li><li>Donut Chart</li><li>Channel Type: Organic Search, Direct, Social, Paid</li></ul></li><li>Visit by Notification<ul><li>중단</li><li>9</li><li>Push</li><li>Email</li><li>Direct</li></ul></li><li>Sales Value<ul><li>하단</li><li>6</li><li>Linear Graph</li><li>전월대비 지수 (%)</li><li>Data: 2 Weaks</li></ul></li><li>Event Rank<ul><li>하단</li><li>6</li><li>Table</li><li>Top 10</li><li>Column: Name, Views, Sales, Bounce rate</li></ul></li></ol><h3 id="Traffic-amp-Engagement"><a href="#Traffic-amp-Engagement" class="headerlink" title="Traffic &amp; Engagement"></a>Traffic &amp; Engagement</h3><ol><li>Traffic Share<ul><li>6</li><li>전월대비 지수 (%)</li><li>Donut Chart</li><li>Organic Search</li><li>Direct</li><li>Social</li><li>Paid</li><li>Push</li></ul></li><li>Traffic Volumes by Source<ul><li>6</li><li>일주일치 데이터</li><li>Line Graph</li><li>Organic Search</li><li>Direct</li><li>Social</li><li>Paid</li><li>Push</li></ul></li><li>Traffic Source Table<ul><li>12</li><li>Table</li><li>Column: Traffic Source, Source Type, Share, Changes(from the previous week)</li></ul></li></ol><h3 id="User-List"><a href="#User-List" class="headerlink" title="User List"></a>User List</h3><ol><li>Search<ul><li>Simple Search</li><li>Detail Search</li></ul></li><li>Sorting<ul><li>ASC / DESC</li><li>Condition</li></ul></li><li>Table<ul><li>12</li><li>Column: Action CheckBox, Name, Date Created, Paid, Notification, Recent, Action</li></ul></li><li>Pagination<ul><li>Buttons: <code>Prev</code>, <code>(numbers)</code>, <code>Next</code></li></ul></li></ol><h3 id="Event-Management"><a href="#Event-Management" class="headerlink" title="Event Management"></a>Event Management</h3><ol><li>Search<ul><li>6</li><li>Simple Search</li><li>Detail Search</li><li></li></ul></li><li>Sorting<ul><li>6</li><li>ASC / DESC, </li><li>Condition</li></ul></li><li>Table<ul><li>12</li><li>Column: Index, Title, Date Created, Open Date, Close Date, Margin, Status, Action</li></ul></li><li>Pagination<ul><li>Buttons: <code>Prev</code>, <code>(numbers)</code>, <code>Next</code></li></ul></li></ol><h3 id="Profile"><a href="#Profile" class="headerlink" title="Profile"></a>Profile</h3><ol><li>General information<ul><li>12</li><li>Form</li><li>Field: First Name, Last Name, Birthday, Email, Department</li></ul></li></ol><h3 id="Sign-in"><a href="#Sign-in" class="headerlink" title="Sign-in"></a>Sign-in</h3><ol><li>Form<ul><li>4</li><li>Form</li><li>Field: Email, Password</li></ul></li><li>Password Reset Require<ul><li>12</li><li>Button</li></ul></li><li>Login<ul><li>Button</li></ul></li><li>Error Message<ul><li>Text</li></ul></li></ol><h2 id="개발"><a href="#개발" class="headerlink" title="개발"></a>개발</h2><p>기본적으로 Nuxt, Bootstrap &amp; Bootstrap-vue를 기반으로 개발할 것입니다.</p><h3 id="개발-환경"><a href="#개발-환경" class="headerlink" title="개발 환경"></a>개발 환경</h3><ul><li>Nuxt (SSR)</li><li>Express (API)</li><li>Heroku</li><li>Git &amp; Github</li><li>Bootstrap &amp; Bootstrap-vue</li><li>Chart.js (Client)</li><li>Axios</li></ul><h3 id="개발-순서"><a href="#개발-순서" class="headerlink" title="개발 순서"></a>개발 순서</h3><ol><li><a href="/2021/04/28/nuxt-bootstrap-dashboard-1/">프로젝트 생성 및 Github Repository 환경구성</a></li><li>Heroku 배포 환경구성</li><li>Nuxt &amp; Express API 환경구성</li><li>Axios</li><li>Bootstrap &amp; Bootstrap-vue 환경구성</li><li>Page &amp; UI 개발<ul><li>Chart.js</li></ul></li></ol><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul><li><p>Benchmark Site</p><ul><li><a href="https://themes.getbootstrap.com/preview/?theme_id=45617">https://themes.getbootstrap.com/preview/?theme_id=45617</a></li><li><a href="https://coderthemes.com/hyper/creative/pages-login.html">https://coderthemes.com/hyper/creative/pages-login.html</a></li><li><a href="https://themes.getbootstrap.com/product-category/admin-dashboard/">https://themes.getbootstrap.com/product-category/admin-dashboard/</a></li></ul></li><li><p>Nuxt Module</p><ul><li><a href="https://modules.nuxtjs.org/?q=bootstra&amp;orderBy=desc">https://modules.nuxtjs.org/?q=bootstra&amp;orderBy=desc</a></li><li><a href="https://blog.lichter.io/posts/nuxt-with-an-api/">https://blog.lichter.io/posts/nuxt-with-an-api/</a></li></ul></li><li><p>Nuxt &amp; Express</p><ul><li><a href="https://github.com/nuxt/create-nuxt-app/issues/563">https://github.com/nuxt/create-nuxt-app/issues/563</a></li><li><a href="https://nuxtjs.org/docs/2.x/configuration-glossary/configuration-dev">https://nuxtjs.org/docs/2.x/configuration-glossary/configuration-dev</a></li><li><a href="https://bithacker.dev/use-express-with-nuxt-js">https://bithacker.dev/use-express-with-nuxt-js</a></li><li><a href="https://blog.lichter.io/posts/nuxt-with-an-api/#using-nuxt-programmatically">https://blog.lichter.io/posts/nuxt-with-an-api/#using-nuxt-programmatically</a></li></ul></li><li><p>Nuxt &amp; Bootstrap-vue</p><ul><li><a href="https://bootstrap-vue.org/docs#nuxtjs-module">https://bootstrap-vue.org/docs#nuxtjs-module</a></li><li><a href="https://nuxtjs.org/docs/2.x/directory-structure/modules">https://nuxtjs.org/docs/2.x/directory-structure/modules</a></li></ul></li><li><p>Nuxt &amp; Chart.js</p><ul><li><a href="https://www.python2.net/questions-1182484.htm">https://www.python2.net/questions-1182484.htm</a><ul><li>답변 # 1 참고</li></ul></li><li><a href="https://vue-chartjs.org/guide/#introduction">https://vue-chartjs.org/guide/#introduction</a></li><li><a href="https://code.luasoftware.com/tutorials/vuejs/setup-vue-chartjs-in-nuxt/">https://code.luasoftware.com/tutorials/vuejs/setup-vue-chartjs-in-nuxt/</a></li></ul></li><li><p>Chart.js</p><ul><li><a href="https://yasminzy.com/vue/chart/#steps">https://yasminzy.com/vue/chart/#steps</a></li><li><a href="https://www.chartjs.org/docs/latest/">https://www.chartjs.org/docs/latest/</a></li></ul></li><li><p>ETC</p><ul><li><a href="https://nuxtjs.org/docs/2.x/features/configuration">https://nuxtjs.org/docs/2.x/features/configuration</a></li><li><a href="https://orlandster.github.io/vue-page-transition/#/">https://orlandster.github.io/vue-page-transition/#/</a></li></ul></li></ul><h2 id="정리"><a href="#정리" class="headerlink" title="정리"></a>정리</h2><blockquote><p>이번 프로젝트의 최대 목표는 <strong><em>ASAP</em></strong> 이다.</p></blockquote><ol><li>가능한 빠르게! 만드는 것이 목표!</li><li>중간중간 배우고 사용한걸 정리하자!</li><li>개발이 완료되고 스케줄을 고려해서 transition을 작업할지 말지 결정하자!</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;/images/nuxt.png&quot; alt=&quot;Nuxt.js&quot;&gt;&lt;/p&gt;
&lt;p&gt;최근들어 공부하고 블로그 쓰고, 공부하고 블로그 쓰는 코드를 잘 안 쓰는 나날들이 계속되다 보니깐 손가락이 굳어가는 느낌과 살짝 지루하다는 생각이 들어서 공</summary>
      
    
    
    
    <category term="Programming" scheme="https://joontae-kim.github.io/categories/Programming/"/>
    
    <category term="nuxt" scheme="https://joontae-kim.github.io/categories/Programming/nuxt/"/>
    
    
    <category term="vue.js" scheme="https://joontae-kim.github.io/tags/vue-js/"/>
    
    <category term="nuxt.js" scheme="https://joontae-kim.github.io/tags/nuxt-js/"/>
    
    <category term="vue" scheme="https://joontae-kim.github.io/tags/vue/"/>
    
    <category term="nuxt" scheme="https://joontae-kim.github.io/tags/nuxt/"/>
    
    <category term="project" scheme="https://joontae-kim.github.io/tags/project/"/>
    
    <category term="portfolio" scheme="https://joontae-kim.github.io/tags/portfolio/"/>
    
  </entry>
  
  <entry>
    <title>알고리즘 시리즈 - 자료구조 2</title>
    <link href="https://joontae-kim.github.io/2021/04/23/algorithm-data-queue/"/>
    <id>https://joontae-kim.github.io/2021/04/23/algorithm-data-queue/</id>
    <published>2021-04-23T08:54:19.000Z</published>
    <updated>2021-04-25T16:23:21.640Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/algorithm.png" alt="알고리즘"></p><p>이번 포스트에서는 선형 자료구조 중 하나인 큐(Queue)에 대해서 다뤄보겠습니다.</p><h2 id="큐-Queue"><a href="#큐-Queue" class="headerlink" title="큐 (Queue)"></a>큐 (Queue)</h2><p>선형 자료구조 중 하나인 큐(Queue)는 FIFO(First In First Out, 선입선출) 구조의 자료구조로 LIFO(Last In First Out, 후입선출) 구조의 스택(Stack)과는 반대되는 개념이다. 현실속에서의 큐는 프린터의 출력처리 방식, 매표소 앞의 일렬로 선 대기열, OS의 프로세스 관리 등 데이터가 입력된 시간 순서대로 처리해야 할 필요가 있는 상황ㅇ 이용된다.</p><h2 id="구조"><a href="#구조" class="headerlink" title="구조"></a>구조</h2><p><img src="/images/queue.png" alt="Queue"></p><p>큐는 복수의 자료로 이루어져 있으며 복수의 자료가 삽입되어 추출되길 기다리고 있는 곳을 <strong>큐</strong> 라고 부르며 큐에 자료를 삽입하는 것을 <strong>Enqueue</strong>, 반대로 자료를 추출하는 것을 <strong>Dequeue</strong> 라고 하며 LIFO(후입선출)을 개념을 갖고 있다. 아래와 같은 구조를 갖고 있다.</p><ul><li>Front (Head): 데이터를 추출할 수 있는 위치</li><li>Rear (Tail): 데이터를 삽입할 수 있는 위치</li><li>Overflow (오버플로우): 큐가 꽉 차서 더 이상 자료를 넣을 수 없는 경우</li><li>Underflow (언더플로우): 큐가 비어 자료를 꺼낼 수 없는 경우</li></ul><h3 id="큐-기능-메서드"><a href="#큐-기능-메서드" class="headerlink" title="큐 기능 (메서드)"></a>큐 기능 (메서드)</h3><ul><li>enqueue(data): 삽입 / 큐의 Rear에 데이터를 삽입</li><li>dequeue(): 추출 / 큐의 Front에서 데이터를 추출</li><li>rear(): 조회 / 큐의 Rear에 데이터 값을 반환</li><li>front(): 조회 / 큐의 Front에 데이터 값을 반환</li><li>size(): 조회 / 큐의 데이터 개수 반환</li><li>empty(): 조회 / 큐가 비었는지 Boolean을 반환</li><li>toString(): 조회 / 큐의 모든 데이터를 문자열로 반환</li></ul><h2 id="구현"><a href="#구현" class="headerlink" title="구현"></a>구현</h2><p>큐를 구현해보자. 큐를 구현하는 방법은 두 가지로, 한 가지는 Javascript의 Array(배열)와 Array의 메서드를 통해 구현하는 방법 그리고 나머지 한 가지는 Linked List와 같이 구현하는 방법으로 총 두가지 입니다. 이번 포스트에서는 두가지 방법 모두 사용해 구현해보겠습니다.</p><p>구현 순서는 아래와 같다.</p><ol><li>Queue 객체 생성</li><li>데이터 삽입 기능 (enqueue)</li><li>데이터 조회 기능 (front, rear, size, empty, toString)</li><li>데이터 추출 기능 (dequeue)</li></ol><h3 id="Javascript-Array를-사용한-Queue-구현-방법"><a href="#Javascript-Array를-사용한-Queue-구현-방법" class="headerlink" title="Javascript Array를 사용한 Queue 구현 방법"></a>Javascript Array를 사용한 Queue 구현 방법</h3><h4 id="Queue-객체-생성"><a href="#Queue-객체-생성" class="headerlink" title="Queue 객체 생성"></a>Queue 객체 생성</h4><p>하나의 대기열이 될 Queue를 객체 생성방식으로 만들어보겠습니다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function Queue () &#123;</span><br><span class="line">  this.queue &#x3D; []</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Queue</code>는 복수의 data로 채워한 하나의 queue를 생성하는 생성자 함수로, 내부 property로 data를 담아둘 queue를 빈 Array(<code>[]</code>)를 할당한다. <em>Javascript Array를 사용한 Queue 구현 방법에서는 Javascript Array와 메서드를 이용할 것이기 때문에 많은 property가 필요하지 않다.</em></p><h4 id="Queue-메서드-구현"><a href="#Queue-메서드-구현" class="headerlink" title="Queue 메서드 구현"></a>Queue 메서드 구현</h4><p>위에서 정의한 <code>Queue</code> 생성자 함수 내부에 구현해도 되지만 저는 <code>prototype</code> 속성을 사용한 객체 생성 방법으로 구현해보겠습니다.</p><h5 id="데이터-삽입-기능"><a href="#데이터-삽입-기능" class="headerlink" title="데이터 삽입 기능"></a>데이터 삽입 기능</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Queue.prototype.enqueue &#x3D; function (data) &#123;</span><br><span class="line">  this.queue.push(data)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>enqueue</strong> 메서드는 <code>Queue</code> 객체에 데이터를 삽입하는 메서드로 Javascript의 Array 메서드 중 <code>push</code>를 사용해 <code>queue</code>에 data를 삽입하는 기능을 구현했습니다.</p><h5 id="데이터-조회-기능"><a href="#데이터-조회-기능" class="headerlink" title="데이터 조회 기능"></a>데이터 조회 기능</h5><p>이번에는 큐에 삽입한 데이터를 조회하는 기능을 구현해보겠습니다. 구현할 조회 메서드는 <strong>front</strong>, <strong>rear</strong>, <strong>size</strong>, <strong>empty</strong>, <strong>toString</strong> 입니다.</p><p><strong>front</strong> 를 구현해보겠습니다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Queue.prototype.front &#x3D; function (data) &#123;</span><br><span class="line">  return !this.queue.length</span><br><span class="line">    ? null</span><br><span class="line">    : this.queue[this.queue.length - 1]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>front</strong> 메서드는 <code>Queue</code> 객체에 삽입된 데이터 중 가장 오래된 데이터이자 가장 먼저 추출될 데이터에 대한 조회 기능입니다.</p><p>이번에는 <strong>rear</strong> 를 구현해보겠습니다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Queue.prototype.rear &#x3D; function (data) &#123;</span><br><span class="line">  return !this.queue.length</span><br><span class="line">    ? null</span><br><span class="line">    : this.queue[0]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>rear</strong> 메서드는 <code>Queue</code> 객체에 삽입된 데이터 중 가장 최근 데이터에 대한 조회 기능입니다.</p><p><strong>size</strong> 를 구현해보겠습니다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Queue.prototype.size &#x3D; function (data) &#123;</span><br><span class="line">  return this.queue.length</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>size</strong> 메서드는 <code>Queue</code> 객체에 삽입된 데이터의 개수를 반환하는 기능을 기능입니다.</p><p><strong>empty</strong> 를 구현해보겠습니다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Queue.prototype.empty &#x3D; function (data) &#123;</span><br><span class="line">  return !this.queue.length</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>empty</strong> 메서드는 <code>Queue</code> 객체의 <strong>queue</strong> 가 비었는지 조회하는 기능입니다.</p><p>마지막으로 <strong>toString</strong> 를 구현해보겠습니다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Queue.prototype.toString &#x3D; function (data) &#123;</span><br><span class="line">  return !this.queue.length</span><br><span class="line">    ? []</span><br><span class="line">    : &#96;[$&#123;this.queue.toString()&#125;]&#96;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>toString</strong> 메서드는 <code>Queue</code> 객체의 <strong>queue</strong> 를 문자열로 출력하는 기능입니다.</p><h5 id="데이터-추출-기능"><a href="#데이터-추출-기능" class="headerlink" title="데이터 추출 기능"></a>데이터 추출 기능</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Queue.prototype.dequeue &#x3D; function (data) &#123;</span><br><span class="line">  this.queue.shift(data)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>dequeue</strong> 메서드는 <code>Queue</code> 객체에 데이터를 추출하는 메서드로 Javascript의 Array 메서드 중 <code>shift</code>를 사용해 <code>queue</code>에 삽입된 data 중 가장 마지막에 삽입되었으며 가장 빨리 추출되어질 data를 추출하는 기능입니다.</p><h3 id="Linked-List-구현방법을-사용한-Queue-구현-방법"><a href="#Linked-List-구현방법을-사용한-Queue-구현-방법" class="headerlink" title="Linked List 구현방법을 사용한 Queue 구현 방법"></a>Linked List 구현방법을 사용한 Queue 구현 방법</h3><p>이번에는 Linked List와 같은 구조로 다수의 data와 data로 채워진 Queue를 구현해보겠습니다. 구현할 메서드는 미리 정해둔 메서드 입니다.</p><h4 id="Data"><a href="#Data" class="headerlink" title="Data"></a>Data</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function Data (val) &#123;</span><br><span class="line">  this.value &#x3D; val</span><br><span class="line">  this.next &#x3D; null</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Data</code>는 큐의 요소인 데이터를 생성하는 생성자 함수로, 내부 property로 data 본인의 값인 value와 다음 data를 참조하기 위한 link를 갖는다.</p><h4 id="Queue-객체-생성-1"><a href="#Queue-객체-생성-1" class="headerlink" title="Queue 객체 생성"></a>Queue 객체 생성</h4><p>큐를 생성할 <code>Queue</code> 생성자 함수를 정의하고, 위에서 정의한 구조와 메서드를 구현하기 위해 필요한 property를 정의했습니다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function Queue () &#123;</span><br><span class="line">  this.count &#x3D; 0</span><br><span class="line">  this.head &#x3D; null</span><br><span class="line">  this.tail &#x3D; null</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Queue-메서드-구현-1"><a href="#Queue-메서드-구현-1" class="headerlink" title="Queue 메서드 구현"></a>Queue 메서드 구현</h4><p>위에서 정의한 <code>Queue</code> 생성자 함수 내부에 구현해도 되지만 저는 <code>prototype</code> 속성을 사용한 객체 생성 방법으로 구현해보겠습니다.</p><h5 id="데이터-삽입-기능-1"><a href="#데이터-삽입-기능-1" class="headerlink" title="데이터 삽입 기능"></a>데이터 삽입 기능</h5><p>큐에 데이터를 생성 및 삽입하는 기능을 구현했습니다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">Queue.prototype.enqueue &#x3D; function (data) &#123;</span><br><span class="line">  let newData &#x3D; new Data(data)</span><br><span class="line">  if (!this.head) &#123;</span><br><span class="line">    this.head &#x3D; newData</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    let current &#x3D; this.head</span><br><span class="line"></span><br><span class="line">    while(current.next)  &#123;</span><br><span class="line">      current &#x3D; current.next</span><br><span class="line">    &#125;</span><br><span class="line">    current.next &#x3D; newData</span><br><span class="line">  &#125;</span><br><span class="line">  this.tail &#x3D; newData</span><br><span class="line">  this.count++</span><br><span class="line">  return newData</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var queue &#x3D; new Queue &#x2F;&#x2F; 큐 객체 생성</span><br><span class="line">queue.enqueue(20) &#x2F;&#x2F; 데이터 생성 및 추가</span><br><span class="line">queue.enqueue(10)</span><br><span class="line">queue.enqueue(18)</span><br><span class="line"></span><br><span class="line">console.log(queue)</span><br></pre></td></tr></table></figure><p><strong>enqueue</strong> 메서드는 큐에 데이터를 삽입하는 메서드로, 새로운 data를 추가하면 기존 <code>head</code> 데이터에 next가 할당되거나 <code>tail</code> 데이터가 갱신되는 것으로, <strong><em>line 3 ~ line 14</em></strong> 코드와 같이 <code>head</code>의 데이터 할당여부에 따라 처리되는 방식이 다르며 <code>head</code>가 지정되어 있다면 새로운 data가 추가되기전 마지막 data의 <code>data.next</code>에 새로운 데이터를 할당해주고 마지막에 <code>this.tail</code>에 생성된 data를 할당해준다.</p><p>위와 같이 구현한 <code>queue</code>를 출력하면 아래와 같습니다.</p><p><img src="/images/queue_enqueue_console.png" alt="data 생성 및 삽입 완료된 queue"></p><h5 id="데이터-조회-기능-1"><a href="#데이터-조회-기능-1" class="headerlink" title="데이터 조회 기능"></a>데이터 조회 기능</h5><p>이번에는 큐에 삽입한 데이터를 조회하는 기능을 구현해보겠습니다. 구현할 조회 메서드는 <strong>front</strong>, <strong>rear</strong>, <strong>size</strong>, <strong>empty</strong>, <strong>toString</strong> 입니다.</p><p><strong>front 메서드</strong>를 구현해보겠습니다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Queue.prototype.front &#x3D; function () &#123;</span><br><span class="line">  return this.head.value</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>front</strong> 메서드는 큐 데이터열에서 가장 앞에 있는 즉, 가장 먼저 추출되며 삽입된지 가장 오래된 데이터가 무엇인지 조회하는 메서드 입니다. <code>head</code> property는 데이터를 삽입할때 할당되므로 추가적인 loop 문을 통해 조회를 할 필요가 없습니다.</p><p><strong>rear 메서드</strong>를 구현해보겠습니다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Queue.prototype.rear &#x3D; function () &#123;</span><br><span class="line">  return this.tail.value</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>rear</strong> 메서드는 큐 데이터열에서 가장 뒤에 있는 즉, 현재 데이터열에서 가장 나중에 추출되며 삽입된지 가장 최신의 데이터가 무엇인지 조회하는 메서드 입니다. <code>tail</code> property는 데이터를 삽입할때마다 갱신되므로 추가적인 loop 문을 통해 조회를 할 필요가 없습니다.</p><p><strong>size 메서드</strong>를 구현해보겠습니다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Queue.prototype.size &#x3D; function () &#123;</span><br><span class="line">  return this.count</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>size</strong> 메서드는 큐 데이터열의 크기를 반환하는 메서드로, 큐에 신규 data를 삽입할때마다 갱신되기 때문에 추가적인 loop 문을 통해 조회를 할 필요가 없습니다.</p><p><strong>empty 메서드</strong>를 구현해보겠습니다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Queue.prototype.empty &#x3D; function () &#123;</span><br><span class="line">  return !this.count</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>size</strong> 메서드는 큐 데이터열이 비었는지 <code>Boolean</code> 값을 반환하는 메서드로, <code>Queue</code> 생성자 함수의 <code>size</code> property를 사용하면 됩니다.</p><p><strong>toString 메서드</strong>를 구현해보겠습니다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Queue.prototype.toString &#x3D; function () &#123;</span><br><span class="line">  let line &#x3D; []</span><br><span class="line">  let current &#x3D; this.head</span><br><span class="line">  if (!current) &#123;</span><br><span class="line">    return &#39;&#39;</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    while (current.next) &#123;</span><br><span class="line">      line.push(current.value)</span><br><span class="line">      current &#x3D; current.next</span><br><span class="line">    &#125;</span><br><span class="line">    return line.toString()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>toString</strong> 메서드는 큐에 삽입된 데이터열을 문자열로 출력하는 메서드로, <code>head</code>의 여부에 따라 반환되는 로직을 분리했습니다.</p><h5 id="데이터-추출-기능-1"><a href="#데이터-추출-기능-1" class="headerlink" title="데이터 추출 기능"></a>데이터 추출 기능</h5><p>마지막으로 큐의 데이터 추출 기능인 <strong>dequeue 메서드</strong>를 구현해보겠습니다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Queue.prototype.dequeue &#x3D; function () &#123;</span><br><span class="line">  let front &#x3D; this.head</span><br><span class="line">  this.head &#x3D; front.next</span><br><span class="line"></span><br><span class="line">  let current &#x3D; this.head</span><br><span class="line">  while (current.next) &#123;</span><br><span class="line">    current &#x3D; current.next</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  this.tail &#x3D; current</span><br><span class="line">  this.count--</span><br><span class="line">  return front</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>dequeue</strong> 메서드는 큐의 front에 해당되는 데이터를 출력하는 메서드로, <code>Queue</code> 생성자 함수 내에 저장된 <code>head</code> property를 반환하고 <code>this.head.next</code>에 할당된 value를 <code>this.head</code>로 갱신해준 후 <code>this.tail</code> property 또한 갱신했습니다.</p><h2 id="마치며"><a href="#마치며" class="headerlink" title="마치며"></a>마치며</h2><p>이번 포스트에서는 알고리즘 시리즈의 자료구조 포스팅 중 두번째로, 큐(Queue)의 정의와 구조 및 메서드에 공부해봤습니다. 그리고 정의한 구조와 메서드를 구현해봤습니다. 다음 포스트에서는 링크드 리스트, 큐와 같이 선형 자료구조 중 하나인 스택에 대해서 공부해보겠습니다.</p><h2 id="참조"><a href="#참조" class="headerlink" title="참조"></a>참조</h2><ul><li><a href="https://github.com/trekhleb/javascript-algorithms/tree/master/src/data-structures/queue">Queue</a></li><li><a href="https://ko.wikipedia.org/wiki/%ED%81%90_(%EC%9E%90%EB%A3%8C_%EA%B5%AC%EC%A1%B0)">큐 (자료 구조)</a></li><li></li><li><a href="https://librewiki.net/wiki/%EC%8B%9C%EB%A6%AC%EC%A6%88:%EC%88%98%ED%95%99%EC%9D%B8%EB%93%AF_%EA%B3%BC%ED%95%99%EC%95%84%EB%8B%8C_%EA%B3%B5%ED%95%99%EA%B0%99%EC%9D%80_%EC%BB%B4%ED%93%A8%ED%84%B0%EA%B3%BC%ED%95%99/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98_%EA%B8%B0%EC%B4%88">시리즈:수학인듯 과학아닌 공학같은 컴퓨터과학/알고리즘 기초</a></li><li><a href="https://wayhome25.github.io/cs/2017/04/18/cs-21/">강의노트 20. 자료구조 - queue(큐)</a></li><li><a href="https://www.zerocho.com/category/Algorithm/post/580b9b94108f510015524097">자료구조(큐, queue)</a></li><li><a href="https://kimyang-sun.tistory.com/151?category=779569">(JavaScript) 자바스크립트 큐(Queue, FIFO) 자료구조 구현</a></li><li><a href="https://dororongju.tistory.com/106?category=731412">[자바스크립트] Queue 큐 클래스</a></li><li><a href="https://curlyjun.github.io/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0/2019/02/13/Queue,Stack,Linked-List/">Queue, Stack, Linked List 정리</a></li><li><a href="https://helloworldjavascript.net/pages/282-data-structures.html">큐, 스택, 트리</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;/images/algorithm.png&quot; alt=&quot;알고리즘&quot;&gt;&lt;/p&gt;
&lt;p&gt;이번 포스트에서는 선형 자료구조 중 하나인 큐(Queue)에 대해서 다뤄보겠습니다.&lt;/p&gt;
&lt;h2 id=&quot;큐-Queue&quot;&gt;&lt;a href=&quot;#큐-Queue</summary>
      
    
    
    
    <category term="Programming" scheme="https://joontae-kim.github.io/categories/Programming/"/>
    
    <category term="Algorithm" scheme="https://joontae-kim.github.io/categories/Programming/Algorithm/"/>
    
    
    <category term="Algorithm" scheme="https://joontae-kim.github.io/tags/Algorithm/"/>
    
    <category term="알고리즘" scheme="https://joontae-kim.github.io/tags/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/"/>
    
    <category term="data structure" scheme="https://joontae-kim.github.io/tags/data-structure/"/>
    
    <category term="data" scheme="https://joontae-kim.github.io/tags/data/"/>
    
    <category term="structure" scheme="https://joontae-kim.github.io/tags/structure/"/>
    
    <category term="자료 구조" scheme="https://joontae-kim.github.io/tags/%EC%9E%90%EB%A3%8C-%EA%B5%AC%EC%A1%B0/"/>
    
    <category term="Queue" scheme="https://joontae-kim.github.io/tags/Queue/"/>
    
    <category term="큐" scheme="https://joontae-kim.github.io/tags/%ED%81%90/"/>
    
  </entry>
  
  <entry>
    <title>알고리즘 시리즈 - 자료구조 1</title>
    <link href="https://joontae-kim.github.io/2021/04/23/algorithm-data-linkedList/"/>
    <id>https://joontae-kim.github.io/2021/04/23/algorithm-data-linkedList/</id>
    <published>2021-04-23T08:34:34.000Z</published>
    <updated>2021-04-25T16:24:14.511Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/algorithm.png" alt="알고리즘"></p><p>이번 포스트에서는 선형 자료구조 중 하나인 링크드 리스트에 대해서 다뤄보겠습니다.</p><h2 id="링크드-리스트"><a href="#링크드-리스트" class="headerlink" title="링크드 리스트"></a>링크드 리스트</h2><p>링크드 리스트 또는 연결 리스트는 순서를 표현하는 노드들의 집합으로, Javascript의 배열(Array)와 유사한 구조이지만 메모리상의 연속적 위치요소를 갖지 않는다는 차이가 있다. 링크드 리스트에서 가장 중요한 것은 <em>연결이 무엇인가를 파악하는 것</em> 이다.</p><p>특징으로는,</p><ul><li>순회하는 동안 순서에 상관없이 효율적인 삽입, 삭제가 가능</li><li>연속되는 node들이 link로 연결되어 있음</li><li>마지막 항목은 null을 가리짐</li><li>배열(Array)에 비해 추가, 삽입, 삭제가 용이하나 순차적 탐색이 아닌 경우 성능이 떨짐</li><li>탐색 또는 정렬가 main =&gt; Array / 추가, 삭제, 삽입이 main =&gt; Linked List </li></ul><h3 id="구조"><a href="#구조" class="headerlink" title="구조"></a>구조</h3><p><img src="/images/linked-list.png" alt="링크드 리스트"></p><p>링크드 리스트는 <strong>Node</strong> 라고 부르는 복수의 요소로 이루어져 있으며 각 노드는 자신의 값인 <strong>데이터</strong>와 다음 노드의 위치를 참조하고 있는 <strong>링크</strong> 를 가지고 있으며 일련의 리스트는 아래와 같이 부를 수 있다.</p><ul><li>Head: 링크드 리스트의 시작 node</li><li>Current: 연산의 기준이 되는 node</li><li>Before: Current node의 참조값인 link 값을 가지고 있는 node </li><li>Tail: 링크드 리스트의 마지막 node이며 null을 가리킨다</li></ul><h3 id="링크드-리스트-기능-메서드"><a href="#링크드-리스트-기능-메서드" class="headerlink" title="링크드 리스트 기능 (메서드)"></a>링크드 리스트 기능 (메서드)</h3><ul><li>append(data): 생성 / 리스트에 새로운 node를 추가하면 가장 마지막에 위치함</li><li>insert(index, data): 수정 / 특정 index의 node에 데이터 삽입</li><li>indexOf(data): 조회 / 특정 데이터의 node index를 반환, 존재하지 않는 경우 -1을 반환</li><li>search(data): 조회 / 특정 데이터를 기준으로 node 반환, 존재하지 않는 경우 null 반환</li><li>isEmpty(): 조회 / 리스트의 node 유무 반환</li><li>size(): 조회 / 리스트의 node 개수 반환</li><li>removeAt(index): 삭제 / 특정 위치에 있는 node를 삭제 </li><li>remove(data): 삭제 / 특정 값을 가진 node를 삭제</li></ul><h3 id="구현"><a href="#구현" class="headerlink" title="구현"></a>구현</h3><p>링크드 리스트를 구현해보자. 구현 순서는 아래와 같다.</p><ol><li>링크드 리스트의 요소인 Node</li><li>노드 생성 기능 (append)</li><li>노드 조회 기능 (indexOf, isEmpty, size)</li><li>노드 수정 기능 (insert)</li><li>노드 삭제 기능 (remove, removeAt)</li></ol><h4 id="Node"><a href="#Node" class="headerlink" title="Node"></a>Node</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function Node (data) &#123;</span><br><span class="line">  this.data &#x3D; data</span><br><span class="line">  this.next &#x3D; null</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Node</code>는 링크드 리스트의 요소인 node를 생성하는 생성자 함수로, 내부 property로 node 본인의 값인 data와 다음 node를 참조하기 위한 link를 갖는다.</p><h4 id="Linked-List"><a href="#Linked-List" class="headerlink" title="Linked List"></a>Linked List</h4><p>링크드 리스트를 생성할 <code>LinkedList</code> 생성자 함수를 정의하고, 위에서 정의한 구조와 메서드를 구현하기 위해 필요한 property를 정의했습니다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function LinkedList () &#123;</span><br><span class="line">  this.count &#x3D; 0</span><br><span class="line">  this.head &#x3D; null</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Linked-List-메서드-구현"><a href="#Linked-List-메서드-구현" class="headerlink" title="Linked List 메서드 구현"></a>Linked List 메서드 구현</h4><p>위에서 정의한 <code>LinkedList</code> 생성자 함수 내부에 구현해도 되지만 저는 <code>prototype</code> 속성을 이용해 객체 생성 개념으로 구현해보겠습니다.</p><h5 id="노드-생성-기능"><a href="#노드-생성-기능" class="headerlink" title="노드 생성 기능"></a>노드 생성 기능</h5><p>링크드 리스트에 노드를 생성하는 기능을 구현했습니다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">LinkedList.prototype.append &#x3D; function (data) &#123;</span><br><span class="line">  let node &#x3D; new Node(data)</span><br><span class="line">  let current &#x3D; null</span><br><span class="line"></span><br><span class="line">  if(this.head &#x3D;&#x3D;&#x3D; null) &#123;</span><br><span class="line">    this.head &#x3D; node</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    current &#x3D; this.head</span><br><span class="line"></span><br><span class="line">    while(current.next) &#123;</span><br><span class="line">      current &#x3D; current.next</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    current.next &#x3D; node</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  this.count++</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var list &#x3D; new LinkedList(); &#x2F;&#x2F; 링크드 리스트 객체 생성</span><br><span class="line">list.append(15); &#x2F;&#x2F; node 생성 및 추가</span><br><span class="line">list.append(23);</span><br><span class="line">list.append(10);</span><br><span class="line"></span><br><span class="line">console.log(list) &#x2F;&#x2F; 링크드 리스트 출력</span><br></pre></td></tr></table></figure><p>링크드 리스트에 노드를 생성한다는 것은 <strong>새로운 node를 추가하면 가장 마지막에 들어간다는 것</strong> 으로, 노드를 생성 및 링크드 리스트에 추가할때는 <strong><em>line 5 ~ line 15</em></strong> 와 같이 리스트에 <code>head</code>가 있는지 없는지 확인해야 한다.</p><p>만약 <code>head</code>가 비었다면(null) 선언해주면 되고, 지정되어 있다면 <code>head</code>를 <code>current</code>에 할당해준 후 while 문의 <code>current.next</code>가 null이 될때까지 선회(loop)한 후 <strong><em>line 14</em></strong> 의 <code>current.next</code>의 current는 마지막 노드이며 마지막 노드의 링크 속성인 <code>current.next</code>에 현재 생성됐고 추가될 node의 정보를 할당해준다.</p><p>위와 같이 구현한 후 <code>list</code>를 출력하면 아래와 같습니다.<br><img src="/images/linkedlist_append_console.png" alt="node 생성 및 삽입 완료된 list"></p><h5 id="노드-조회-기능"><a href="#노드-조회-기능" class="headerlink" title="노드 조회 기능"></a>노드 조회 기능</h5><p>이번에는 링크드 리스트에 삽입한 노드를 조회하는 기능을 구현해보겠습니다. 구현할 조회 메서드는 <strong>indexOf</strong>, <strong>search</strong>, <strong>isEmpty</strong>, <strong>size</strong> 입니다.</p><p><strong>indexOf 메서드</strong>를 구현해보겠습니다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">LinkedList.prototype.indexOf &#x3D; function (data) &#123;</span><br><span class="line">  let current &#x3D; this.head</span><br><span class="line">  let index &#x3D; 0</span><br><span class="line"></span><br><span class="line">  while(current) &#123;</span><br><span class="line">    if (current.data &#x3D;&#x3D;&#x3D; data) &#123;</span><br><span class="line">      return index</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    index++</span><br><span class="line">    current &#x3D; current.next</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return -1</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>위 코드는 링크드 리스트 객체에서 인자로 넘겨받은 <code>data</code>를 기준으로 리스트 내 index를 반환하는 함수로 <strong><em>line 4</em></strong> 에서 while 문으로 순회하면서 <code>current.data</code>와 인자 <code>data</code>를 비교한 후 index를 반환한다.</p><p><strong>search</strong>를 구현해보겠습니다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">LinkedList.prototype.search &#x3D; function (data) &#123;</span><br><span class="line">  let current &#x3D; this.head</span><br><span class="line"></span><br><span class="line">  while (current.data !&#x3D;&#x3D; data) &#123;</span><br><span class="line">    current &#x3D; current.next</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return current</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>위 코드는 링크드 리스트 객체에서 data를 기준으로 node를 조회하는 메서드로, <code>while</code> 문 안에서 <code>current.data</code>의 값과 비교해서 동일할때까지 순회하는 구조입니다.</p><p><strong>size 메서드</strong>를 구현해보겠습니다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">LinkedList.prototype.size &#x3D; function (data) &#123;</span><br><span class="line">  return this.count</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>리스트의 크기값을 반환합니다.</p><p><strong>isEmpty 메서드</strong>를 구현해보겠습니다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">LinkedList.prototype.isEmpty &#x3D; function (data) &#123;</span><br><span class="line">  return this.count &#x3D;&#x3D;&#x3D; 0</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>생성자 함수 <code>LinkedList</code>에 의해 생성된 객체의 <code>count</code> property를 이용해 리스트가 비었는지 아닌지 반환한다.</p><h5 id="노드-수정-기능"><a href="#노드-수정-기능" class="headerlink" title="노드 수정 기능"></a>노드 수정 기능</h5><p>이번에는 링크드 리스트의 특정 index의 node에 데이터를 삽입하는 기능을 구현해보겠습니다. 구현할 조회 메서드는 <strong>insert</strong> 입니다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">LinkedList.prototype.insert &#x3D; function (position, data) &#123;</span><br><span class="line">  if (position &gt;&#x3D; 0 &amp;&amp; position &lt;&#x3D; this.count) &#123;</span><br><span class="line">    let node &#x3D; new Node(data)</span><br><span class="line">    let current &#x3D; this.head</span><br><span class="line">    let previous &#x3D; null</span><br><span class="line">    let index &#x3D; 0</span><br><span class="line"></span><br><span class="line">    if (position &#x3D;&#x3D;&#x3D; 0) &#123;</span><br><span class="line">      node.next &#x3D; current</span><br><span class="line">      this.head &#x3D; node</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      while (index++ &lt; position) &#123;</span><br><span class="line">        previous &#x3D; current</span><br><span class="line">        current &#x3D; current.next</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    node.next &#x3D; current</span><br><span class="line">    previous.next &#x3D; node</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  this.count++</span><br><span class="line">  return node</span><br><span class="line"></span><br><span class="line">  return false</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>위 코드는 새로운 <code>node</code>를 생성하고, 특정 위치에 기존 node의 이전과 이후의 node에 연결해주는 메서드이다. position이 0이라면 <strong>head</strong>를 변경해주면 되고, 그렇지 않을 경우 <code>while</code> 문으로 position까지 선회한 후 이전 node를 나타내는 <code>previous</code> 변수에는 교체 전 node를, <code>current</code> 변수에는 교체 전 node의 다음 node 값을 갖는다. 그리고 <code>while</code> 문이 끝나면 교체해야할 <code>node.next</code> 프로퍼티에 교체대상의 다음 node 값을 할당한 <code>current</code> 변수를 할당하고, 교체대상의 이전 node인 <code>previous.next</code> 프로퍼티에는 새롭게 생성한 node를 할당해준다.</p><h5 id="노드-삭제-기능"><a href="#노드-삭제-기능" class="headerlink" title="노드 삭제 기능"></a>노드 삭제 기능</h5><p>노드 삭제 기능 ()<br>마지막으로 링크드 리스트에 삽입한 노드를 삭제하는 기능을 구현해보겠습니다. 구현할 조회 메서드는 <strong>remove</strong>, <strong>removeAt</strong> 입니다.</p><p>이번에는 <strong>removeAt</strong> 메소드를 구현해보겠습니다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">LinkedList.prototype.removeAt &#x3D; function (position) &#123;</span><br><span class="line">  if (position &gt; -1 &amp;&amp; position &lt; this.count) &#123;</span><br><span class="line">    let current &#x3D; this.head</span><br><span class="line">    let previoud &#x3D; null</span><br><span class="line">    let index &#x3D; 0</span><br><span class="line"></span><br><span class="line">    if (position &#x3D;&#x3D;&#x3D; 0) &#123;</span><br><span class="line">      this.head &#x3D; current.next</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      while (index++ &lt; position) &#123;</span><br><span class="line">        previous &#x3D; current</span><br><span class="line">        current &#x3D; current.next</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      previous.next &#x3D; current.next</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    this.count--</span><br><span class="line">    current.next &#x3D; null</span><br><span class="line"></span><br><span class="line">    return current.data</span><br><span class="line">  &#125;</span><br><span class="line">  return null</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>위 코드는 특정 index를 기준으로 리스트의 node를 삭제하는 메서드로 먼저 삭제한 node의 index인 <code>position</code> 인자를 검증한 후 <strong>Line 7</strong> 과 같이 삭제할 index가 <strong>head</strong> 인지 검증한 후 만약 head라면 다음 node를 head로 할당해주고, 그렇지 않을 경우 while 문으로 선회하면서 삭제할 index의 직전 node에서 멈춘 후 이 node를 <code>previous</code> 변수에 할당하고, <code>previous.next</code>의 값을 <code>current.next.next</code>로 할당해 삭제할 index의 node의 앞과 뒤 node를 이어준다.</p><p>이번에는 <strong>remove</strong> 메소드를 구현해보겠습니다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">LinkedList.prototype.remove &#x3D; function (data) &#123;</span><br><span class="line">  var index &#x3D; this.indexOf(data)</span><br><span class="line">  return this.removeAt(index)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>위 코드는 <strong>indexOf</strong> 메서드를 이용해 data를 기준으로 node의 index를 조회해 <strong>removeAt</strong> 메서드로 삭제해준다.</p><h2 id="마치며"><a href="#마치며" class="headerlink" title="마치며"></a>마치며</h2><p>이번 포스트에서는 알고리즘 시리즈의 자료구조 포스팅 중 첫번째로, 링크드 리스트의 정의와 구조 및 메서드에 공부해봤습니다. 그리고 정의한 구조와 메서드를 구현해봤습니다. 다음 포스트에서는 링크드 리스트와 같이 선형 자료구조 중 하나인 큐에 대해서 공부해보겠습니다.</p><hr><h2 id="참조"><a href="#참조" class="headerlink" title="참조"></a>참조</h2><ul><li><a href="https://github.com/trekhleb/javascript-algorithms/blob/master/src/data-structures/linked-list/README.ko-KR.md">링크드 리스트</a></li><li><a href="https://jeong-pro.tistory.com/123?category=799620">ES6 javascript로 자료구조 List 구현하기 (배웠으면 사용해보자!!)</a></li><li><a href="https://www.zerocho.com/category/Algorithm/post/58008a628475ed00152d6c4d">자료구조(연결 리스트, linked list)</a></li><li><a href="https://boycoding.tistory.com/33">자바스크립트 자료구조 연결 리스트(Linked List)</a></li><li><a href="https://dororongju.tistory.com/107">[자바스크립트] LinkedList 연결 리스트</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;/images/algorithm.png&quot; alt=&quot;알고리즘&quot;&gt;&lt;/p&gt;
&lt;p&gt;이번 포스트에서는 선형 자료구조 중 하나인 링크드 리스트에 대해서 다뤄보겠습니다.&lt;/p&gt;
&lt;h2 id=&quot;링크드-리스트&quot;&gt;&lt;a href=&quot;#링크드-리스트&quot;</summary>
      
    
    
    
    <category term="Programming" scheme="https://joontae-kim.github.io/categories/Programming/"/>
    
    <category term="Algorithm" scheme="https://joontae-kim.github.io/categories/Programming/Algorithm/"/>
    
    
    <category term="Algorithm" scheme="https://joontae-kim.github.io/tags/Algorithm/"/>
    
    <category term="data structure" scheme="https://joontae-kim.github.io/tags/data-structure/"/>
    
    <category term="data" scheme="https://joontae-kim.github.io/tags/data/"/>
    
    <category term="structure" scheme="https://joontae-kim.github.io/tags/structure/"/>
    
    <category term="자료 구조" scheme="https://joontae-kim.github.io/tags/%EC%9E%90%EB%A3%8C-%EA%B5%AC%EC%A1%B0/"/>
    
    <category term="linked list" scheme="https://joontae-kim.github.io/tags/linked-list/"/>
    
    <category term="링크드 리스트" scheme="https://joontae-kim.github.io/tags/%EB%A7%81%ED%81%AC%EB%93%9C-%EB%A6%AC%EC%8A%A4%ED%8A%B8/"/>
    
  </entry>
  
  <entry>
    <title>알고리즘 시리즈 - 자료구조</title>
    <link href="https://joontae-kim.github.io/2021/04/18/algorithm-data-structrue/"/>
    <id>https://joontae-kim.github.io/2021/04/18/algorithm-data-structrue/</id>
    <published>2021-04-17T17:20:38.000Z</published>
    <updated>2021-04-24T06:36:38.929Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/algorithm.png" alt="알고리즘"></p><p>이전 포스트인 <a href="">알고리즘 시리즈 - 시간 복잡도</a>에서는 알고리즘의 성능을 파악하는 척도 중 하나인 시간복잡도와 big-O에 대해서 공부해봤습니다. 시간 복잡도란 <strong>문제를 해결하는데 걸리는 시간과 입력의 함수 관계</strong> 로 문제에 적합한 자료구조와 그에 따른 알고리즘에 영향을 받으며 알고리즘의 수행 시간은 동일 크기의 다양한 입력에 의해 달라질 수 있다.</p><table><thead><tr><th>자료 구조</th><th>접근</th><th>검색</th><th>삽입</th><th>삭제</th><th>비고</th></tr></thead><tbody><tr><td>배열</td><td>1</td><td>n</td><td>n</td><td>n</td><td></td></tr><tr><td>스택</td><td>n</td><td>n</td><td>1</td><td>1</td><td></td></tr><tr><td>큐</td><td>n</td><td>n</td><td>1</td><td>1</td><td></td></tr><tr><td>연결 리스트</td><td>n</td><td>n</td><td>1</td><td>1</td><td></td></tr><tr><td>해시 테이블</td><td>-</td><td>n</td><td>n</td><td>n</td><td>완벽한 해시 함수의 경우 O(1)</td></tr><tr><td>이진 탐색 트리</td><td>n</td><td>n</td><td>n</td><td>n</td><td>균형 트리의 경우 O(log(n))</td></tr><tr><td>B-트리</td><td>log(n)</td><td>log(n)</td><td>log(n)</td><td>log(n)</td><td></td></tr><tr><td>Red-Black 트리</td><td>log(n)</td><td>log(n)</td><td>log(n)</td><td>log(n)</td><td></td></tr><tr><td>AVL 트리</td><td>log(n)</td><td>log(n)</td><td>log(n)</td><td>log(n)</td><td></td></tr><tr><td>Bloom Filter</td><td>-</td><td>1</td><td>1</td><td>-</td><td>거짓 양성이 탐색 중 발생 가능</td></tr></tbody></table><p>위 표는 <strong>자료구조 작업별 복잡도</strong> 로써 자료구조의 특성에 따라 작업별 시간복잡도가 다름을 알 수 있으며 이번 포스트에서는 상대적으로 <a href="https://github.com/trekhleb/javascript-algorithms/blob/master/README.ko-KR.md#%EC%9E%90%EB%A3%8C-%EA%B5%AC%EC%A1%B0">입문자 레벨 (참조 - JavaScript 알고리즘 및 자료 구조)</a>에 속하는 아래 데이터 구조에 대해 공부해보겠습니다.</p><ol><li>연결 리스트</li><li>이중 연결 리스트</li><li>큐</li><li>스택</li><li>해시 테이블</li><li>힙</li><li>우선순위 큐</li></ol><h2 id="자료구조란"><a href="#자료구조란" class="headerlink" title="자료구조란"></a>자료구조란</h2><p>자료구조란 데이터 값의 모임, 데이터 간의 관계 그리고 데이터가 사용할 수 있는 함수로써, 특정 문제를 해결하기 위한 추상화된 모델링(자료구조)은 시간 복잡도와 공간 복잡도를 줄여주는 효과가 있으며 그에 따라 효율적인 알고리즘을 수행할 수 있다. 프로그램을 설계하거나 문제해결 과정을 설계할때, 우선적으로 어떤 자료구조로 모델링할지 고려되야하며 자료구조가 선택되면 적용할 알고리즘의 폭은 상대적으로 좁혀지기 때문에 그 안에서 복잡도를 분석해가며 알고리즘을 선택하면 되겠다. </p><h3 id="자료구조-종류"><a href="#자료구조-종류" class="headerlink" title="자료구조 종류"></a>자료구조 종류</h3><p><img src="https://wayhome25.github.io/assets/post-img/cs/data-structure.png" alt="자료구조의 종류 (출처: 초보몽키님)"></p><p>자료구조는 위 사진에서 볼수 있듯이 단순 / 선형 / 비선형 / 파일 구조로 구분되며 알고리즘 문제풀이에서 많이 사용되는 구조는 선형 / 비선형 구조이다.</p><h3 id="선형-구조"><a href="#선형-구조" class="headerlink" title="선형 구조"></a>선형 구조</h3><p>한 종류의 데이터가 선처럼 길게 나열된 자료구조로써, 데이터 요소에 랜덤 접근여부에 따라서 랜덤 접근 가능 자료구조 - 배열, 해시 / 랜덤 접근 불가능 자료구조 - 스택, 큐, 데크, 링크드 리스트로 구분된다.</p><p>선형 구조의 자료 탐색법으로는 아래와 같다.</p><ul><li>순차 탐색</li><li>이분 탐색</li></ul><h3 id="비선형-구조"><a href="#비선형-구조" class="headerlink" title="비선형 구조"></a>비선형 구조</h3><p>선형 자료구조가 아닌 모든 자료구조로써, 사전적인 정의로 i 번째 값을 탐색한 뒤의 i+1이 정해지지 않은 구조를 의미한다. 비선형 자료구조의 종류와 간략한 정의는 아래와 같다.</p><ol><li>그래프<ul><li>꼭지점과 꼭지점을 있는 변으로 구성</li><li>방향 그래프, 무방향 그래프: 변이 방향성을 갖는지 아닌지에 따라 그래프의 유형을 구분할 수 있으며 무방향 그래프는 순환이 없는 그래프이고, 방향 그래프는 변의 방향이 보통 부모를 가리키도록 구현된 그래프이다.</li></ul></li><li>트리<ul><li>뿌리와 뿌리 또는 다른 꼭지점을 단 하나의 부모로 갖는 꼭짓접들로 이루어진 구조</li><li>부모 자식 관계는 변으로 표현된다.</li><li>트리의 종류는 연결된 자식의 개수에 따라 구분되는데 일반적으로 1개의 자식을 갖는 구조를 단순 일반 트리, 자식이 최대 2개인 트리를 이진 트리라고 한다.</li><li>힙 또한 이진 트리의 한 종류로 이진 트리에 특성을 부여한 것이라 할 수 있다.</li></ul></li></ol><h2 id="마치며"><a href="#마치며" class="headerlink" title="마치며"></a>마치며</h2><p>이후 포스트 부터는 선형 및 비선형 구조의 각 자료구조에 대해 순서대로 다뤄보겠습니다.</p><hr><h2 id="참고"><a href="#참고" class="headerlink" title="참고"></a>참고</h2><ul><li><a href="https://ko.wikipedia.org/wiki/%EC%9E%90%EB%A3%8C_%EA%B5%AC%EC%A1%B0">자료 구조</a></li><li><a href="https://librewiki.net/wiki/%EC%8B%9C%EB%A6%AC%EC%A6%88:%EC%88%98%ED%95%99%EC%9D%B8%EB%93%AF_%EA%B3%BC%ED%95%99%EC%95%84%EB%8B%8C_%EA%B3%B5%ED%95%99%EA%B0%99%EC%9D%80_%EC%BB%B4%ED%93%A8%ED%84%B0%EA%B3%BC%ED%95%99/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98_%EA%B8%B0%EC%B4%88">시리즈:수학인듯 과학아닌 공학같은 컴퓨터과학/알고리즘 기초</a></li><li><a href="https://wayhome25.github.io/cs/2017/04/17/cs-18/">강의노트 17. 알고리즘, 자료구조 개요</a></li><li><a href="https://geniee.tistory.com/20?category=848930">JavaScript를 위한 자료구조</a></li><li><a href="https://github.com/trekhleb/javascript-algorithms/blob/master/README.ko-KR.md">JavaScript 알고리즘 및 자료 구조</a></li><li><a href="https://dingrr.com/blog/post/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98%EC%8B%9C%EA%B0%84%EB%B3%B5%EC%9E%A1%EB%8F%84-big-o">[알고리즘]시간복잡도 Big O</a></li><li><a href="https://reactiver.dev/data-structure-for-javascript/">Data Structure For JavaScript</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;/images/algorithm.png&quot; alt=&quot;알고리즘&quot;&gt;&lt;/p&gt;
&lt;p&gt;이전 포스트인 &lt;a href=&quot;&quot;&gt;알고리즘 시리즈 - 시간 복잡도&lt;/a&gt;에서는 알고리즘의 성능을 파악하는 척도 중 하나인 시간복잡도와 big-O에 대해서</summary>
      
    
    
    
    <category term="Programming" scheme="https://joontae-kim.github.io/categories/Programming/"/>
    
    <category term="Algorithm" scheme="https://joontae-kim.github.io/categories/Programming/Algorithm/"/>
    
    
    <category term="Algorithm" scheme="https://joontae-kim.github.io/tags/Algorithm/"/>
    
    <category term="data structure" scheme="https://joontae-kim.github.io/tags/data-structure/"/>
    
    <category term="data" scheme="https://joontae-kim.github.io/tags/data/"/>
    
    <category term="structure" scheme="https://joontae-kim.github.io/tags/structure/"/>
    
    <category term="자료 구조" scheme="https://joontae-kim.github.io/tags/%EC%9E%90%EB%A3%8C-%EA%B5%AC%EC%A1%B0/"/>
    
  </entry>
  
  <entry>
    <title>알고리즘 시리즈 - 시간 복잡도</title>
    <link href="https://joontae-kim.github.io/2021/04/15/algorithm-big-O/"/>
    <id>https://joontae-kim.github.io/2021/04/15/algorithm-big-O/</id>
    <published>2021-04-15T06:30:46.000Z</published>
    <updated>2021-04-23T07:05:36.807Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/algorithm.png" alt="알고리즘"></p><h2 id="알고리즘-개요"><a href="#알고리즘-개요" class="headerlink" title="알고리즘 개요"></a>알고리즘 개요</h2><p>지난 포스트인 <a href="/2021/04/04/algorithm/">알고리즘 시리즈 - 시작</a>에서는 우리는 알고리즘을 <strong>특정 문제를 해결하기 위한 일련의 계산과정</strong>으로 <em>입력, 출력 그리고 계산과정</em> 이 존재한다고 정의했었습니다. 또한 해결해야하는 문제의 특성에 따라 사용하기에 적합한 데이터 형태가 다르며 어떤 데이터 형태와 알고리즘 구조를 설계했느냐에 따라서 알고리즘 성능 분석 기준 중 시간복잡도와 공간복잡도 또한 달라집니다. 이번 포스트에서는 그중에 하나인 시간 복잡도에 대해서 공부해보겠습니다.</p><h2 id="시간-복잡도"><a href="#시간-복잡도" class="headerlink" title="시간 복잡도"></a>시간 복잡도</h2><h3 id="시나리오"><a href="#시나리오" class="headerlink" title="시나리오"></a>시나리오</h3><p>A라는 지점에서 B 지점을 가야한다고 상상해보자. B 지점은 처음 가는 곳이며 버스를 타고 가야할지, 지하철을 타고 가야할지 그리고 대중교통 선택했다면 어떤 버스를 또는 지하철을 타고 가야하는지 조차 정보가 없다. 네이버맵에서 경로 검색 후 지하철을 타기로 했다. 추천 노선은 총 2개이고, 추천 경로는 총 5개이며 모두 경험이 없는 경로여서 어떤 경로를 선택할지 일일히 탐색해봐야 한다. (경로 탐색중…) 5개의 경로를 모두 탐색했고 그 중 1번의 환승임에도 불구하고 가장 빠르게 도착하는 경로를 선택했다.</p><h3 id="시간-복잡도란…"><a href="#시간-복잡도란…" class="headerlink" title="시간 복잡도란…"></a>시간 복잡도란…</h3><p>위와 같은 경로 탐색의 시간이 바로 시간 복잡도 이다. 위 시나리오 처럼 전혀 데이터가 없어 모든 추천경로를 탐색한 후 비교 분석을 통해 선택한다면 시간은 추천경로의 개수만큼 늘어날 것이고, 만약 개중 데이터가 있는 경로가 있었다면 그중 선택함으로써 추천경로 모두를 탐색하지 않아도 됐을 것이다.</p><p>즉, <strong>시간 복잡도란 문제를 해결하는데 걸리는 시간과 입력의 함수 관계</strong> 로써, 같은 결과를 내는 다수의 알고리즘이 있다면 가능한 시간이 적게 걸리는 다시말해 시간 복잡도가 낮은 알고리즘이 좋은 알고리즘이라고 판단할 수 있겠다. 기본적인 연산을 수행하는데에 고정된 시간이 걸릴 때, 알고리즘에 의해서 수행되는 기본 연산의 개수를 세어 예측할 수 있다. 알고리즘의 수행 시간은 동일 크기의 다양한 입력에 의해 달라질 수 있기 때문에, 가장 많이 쓰이는 최악의 시간 복잡도의 알고리즘 시간을 T(n)이라고 했을 때, 이것은 크기 n의 모든 입력에 대해 걸리는 최대의 시간으로 정의할 수 있다.</p><h3 id="시간-복잡도의-종류"><a href="#시간-복잡도의-종류" class="headerlink" title="시간 복잡도의 종류"></a>시간 복잡도의 종류</h3><ol><li>Every-Case Time Complexity ( 𝑇(𝑛) )<ul><li>입력 크기 n 이 입력됐을 때, 알고리즘이 연산을 수행하는 횟수</li><li>입력 크기에만 종속되며, 어떤 입력값이 들어오더라도 일정하다.</li></ul></li><li>The Worst Case Time Complexity( 𝑊(𝑛) )<ul><li>입력크기 n 이 주어졌을 때, 알고리즘이 연산을 수행하는 최대 횟수</li><li>입력크기와 입력값 모두에 종속되며, 단위연산이 수행되는 횟수가 최대인 경우 선택</li></ul></li><li>The Best Case Time Complexity ( 𝐵(𝑛) )<ul><li>입력크기 n 이 주어졌을 때, 알고리즘이 연산을 수행하는 최소 횟수</li><li>입력크기와 입력값 모두에 종속되며, 단위연산이 수행되는 횟수가 최소인 경우 선택</li></ul></li><li>The Average Case Time Complexity ( 𝐴(𝑛) )<ul><li>입력크기 n 이 주어졌을 때, 알고리즘이 연산을 수행하는 평균 횟수</li><li>입력크기와 입력값 모두에 종속되며, 모든 입력에 대해서 단위연산이 수행되는 기대치</li></ul></li></ol><h3 id="점근적-분석법"><a href="#점근적-분석법" class="headerlink" title="점근적 분석법"></a>점근적 분석법</h3><p>점근적 분석법이란 <strong>입력되는 데이터의 크기에 따라 수행 시간간과 공간이 얼마나 차지하는지 알아보는 탐색법</strong>으로써, 주어진 데이터의 형태나 실험을 수행하는 환경 또는 실험에 사용한 시스템의 성능 등의 요소에 의해 공평한 결과가 나오기 힘들고, 그 비교가 항상 일정하지 않기 때문에 필요하다.</p><p>시간복잡도를 나타내는 점근적 분석법의 표기법으로는 아래와 같으며 주로 최악의 경우인 <strong>빅오 표기법 (Big-O Notation)</strong> 을 사용하는데 그 이유는 평균의 경우를 사용하면 그 기준을 맞추기 까다롭고 모호할 수 있으며 최악의 경우를 사용하면 <em>“아무리 나빠도 다른 알고리즘 보다는 같거나 좋다.”</em> 라는 비교분석을 따르면 평균에 가까운 성능을 예측하기 쉽기 때문이다.</p><ul><li>최상의 경우 : 오메가 표기법 (Big-Omega(Ω) Notation)</li><li>평균의 경우 : 세타 표기법 (Theta(θ) Notation)</li><li>최악의 경우 : 빅오 표기법 (Big-O Notation)</li></ul><h2 id="Big-O"><a href="#Big-O" class="headerlink" title="Big-O"></a>Big-O</h2><ul><li>시간 복잡도에 가장 큰 영향을 미치는 차항으로 시간복잡도를 나타내는 것으로 <strong>알고리즘 실행 시간의 상한선</strong>을 나타낸 표기법이다.</li><li><strong>Big-O 표기법</strong> 이라 하며 <strong>O(f(n))</strong> 과 같이 표기한다. (O는 order 라고 읽는다.)</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1                        # O(1): 상수</span><br><span class="line"></span><br><span class="line">T(n)&#x3D;2n                  # O(n): n이 가장 큰 영향을 미친다.</span><br><span class="line"></span><br><span class="line">T(n)&#x3D;2n^5+3n^4+n^3+n^2+1 # O(n5): n^5이 가장 큰 영향을 미친다</span><br><span class="line"></span><br><span class="line">T(n)&#x3D;3n^2+2n+1           # O(n2): n^2이 가장 큰 영향을 미친다.</span><br></pre></td></tr></table></figure><h3 id="Big-O-표기법의-종류"><a href="#Big-O-표기법의-종류" class="headerlink" title="Big-O 표기법의 종류"></a>Big-O 표기법의 종류</h3><p>※ 여기서 n이란 입력되는 데이터를 의미합니다.</p><table><thead><tr><th>f(n)</th><th>Name</th><th>비고</th></tr></thead><tbody><tr><td>1</td><td>Contant (상수)</td><td>Operation push and pop on Stack</td></tr><tr><td>log n</td><td>Logarithmic (로그)</td><td>Binary Tree</td></tr><tr><td>n</td><td>Linear (선형)</td><td>for loop</td></tr><tr><td>n log n</td><td>Log Linear (선형 로그)</td><td>Quick Sort, Merge Sort, Heap Sort</td></tr><tr><td>n<sup>2</sup></td><td>Quadratic (제곱)</td><td>Double for loop, Insert Sort, Bubble Sort, Selection Sort</td></tr><tr><td>2<sup>n</sup></td><td>Exponential (지수)</td><td>Fibonacci Sequence</td></tr></tbody></table><h3 id="Big-O-표기법의-설명"><a href="#Big-O-표기법의-설명" class="headerlink" title="Big-O 표기법의 설명"></a>Big-O 표기법의 설명</h3><ol><li>O(1)<ul><li>상수 시간</li><li>문제 해결을 위해 오직 한 단계만 거침</li><li>입력되는 데이터 양과 상관없이 일정한 시간 동안 실행</li></ul></li><li>O(log n)<ul><li>로그 시간</li><li>입력 데이터의 크기가 커질수록 처리 시간이 로그(log) 만큼 짧아지는 알고리즘</li><li>입력값 n이 주어졌을때, 문제를 해결하는데 필요한 단계들이 연산마다 특정요인에 의해 줄어듬</li><li>입력 데이터 10 투입되면 시간은 2배가 걸림</li></ul></li><li>O(n)<ul><li>직선적 시간</li><li>문제를 해결하기 위한 단계의 수와 입력 데이터의 크가 n이 1:1 관계를 가지는 알고리즘</li><li>예) 1차원 for loop</li></ul></li><li>O(n log n)<ul><li>선형 로그 시간</li><li>입력 데이터의 크기가 커질수록 처리 시간이 로그(log) 만큼 늘어나는 알고리즘</li><li>예) 입력 데이터 10 투입되면 시간은 20배가 걸림</li><li>대표적 알고리즘: 병합 정렬 알고리즘, 퀵 정렬 알고리즘</li></ul></li><li>O(n<sup>2</sup>)<ul><li>제곱 시간</li><li>입력 데이터의 크기에 따라 걸리는 시간은 제곱에 비례</li><li>이중 루프 내에서 입력 데이터를 처리하는 경우에 나타남</li><li><code>n</code> 값이 커지면 실행 시간이 감당할 수 없을 정도로 늘어남</li><li>문제를 해결하기 위한 단계의 수에 해당</li><li>대표적 알고리즘: 버블 정렬 알고리즘, 삽입 정렬 알고리즘 (둘다 2중 for loop 구조)</li></ul></li><li>O(2<sup>n</sup>)<ul><li>지수 시간</li><li>입력 데이터의 크기에 따라 걸리는 시간은 2의 n 제곱만큼 비례</li><li>보통 문제를 풀기 위한 모든 조합과 방법을 시도할 때 사용됨</li><li>대표적 알고리즘: 피보나치 수열, 재귀가 역기능을 할 경우도 해당됨</li></ul></li></ol><h4 id="성능-순서"><a href="#성능-순서" class="headerlink" title="성능 순서"></a>성능 순서</h4><p><strong>[Excellent]</strong> O(1) &lt; O(logn) &lt; O(n) &lt; O(n log n) &lt; O(n<sup>2</sup>) &lt; O(2<sup>n</sup>) <strong>[Horrible]</strong><br><img src="https://github.com/trekhleb/javascript-algorithms/raw/master/assets/big-o-graph.png" alt="Big-O 성능 그래프"></p><p>Big O 표기와 입력 데이터 크기에 따른 성능을 비교<br>| Big O 표기 |    10 개 일때 |    100 개 일때 |    1000 개 일때 |<br>|——|——|——|——|<br>| O(1)     | 1 | 1 | 1 |<br>| O(log n)     | 3 | 6 | 9 |<br>| O(n)     | 10 |    100 | 1000 |<br>| O(n log n)     | 30 |    600 | 9000 |<br>| O(n<sup>2</sup>)     | 100 | 10000 | 1000000 |<br>| O(2<sup>n</sup>)     |  1024 | 1.26e+29 | 1.07e+301 |<br>| O(N!)         | 3628800 | 9.3e+157    | 4.02e+2567 |</p><h3 id="Big-O-시간복잡도-계산"><a href="#Big-O-시간복잡도-계산" class="headerlink" title="Big-O 시간복잡도 계산"></a>Big-O 시간복잡도 계산</h3><p>몇 가지 시간복잡도 Big-O 표기법을 예시로 계산법을 알아보도록 하겠습니다.</p><h4 id="문제-1"><a href="#문제-1" class="headerlink" title="문제 1"></a>문제 1</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function print(arg) &#123;</span><br><span class="line">  console.log(arg)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">print(&#39;hello&#39;)</span><br><span class="line">&gt; &quot;hello&quot;</span><br></pre></td></tr></table></figure><p>위 코드는 <strong>시간 복잡도: O(1)</strong> 인 코드로 실행되는 코드 라인은 <code>print</code> 함수 내부 <code>console.log(arg)</code> 뿐이다.</p><h4 id="문제-2"><a href="#문제-2" class="headerlink" title="문제 2"></a>문제 2</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function loop(n) &#123;</span><br><span class="line">  for(let i&#x3D;0;i &lt; n;i++)&#123;</span><br><span class="line">    console.log(i);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">loop(10)</span><br><span class="line">&gt; 1</span><br><span class="line">&gt; 2</span><br><span class="line">&gt; ....</span><br><span class="line">&gt; 10</span><br></pre></td></tr></table></figure><p>위 코드는 <strong>시간 복잡도: O(n)</strong> 인 코드로 실행되는 코드 라인은 <code>loop</code> 함수의 for loop가 <code>n</code> 번만큼 반복하기 떄문이다.</p><h5 id="문제-2-기출변형"><a href="#문제-2-기출변형" class="headerlink" title="문제 2: 기출변형"></a>문제 2: 기출변형</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function loop2(n) &#123;</span><br><span class="line">  for(let i&#x3D;0;i&lt;n;i++)&#123;</span><br><span class="line">    console.log(i);</span><br><span class="line">  &#125;</span><br><span class="line">  for(let i&#x3D;0;i&lt;n;i++)&#123;</span><br><span class="line">    console.log(i);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">loop2(10)</span><br></pre></td></tr></table></figure><p>위 코드 <code>loop2</code> 함수 내부에 loop 문이 2개 있지만 시간복잡도 계산에서는 영향이 가장 큰 알고리즘 하나만 계산하기 때문에 O(n<sup>2</sup>)가 아닌 <strong>시간 복잡도: O(n)</strong> 입니다.</p><h4 id="문제-3"><a href="#문제-3" class="headerlink" title="문제 3"></a>문제 3</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function looploop(n) &#123;</span><br><span class="line">  for(let i&#x3D;0;i&lt;n;i++)&#123;</span><br><span class="line">    console.log(i);</span><br><span class="line">    for(let j&#x3D;0;j&lt;n;j++)&#123;</span><br><span class="line">      console.log(j);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">looploop(10)</span><br></pre></td></tr></table></figure><p>위 코드는 loop에 loop가 있는 이중 loop 문으로 <strong>시간 복잡도: O(n<sup>2</sup>)</strong> 입니다.</p><h5 id="문제-3-기출변형"><a href="#문제-3-기출변형" class="headerlink" title="문제 3: 기출변형"></a>문제 3: 기출변형</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">function looploop2(n) &#123;</span><br><span class="line">  for(let i&#x3D;0;i&lt;n;i++)&#123;</span><br><span class="line">    for(let j&#x3D;i;j&lt;n;j++&#123;</span><br><span class="line">      console.log(j);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  for(let i&#x3D;0;i&lt;n;i++)&#123;</span><br><span class="line">    console.log(i);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">looploop2(10)</span><br></pre></td></tr></table></figure><p>위 코드는 이중 loop문과 단수 loop이 있는 코드로써, <strong>##### 문제 2: 기출변형</strong> 에서 언급했듯이 영향이 가장 큰 알고리즘만 시간복잡도에서는 계산하기 때문에 <strong>시간 복잡도: O(n<sup>2</sup>)</strong> 이다.</p><h4 id="아래-문제는-아래의-데이터를-기반으로-풀어보겠습니다"><a href="#아래-문제는-아래의-데이터를-기반으로-풀어보겠습니다" class="headerlink" title="아래 문제는 아래의 데이터를 기반으로 풀어보겠습니다."></a>아래 문제는 아래의 데이터를 기반으로 풀어보겠습니다.</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var attendance &#x3D; &#123;</span><br><span class="line">  &#39;Kim&#39; : true,</span><br><span class="line">  &#39;Amili&#39; : false,</span><br><span class="line">  &#39;Moon&#39; : true,</span><br><span class="line">  &#39;Koon&#39; :  true,</span><br><span class="line">  &#39;Joon&#39; : true,</span><br><span class="line">&#125;</span><br><span class="line">var attendanceAges &#x3D; [21, 29, 22, 25, 27]</span><br></pre></td></tr></table></figure><h5 id="문제-4"><a href="#문제-4" class="headerlink" title="문제 4"></a>문제 4</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function isAttendant (name) &#123;</span><br><span class="line">  return attendance[name]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">isAttendant[&#39;Kim&#39;]</span><br><span class="line">isAttendant[&#39;Moon&#39;]</span><br></pre></td></tr></table></figure><p>위 코드는 <strong>isAttendant</strong> 함수에 <code>name</code> 인자를 넘겨 <code>attendance</code> 데이터에서 알고 있는 또는 전달받은 key 또는 index에 따라 결과값을 return 하는 함수로 <strong>시간 복잡도: O(1)</strong> 이다.</p><h5 id="문제-5"><a href="#문제-5" class="headerlink" title="문제 5"></a>문제 5</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function thisOld(num, array)&#123;</span><br><span class="line">  var midPoint &#x3D; Math.floor(array.length&#x2F;2);</span><br><span class="line">  if( array[midPoint] &#x3D;&#x3D;&#x3D; num) return true;</span><br><span class="line">  if( array[midPoint] &lt; num ) &#x2F;&#x2F; --&gt; only look at second half of the array</span><br><span class="line">  if( array[midpoint] &gt; num ) &#x2F;&#x2F; --&gt; only look at first half of the array</span><br><span class="line">  &#x2F;&#x2F; recursively repeat until you arrive at your solution </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">thisOld(28, attendanceAges)</span><br></pre></td></tr></table></figure><p>위 코드는 <strong>이진탐색 트리</strong> 알고리즘으로, <strong>thisOld</strong> 함수에 인자로 <code>array</code> 배열과 <code>num</code>을 념겨주고 내부 함수에서는 함수의 결과값을 찾기 위해 <code>array</code> 인자를 계속 반으로 분할하면서 값을 탐색하기 떄문에 배열에서 어느 방향으로 탐색을 시작할지 알고 있으면 탐색시간이 두배로 줄어든다. 따라서 <strong>시간 복잡도: O(log n)</strong> 인 알고리즘이다.</p><h2 id="시간복잡도-줄이는-법"><a href="#시간복잡도-줄이는-법" class="headerlink" title="시간복잡도 줄이는 법"></a>시간복잡도 줄이는 법</h2><p>일단 시간복잡도를 줄이는 법을 많이 찾아봤지만 자료를 많이 찾아보진 못했고 몇몇 국내외 블로그에서 언급 됐던 것은 아래와 같습니다.</p><ol><li>알고리즘에서 시간복잡도에 가장 큰 영향을 끼치는 것은 <strong>반복문</strong> 이다.<ul><li><em>#문제1 ~ 3</em> 이 반복문이 시간복잡도를 올리는 그 예이다.</li></ul></li><li>해결해야할 문제 또는 이슈에 맞는 적절한 <strong>알고리즘</strong>을 설계하라.<ul><li>알고리즘마다 핸들링 가능한 적절한 문제해결 케이스가 있기 때문에 외워두고 있거나 참고자료를 참고한다면 시간복잡도를 낮출 수 있다.</li></ul></li><li>각 알고리즘의 형태에 맞는 효율적인 <strong>자료구조</strong> 들을 이용한다면 시간 복잡도를 낮출 수 있다.<br><img src="/images/Common_Data_Structure_Operations.png" alt="Common Data Structure Operations"><br><img src="/images/Array_Sorting_Algorithms.png" alt="Array Sorting Algorithms"></li></ol><h2 id="부록"><a href="#부록" class="headerlink" title="부록"></a>부록</h2><h3 id="자료구조-작업별-복잡도"><a href="#자료구조-작업별-복잡도" class="headerlink" title="자료구조 작업별 복잡도"></a>자료구조 작업별 복잡도</h3><table><thead><tr><th>자료 구조</th><th>접근</th><th>검색</th><th>삽입</th><th>삭제</th><th>비고</th></tr></thead><tbody><tr><td>배열</td><td>1</td><td>n</td><td>n</td><td>n</td><td></td></tr><tr><td>스택</td><td>n</td><td>n</td><td>1</td><td>1</td><td></td></tr><tr><td>큐</td><td>n</td><td>n</td><td>1</td><td>1</td><td></td></tr><tr><td>연결 리스트</td><td>n</td><td>n</td><td>1</td><td>1</td><td></td></tr><tr><td>해시 테이블</td><td>-</td><td>n</td><td>n</td><td>n</td><td>완벽한 해시 함수의 경우 O(1)</td></tr><tr><td>이진 탐색 트리</td><td>n</td><td>n</td><td>n</td><td>n</td><td>균형 트리의 경우 O(log(n))</td></tr><tr><td>B-트리</td><td>log(n)</td><td>log(n)</td><td>log(n)</td><td>log(n)</td><td></td></tr><tr><td>Red-Black 트리</td><td>log(n)</td><td>log(n)</td><td>log(n)</td><td>log(n)</td><td></td></tr><tr><td>AVL 트리</td><td>log(n)</td><td>log(n)</td><td>log(n)</td><td>log(n)</td><td></td></tr><tr><td>Bloom Filter</td><td>-</td><td>1</td><td>1</td><td>-</td><td>거짓 양성이 탐색 중 발생 가능</td></tr></tbody></table><h3 id="정렬-알고리즘-복잡도"><a href="#정렬-알고리즘-복잡도" class="headerlink" title="정렬 알고리즘 복잡도"></a>정렬 알고리즘 복잡도</h3><table><thead><tr><th>이름</th><th>최적</th><th>평균</th><th>최악</th><th>메모리</th><th>동일값 순서 유지</th><th>비고</th></tr></thead><tbody><tr><td>거품 정렬</td><td>n</td><td>n<sup>2</sup></td><td>n<sup>2</sup></td><td>1</td><td>Yes</td><td></td></tr><tr><td>삽입 정렬</td><td>n</td><td>n<sup>2</sup></td><td>n<sup>2</sup></td><td>1</td><td>Yes</td><td></td></tr><tr><td>선택 정렬</td><td>n<sup>2</sup></td><td>n<sup>2</sup></td><td>n<sup>2</sup></td><td>1</td><td>No</td><td></td></tr><tr><td>힘 정렬</td><td>n log(n)</td><td>n log(n)</td><td>n log(n)</td><td>1</td><td>No</td><td></td></tr><tr><td>병합 정렬</td><td>n log(n)</td><td>n log(n)</td><td>n log(n)</td><td>n</td><td>Yes</td><td></td></tr><tr><td>퀵 정렬</td><td>n log(n)</td><td>n log(n)</td><td>n<sup>2</sup></td><td>log(n)</td><td>No</td><td>보통 제자리로 O(log(n)) <br> 스택공간으로 수행됨</td></tr><tr><td>셀 정렬</td><td>n log(n)</td><td>n log(n)</td><td>n (log(n))<sup>2</sup></td><td>1</td><td>No</td><td></td></tr><tr><td>계수 정렬</td><td>n + r</td><td>n + r</td><td>n + r</td><td>n + r</td><td>Yes</td><td>r - 배열내 가장 큰 수</td></tr><tr><td>기수 정렬</td><td>n * k</td><td>n * k</td><td>n * k</td><td>n * k</td><td>n + k</td><td>Yes</td></tr></tbody></table><hr><h2 id="참고"><a href="#참고" class="headerlink" title="참고"></a>참고</h2><ul><li><a href="https://coding-factory.tistory.com/608">[Algorithm] 알고리즘 시간복잡도에 대하여</a></li><li><a href="https://callmedevmomo.medium.com/%EC%9B%B9-%EA%B0%9C%EB%B0%9C%EC%9E%90%EB%A5%BC-%EC%9C%84%ED%95%9C-%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0%EC%99%80-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-01-%EB%B9%85%EC%98%A4-%ED%91%9C%EA%B8%B0%EB%B2%95-ff369f0efc1d">웹 개발자를 위한 자료구조와 알고리즘 (#01. 빅오 표기법)</a></li><li><a href="https://www.freecodecamp.org/news/time-is-complex-but-priceless-f0abd015063c/#.j7h5s1m2p">Algorithms in plain English: time complexity and Big-O notation</a></li><li><a href="https://blog.chulgil.me/algorithm/">알고리즘의 시간 복잡도와 Big-O 쉽게 이해하기</a></li><li><a href="https://www.bigocheatsheet.com/">Know Thy Complexities!</a></li><li><a href="https://velog.io/@dls4585/%EC%8B%9C%EA%B0%84%EB%B3%B5%EC%9E%A1%EB%8F%84Time-Complexity-%EC%A0%95%EB%A6%AC">시간복잡도(Time Complexity) 정리</a></li><li><a href="https://dingrr.com/blog/post/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98%EC%8B%9C%EA%B0%84%EB%B3%B5%EC%9E%A1%EB%8F%84-big-o">[알고리즘]시간복잡도 Big O</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;/images/algorithm.png&quot; alt=&quot;알고리즘&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;알고리즘-개요&quot;&gt;&lt;a href=&quot;#알고리즘-개요&quot; class=&quot;headerlink&quot; title=&quot;알고리즘 개요&quot;&gt;&lt;/a&gt;알고리즘 개요&lt;/h2&gt;&lt;</summary>
      
    
    
    
    <category term="Programming" scheme="https://joontae-kim.github.io/categories/Programming/"/>
    
    <category term="Algorithm" scheme="https://joontae-kim.github.io/categories/Programming/Algorithm/"/>
    
    
    <category term="Algorithm" scheme="https://joontae-kim.github.io/tags/Algorithm/"/>
    
    <category term="big-O" scheme="https://joontae-kim.github.io/tags/big-O/"/>
    
    <category term="time complexity" scheme="https://joontae-kim.github.io/tags/time-complexity/"/>
    
    <category term="알고리즘" scheme="https://joontae-kim.github.io/tags/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/"/>
    
    <category term="빅오" scheme="https://joontae-kim.github.io/tags/%EB%B9%85%EC%98%A4/"/>
    
    <category term="시간 복잡도" scheme="https://joontae-kim.github.io/tags/%EC%8B%9C%EA%B0%84-%EB%B3%B5%EC%9E%A1%EB%8F%84/"/>
    
  </entry>
  
  <entry>
    <title>Prototype 기반의 Javascript</title>
    <link href="https://joontae-kim.github.io/2021/04/07/js-oop-prototype/"/>
    <id>https://joontae-kim.github.io/2021/04/07/js-oop-prototype/</id>
    <published>2021-04-07T14:00:24.000Z</published>
    <updated>2021-08-05T09:06:29.215Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/js_with_prototype.png" alt="Javascript"></p><p>지난 포스트인 <a href="/2020/11/02/js-oop-2/">Javascript와 객체 지향 프로그래밍 - 객체 지향 프로그래밍(OOP)</a>에서는 객체 지향 프로그래밍의 기본적인 개념, 기본 구성요소, OOP의 기법 또는 특성으로 많이 언급되는 추상화, 캔슐화, 은닉화, 상속성, 다형성 그리고 OOP의 장단점에 대해 공부해보면서 객체 지향 프로그래밍에서 중요시하는 것은 무엇이며 프로그래밍 설계 및 구현시 이반되는 장점에 대해 알 수 있었습니다.</p><p>이번 포스트에서 다를 주제는 <strong>Prototype 기반의 프로그래밍</strong>입니다.</p><h2 id="Prototype-기반의-프로그래밍"><a href="#Prototype-기반의-프로그래밍" class="headerlink" title="Prototype 기반의 프로그래밍?"></a>Prototype 기반의 프로그래밍?</h2><p>Prototype 이란 사전적 의미는 <strong>원형, 원본</strong> 이다. 그럼 Prototype 기반의 프로그래밍은 무엇일까? Javascript에서 어디에 쓰는 개념인고…?<br>일단 이전 포스트인 <a href="/2020/11/02/js-oop-2/">Javascript와 객체 지향 프로그래밍 - 객체 지향 프로그래밍(OOP)</a>에서 언급한 <strong>Class</strong>에 대해 복기해보면 객체 지향 프로그래밍을 구현하기 위해 추상화된 속성과 메서드를 Class 라는 하나의 틀(template)을 정의하고, 클래스에 의해 생성된 새로운 객체(object)를 클래스의 <strong>인스턴스</strong>라고 부르며 클래스의 속성과 메서드를 그대로 상속받아 OOP의 기법인 캡슐화와 은닉화, 추상화, 상속성과 다형성의 개념을 구현할 수 있다.</p><p>위와 같은 Class의 개념이 Javascript에서는 <strong>Prototype</strong> 이다. 즉, 프로토타입 기반 프로그래밍이란 객체의 원형인 프로토타입을 이용해 새로운 객체를 만들어내는 프로그래밍 기법으로, 새롭게 생성된 객체는 자기 자신의 원형(Prototype)을 가지며 원형의 속성과 메서드를 상속받거나 확장할 수 있다.</p><h2 id="객체-생성법"><a href="#객체-생성법" class="headerlink" title="객체 생성법"></a>객체 생성법</h2><p>Javascript에서 객체를 생성하는 방법은 총 3가지로 객체 리터럴, Object 생성자 함수, 생성자 함수가 있으며 Javascript에서는 <code>new</code> 연산자와 함께 생성자 함수를 사용해 인스턴스 객체를 생성할 수 있다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">var obj &#x3D; &#123;</span><br><span class="line">  name : &#39;BKJang&#39;,</span><br><span class="line">  job : &#39;Developer&#39;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Object 생성자 함수</span><br><span class="line">var obj &#x3D; new Object();</span><br><span class="line">obj.name &#x3D; &#39;BKJang&#39;;</span><br><span class="line">obj.job &#x3D; &#39;Developer&#39;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 생성자 함수</span><br><span class="line">function Person(name, job) &#123;</span><br><span class="line">  this.name &#x3D; name;</span><br><span class="line">  this.job &#x3D; job;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 인스턴스 생성</span><br><span class="line">var obj &#x3D; new Person(&#39;BKJang&#39;, &#39;Developer&#39;);</span><br></pre></td></tr></table></figure><h3 id="생성자-함수와-new-연산자"><a href="#생성자-함수와-new-연산자" class="headerlink" title="생성자 함수와 new 연산자"></a>생성자 함수와 new 연산자</h3><p>생성자 함수란 객체 인스터스를 생성하는 함수로, 선언된 일반 함수를 <code>new</code> 키워드와 함께 호출 및 실행하는 함수로, Javascript에서는 두 가지 타입의 생성자 함수가 존재합니다.</p><ul><li><code>Array</code>와 <code>Object</code> 와 같은 내장 생성자 함수: 런타임 환경의 실행 컨텍스트 환경에서 자동으로 사용 가능</li><li>커스텀 생성자 함수: 객체 타입으로 프로퍼티와 메서드 정의</li></ul><p>객체 생성을 위해 우리가 사용할 생성자 함수 타입은 두번째로, 위에서 객체 생성 방법 중 굳이 생성자 함수를 사용하는 이유는 동일한 프로퍼티와 메서드를 갖는 복수의 객체를 생성할때 객체 리터럴 방식보다 유용하기 때문이며 객체 인스턴스를 생성할때 생성자 함수의 <code>this</code> 가 반환되면서 인스턴스 각자의 실행 컨텍스트를 갖게 되어 독립적 실행환경을 유지할 수 있기 때문입니다.</p><h4 id="new-연산자"><a href="#new-연산자" class="headerlink" title="new 연산자"></a>new 연산자</h4><p>Javascript에서 <code>new</code> 연산자는 사용자 정의 객체 타입 또는 내장 객체 타입의 인스턴스를 생성할때 사용되며 아래와 같은 문법을 따릅니다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">new constructor[([arguments])]</span><br></pre></td></tr></table></figure><ul><li>constructor: 객체 인스턴스의 타입을 기술 또는 명세하는 함수</li><li>arguments: constructor와 함께 호출될 값 목록</li></ul><h4 id="생성자-함수와-함께-new-연산자를-사용하면…"><a href="#생성자-함수와-함께-new-연산자를-사용하면…" class="headerlink" title="생성자 함수와 함께 new 연산자를 사용하면…"></a>생성자 함수와 함께 <code>new</code> 연산자를 사용하면…</h4><p>생성자 함수와 함께 <code>new</code> 연산자를 사용하면 아래의 단계를 거쳐 객체 인스턴스가 생성됩니다.</p><ol><li>비어있는 객체(<code>&#123;&#125;</code>)를 만듭니다.</li><li>생성자 함수의 <code>Prototype Object</code>에 연결된 새 객체(<code>__proto__</code>)를 프로퍼티에 추가합니다.<ul><li>따라서, <code>new</code> 연산자를 사용함으로써 생성자 함수 prototype에 추가된 프로퍼티와 객체는 생성자 함수에 의해 생성된 모든 인스턴스에서 접근가능(accessible)하다.</li></ul></li><li>새롭게 생성된 객체 인스턴스를 <code>this</code> 컨텍스트로 바인딩한다.<ul><li>i.e.) 생성자 함수에서 <code>this</code>에 대한 모든 참고는 현재 첫번째 단계에서 생성된 객체를 참고한다.</li></ul></li><li>만약 함수가 객체를 반환하지 않는다면 <code>this</code>를 반환한다.</li></ol><h4 id="사용자-정의-객체를-생성하기-위해서는…"><a href="#사용자-정의-객체를-생성하기-위해서는…" class="headerlink" title="사용자 정의 객체를 생성하기 위해서는…"></a>사용자 정의 객체를 생성하기 위해서는…</h4><p>사용자 정의 객체를 생성하기 위해서는 총 2개의 과정이 필요합니다.</p><ol><li>이름과 속성을 가진 함수를 작성함으로써 객체 타입을 정의한다.</li><li><code>new</code> 연산자와 함께 객체의 인스턴스를 생성한다.</li></ol><h5 id="예제-및-실행문맥-분석-parsing"><a href="#예제-및-실행문맥-분석-parsing" class="headerlink" title="예제 및 실행문맥 분석 (parsing)"></a>예제 및 실행문맥 분석 (parsing)</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 1. 생성자 함수 정의</span><br><span class="line">function Car(make, model, year) &#123;</span><br><span class="line">  this.make &#x3D; make;</span><br><span class="line">  this.model &#x3D; model;</span><br><span class="line">  this.year &#x3D; year;</span><br><span class="line">  this.introduce &#x3D; function () &#123;</span><br><span class="line">    console.log(&#96;This Car&#39;s Model is $&#123;this.model&#125; made by $&#123;this.make&#125; in $&#123;this.year&#125;&#96;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 2. 객체 인스턴스 생성</span><br><span class="line">var myCar &#x3D; new Car(&#39;Eagle&#39;, &#39;Talon TSi&#39;, 1993);</span><br><span class="line">myCar.make</span><br><span class="line">&gt; &quot;Eagle&quot;</span><br><span class="line">myCar.introduce()</span><br><span class="line">&gt; &quot;This Car&#39;s Model is &#39;Talon TSi&#39; made by &#39;Eagle in 1993&quot;</span><br></pre></td></tr></table></figure><p><code>new Car(...)</code>를 실행하면 </p><ol><li><code>Car.prototype</code> 으로부터 상속된 새로운 객체(인스턴스)가 생성된다.</li><li><code>make</code>, <code>model</code>, <code>year</code> 인자와 함께 생성자 함수 <code>Car</code>가 호출되며 새롭게 생성된 객체에 <code>this</code>가 바인딩 됩니다. <code>new Car</code>는 <code>new Car()</code>와 동일하고, 예를 들어 인자가 지정되지 않았다면 인자 없이 <code>Car</code>를 호출합니다.<br>3, 생성자 함수에 의해 반환된 객체는 전체 <code>new</code> 표현식의 결과입니다. 만약 생성자 함수가 객체를 반환하지 않는다면, 1 단계에서 생성된 객체가 대신 사용됩니다. (일반적으로 생성자 함수는 값(value)를 반환하지 않으나 만약 객체 생성 과정을 재정의(overide)하려는 경우 그렇게 할 수도 있습니다)</li></ol><p>위와 같이 동일한 프로퍼티 또는 멤버와 메서드를 같는 객체를 효율적으로 생성할 수 있는 방법이 <strong>생성자 함수</strong>이다. 인스턴스가 생성되면 각 인스턴스는 <code>make</code>, <code>model</code>, <code>year</code>라는 프로퍼티와 <code>introduce</code>와 같은 메서드를 동일하게 갖게 된다. 즉, 인스턴스가 생성될 때마다 동일한 프로퍼티와 메서드가 계속 생성되는 것이다. 필요한 만큼. 만약 인스턴스가 매우 많아지거나 각 사이즈가 늘어난다면 <strong><em>메모리를 낭비하게 되는 구조가 된다.</em></strong> 이를 해결하기 위해 개념이 바로 <strong>Prototype 기반의 객체지향 프로그래밍</strong> 이다. </p><p><strong><em>prototype에 대해 공부해본 후 생성자 함수 <code>Car</code>를 수정하고 확장해보자.</em></strong></p><h2 id="Javascript에서-Prototype이란"><a href="#Javascript에서-Prototype이란" class="headerlink" title="Javascript에서 Prototype이란?"></a>Javascript에서 Prototype이란?</h2><p>먼저, 프로토타입 기반 프로그래밍에 대해 다시 복기해보면, 아래와 같이 정의했었다.</p><blockquote><p>프로토타입 기반 프로그래밍이란 객체의 원형인 프로토타입 객체를 이용해 새로운 객체를 만들어내는 프로그래밍 기법으로, 새롭게 생성된 객체는 자기 자신의 원형(prototype)을 가지며 원형의 프로퍼티와 메서드를 상속받거나 확장할 수 있다.</p></blockquote><p>그리고 <strong>생성자 함수와 new 연산자 섹션</strong>의 2번에서 우리는<br>생성자 함수와 <code>new</code> 연산자를 통해 인스턴스를 생성했을때, 생성자 함수의 <code>Prototype Object</code>에 연결된 새 객체(<code>__proto__</code>)를 프로퍼티에 추가한다는 것을 배웠다. 따라서, 생성자 함수에 추가된 속성과 객체는 생성자 함수에 의해 생성된 모든 인스턴스에서 접근 가능(accessible)하게 해주며 Javascript에서 OOP의 개념이 가능하게 해준다.</p><p>어떻게 이게 가능할까?</p><p>Javascript에는 아래와 같이 크게 2가지 개념의 <strong>protoype</strong> 이 존재하며 이는 Javascript의 함수와 객체에 대한 내부 구조를 더 살펴봐야 한다.</p><ul><li>함수의 <strong>prototype</strong> 프로퍼티가 가리키고 있는 <code>Prototype Object</code></li><li><strong>자기 자신을 만들어낸 인스턴스 객체의 원형</strong>을 의미하는 <code>Prototype Link</code></li></ul><h3 id="함수와-객체의-구조"><a href="#함수와-객체의-구조" class="headerlink" title="함수와 객체의 구조"></a>함수와 객체의 구조</h3><p>Javascript의 모든 객체는 생성과 동시에 정의된 프로퍼티와 메서드를 가진 <strong>프로토타입 객체(Prototype Object)</strong> 라는 새로운 객체를 복제(Cloning)하여 만드는데 함수의 경우에도 객체 타입으로써 정의 및 분석(parsing) 단계에서 함수 내부에 <code>prototype</code> 프로퍼티를 추가한 후 복제된  <strong>프로토타입 객체(Prototype Object)</strong> 를 참조하도록 한다. 또한, <strong>프로토타입 객체(Prototype Object)</strong> 는 <code>constructor</code> 프로퍼티를 갖는 구조로써, 이는 함수를 참조하는 구조를 갖는다.</p><p>단계를 나열하면 아래와 같다.</p><ol><li>생성자 함수 <code>function Car (make, model, year)</code> 정의 및 <code>prototype</code> 프로퍼티 추가</li><li>생성자 함수 <code>Car</code>의 원형인 <strong>프로토타입 객체(Prototype Object) - Car Prototype Object</strong> 생성 및 <code>constructor</code> 프로퍼티 추가</li><li>생성자 함수 <code>Car</code>의 <code>prototype</code> 프로퍼티는 <code>Car Prototype Object</code> 참조</li><li><strong>Car Prototype Object</strong>의 <code>constructor</code>는 생성자 함수 <code>Car</code> 참조</li></ol><p><img src="/images/protoype_exam_graph.png" alt="생성자 함수와 인스턴스 그리고 Prototype Object의 관계도"></p><p>즉, <strong>Car Prototype Object</strong>는 <code>new</code> 연산자와 생성자 함수에 의해 생성될 새로운 인스턴스가 참조할 <strong>원형 객체(Prototype Object)</strong> 이다. 또한 생성된 인스턴스는 아래와 같은 구조를 갖는데 예를 들어, <strong>myCar</strong> 인스턴스는 생성자 함수를 참조한 프로퍼티 이외에 <code>__proto__</code> 프로퍼티를 가지고 있는데 바로 이 프로퍼티가 <strong>myCar</strong> 라는 객체를 만들어내기 위해 사용된 <em>프로토타입 객체 (Car protototype object)에 대한 숨겨진 연결</em> 이며 이를 <code>Prototype Link</code>라고 한다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 인스턴스 &#96;myCar&#96;</span><br><span class="line">myCar &#123;</span><br><span class="line">  introduce: ƒ ()</span><br><span class="line">  make: &quot;Eagle&quot;</span><br><span class="line">  model: &quot;Talon TSi&quot;</span><br><span class="line">  year: 1993</span><br><span class="line">  __proto__: &#123;</span><br><span class="line">    constructor: ƒ Car(make, model, year)</span><br><span class="line">    __proto__: Object</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 인스턴스의 __proto__의 생성자와 생성자 함수의 prototype 프로퍼티의 생성자 비교</span><br><span class="line">myCar.__proto__.constructor &#x3D;&#x3D;&#x3D; Car.prototype.constructor</span><br><span class="line">&gt; true</span><br></pre></td></tr></table></figure><p>예시를 기반으로 생성자 함수, 인스턴스 그리고 <strong>프로토타입 객체(Prototype Object)</strong> 에 대해 정리해보면,</p><ul><li><code>constructor</code>는 생성자 함수 본인이고,</li><li><code>prototype</code>은 생성자 함수에 정의한 모든 객체가 공유할 원형으로 <strong>하위로 물려줄 연결에 대한 속성</strong></li><li><code>__proto__</code>는 생성자 함수를 new로 호출할 때, 정의해두었던 <code>prototype</code>을 참조한 객체로서 <strong>상위에서 물려받은 객체의 프로토타입에 대한 정보</strong></li><li><code>prototype</code>은 생성자 함수에 사용자가 직접 넣는 거고, <code>__proto__</code>는 new를 호출할 때 <code>prototype</code>을 참조하여 자동으로 만들어짐</li><li>생성자에는 <code>prototype</code>, 생성자로부터 만들어진 객체에는 <code>__proto__</code></li></ul><h3 id="Prototype-Chain-프로토타입-체인"><a href="#Prototype-Chain-프로토타입-체인" class="headerlink" title="Prototype Chain (프로토타입 체인)"></a>Prototype Chain (프로토타입 체인)</h3><p>우리는 <strong>프로토타입 객체(Prototype Object)</strong> 와 <strong>프로토타입 링크(Prototype Link)</strong> 에 대해 살펴봤습니다. 생성자 함수의 <code>prototype</code> 프로퍼티가 함수의 프로토타입 객체(Prototype Object)를 참고하고 있으며 <code>new</code> 연산자와 생성자 함수에 의해 생성한 인스턴스는 <code>__proto__</code> 프로퍼티를 통해서 함수 객체의 원형을 참조하고 있음을 알 수 있었다. 따라서 생성된 인스턴스들은 생성자 함수의 <strong>프로토타입 객체(Prototype Object)</strong> 을 계속 주시하고 있으며 생성자 함수의 <code>prototype</code> 프로퍼티에 프로퍼티 또는 메서드를 추가할 경우 <strong>프로토타입 링크(Prototype Link)</strong> 의 관계인 인스턴스도 이를 공유받아 추가된 속성들을 활용할 수 있습니다. 이는 그 어떠한 상위 프로토타입 객체도 마찬가지입니다. 이러한 개념이 바로 <strong>프로토타입 체인(prototype chain)</strong> 이고 다른 객체에 정의된 메소드와 속성을 한 객체에서 사용할 수 있도록 하는 원리입니다.</p><p>정확히 말하자면 상속되는 속성과 메소드들은 각 객체가 아니라 객체(인스턴스) 생성자의 <code>prototype</code> 이라는 속성에 정의되어 있습니다.</p><p>그리고 위와 같이 객체 인스턴스와 프로토타입 객체 간에 연결을 생성자 함수의 <code>prototype</code> 프로퍼티와 인스턴스 객체의  <code>__proto__</code> 프로터리를 통해 구성하고 있으며 이 연결을 따라 타고 올라가며 속성과 메소드를 탐색하는 것을 <strong>프로토타입 체인(Prototype Chain)</strong> 이라고 정리할 수 있습니다.</p><p>아래 코드는 프로토타입 체인을 설명하기 위한 예시입니다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; #예제 1.</span><br><span class="line">function exam1 () &#123;</span><br><span class="line">  this.x &#x3D; function () &#123;</span><br><span class="line">    console.log(&#39;hello&#39;);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br><span class="line">exam1.x&#x3D;function() &#123;</span><br><span class="line">    console.log(&#39;world&#39;);</span><br><span class="line">&#125;;</span><br><span class="line">var exam1A &#x3D; new A();</span><br><span class="line">var exam1B &#x3D; new A();</span><br><span class="line">exam1A.x();</span><br><span class="line">&gt; hello</span><br><span class="line">exam1B.x();</span><br><span class="line">&gt; hello</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; #예제 2.</span><br><span class="line">var exam2 &#x3D; function () &#123; &#125;;</span><br><span class="line">exam2.x&#x3D;function() &#123;</span><br><span class="line">  console.log(&#39;hello&#39;);</span><br><span class="line">&#125;;</span><br><span class="line">exam2.prototype.x &#x3D; function () &#123;</span><br><span class="line">  console.log(&#39;world&#39;);</span><br><span class="line">&#125;;</span><br><span class="line">var exam2A &#x3D; new exam2();</span><br><span class="line">var exam2B &#x3D; new exam2();</span><br><span class="line">exam2A.x();</span><br><span class="line">&gt; world</span><br><span class="line">exam2B.x();</span><br><span class="line">&gt; world</span><br></pre></td></tr></table></figure><p><strong>프로토타입 객체</strong>와 <strong>프로토타입 링크</strong> 에 대해 잘 이해했다면, ‘#예제1’에서 메서드 메서드 <code>x</code>의 수정이 즉시 반영되지 않는 이유를 금방 눈치챌 수 있을 것입니다. 힌트는 바로 <em>생성자 함수 객체의 메서드를 어디에서 수정했냐</em> 이다. 생성자 함수와 객체 인스턴스는 <strong>프로토타입 객체(Prototype Object)</strong> 와 연결되어 있으며 생성자 함수 내 메서드의 추가, 변경, 삭제 등의 내부 속성의 변경상태를 공유하기 위해서는 ‘#예제2’ 와 같이 생성자 함수의 <code>prototype</code> 프로퍼티를 통해 정의 및 수정해야 한다.  <strong>#예제1</strong> 의 <code>exam1.x=function () &#123; ~ &#125;</code> 와 같은 수정은 단지 생성자 함수 객체의 메서드를 변경한 것 뿐이다.</p><h3 id="잊고-있던-예제를-개선해보자"><a href="#잊고-있던-예제를-개선해보자" class="headerlink" title="잊고 있던 예제를 개선해보자."></a>잊고 있던 예제를 개선해보자.</h3><p>Javascript의 <code>prototype</code>에 대해 공부하면서 잊고 있었던 <code>Car</code> 생성자 함수의 <strong>introduce</strong> 메서드 할당을 개선해보자.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 1. 생성자 함수 정의</span><br><span class="line">function Car(make, model, year) &#123;</span><br><span class="line">  this.make &#x3D; make;</span><br><span class="line">  this.model &#x3D; model;</span><br><span class="line">  this.year &#x3D; year;</span><br><span class="line">  &#x2F;&#x2F; this.introduce &#x3D; function () &#123;</span><br><span class="line">  &#x2F;&#x2F;   console.log(&#96;This Car&#39;s Model is $&#123;this.model&#125; made by $&#123;this.make&#125; in $&#123;this.year&#125;&#96;)</span><br><span class="line">  &#x2F;&#x2F; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 2. &#96;introduce&#96; 메서드를 &#96;Car&#96; 함수의 prototype 속성에 추가</span><br><span class="line">Car.prototype.introduce &#x3D; function () &#123;</span><br><span class="line">  console.log(&#96;This Car&#39;s Model is $&#123;this.model&#125; made by $&#123;this.make&#125; in $&#123;this.year&#125;&#96;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 3. 인스턴스 생성</span><br><span class="line">var myCar &#x3D; new Car(&#39;Eagle&#39;, &#39;Talon TSi&#39;, 1993);</span><br><span class="line">myCar.make</span><br><span class="line">&gt; &quot;Eagle&quot;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 4. 인스턴스에서 &#96;introduce&#96; 메서드 호출</span><br><span class="line">myCar.introduce()</span><br><span class="line">&gt; &quot;This Car&#39;s Model is &#39;Talon TSi&#39; made by &#39;Eagle in 1993&quot;</span><br></pre></td></tr></table></figure><p>위와 같이 생성자 함수의 내부에 메서드를 할당하는 대신 <code>prototype</code> 프로퍼티에 메서드를 할당해줌으로써 <code>Car Prototype Object</code> 또한 참조 받으며 생성된 인스턴스 객체들 또한 <strong>Prototype Link</strong> 속성으로 추가된 메서드 또는 프로퍼티를 공유받아 생성 이후에 할당된 기능들도 실행시킬 수 있게 된다.</p><h2 id="마치며"><a href="#마치며" class="headerlink" title="마치며"></a>마치며</h2><p>Prototype에 대해 학습하면서 몇몇 부분에서 제대로 이해되지 않아 디테일한 부분까지 찾아보다보니 많은 블로그를 찾아보았고 많은 시간을 소모했다고 느꼈지만 끝나고나니 이제서야 왜 Javascript에서 Prototype 기반의 프로그래밍이 중요하고 OOP를 구현하기 위한 기반이라고 했는지 이해하게 되었다.</p><p>다음 포스트 주제로는 prototype의 상속에 대해 다뤄보겠습니다.</p><hr><h2 id="참고"><a href="#참고" class="headerlink" title="참고"></a>참고</h2><ul><li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/new#object_property_that_is_itself_another_object">new Operator</a></li><li><a href="https://ko.javascript.info/constructor-new">‘new’ 연산자와 생성자 함수</a></li><li><a href="https://bamdule.tistory.com/196">[javascript] new 연산자와 생성자 함수</a></li><li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/new">new operator</a></li><li><a href="https://oneroomtable.tistory.com/entry/%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8-%EA%B0%9D%EC%B2%B4-%EC%83%9D%EC%84%B1%EC%9E%90-%ED%95%A8%EC%88%98%EB%9E%80">자바스크립트 객체 생성자 함수란?</a></li><li><a href="http://insanehong.kr/post/javascript-prototype/">Javascript 기초 - Object prototype 이해하기</a></li><li><a href="https://www.nextree.co.kr/p7323/">Javascript: 프로토타입 (prototype) 이해</a></li><li><a href="https://www.zerocho.com/category/JavaScript/post/573c2acf91575c17008ad2fc">객체 지향 프로그래밍(생성자와 프로토타입)</a></li><li><a href="https://medium.com/@bluesh55/javascript-prototype-%EC%9D%B4%ED%95%B4%ED%95%98%EA%B8%B0-f8e67c286b67">[Javascript ] 프로토타입 이해하기</a></li><li><a href="https://webclub.tistory.com/158?category=501048">자바스크립트는 프로토타입 기반의 객체지향 프로그래밍 언어이다.</a></li><li><a href="https://webclub.tistory.com/301?category=501048">함수의 프로토타입 - prototype</a></li><li><a href="https://poiemaweb.com/js-object-oriented-programming">자바스크립트 객체지향 프로그래밍</a></li><li><a href="https://developer.mozilla.org/ko/docs/Learn/JavaScript/Objects/Object_prototypes">Object prototypes</a></li><li><a href="https://developer.mozilla.org/ko/docs/Learn/JavaScript/Objects/Inheritance">Inheritance in JavaScript</a></li><li><a href="https://medium.com/javascript-scene/common-misconceptions-about-inheritance-in-javascript-d5d9bab29b0a">Common Misconceptions About Inheritance in JavaScript</a></li><li><a href="https://bkdevlog.netlify.app/posts/oop-class-of-js">[JavaScript] 8-1. 객체지향 프로그래밍(클래스 vs 프로토타입)</a></li><li><a href="https://bkdevlog.netlify.app/posts/oop-inheritance-of-js">[JavaScript] 8-2. 객체지향 프로그래밍(상속)</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;/images/js_with_prototype.png&quot; alt=&quot;Javascript&quot;&gt;&lt;/p&gt;
&lt;p&gt;지난 포스트인 &lt;a href=&quot;/2020/11/02/js-oop-2/&quot;&gt;Javascript와 객체 지향 프로그래밍 - 객체 지향</summary>
      
    
    
    
    <category term="Programming" scheme="https://joontae-kim.github.io/categories/Programming/"/>
    
    <category term="Javascript" scheme="https://joontae-kim.github.io/categories/Programming/Javascript/"/>
    
    
    <category term="javascript" scheme="https://joontae-kim.github.io/tags/javascript/"/>
    
    <category term="oop" scheme="https://joontae-kim.github.io/tags/oop/"/>
    
    <category term="prototype" scheme="https://joontae-kim.github.io/tags/prototype/"/>
    
    <category term="object" scheme="https://joontae-kim.github.io/tags/object/"/>
    
    <category term="프로토타입" scheme="https://joontae-kim.github.io/tags/%ED%94%84%EB%A1%9C%ED%86%A0%ED%83%80%EC%9E%85/"/>
    
    <category term="new" scheme="https://joontae-kim.github.io/tags/new/"/>
    
    <category term="contructor" scheme="https://joontae-kim.github.io/tags/contructor/"/>
    
    <category term="new 생성자" scheme="https://joontae-kim.github.io/tags/new-%EC%83%9D%EC%84%B1%EC%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>알고리즘 시리즈 - 시작</title>
    <link href="https://joontae-kim.github.io/2021/04/04/algorithm/"/>
    <id>https://joontae-kim.github.io/2021/04/04/algorithm/</id>
    <published>2021-04-04T09:06:15.000Z</published>
    <updated>2021-04-15T16:41:01.660Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/algorithm.png" alt="알고리즘"></p><p>알고리즘을 공부하기 위해 책과 자료들을 수집해 보고 공부하기만 해서 정리하는 느낌으로 알고리즘 시리즈를 연재해보려고 합니다.</p><h2 id="알고리즘에-대한-갈증"><a href="#알고리즘에-대한-갈증" class="headerlink" title="알고리즘에 대한 갈증"></a>알고리즘에 대한 갈증</h2><p>알고리즘에 대한 필요성은 <a href="https://clippler-9d22e.web.app/">클립플러</a>를 개발하면서 강하게 느꼈다. 클립플러의 일부 기능 중 clip으로 만들 사이트의 메타태그를 긁어와 유효한 태그를 추천하는 기능을 설계하는데 가장 큰 문제에 봉착했었다. 바로 코딩. 분명 팩토리얼로 단어의 조합을 만들면 된다는 생각은 있는데 팩토리얼 알고리즘 맞는지 그리고 어떻게 구현하는지 까마득했다;;; 그러다 잠시 개발은 중단하고 알고리즘에 대한 기초중의 기초와 중간을 건너띄고 팩토리얼 알고리즘에 대해 공부했다. 기능개발은 했지만 리팩토링은 물론 성능분석도 거의 하지 못했다. 그러다 조언을 구하면 더 나은 코드 설계와 개발실력을 갖추기 위해서는 알고리즘 공부가 도움이 많이 되고, 나중에 취업을 할때에도 도움이 많이 될거라고 했는데… 그렇게 모두의 충고를 과소평가하고 드문드문 보기만 했다;;; 그러다보니 알고리즘에 대한 베이스가 약하고, 코딩 테스트를 보더라도 쉬운 문제까지가 한계였다.</p><p>그래서 이번 기회에 알고리즘에 대한 숙제를 시리즈로 연재해보려고 마음 먹었다. 다시 시작하는 마음으로 꼬박꼬박 정리해가면서 다음에 봐도 공부할만한 자료가 될때까지.</p><p>먼저 알고리즘에 대해 간략하게 다룬 후 연재를 어떤 방향으로 할지 논해보려고 한다.</p><h2 id="알고리즘이란"><a href="#알고리즘이란" class="headerlink" title="알고리즘이란?"></a>알고리즘이란?</h2><p>우리는 이미 알고리즘에 익숙해져있다. 다만, 그러한 것들을 ‘알고리즘’이라고 부르지 않을뿐. 이를테면,</p><ul><li>가장 빠른 또는 편한 출근길 또는 퇴근길 경로 탐색</li><li>오늘 치킨을 먹을것인가, 주중에 먹을것인가에 대한 기회비용 탐색</li><li>한정된 금액 안에서 장보기</li></ul><p>위와 같은 과정 모두 알고리즘이라고 할 수 있으며, <strong>특정 문제를 해결하기 위한 일련의 계산과정</strong>으로 <em>입력, 출력 그리고 계산과정</em> 이 존재한다.</p><p>프로그래밍에서 알고리즘이란 필수적인 것은 아니지만 더 효율적이고 효과적인 방법으로 어떤 결과값(출력)을 만들어낼 수 있는 과학적 접근법으로, 어떤 알고리즘으로 과정을 설계하느냐에 따라 결과가 동일하더라도 프로그램의 속도나 처리방식 등이 크게 차이나는 경우도 있다.</p><h2 id="알고리즘의-조건"><a href="#알고리즘의-조건" class="headerlink" title="알고리즘의 조건"></a>알고리즘의 조건</h2><p>알고리즘은 다음의 조건을 만족해야 한다.</p><ul><li>입력: 외부에서 제공되는 자료가 0개 이상 존재한다.</li><li>출력: 적어도 2개 이상의 서로 다른 결과를 내어야 한다.(즉 모든 입력에 하나의 출력이 나오면 안됨)</li><li>명확성: 수행 과정은 명확하고 모호하지 않은 명령어로 구성되어야 한다.</li><li>유한성(종결성): 유한 번의 명령어를 수행 후(유한 시간 내)에 종료한다.</li><li>효율성: 모든 과정은 명백하게 실행 가능(검증 가능)한 것이어야 한다.</li></ul><h2 id="좋은-알고리즘이란-분석-기준"><a href="#좋은-알고리즘이란-분석-기준" class="headerlink" title="좋은 알고리즘이란? 분석 기준."></a>좋은 알고리즘이란? 분석 기준.</h2><ul><li>정확성 : 적당한 입력에 대해서 유한 시간내에 올바른 답을 산출하는가를 판단.</li><li>작업량 : 전체 알고리즘에서 수행되는 가장 중요한 연산들만으로 작업량을 측정. 해결하고자 하는 문제의 중요 연산이 여러개인 경우에는 각각의 중요 연산들의 합으로 간주하거나 중요 연산들에 가중치를 두어 계산</li><li>최적성 :그 알고리즘보다 더 적은 연산을 수행하는 알고리즘은 없는가? 최적이란 가장 ‘잘 - 알려진’ 이 아니라 ‘가장 좋은’의 의미이다</li><li>시간 복잡도 (Big-O Notation), (<em>이 부분에 대해서는 연재물로 따로 다루겠습니다.</em>)</li><li>기억 장소 사용량 (공간 복잡도) : 수행에 필요한 저장 공간</li></ul><h2 id="알고리즘-설계-순서"><a href="#알고리즘-설계-순서" class="headerlink" title="알고리즘 설계 순서"></a>알고리즘 설계 순서</h2><ul><li><em>from <a href="https://velog.io/@leobit/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98Algorithm">leobit님 블로그 - 알고리즘</a></em></li><li>일반적인 알고리즘 순서<ol><li>문제 정의</li><li>모델 고안</li><li>명세 작성</li><li>설계</li><li>검증</li><li>분석(복잡도 등)</li><li>구현</li><li>테스트</li><li>문서화</li></ol></li></ul><ul><li>자연어 ↔ 프로그래밍 언어 사이의 방식을 단계별로 기록<ol><li>프로그램의 진행 과정에 조금이라도 관심이 있는 사람이라면, 이 의사 코드를 읽고 이해할 수 있을까?</li><li>이 의사 코드는 실제 코드로 쉽게 바뀔 수 있을까?</li><li>과정을 진행하는데 필요한 단계 중, 빠뜨린 것은 없나?</li><li>의사 코드를 읽는 사람들이 이해할 수 있는 용어들을 사용했는가?</li></ol></li></ul><h2 id="알고리즘과-함께-논하는-개념들"><a href="#알고리즘과-함께-논하는-개념들" class="headerlink" title="알고리즘과 함께 논하는 개념들"></a>알고리즘과 함께 논하는 개념들</h2><ul><li>시간 복잡도</li><li>자료구조</li><li>정렬</li></ul><p>알고리즘 공부를 준비함과 동시에 취업 및 면접에 대한 자료를 찾고 읽으면서 가장 많이 언급된 것들로 시간 복잡도에 대한 정확한 이해와 각 알고리즘에 대한 시간 복잡도 특성에 대해 암기수준으로 준비를 한다면 면접에서 많은 점수를 딸수 있다고 했습니다. 그리고 자료구조와 정렬의 경우도 마찬가지이다. 알고리즘과 뗄 수 없는 관계이며 각 알고리즘에 맞는 자료구조와 <strong>어떤 특징</strong>을 가지고 있으며 <strong>왜 사용하는지</strong> 를 알고 있다면 이 또한 (많은) 점수를 얻을 수 있다고 합니다.</p><h2 id="연재-계획"><a href="#연재-계획" class="headerlink" title="연재 계획"></a>연재 계획</h2><p>앞으로 다룰 주제는 <strong><em>알고리즘과 함께 논하는 개념들</em></strong> 순서로 연재할 것이며 중간중간 문제를 풀어보며 되새김질을 빙자한 복습을 이어가려고 합니다.</p><h2 id="주워-들은-팁"><a href="#주워-들은-팁" class="headerlink" title="주워 들은 팁"></a>주워 들은 팁</h2><p>이 부분은 <a href="https://blog.yena.io/studynote/2018/11/14/Algorithm-Basic.html">yena님의 알고리즘 포스팅</a>에서 보고 나 또한 상기하는 목적에서 복붙해왔습니다.</p><blockquote><p>많은 사람들이 공통적으로 얘기하는 사실들이 있다.</p><ul><li>처음부터 어려운 걸 하려고 하지 말고, 간단한 것부터 시작하자.</li><li>선택한 언어의 문법과 클래스를 잘 파악하자.</li><li>풀고 난 후 다른 사람의 풀이 참고하자.</li><li>경험이 쌓이면 익숙해진다. 조급해하지 말자.</li></ul></blockquote><p><em>(보실지는 모르겠지만 yena님 감사합니다.)</em></p><hr><h2 id="참조"><a href="#참조" class="headerlink" title="참조"></a>참조</h2><ul><li><a href="https://blog.yena.io/studynote/2018/11/14/Algorithm-Basic.html">[Algorithm] 알고리즘 공부 시작 방법 및 순서</a></li><li><a href="https://ko.wikipedia.org/wiki/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98">알고리즘</a></li><li><a href="https://opentutorials.org/course/2471/13912">프로그래밍 입문 - 알고리즘의 정의</a></li><li><a href="https://wayhome25.github.io/cs/2017/04/17/cs-18/">강의노트 17. 알고리즘, 자료구조 개요</a></li><li><a href="https://librewiki.net/wiki/%EC%8B%9C%EB%A6%AC%EC%A6%88:%EC%88%98%ED%95%99%EC%9D%B8%EB%93%AF_%EA%B3%BC%ED%95%99%EC%95%84%EB%8B%8C_%EA%B3%B5%ED%95%99%EA%B0%99%EC%9D%80_%EC%BB%B4%ED%93%A8%ED%84%B0%EA%B3%BC%ED%95%99/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98_%EA%B8%B0%EC%B4%88">시리즈:수학인듯 과학아닌 공학같은 컴퓨터과학/알고리즘 기초</a></li><li>알고리즘(Algorithm)[<a href="https://velog.io/@leobit/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98Algorithm]">https://velog.io/@leobit/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98Algorithm]</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;/images/algorithm.png&quot; alt=&quot;알고리즘&quot;&gt;&lt;/p&gt;
&lt;p&gt;알고리즘을 공부하기 위해 책과 자료들을 수집해 보고 공부하기만 해서 정리하는 느낌으로 알고리즘 시리즈를 연재해보려고 합니다.&lt;/p&gt;
&lt;h2 id=&quot;알고리</summary>
      
    
    
    
    <category term="Programming" scheme="https://joontae-kim.github.io/categories/Programming/"/>
    
    <category term="Algorithm" scheme="https://joontae-kim.github.io/categories/Programming/Algorithm/"/>
    
    
    <category term="Algorithm" scheme="https://joontae-kim.github.io/tags/Algorithm/"/>
    
    <category term="알고리즘" scheme="https://joontae-kim.github.io/tags/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/"/>
    
  </entry>
  
  <entry>
    <title>Nuxt 라이프사이클</title>
    <link href="https://joontae-kim.github.io/2021/03/18/nuxt-lifecycle/"/>
    <id>https://joontae-kim.github.io/2021/03/18/nuxt-lifecycle/</id>
    <published>2021-03-18T07:35:59.000Z</published>
    <updated>2021-03-19T15:20:57.497Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/nuxt.png" alt="Nuxt.js"></p><p>Vue.js를 사용해 웹 어플리케이션 개발할때 라이프사이클에 대한 공부를 제대로 시작하지 고생한 경험이 있는데 Nuxt는 그런 과정을 밟지 않기위해 라이프사이클부터 차근차근 공부해보자. 일단 공식문서 번역과 아래 <strong>Nuxt Lifecycle HOOKS</strong> 이미지에 대한 내용에 대해 공부해보자.</p><h1 id="Nuxt-Lifecycle"><a href="#Nuxt-Lifecycle" class="headerlink" title="Nuxt Lifecycle"></a>Nuxt Lifecycle</h1><p><img src="https://nuxtjs.org/docs/2.x/nuxt-lifecycle.svg" alt="Nuxt Lifecycle"></p><p>여러분이 어떤 도구(tool)를 사용하든 그 도구의 서두(the hood)에 대해 잘 이해하고 있을때 더 자신있음을 느낄 것입니다. Nuxt.js도 해당됩니다. 이 챕터에서는 여러분에게 프레임워크의 실행순서와 어떻게 함께 작동하는지 서로 다른 부분에 대한 수준 높은 개요를 제공할 것입니다.</p><p>Nuxt.js 라이프사이클은 빌드 단계 이후에 무엇이 발생되는지, 여러분의 어플리케이션이 어디서 번들되고(bundled), 청크되고(chunked), 최소화(minified) 되는지 설명합니다. 이 단계 이후에 발생하는 것은 여러분이 서버사이드 렌더링(server-side rendering) 활성화 여부에 따라 다릅니다. 만약 여러분이 서버사이드 렌더링 사용한다면, 추가적으로 여러분이 선택한 서버사이드 렌더링의 유형에 따라 달라집니다.</p><p>Dynamic SSR (<code>nuxt start</code>) 또는 Static Site Generation (<code>nuxt generate</code>).</p><h2 id="Lifecycle"><a href="#Lifecycle" class="headerlink" title="Lifecycle"></a>Lifecycle</h2><h3 id="Server"><a href="#Server" class="headerlink" title="Server"></a>Server</h3><p>SSR을 위해서 아래의 단계가 여러분의 어플리케이션에서 모든 초기요청(request) 동안에 실행될 것입니다.</p><ul><li>서버 시작 <em>The server starts</em> (<code>nuxt start</code>)</li></ul><p>정적 사이트 생성모드를 사용하면, 서버 단계에서는 오직 빌드타임에만 실행되나 모든 페이지에 대해 단 한번만 실행될 것입니다.</p><ul><li>생성 프로세스 시작 (<code>nuxt generate</code>)</li><li>Nuxt hooks</li><li>serverMiddleware</li><li>Server-side Nuxt 플러그인(plugins)<ul><li>nuxt.config.js에 정의된 순서대로 <em>(in order as defined in nuxt.config.js)</em></li></ul></li><li>nuxtServerInit<ul><li><em>만약 Vuex store를 설정했다면 서버 사이드에서 요청되는 첫번째 생명주기 훅(lifecycle hook)이다</em></li><li>스토어(store)를 미리 채우기(pre-populate) 위해 서버 사이드에서 Vuex 호출한다.</li><li>첫번째 인자(argument)는 Vuex context, 두번째 인자는 Nuxt.js context 입니다.<ul><li>서버 사이드에서 연속적인 스토어 액션(action)을 위해 오직 “entry point”에서 다른 액션을 Dispatch 합니다.</li></ul></li><li>오직 <code>store/index.js</code>에 정의할 수 있습니다.</li></ul></li><li>미들웨어 (Middleware 또는 Route Middleware)<ul><li><em>페이지 컴포넌트가 렌더링되기 전에 호출됩니다.</em></li><li><em>조건을 설정하거나 체크할수도 있으며 페이지를 리다이렉트(redirect)하는데 사용할 수 있습니다.</em></li><li>전역 미들웨어(Global middleware) <em>- 모든 라우트에 영향을 끼치며, <strong>route.config.js</strong>에 정의합니다.</em></li><li>레이아웃 미들웨어(Layout middleware) <em>- 라우트 그룹에 영향을 끼치며, <strong>layout</strong>에 정의합니다.</em></li><li>페이지 미들웨어(Page middleware) <em>- 싱글 라우트에 영향을 끼치며, <strong>page component</strong>에 정의합니다.</em></li></ul></li><li><em>validate</em><ul><li><em>동적 라우트 파라미터(dynamic route parameter)를 검증하는데 유용합니다.</em></li><li><em>페이지 컴포넌트가 렌더링 되기 전에 호출됩니다.</em></li></ul></li><li>asyncData<ul><li><em>페이지 컴포넌트가 로딩되기 전에 매번 호출됩니다.</em></li><li><em>컴포넌트 <code>data</code> 프로퍼티와 병합(merge)됩니다.</em></li></ul></li><li>beforeCreate (Vue 라이크사이클 메서드)<ul><li><em>Vue 인스턴트(instance)가 초기화(initialized) 될때 호출됩니다.</em></li></ul></li><li>created (Vue 라이크사이클 메서드)</li><li>The new fetch (top to bottom, siblings = parallel)</li><li>상태의 일렬화(Serialization of state) (<code>render:routeContext</code> Nuxt.js hook)</li><li>HTML을 렌더링 할때 일어난다. (<code>render:route</code> Nuxt.js hook)</li><li><code>render:routeDone</code> 훅: HTML 파일을 브라우저로 보낼때 일어난다.</li><li><code>generate:before</code> Nuxt.js hook</li><li>HTML 파일들을 생성한다.<ul><li><strong>Full static generation</strong><ul><li>e.g. 정적 페이로드(static payloads)를 추출한다.</li></ul></li></ul></li><li><code>generate:page</code> (HTML 편집가능(editable))</li><li><code>generate:routeCreated</code> (Route가 생성된다.)</li><li><code>generate:done</code> 훅: 모든 HTML 파일들이 생성될때 일어난다.</li></ul><h3 id="Client"><a href="#Client" class="headerlink" title="Client"></a>Client</h3><p>여러분이 Nuxt.js의 어떤 모드를 선택하든, 이 부분은 라이프사이클 중에 완전히 브라우저에서 실행된다.</p><ul><li>HTML 파일을 받는다(Receives).</li><li>assets 로딩하기 (e.g. JavaScript)</li><li>Vue Hydration</li><li>미들웨어 (Middleware 또는 Route Middleware)<ul><li><em>페이지 컴포넌트가 렌더링되기 전에 호출됩니다.</em></li><li><em>조건을 설정하거나 체크할수도 있으며 페이지를 리다이렉트(redirect)하는데 사용할 수 있습니다.</em></li><li>전역 미들웨어(Global middleware) <em>- 모든 라우트에 영향을 끼치며, <strong>route.config.js</strong>에 정의합니다.</em></li><li>레이아웃 미들웨어(Layout middleware) <em>- 라우트 그룹에 영향을 끼치며, <strong>layout</strong>에 정의합니다.</em></li><li>페이지 미들웨어(Page middleware) <em>- 싱글 라우트에 영향을 끼치며, <strong>page component</strong>에 정의합니다.</em></li></ul></li><li>클라이언트 사이드(client-side) Nuxt.js 플러그인<ul><li>nuxt.config.js에 정의된 순서대로 <em>(in order as defined in nuxt.config.js)</em></li></ul></li><li>asyncData (비동기, blocking)<ul><li><em>페이지 컴포넌트가 로딩되기 전에 매번 호출됩니다.</em></li><li><em>컴포넌트 <code>data</code> 프로퍼티와 병합(merge)됩니다.</em></li></ul></li><li>beforeCreate (Vue 라이크사이클 메서드)<ul><li><em>Vue 인스턴트(instance)가 초기화(initialized) 될때 호출됩니다.</em></li></ul></li><li>created (Vue 라이크사이클 메서드)</li><li>The new fetch (top to bottom, siblings = parallel) (동기, non-blocking)</li><li>beforeMount (Vue 라이크사이클 메서드)</li><li>mounted (Vue 라이크사이클 메서드)</li></ul><h3 id="NuxtLink-컴포넌트-component-를-사용한-네비게이트-Navigate"><a href="#NuxtLink-컴포넌트-component-를-사용한-네비게이트-Navigate" class="headerlink" title="NuxtLink 컴포넌트(component)를 사용한 네비게이트(Navigate)"></a>NuxtLink 컴포넌트(component)를 사용한 네비게이트(Navigate)</h3><p>클라이언트 사이드 부분과 동일하게 브라우저에서 모든것이 발생하지만 오직 <code>&lt;NuxtLink&gt;</code>를 통해 네비게이팅 될때만 발생합니다.</p><blockquote><p><a href="https://nuxtjs.org/docs/2.x/features/nuxt-components#the-nuxtlink-component"><code>&lt;NuxtLink&gt;</code></a> 에 대한 더 자세한 정보는 컴포넌트 챕터에서 확인하세요</p></blockquote><ul><li>middleware (비동기, blocking)</li><li>전역 미들웨어(Global middleware)</li><li>레이아웃 미들웨어(Layout middleware)</li><li>라우트 미들웨어(Route middleware)</li><li>asyncData (비동기, blocking)</li><li>asyncData (비동기, blocking) [또는 완전히 정적 페이로드(static payload)가 로딩된 후]</li><li>beforeCreate &amp; created (Vue 라이크사이클 메서드)</li><li>fetch (동기, non-blocking)</li><li>beforeMount &amp; mounted</li></ul><h2 id="중간-정리"><a href="#중간-정리" class="headerlink" title="중간 정리"></a>중간 정리</h2><p>Nuxt의 라이프사이클은 전체적으로 서버와 클라이언트 사이드 부분으로 나뉘는 것을 알 수 있으며 각 부분에서 공통으로 실행되는 과정과 아닌 과정이 있음을 확인할 수 있었습니다. 또한, 정적 (Static) 어플리케이션를 만드느냐 SSR(Server-Side Rendering) 또는 유니버설(universal) 어플리케이션을 만드느냐에 따라 과정이 달라질 수 있다.</p><h2 id="추가-공부"><a href="#추가-공부" class="headerlink" title="추가 공부"></a>추가 공부</h2><p>라이프사이클에 대해 공부 및 정리하면서 봤던 내용들에 대해 정리해보자.</p><h3 id="1-활용도가-높고-중요한-몇가지-훅"><a href="#1-활용도가-높고-중요한-몇가지-훅" class="headerlink" title="1. 활용도가 높고 중요한 몇가지 훅"></a>1. 활용도가 높고 중요한 몇가지 훅</h3><ul><li>middleware(클라이언트, 서버)<ul><li>클라이언트와 서버 모두 훅들이 본격적으로 호출되기 전에, 앱을 만드는 과정에서 미리 정의해놓은 미들웨어들이 먼저 동작합니다.</li><li>만약 <code>serverMiddlware</code>을 정의했다면 서버 사이드에서만 렌더링 과정에서 일반 미들웨어가 동작하기 전에 먼저 동작합니다.</li></ul></li><li>asyncData(서버 or 클라이언트)<ul><li>서버 혹은 클라이언트 사이드에서 생명주기 통틀어 한번씩만 호출되는 훅입니다.</li><li>Vue 인스턴스의 생명주기 이전에 먼저 데이터를 가져와서 렌더링을 하고싶은 경우에 사용합니다.</li><li>컴포넌트를 로드하기 전에 항상 호출되며, 페이지 컴포넌트의 경우에만 사용할 수 있습니다.</li><li>asyncData 의 리턴값은 Vue 인스턴스의 data()와 병합됩니다.</li></ul></li><li>beforeCreated, created(클라이언트, 서버)<ul><li>서버에서 새로운 vue 인스턴스를 생성한 뒤 이를 프리랜더링 하기 때문에 Vue 인스턴스가 서버에서 만들어지는 시점에 created와 beforeCreated 훅이 호출됩니다.</li><li>또한 클라이언트에서도 인스턴스를 만들고 $mount 메소드가 호출될 때도 따라 호출됩니다.</li><li>즉 서버와 클라이언트 사이드 양쪽에서 호출되는 훅입니다.</li></ul></li><li>beforeMount 이후의 훅(클라이언트)<ul><li>클라이언트 사이드에서만, 하이드레이션 이후에 $mount 메소드가 호출될 때 나머지 Vue 생명주기 훅들이 실행됩니다.</li></ul></li></ul><p><em>출처: 참조 1</em></p><h3 id="2-Nuxt-js-비동기-데이터"><a href="#2-Nuxt-js-비동기-데이터" class="headerlink" title="2. Nuxt.js 비동기 데이터"></a>2. Nuxt.js 비동기 데이터</h3><blockquote><p>Nuxt.js에는 비동기데이터 가져 오기를 위해 설계된 3가지 후크가 있다.</p></blockquote><ul><li>nuxtServerInit : 모든 페이지에 호출되는 VueX 저장소를 미리 채우는 데 사용됩니다.</li><li>fetch : 페이지 내에서 호출 된 데이터로 VueX 저장소를 미리 채우는 데 사용됩니다.</li><li>asyncData : data 페이지의 객체와 동기 데이터를 병합하는데 사용된다. 비동기 방식으로 미들웨어를 사용할 수도 있습니다. 즉, 미들웨어를 사용하여 VueX 저장소를 채울 수 있습니다.</li></ul><p><img src="https://linked2ev.github.io/assets/img/devlog/201811/Nust-SSR-sample-s1.png" alt="Nust-SSR"></p><h4 id="asyncData-메소드"><a href="#asyncData-메소드" class="headerlink" title="asyncData 메소드"></a>asyncData 메소드</h4><p>서버사이드에서 데이터를 가져와서 렌더링하고 싶을 때, 이때 pages 컴포넌트를 로딩하기 전에 매번 호출되는 <code>asyncData</code>를 사용하면 된다.</p><ul><li>pages 컴포넌트에서만 지원됩니다.</li><li>서버사이드에서 호출되거나 페이지를 이동할 때 호출</li><li>컴포넌트가 렌더링 되기 전에 호출</li><li>context 인자 사용가능</li><li>nuxt.js가 <code>컴포넌트와 데이터를 자동으로 Merge하는 개념</code></li></ul><blockquote><p><code>!! asyncData 안에서 컴포넌트가 생성되기 전에 호출하기 때문에 this를 엑세스할 수 없다.</code></p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  data () &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      title: &#39;&#39;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  asyncData (&#123; params &#125;) &#123;</span><br><span class="line">    return axios.get(&#96;http:&#x2F;&#x2F;localhost:8080&#x2F;test&#x2F;1&#96;)</span><br><span class="line">    .then((res) &#x3D;&gt; &#123;</span><br><span class="line">      &#x2F;&#x2F; 여기서 this는 컴포넌트 생성 전이기에 &#39;undefined&#39;</span><br><span class="line">      return this.title &#x3D; res.data</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure><p><em>출처: 참조 2</em></p><h4 id="3-asyncData-와-fetch"><a href="#3-asyncData-와-fetch" class="headerlink" title="3. asyncData()와 fetch()"></a>3. asyncData()와 fetch()</h4><ul><li><p>두 개의 Hook은 매우 비슷해보이면서 목적은 다름</p><ul><li>공통점: 컴포넌트가 로딩되기 전에 매번 호출된다는 점, 첫번째 인자로 컨텍스트 오브젝트를 받음</li></ul></li><li><p>asyncData</p><ul><li>페이지가 로딩되기전에 컴포넌트 data를 미리 지정하여 컴포넌트가 생성될 때 병합하는데에 목적</li><li>즉 필요한 컴포넌트의 data를 컴포넌트가 랜더링 되기 전에 미리 지정하여 보다 빠르게 구성한다는 데에 목적을 둠</li></ul></li><li><p>fetch</p><ul><li>주로 비동기 작업을 작성하게 되면, 컴포넌트가 랜더링 되기전에 이 작업을 기다리게 됨</li><li>예를들어 유저정보가 필요한 컴포넌트라면 <code>fetch</code> 부분에 유저정보를 가져오는 API를 호출하여 활용할 수 있음</li></ul></li><li><p>요약하자면,</p><ul><li><code>asyncData</code>는 컴포넌트가 랜더링 되기전에 <em>컴포넌트 데이터를 구성하는데에 목적</em>이 있고,</li><li><code>fetch</code>는 컴포넌트가 랜더링 되기전에 <em>비동기로직을 호출하는데에 목적</em>이 있다고 생각합니다!</li></ul></li></ul><p><em>출처: 참조 4</em></p><h4 id="4-잘-정리된-Nuxt-Lifecucle-Hooks"><a href="#4-잘-정리된-Nuxt-Lifecucle-Hooks" class="headerlink" title="4. 잘 정리된 Nuxt Lifecucle Hooks"></a>4. 잘 정리된 Nuxt Lifecucle Hooks</h4><p><img src="https://miro.medium.com/max/1400/0*e4lPLcP-qGU9g8sv.jpg" alt="Nuxt Lifecucle Hooks"></p><p><em>출처: 참조 5</em></p><hr><h2 id="참조"><a href="#참조" class="headerlink" title="참조"></a>참조</h2><ul><li>(1) <a href="https://maxkim-j.github.io/posts/nuxt-ssr">🌧 Nuxt로 살펴보는 서버사이드 렌더링의 핵심</a></li><li>(2) <a href="https://linked2ev.github.io/devlog/2018/11/21/Nuxt-%EC%99%84-6.-Nuxt-SSR-sample/">[Nuxt][완] 6. Nuxt.js로 SSR 확인</a></li><li>(3) <a href="https://evan-moon.github.io/2018/09/25/vue-ssr/">Vue Server Side Rendering</a></li><li>(4) <a href="https://www.a-ha.io/questions/4050f94b442d0048b8c81562dc3d26e1">Nuxt.js 에서 asyncData() 와 fetch() 은 차이는 무엇인가요?</a></li><li>(5) <a href="https://medium.com/@imsukmin/%EB%B2%88%EC%97%AD-universal-application-code-structure-in-nuxt-js-f624f2e5e7e9">[번역] Universal application code structure in Nuxt.js</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;/images/nuxt.png&quot; alt=&quot;Nuxt.js&quot;&gt;&lt;/p&gt;
&lt;p&gt;Vue.js를 사용해 웹 어플리케이션 개발할때 라이프사이클에 대한 공부를 제대로 시작하지 고생한 경험이 있는데 Nuxt는 그런 과정을 밟지 않기위해 라이프사</summary>
      
    
    
    
    <category term="Programming" scheme="https://joontae-kim.github.io/categories/Programming/"/>
    
    <category term="nuxt" scheme="https://joontae-kim.github.io/categories/Programming/nuxt/"/>
    
    
    <category term="vue.js" scheme="https://joontae-kim.github.io/tags/vue-js/"/>
    
    <category term="nuxt.js" scheme="https://joontae-kim.github.io/tags/nuxt-js/"/>
    
    <category term="vue" scheme="https://joontae-kim.github.io/tags/vue/"/>
    
    <category term="nuxt" scheme="https://joontae-kim.github.io/tags/nuxt/"/>
    
    <category term="lifecycle" scheme="https://joontae-kim.github.io/tags/lifecycle/"/>
    
    <category term="nuxt lifecycle" scheme="https://joontae-kim.github.io/tags/nuxt-lifecycle/"/>
    
  </entry>
  
  <entry>
    <title>Nuxt 디렉토리 구조</title>
    <link href="https://joontae-kim.github.io/2021/03/18/nuxt-directory-3/"/>
    <id>https://joontae-kim.github.io/2021/03/18/nuxt-directory-3/</id>
    <published>2021-03-18T07:11:39.000Z</published>
    <updated>2021-03-18T07:22:59.075Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-Nuxt-프로젝트-디렉토리"><a href="#1-Nuxt-프로젝트-디렉토리" class="headerlink" title="1.Nuxt 프로젝트 디렉토리"></a>1.Nuxt 프로젝트 디렉토리</h3><p>막 생성된 nuxt 프로젝트의 디렉토리는 아래와 같다. 디렉토리에 대한 정의를 잘 몰라도 이미 Vue.js를 사용했던 개발자라면 비슷한 구조이며 스캐폴딩이 이미 되어있다는 생각이 들것이다.<br><img src="/images/nuxt-directory.png" alt="nuxt 프로젝트 디렉토리"></p><p>각 디렉토리의 역할에 대해 알아보자.</p><h4 id="static"><a href="#static" class="headerlink" title="static"></a>static</h4><p>The <code>static</code> directory is directly mapped to the server root and contains files that likely won’t be changed. All included files will be automatically served by Nuxt and are accessible through your project root URL.</p><p><code>/static/robots.txt</code> will be available at <code>http://localhost:3000/robots.txt</code></p><p><code>/static/favicon.ico</code> will be available at <code>http://localhost:3000/favicon.ico</code></p><p>This option is helpful for files like <code>robots.txt</code>, <code>sitemap.xml</code> or <code>CNAME</code> (which is important for GitHub Pages deployment).</p><blockquote><p>This directory cannot be renamed without extra configuration.</p></blockquote><h5 id="Static-Assets"><a href="#Static-Assets" class="headerlink" title="Static Assets"></a>Static Assets</h5><p>If you don’t want to use Webpack <code>assets</code> from the assets directory, you can add the images to the static directory.</p><p>In your code, you can then reference these files relative to the root (<code>/</code>):</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- Static image from static directory --&gt;</span><br><span class="line">&lt;img src&#x3D;&quot;&#x2F;my-image.png&quot; &#x2F;&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- webpacked image from assets directory --&gt;</span><br><span class="line">&lt;img src&#x3D;&quot;~&#x2F;assets&#x2F;my-image-2.png&quot; &#x2F;&gt;</span><br></pre></td></tr></table></figure><h5 id="Static-Directory-Config"><a href="#Static-Directory-Config" class="headerlink" title="Static Directory Config"></a>Static Directory Config</h5><p>Should you need to you can configure the <code>static/</code> directory behavior in the <code>nuxt.config.js</code> file.</p><h6 id="Static-asset-Prefix"><a href="#Static-asset-Prefix" class="headerlink" title="Static asset Prefix"></a>Static asset Prefix</h6><p>If you deploy Nuxt.js to a subfolder, e.g. <code>/blog/</code>, the router base will be added to the static asset path by default. If you want to disable this behavior, you can set <code>static.prefix</code> to false in the <code>nuxt.config.js</code>.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">export default &#123;</span><br><span class="line">  static: &#123;</span><br><span class="line">    prefix: false</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Default: <code>/blog/my-image.png</code><br>With <code>static.prefix</code> disabled: <code>/my-image.png</code></p><h4 id="store"><a href="#store" class="headerlink" title="store"></a>store</h4><p>The <code>store</code> directory contains your <a href="https://vuex.vuejs.org/guide/">Vuex Store</a> files. The Vuex Store comes with Nuxt.js out of the box but is disabled by default. Creating an  index.js  file in this directory enables the store.</p><blockquote><p>This directory cannot be renamed without extra configuration.</p></blockquote><h5 id="Activate-the-Store"><a href="#Activate-the-Store" class="headerlink" title="Activate the Store"></a>Activate the Store</h5><p>Nuxt.js will look for the <code>store</code> directory. If it contains a file, that isn’t a hidden file or a <code>README.md</code> file, then the store will be activated. This means that Nuxt will:</p><ol><li>Import Vuex,</li><li>Add the <code>store</code> option to the root Vue instance.</li></ol><h5 id="Modules"><a href="#Modules" class="headerlink" title="Modules"></a>Modules</h5><p>Every <code>.js</code> file inside the <code>store</code> directory is transformed as a <a href="https://vuex.vuejs.org/guide/modules.html">namespaced module</a> (<code>index</code> being the root module). Your <code>state</code> value should always be a <code>function</code> to avoid unwanted shared state on the server side.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- store&#x2F;index.js --&gt;</span><br><span class="line"></span><br><span class="line">new Vuex.Store(&#123;</span><br><span class="line">  state: () &#x3D;&gt; (&#123;</span><br><span class="line">    counter: 0</span><br><span class="line">  &#125;),</span><br><span class="line">  mutations: &#123;</span><br><span class="line">    increment(state) &#123;</span><br><span class="line">      state.counter++</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  modules: &#123;</span><br><span class="line">    todos: &#123;</span><br><span class="line">      namespaced: true,</span><br><span class="line">      state: () &#x3D;&gt; (&#123;</span><br><span class="line">        list: []</span><br><span class="line">      &#125;),</span><br><span class="line">      mutations: &#123;</span><br><span class="line">        add(state, &#123; text &#125;) &#123;</span><br><span class="line">          state.list.push(&#123;</span><br><span class="line">            text,</span><br><span class="line">            done: false</span><br><span class="line">          &#125;)</span><br><span class="line">        &#125;,</span><br><span class="line">        remove(state, &#123; todo &#125;) &#123;</span><br><span class="line">          state.list.splice(state.list.indexOf(todo), 1)</span><br><span class="line">        &#125;,</span><br><span class="line">        toggle(state, &#123; todo &#125;) &#123;</span><br><span class="line">          todo.done &#x3D; !todo.done</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>And in your pages/todos.vue, using the todos module:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- pages&#x2F;todos.vue --&gt;</span><br><span class="line"></span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;ul&gt;</span><br><span class="line">    &lt;li v-for&#x3D;&quot;todo in todos&quot; :key&#x3D;&quot;todo.text&quot;&gt;</span><br><span class="line">      &lt;input :checked&#x3D;&quot;todo.done&quot; @change&#x3D;&quot;toggle(todo)&quot; type&#x3D;&quot;checkbox&quot;&gt;</span><br><span class="line">      &lt;span :class&#x3D;&quot;&#123; done: todo.done &#125;&quot;&gt;&#123;&#123; todo.text &#125;&#125;&lt;&#x2F;span&gt;</span><br><span class="line">    &lt;&#x2F;li&gt;</span><br><span class="line">    &lt;li&gt;&lt;input @keyup.enter&#x3D;&quot;addTodo&quot; placeholder&#x3D;&quot;What needs to be done?&quot;&gt;&lt;&#x2F;li&gt;</span><br><span class="line">  &lt;&#x2F;ul&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">import &#123; mapMutations &#125; from &#39;vuex&#39;</span><br><span class="line"></span><br><span class="line">export default &#123;</span><br><span class="line">  computed: &#123;</span><br><span class="line">    todos () &#123;</span><br><span class="line">      return this.$store.state.todos.list</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    addTodo (e) &#123;</span><br><span class="line">      this.$store.commit(&#39;todos&#x2F;add&#39;, e.target.value)</span><br><span class="line">      e.target.value &#x3D; &#39;&#39;</span><br><span class="line">    &#125;,</span><br><span class="line">    ...mapMutations(&#123;</span><br><span class="line">      toggle: &#39;todos&#x2F;toggle&#39;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style&gt;</span><br><span class="line">.done &#123;</span><br><span class="line">  text-decoration: line-through;</span><br><span class="line">&#125;</span><br><span class="line">&lt;&#x2F;style&gt;</span><br></pre></td></tr></table></figure><h5 id="Example-folder-structure"><a href="#Example-folder-structure" class="headerlink" title="Example folder structure"></a>Example folder structure</h5><p>A complex store setup file/folder structure might look like this:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">store&#x2F;</span><br><span class="line">--| index.js</span><br><span class="line">--| ui.js</span><br><span class="line">--| shop&#x2F;</span><br><span class="line">----| cart&#x2F;</span><br><span class="line">------| actions.js</span><br><span class="line">------| getters.js</span><br><span class="line">------| mutations.js</span><br><span class="line">------| state.js</span><br><span class="line">----| products&#x2F;</span><br><span class="line">------| mutations.js</span><br><span class="line">------| state.js</span><br><span class="line">------| itemsGroup1&#x2F;</span><br><span class="line">--------| state.js</span><br></pre></td></tr></table></figure><h4 id="nuxt-config"><a href="#nuxt-config" class="headerlink" title="nuxt.config"></a>nuxt.config</h4><p>By default, Nuxt.js is configured to cover most use cases. This default configuration can be overwritten with the nuxt.config.js file.</p><h5 id="nuxt-config-js"><a href="#nuxt-config-js" class="headerlink" title="nuxt.config.js"></a>nuxt.config.js</h5><h6 id="alias"><a href="#alias" class="headerlink" title="alias"></a>alias</h6><p>This option lets you define aliases that will be available within your JavaScript and CSS.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">nuxt.config.js</span><br><span class="line">import &#123; resolve &#125; from &#39;path&#39;</span><br><span class="line"></span><br><span class="line">export default &#123;</span><br><span class="line">  alias: &#123;</span><br><span class="line">    &#39;style&#39;: resolve(__dirname, &#39;.&#x2F;assets&#x2F;style&#39;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="css"><a href="#css" class="headerlink" title="css"></a>css</h6><p>This option lets you define the CSS files, modules, and libraries you want to include globally (on every page).</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">export default &#123;</span><br><span class="line">  css: [&#39;~&#x2F;assets&#x2F;css&#x2F;main.css&#39;, &#39;~&#x2F;assets&#x2F;css&#x2F;animations.scss&#39;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="env"><a href="#env" class="headerlink" title="env"></a>env</h6><p>This option lets you define environment variables that are required at build time (rather than runtime) such as <code>NODE_ENV=staging</code> or <code>VERSION=1.2.3</code>. However, for runtime environment variables <code>runtimeConfig</code> is required.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">export default &#123;</span><br><span class="line">  env: &#123;</span><br><span class="line">    baseURL: process.env.BASE_URL</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="More-Configuration-property"><a href="#More-Configuration-property" class="headerlink" title="More Configuration property"></a>More Configuration property</h6><p><em>Refer <a href="https://nuxtjs.org/docs/2.x/directory-structure/nuxt-config">https://nuxtjs.org/docs/2.x/directory-structure/nuxt-config</a></em></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;1-Nuxt-프로젝트-디렉토리&quot;&gt;&lt;a href=&quot;#1-Nuxt-프로젝트-디렉토리&quot; class=&quot;headerlink&quot; title=&quot;1.Nuxt 프로젝트 디렉토리&quot;&gt;&lt;/a&gt;1.Nuxt 프로젝트 디렉토리&lt;/h3&gt;&lt;p&gt;막 생성된 nuxt 프로젝</summary>
      
    
    
    
    <category term="Programming" scheme="https://joontae-kim.github.io/categories/Programming/"/>
    
    <category term="nuxt" scheme="https://joontae-kim.github.io/categories/Programming/nuxt/"/>
    
    
    <category term="vue.js" scheme="https://joontae-kim.github.io/tags/vue-js/"/>
    
    <category term="nuxt.js" scheme="https://joontae-kim.github.io/tags/nuxt-js/"/>
    
    <category term="vue" scheme="https://joontae-kim.github.io/tags/vue/"/>
    
    <category term="nuxt" scheme="https://joontae-kim.github.io/tags/nuxt/"/>
    
  </entry>
  
  <entry>
    <title>Nuxt 디렉토리 구조</title>
    <link href="https://joontae-kim.github.io/2021/03/18/nuxt-directory-2/"/>
    <id>https://joontae-kim.github.io/2021/03/18/nuxt-directory-2/</id>
    <published>2021-03-18T07:05:00.000Z</published>
    <updated>2021-04-18T17:11:05.420Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-Nuxt-프로젝트-디렉토리"><a href="#1-Nuxt-프로젝트-디렉토리" class="headerlink" title="1.Nuxt 프로젝트 디렉토리"></a>1.Nuxt 프로젝트 디렉토리</h3><p>막 생성된 nuxt 프로젝트의 디렉토리는 아래와 같다. 디렉토리에 대한 정의를 잘 몰라도 이미 Vue.js를 사용했던 개발자라면 비슷한 구조이며 스캐폴딩이 이미 되어있다는 생각이 들것이다.<br><img src="/images/nuxt-directory.png" alt="nuxt 프로젝트 디렉토리"></p><p>각 디렉토리의 역할에 대해 알아보자.</p><h4 id="modules"><a href="#modules" class="headerlink" title="modules"></a>modules</h4><p><img src="https://nuxtjs.org/docs/2.x/modules.svg" alt="Nuxt Modules"></p><p>Nuxt Module은 Nuxt 프레임워크의 핵심 기능을 확장하고 통합 및 추가할 수 있다. 사용자가 직접 모듈을 작성할 수 있으며 Nuxt 커뮤니티에 이미 많은 모듈이 공개되어있다.</p><p><img src="https://nuxtjs.org/docs/2.x/modules.svg" alt="Nuxt modules Cheetsheet"></p><h5 id="The-modules-Property"><a href="#The-modules-Property" class="headerlink" title="The modules Property"></a>The modules Property</h5><!-- Modules are Nuxt.js extensions which can extend the framework's core functionality and add endless integrations. Once you have installed the modules you can then add them to your nuxt.config.js file under the modules property. --><p>모듈은 프레임워크의 핵심 기능을 확장하고 끝없는 통합을 추가할 수 있는 Nuxt.js 확장기능 이다. 모듈을 설치한 후에는 <code>nuxt.config.js</code> 파일의 모듈 속성 아래에 추가할 수 있습니다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- nuxt.config.js --&gt;</span><br><span class="line"></span><br><span class="line">export default &#123;</span><br><span class="line">  modules: [</span><br><span class="line">    &#x2F;&#x2F; Using package name</span><br><span class="line">    &#39;@nuxtjs&#x2F;axios&#39;,</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Relative to your project srcDir</span><br><span class="line">    &#39;~&#x2F;modules&#x2F;awesome.js&#39;,</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Providing options</span><br><span class="line">    [&#39;@nuxtjs&#x2F;google-analytics&#39;, &#123; ua: &#39;X1234567&#39; &#125;],</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Inline definition</span><br><span class="line">    function () &#123;&#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><!-- > Module developers usually provide additionally needed steps and details for usage. --><blockquote><p>모듈 개발자들은 보통 추가적으로 사용법에 대한 필요한 단계와 상세내역을 제공한다.</p></blockquote><!-- Nuxt.js tries to resolve each item in the modules array using node require path (in the node_modules) and then will resolve from the project `srcDir` if `@` alias is used. --><p>Nuxt.js은 (the node_modules 내부) node require path를 사용해 모듈 배열에 각 아이템을 확인하려고 하고, 그 후 <code>@</code> 명칭을 사용하면 <code>srcDir</code> 프로젝트로부터 확인할 것입니다.</p><!-- > Modules are executed sequentially so the order is important. --><blockquote><p>모듈은 순서대로 실행되기 때문에 순서가 중요합니다.</p></blockquote><!-- Modules should export a function to enhance build/runtime and optionally return a promise until their job is finished. Note that they are imported at runtime so they should be already transpiled if using modern ES6 features. --><p>모듈은 빌드/런타임을 향상시키기 위해 함수로 내보내야(export) 하고, 선택적으로 모듈의 작업이 끝날때까지 promise를 반환해야 합니다. 런타임에 가져오기 때문에 최신 ES6 기능을 사용한다면, 이미 변환(transpiled)되어있어야 합니다.</p><h4 id="pages"><a href="#pages" class="headerlink" title="pages"></a>pages</h4><!-- The `pages` directory contains your application views and routes. Nuxt.js reads all the `.vue` files inside this directory and automatically creates the router configuration for you. --><p><code>pages</code> 디렉토리는 어플리케이션의 views와 route를 포함합니다. Nuxt.js는 이 디렉토리 내부에 있는 모든 <code>.vue</code> 파일을 읽으며 자동으로 router 구성을 생성합니다.</p><!-- > You can also create routes with .js files and .ts files --><blockquote><p>또한, <code>.js</code>와 <code>.ts</code> 파일을 이용해 route를 생성할 수 있습니다.</p></blockquote><!-- Every Page component is a Vue component but Nuxt.js adds special attributes and functions to make the development of your universal application as easy as possible. --><p>모든 페이지 컴포넌트가 Vue 컴포넌트 이지만 가능한 쉽게 universal 어플리케이션의 개발을 할 수 있도록  Nuxt.js는 특별한 속성과 기능을 추가합니다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;h1 class&#x3D;&quot;red&quot;&gt;Hello &#123;&#123; name &#125;&#125;!&lt;&#x2F;h1&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">  export default &#123;</span><br><span class="line">    &#x2F;&#x2F; page properties go here</span><br><span class="line">  &#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style&gt;</span><br><span class="line">  .red &#123;</span><br><span class="line">    color: red;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;&#x2F;style&gt;</span><br></pre></td></tr></table></figure><h5 id="Dynamic-Pages"><a href="#Dynamic-Pages" class="headerlink" title="Dynamic Pages"></a>Dynamic Pages</h5><p>Dynamic pages can be created when you don’t know the name of the page due to it coming from an API or you don’t want to have to create the same page over and over again. To create a dynamic page you need to add an underscore before the .vue file name or before the the name of the directory, if you want the directory to be dynamic. You can name the file or directory anything you want but you must prefix it with an underscore.</p><p>동적 페이지는 API에서 가져온 페이지의 이름을 모르거나 동일한 페이지를 반복해서 만들 필요가 없을때 생성할 수 있습니다. 동적 페이지를 생성하기 위해서 <code>.vue</code> 언더스코어(underscore)를 추가하거나 디렉토리가 동적이길 원한다면 디렉토리의 이름 앞에 언더스코어(underscore)를 추가할 필요가 없습니다. 파일이나 디렉토리에 원하는 이름을 지을수 있지만 이름 뒤에 언더스코어(underscore)를 붙여야합니다.</p><!-- If you've defined a file named `_slug.vue` in your pages folder, you can access the value using the context with params.slug --><p>pages 폴더에 <code>_slug.vue</code> 라는 이름의 파일이 있다면 <code>params.slug</code>을 가진 컨텍스트(context)에서 값에 접근할 수 있다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- pages&#x2F;_slug.vue --&gt;</span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;h1&gt;&#123;&#123; this.slug &#125;&#125;&lt;&#x2F;h1&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">  export default &#123;</span><br><span class="line">    async asyncData(&#123; params &#125;) &#123;</span><br><span class="line">      const slug &#x3D; params.slug &#x2F;&#x2F; When calling &#x2F;abc the slug will be &quot;abc&quot;</span><br><span class="line">      return &#123; slug &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure><!-- If you've defined a file named `_slug.vue` inside a folder called `_book` you can access the value using the context with params.slug and params.book --><p><code>_book</code>이라는 이름의 폴더에 <code>_slug.vue</code>라는 이름의 파일이 있다면 <code>params.slug</code>와 <code>params.book</code>을 가진 컨텍스트(context)에서 값에 접근할 수 있습니다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">pages&#x2F;_book&#x2F;_slug.vue</span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;h1&gt;&#123;&#123; this.book &#125;&#125; &#x2F; &#123;&#123; this.slug &#125;&#125;&lt;&#x2F;h1&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">  export default &#123;</span><br><span class="line">    async asyncData(&#123; params &#125;) &#123;</span><br><span class="line">      const book &#x3D; params.book</span><br><span class="line">      const slug &#x3D; params.slug</span><br><span class="line">      return &#123; book, slug &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure><h5 id="Properties"><a href="#Properties" class="headerlink" title="Properties"></a>Properties</h5><h6 id="asyncData"><a href="#asyncData" class="headerlink" title="asyncData"></a>asyncData</h6><!-- asyncData is called every time before loading the component. It can be asynchronous and receives the context as an argument. The returned object will be merged with your data object. --><p>asyncData는 컴포넌트가 로딩되기 전에 매번 호출되며 비동기로 인자로써 컨텍스트(context)를 받을 수 있습니다. 반환된 객체는 data object에 병합됩니다. </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- pages&#x2F;index.vue --&gt;</span><br><span class="line"></span><br><span class="line">export default &#123;</span><br><span class="line">  asyncData(context) &#123;</span><br><span class="line">    return &#123; name: &#39;World&#39; &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="fetch"><a href="#fetch" class="headerlink" title="fetch"></a>fetch</h6><p>Every time you need to get asynchronous data you can use fetch. Fetch is called on server-side when rendering the route, and on client-side when navigating.<br>비동기 데이터를 가져와야할 필요가 있다면 fetch를 사용할 수 있습니다. server-side에서는 route를 렌더링하기 전에 그리고 client-side에서는 네비게이팅될 때 Fetch가 호출됩니다. </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">  export default &#123;</span><br><span class="line">    data() &#123;</span><br><span class="line">      return &#123;</span><br><span class="line">        posts: []</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    async fetch() &#123;</span><br><span class="line">      this.posts &#x3D; await fetch(&#39;https:&#x2F;&#x2F;api.nuxtjs.dev&#x2F;posts&#39;).then(res &#x3D;&gt;</span><br><span class="line">        res.json()</span><br><span class="line">      )</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure><h6 id="head"><a href="#head" class="headerlink" title="head"></a>head</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">export default &#123;</span><br><span class="line">  head() &#123;</span><br><span class="line">    &#x2F;&#x2F; Set Meta Tags for this Page</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="layout"><a href="#layout" class="headerlink" title="layout"></a>layout</h6><!-- Specify a layout defined in the layouts directory. --><p>레이아웃 디렉토리에 정의된 레이아웃을 지정합니다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- pages&#x2F;index.vue --&gt;</span><br><span class="line"></span><br><span class="line">export default &#123;</span><br><span class="line">  layout: &#39;blog&#39;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="loading"><a href="#loading" class="headerlink" title="loading"></a>loading</h6><p><a href="https://nuxtjs.org/docs/2.x/directory-structure/pages#loading">https://nuxtjs.org/docs/2.x/directory-structure/pages#loading</a></p><h6 id="transition"><a href="#transition" class="headerlink" title="transition"></a>transition</h6><p><a href="https://nuxtjs.org/docs/2.x/directory-structure/pages#transition">https://nuxtjs.org/docs/2.x/directory-structure/pages#transition</a></p><h6 id="scrollToTop"><a href="#scrollToTop" class="headerlink" title="scrollToTop"></a>scrollToTop</h6><p><a href="https://nuxtjs.org/docs/2.x/directory-structure/pages#scrolltotop">https://nuxtjs.org/docs/2.x/directory-structure/pages#scrolltotop</a></p><h6 id="middleware"><a href="#middleware" class="headerlink" title="middleware"></a>middleware</h6><p><a href="https://nuxtjs.org/docs/2.x/directory-structure/pages#middleware">https://nuxtjs.org/docs/2.x/directory-structure/pages#middleware</a></p><h4 id="plugins"><a href="#plugins" class="headerlink" title="plugins"></a>plugins</h4><p><img src="https://nuxtjs.org/docs/2.x/plugins.svg" alt="Nuxt Plugins Cheetsheet"></p><!-- The plugins directory contains JavaScript plugins that you want to run before instantiating the root Vue.js Application. This is the place to add Vue plugins and to inject functions or constants. Every time you need to use Vue.use(), you should create a file in `plugins/` and add its path to plugins in `nuxt.config.js`. --><p>plugins 디렉토리는 Vue.js 어플리케이션의 root에서 인스턴스화되기 전에 실행하려는 JavaScript 플러그인이 포함되어 있습니다. 이 디렉토리는 Vue 플러그인을 추가할수도 있으며 기능 또는 상수를 주입할 수도 있습니다. <code>Vue.use()</code>를 사용할 필요가 있을때마다 <code>plugins/</code>에 파일을 생성하고 <code>nuxt.config.js</code>에 플러그인의 경로를 설정해줘야 합니다.</p><h5 id="External-Packages"><a href="#External-Packages" class="headerlink" title="External Packages"></a>External Packages</h5><!-- You may want to use external packages/modules in your application (one great example is axios) for making HTTP requests for both server and client. --><p>서버와 클라이언트에서 HTTP 요청을 수행하기 위해 외부 패키지/모듈을 사용하고 싶을지도 모릅니다(한가지 큰 예가 axios 입니다). </p><h6 id="Install-Package"><a href="#Install-Package" class="headerlink" title="Install Package"></a>Install Package</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">yarn add @nuxtjs&#x2F;axios</span><br><span class="line">&#x2F;&#x2F; or</span><br><span class="line">npm install @nuxtjs&#x2F;axios</span><br></pre></td></tr></table></figure><p>You can configure for example the axios interceptors to react on possible errors from your API calls across the application. In this example we redirect the user to a custom error page called sorry when we get a 500 status error from our API.<br>예를 들, 어플리케이션 간에 API 요청에서 가능한 에러에 대응하기 위해 axios interceptors를 구성할 수도 있습니다. 이 예는 API에서 500 상태 에러를 받았을때 사용자를 sorry라고 부르는 커스텀 오류 페이지로 리다이렉트합니다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">plugins&#x2F;axios.js</span><br><span class="line">export default function (&#123; $axios, redirect &#125;) &#123;</span><br><span class="line">  $axios.onError(error &#x3D;&gt; &#123;</span><br><span class="line">    if (error.response.status &#x3D;&#x3D;&#x3D; 500) &#123;</span><br><span class="line">      redirect(&#39;&#x2F;sorry&#39;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><!-- Last but not least, add the module and the newly created plugin to the project configuration. --><p>마지막으로, 모듈과 새롭게 생성된 플러그인을 프로젝트 구성에 추가합니다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">nuxt.config.js</span><br><span class="line">module.exports &#x3D; &#123;</span><br><span class="line">  modules: [&#39;@nuxtjs&#x2F;axios&#39;],</span><br><span class="line">  plugins: [&#39;~&#x2F;plugins&#x2F;axios.js&#39;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><!-- Then we can use it directly in your page components: --><p>그리고 나서 이 플러그인을 페이지 컴포넌트에 직접 사용할 수 있습니다:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;h1&gt;&#123;&#123; post.title &#125;&#125;&lt;&#x2F;h1&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">    async asyncData (&#123; $axios, params &#125;) &#123;</span><br><span class="line">      const  post  &#x3D; await $axios.$get(&#96;https:&#x2F;&#x2F;api.nuxtjs.dev&#x2F;posts&#x2F;$&#123;params.id&#125;&#96;)</span><br><span class="line">      return &#123; post &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure><!-- Another way to use axios without installing the module is by importing axios direct in the `<script>` tag. --><p>모듈을 설치하지 않고 axios를 사용하는 또다른 방법으로는 <code>&lt;script&gt;</code> 태그에 axios를 직접 부르는 것입니다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- pages&#x2F;index.vue --&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">import axios from &#39;axios&#39;</span><br><span class="line"></span><br><span class="line">export default &#123;</span><br><span class="line">    async asyncData (&#123; params &#125;) &#123;</span><br><span class="line">      const &#123; data: post &#125;  &#x3D; await axios.get(&#96;https:&#x2F;&#x2F;api.nuxtjs.dev&#x2F;posts&#x2F;$&#123;params.id&#125;&#96;)</span><br><span class="line">      return &#123; post &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure><!-- > If you get an _Cannot use import statement outside a module_ error, you may need to add your package to the build > transpile option in nuxt.config.js for webpack loader to make your plugin available. --><blockquote><p> 만약 “<em>Cannot use import statement outside a module</em>“ 이라는 오류를 봤다면, 웹팩 로더에서 플러그인을 사용가능하도록 하기 위해 <code>nuxt.config.js</code>에 <code>build</code> &gt; <code>transpile</code> 옵션에서 패키지를 추가해야할지도 모릅니다.</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">nuxt.config.js</span><br><span class="line">build: &#123;</span><br><span class="line">  &#x2F;&#x2F; You can extend webpack config here</span><br><span class="line">  transpile: [&#39;npm-package-name&#39;],</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><h5 id="Vue-Plugins"><a href="#Vue-Plugins" class="headerlink" title="Vue Plugins"></a>Vue Plugins</h5><!-- If we want to use Vue plugins, like v-tooltip to display tooltips in your application, we need to setup the plugin before launching the app. --><p>application에서 tooltip을 보여주기 위해 <code>v-tooltip</code>와 같은 Vue 플러그인을 사용하기 원한다면 앱을 런칭하기 전에 플러그인을 설치해야 합니다.</p><!-- First we need to install it --><p>첫번째로 플러그인을 설치합니다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- install vue plugin --&gt;</span><br><span class="line">npm install v-tooltip</span><br><span class="line"></span><br><span class="line">&lt;!-- plugins&#x2F;vue-tooltip.js --&gt;</span><br><span class="line"></span><br><span class="line">import Vue from &#39;vue&#39;</span><br><span class="line">import VTooltip from &#39;v-tooltip&#39;</span><br><span class="line"></span><br><span class="line">Vue.use(VTooltip)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h6 id="The-plugins-Property"><a href="#The-plugins-Property" class="headerlink" title="The plugins Property"></a>The plugins Property</h6><!-- Then we add the file path inside the plugins key of our `nuxt.config.js`. The plugins property lets you add Vue.js plugins easily to your main application. All the paths defined in the plugins property will be imported before initializing the main application. --><p>그리고 나서 <code>nuxt.config.js</code>의 플러그인 키안에 파일 경로를 추가합니다. 플러그인 속성을 사용하면 Vue.js 플러그인을 메인 어플리케이션에 쉽게 추가할 수 있습니다. 메인 어플리케이션이 초기화되기 전에 플러그인 속성에 정의된 모든 경로를 가져옵니다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- nuxt.config.js --&gt;</span><br><span class="line"></span><br><span class="line">export default &#123;</span><br><span class="line">  plugins: [&#39;~&#x2F;plugins&#x2F;vue-tooltip.js&#39;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="ES6-Plugins"><a href="#ES6-Plugins" class="headerlink" title="ES6 Plugins"></a>ES6 Plugins</h6><!-- If the plugin is located in `node_modules` and exports an ES6 module, you may need to add it to the `transpile` build option: --><p>만약 플러그인이 <code>node_modules</code>에 위치해있고 ES6 모듈로 내보내진다면, <code>transpile</code>에서 빌드 옵션에 플러그인을 추가해줘야 합니다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- nuxt.config.js --&gt;</span><br><span class="line">module.exports &#x3D; &#123;</span><br><span class="line">  build: &#123;</span><br><span class="line">    transpile: [&#39;vue-tooltip&#39;]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>자세한 빌드 옵션은 <a href="https://nuxtjs.org/docs/2.x/configuration-glossary/configuration-build#transpile">빌드 구성사항 문서</a>를 참고할 수 있습니다.</p><h6 id="ES6-Plugins-1"><a href="#ES6-Plugins-1" class="headerlink" title="ES6 Plugins"></a>ES6 Plugins</h6><p><a href="https://nuxtjs.org/docs/2.x/directory-structure/plugins#es6-plugins">https://nuxtjs.org/docs/2.x/directory-structure/plugins#es6-plugins</a></p><h6 id="Client-or-server-side-only"><a href="#Client-or-server-side-only" class="headerlink" title="Client or server side only"></a>Client or server side only</h6><p><a href="https://nuxtjs.org/docs/2.x/directory-structure/plugins#client-or-server-side-only">https://nuxtjs.org/docs/2.x/directory-structure/plugins#client-or-server-side-only</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;1-Nuxt-프로젝트-디렉토리&quot;&gt;&lt;a href=&quot;#1-Nuxt-프로젝트-디렉토리&quot; class=&quot;headerlink&quot; title=&quot;1.Nuxt 프로젝트 디렉토리&quot;&gt;&lt;/a&gt;1.Nuxt 프로젝트 디렉토리&lt;/h3&gt;&lt;p&gt;막 생성된 nuxt 프로젝</summary>
      
    
    
    
    <category term="Programming" scheme="https://joontae-kim.github.io/categories/Programming/"/>
    
    <category term="nuxt" scheme="https://joontae-kim.github.io/categories/Programming/nuxt/"/>
    
    
    <category term="vue.js" scheme="https://joontae-kim.github.io/tags/vue-js/"/>
    
    <category term="nuxt.js" scheme="https://joontae-kim.github.io/tags/nuxt-js/"/>
    
    <category term="vue" scheme="https://joontae-kim.github.io/tags/vue/"/>
    
    <category term="nuxt" scheme="https://joontae-kim.github.io/tags/nuxt/"/>
    
  </entry>
  
  <entry>
    <title>Nuxt 디렉토리 구조</title>
    <link href="https://joontae-kim.github.io/2021/03/18/nuxt-directory/"/>
    <id>https://joontae-kim.github.io/2021/03/18/nuxt-directory/</id>
    <published>2021-03-18T03:49:55.000Z</published>
    <updated>2021-04-18T10:14:41.619Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-Nuxt-프로젝트-디렉토리"><a href="#1-Nuxt-프로젝트-디렉토리" class="headerlink" title="1.Nuxt 프로젝트 디렉토리"></a>1.Nuxt 프로젝트 디렉토리</h3><p>막 생성된 nuxt 프로젝트의 디렉토리는 아래와 같다. 디렉토리에 대한 정의를 잘 몰라도 이미 Vue.js를 사용했던 개발자라면 비슷한 구조이며 스캐폴딩이 이미 되어있다는 생각이 들것이다.<br><img src="/images/nuxt-directory.png" alt="nuxt 프로젝트 디렉토리"></p><p>각 디렉토리의 역할에 대해 알아보자.</p><h4 id="nuxt"><a href="#nuxt" class="headerlink" title=".nuxt"></a>.nuxt</h4><!-- The .nuxt directory is the so-called build directory. It is dynamically generated and hidden by default. Inside the directory you can find automatically generated files when using nuxt dev or your build artifacts when using nuxt build. --><p><code>.directory</code>를 빌드 디렉토리라고 부르며 기본적으로 숨겨져 있고 동적으로 생성됩니다. <code>nuxt dev</code>를 사용했을땐 이 디렉토리에서 동적으로 생성된 파일들을 찾을 수 있으며 <code>nuxt build</code>를 사용하면 작업물들을 빌드할 수 있습니다.</p><h4 id="assets"><a href="#assets" class="headerlink" title="assets"></a>assets</h4><!-- The assets directory contains your uncompiled assets such as Stylus or Sass files, images, or fonts. --><p><code>assets</code> 디렉토리는 Stylus 또는 Sass files, images 또는 fonts 와 같은 컴파일된 애셋이 포함되어 있습니다.</p><h5 id="Images"><a href="#Images" class="headerlink" title="Images"></a>Images</h5><!-- Inside your vue templates, if you need to link to your assets directory use ~/assets/your_image.png with a slash before assets. --><p><code>vue</code> 템플릿 내부에는, 만약 assets을 링크해야 한다면, 슬래시(/)와 앞에 <code>~/assets/your_image.png</code>와 같이 사용할 수 있습니다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;img src&#x3D;&quot;~&#x2F;assets&#x2F;your_image.png&quot; &#x2F;&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br></pre></td></tr></table></figure><!-- Inside your css files, if you need to reference your  assets  directory, use ~assets/your_image.png(without a slash) --><p>css 파일에서 <code>assets</code> 디렉토리에 대한 참조가 필요하다면, 슬래시 없이 <code>~assets/your_image.png</code>와 같이 사용할 수 있습니다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">background: url(&#39;~assets&#x2F;banner.svg&#39;);</span><br></pre></td></tr></table></figure><h5 id="Styles"><a href="#Styles" class="headerlink" title="Styles"></a>Styles</h5><!-- Nuxt.js lets you define the CSS files/modules/libraries you want to set globally (included in every page). In the nuxt.config you can easily add your styles using the CSS Property. --><p>Nuxt.js를 사용하면 모든 페이지에서 포함된 전역으로 설정하기 원하는 CSS 파일/모듈/라이브러리를 정의할 수 있습니다. <code>nuxt.config</code> 에서 CSS 프로퍼티를 사용합으로써 스타일을 쉽게 추가할 수 있습니다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">export default &#123;</span><br><span class="line">  css: [</span><br><span class="line">    &#x2F;&#x2F; Load a Node.js module directly (here it&#39;s a Sass file)</span><br><span class="line">    &#39;bulma&#39;,</span><br><span class="line">    &#x2F;&#x2F; CSS file in the project</span><br><span class="line">    &#39;~&#x2F;assets&#x2F;css&#x2F;main.css&#39;,</span><br><span class="line">    &#x2F;&#x2F; SCSS file in the project</span><br><span class="line">    &#39;~&#x2F;assets&#x2F;css&#x2F;main.scss&#39;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="Fonts"><a href="#Fonts" class="headerlink" title="Fonts"></a>Fonts</h5><!-- You can use local fonts by adding them to your assets folder. Once they have been added you can then access them through your css using the @font-face. --><p>여러분의 에셋 폴더에 로컬 폰트를 추가해 사용할 수 있습니다. 일단 폰트를 추가하면, 여러분은 <code>@font-face</code>를 사용해 css에서 폰트에 접근할 수 있습니다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-| assets</span><br><span class="line">----| fonts</span><br><span class="line">------| DMSans-Regular.ttf</span><br><span class="line">------| DMSans-Bold.ttf</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">@font-face &#123;</span><br><span class="line">  font-family: &#39;DM Sans&#39;;</span><br><span class="line">  font-style: normal;</span><br><span class="line">  font-weight: 400;</span><br><span class="line">  font-display: swap;</span><br><span class="line">  src: url(&#39;~assets&#x2F;fonts&#x2F;DMSans-Regular.ttf&#39;) format(&#39;truetype&#39;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@font-face &#123;</span><br><span class="line">  font-family: &#39;DM Sans&#39;;</span><br><span class="line">  font-style: normal;</span><br><span class="line">  font-weight: 700;</span><br><span class="line">  font-display: swap;</span><br><span class="line">  src: url(&#39;~assets&#x2F;fonts&#x2F;DMSans-Bold.ttf&#39;) format(&#39;truetype&#39;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="components"><a href="#components" class="headerlink" title="components"></a>components</h4><!-- The components directory contains your Vue.js components. Components are what makes up the different parts of your page and can be reused and imported into your pages, layouts and even other components. --><p>컴포넌트 디렉토리는 Vue.js 컴포넌트들을 포함하고 있으며 컴포넌트들은 페이지의 서로 다른 부분을 구성할 것이고 페이지, 레이아웃 심지어 다른 컴포넌트안에서 불러지고, 재사용할 될 수 있습니다.</p><h5 id="Fetching-Data"><a href="#Fetching-Data" class="headerlink" title="Fetching Data"></a>Fetching Data</h5><!-- To access asynchronous data from an API in your components you can use Nuxt fetch() hook. --><p>컴포넌트에서 API에 동적으로 데이터를 접근하기 위해서 Nuxt의 <code>fetch() hook</code>을 사용할 수 있습니다.</p><!-- By checking $fetchState.pending, we can show a message when data is waiting to be loaded. We can also check $fetchState.error and show an error message if there is an error fetching the data. When using fetch(), we must declare the appropriate properties in data(). The data that comes from the fetch can then be assigned to these properties. --><p><code>$fetchState.pending</code>을 확인함으로써, 데이터가 로드될 때까지 기다리고 있을때 메시지를 표시할 수 있다. 또한, 데이터를 가져오는데 오류가 있을 경우 <code>$fetchState.error</code>를 확인해 오류 메시지를 표시할 수 있습니다. <code>fetch()</code>을 사용하면 <code>data()</code>에서 적절한 프로퍼티에 선언해야 합니다. fetch로부터 받은 데이터는 이러한 속성들에 선언할 수 있습니다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;p v-if&#x3D;&quot;$fetchState.pending&quot;&gt;Loading....&lt;&#x2F;p&gt;</span><br><span class="line">    &lt;p v-else-if&#x3D;&quot;$fetchState.error&quot;&gt;Error while fetching mountains&lt;&#x2F;p&gt;</span><br><span class="line">    &lt;ul v-else&gt;</span><br><span class="line">      &lt;li v-for&#x3D;&quot;(mountain, index) in mountains&quot; :key&#x3D;&quot;index&quot;&gt;</span><br><span class="line">        &#123;&#123; mountain.title &#125;&#125;</span><br><span class="line">      &lt;&#x2F;li&gt;</span><br><span class="line">    &lt;&#x2F;ul&gt;</span><br><span class="line">  &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  export default &#123;</span><br><span class="line">    data() &#123;</span><br><span class="line">      return &#123;</span><br><span class="line">        mountains: []</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    async fetch() &#123;</span><br><span class="line">      this.mountains &#x3D; await fetch(</span><br><span class="line">        &#39;https:&#x2F;&#x2F;api.nuxtjs.dev&#x2F;mountains&#39;</span><br><span class="line">      ).then(res &#x3D;&gt; res.json())</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure><h4 id="content"><a href="#content" class="headerlink" title="content"></a>content</h4><!-- Empower your Nuxt.js application with @nuxtjs/content module where you can write in a content/ directory and fetch your Markdown, JSON, YAML and CSV files through a MongoDB like API, acting as a Git-based Headless CMS. --><p><code>content/</code> 디렉토리에 작성한 <code>@nuxtjs/content</code> 모듈은 Nuxt.js 어플리케이션을 강력하게 만들수 있으며 <strong>Git-based Headless CMS</strong> 와 같은 역할을 하는 MongoDB와 같은 API를 통해 Markdown, JSON, YAML and CSV 파일들을 불러옵니다.<br><img src="https://nuxtjs.org/docs/2.x/nuxt-content.svg"></p><h4 id="dist"><a href="#dist" class="headerlink" title="dist"></a>dist</h4><!-- The **dist** folder, short for distribution folder. It is dynamically generated when using the nuxt generate command and includes the generated production ready HTML files and assets that are necessary to deploy and run your statically generated Nuxt.js application. --><p><em>배포</em> 폴더를 간추려 <strong>dist</strong> 폴더라고 하며 <code>nuxt generate</code> 명령어를 사용해 동적으로 생성하고, 생성된 프로덕션에 준비된 HTML 파일들과 배포하기 위해 필수적인 에셋들이 포함되고, 전략적으로 생성한 Nuxt.js 어플리케이션이 작동합니다.</p><h4 id="layouts"><a href="#layouts" class="headerlink" title="layouts"></a>layouts</h4><!-- Layouts are a great help when you want to change the look and feel of your Nuxt.js app. Whether you want to include a sidebar or have distinct layouts for mobile and desktop. --><p>사이드바 또는 모바일이나 데스크톱에 대한 구별된 레이아웃을 원할 경우 레이아웃은 Nuxt.js 앱의 느낌과 외형을 변경하려고 할때 큰 도움이 됩니다.</p><!-- > This directory cannot be renamed without extra configuration. --><blockquote><p>이 디렉토리는 추가 설졍없이 이름을 재설정할 수 없습니다.</p></blockquote><h5 id="Default-Layout"><a href="#Default-Layout" class="headerlink" title="Default Layout"></a>Default Layout</h5><!-- You can extend the main layout by adding a layouts/default.vue file. It will be used for all pages that don't have a layout specified. Make sure to add the <Nuxt> component when creating a layout to actually include the page component. --><p><code>layouts/default.vue</code> 파일을 추가하면 메인 레이아웃을 확장할 수 있으며 특정 레이아웃을 가지고 있지 않은 모든 페이지에서 사용할 수 있습니다. 실제로 페이지 컴포넌트에 포함하도록 생성한 레이아웃을 생성할때 <code>&lt;Nuxt&gt;</code> 컴포넌트를 추가해야 합니다. </p><!-- All you need in your layout is three lines of code which will render the page component. --><p>레이아웃에서 필요한 것은 페이지 컴포넌트를 렌더링 할 세줄의 코드입니다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- layouts&#x2F;default.vue --&gt;</span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;Nuxt &#x2F;&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br></pre></td></tr></table></figure><!-- You can add more components here such as Navigation, Header, Footer etc. --><p>네비게이션, 헤너, 푸터 등과 같은 더 많은 컴포넌트들을 추가할 수 있습니다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- layouts&#x2F;default.vue --&gt;</span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;TheHeader &#x2F;&gt;</span><br><span class="line">    &lt;Nuxt &#x2F;&gt;</span><br><span class="line">    &lt;TheFooter &#x2F;&gt;</span><br><span class="line">  &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br></pre></td></tr></table></figure><!-- > If you have components set to true then there is no need to add any import statements for your components. --><blockquote><p>만약 <code>components</code>에 <code>true</code>를 설정하면 컴포넌트를 위한 그 어떠한 <code>import</code> 구분도 필요하지 않습니다.</p></blockquote><h5 id="Custom-Layout"><a href="#Custom-Layout" class="headerlink" title="Custom Layout"></a>Custom Layout</h5><!-- Every file (top-level) in the layouts directory will create a custom layout accessible with the layout property in the page components. --><p><code>layouts</code> 디렉토리의 (top-level의) 모든 파일은 페이지 컴포넌트에서 레이아웃 속성에 접근 가능한 커스텀 레이아웃을 만듭니다.</p><!-- Let's say we want to create a blog layout and save it to layouts/blog.vue: --><p>블로그 레이아웃을 생성하기 위해 <code>layouts/blog.vue</code>에 아래의 코드를 저장합니다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;div&gt;My blog navigation bar here&lt;&#x2F;div&gt;</span><br><span class="line">    &lt;Nuxt &#x2F;&gt;</span><br><span class="line">  &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br></pre></td></tr></table></figure><!-- Then you have to tell the pages to use your custom layout --><p>그리고나서 페이지에서 아래와 같이 여러분의 커스텀 레이아웃을 설정해야 합니다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  layout: &#39;blog&#39;,</span><br><span class="line">  &#x2F;&#x2F; OR</span><br><span class="line">  layout (context) &#123;</span><br><span class="line">    return &#39;blog&#39;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure><h4 id="middleware"><a href="#middleware" class="headerlink" title="middleware"></a>middleware</h4><!-- The middleware directory contains your application middleware. Middleware lets you define custom functions that can be run before rendering either a page or a group of pages (layout). --><p><code>middleware</code> 디렉토리는 어플리케이션 미들웨어를 포함하며 페이지 하나 또는 페이지 그룹 또는 레이아웃리 렌더링되기 전에 작동할 수 있는 커스텀 함수들을 정의할 수 있습니다.</p><!-- Shared `middleware` should be placed in the  `middleware/`  directory. The filename will be the name of the middleware (`middleware/auth.js` will be the `auth` middleware). You can also define page-specific middleware by using a function directly, see [anonymous middleware](https://nuxtjs.org/docs/2.x/components-glossary/pages-middleware#anonymous-middleware). --><p>공유된 <code>middleware</code>는 <code>middleware/</code> 디렉토리에 배치해야 하며 파일이름은 미들웨어의 이름이 될 것 입니다(<code>middleware/auth.js</code>는 <code>auth</code> 미들웨어가 됩니다). 또한 페이지 특정 미들웨어는 직접 함수로 사용할 수 있습니다.<br><a href="https://nuxtjs.org/docs/2.x/components-glossary/pages-middleware#anonymous-middleware">anonymous middleware</a>를 참고하세요.</p><!-- A middleware receives [the context](https://nuxtjs.org/docs/2.x/internals-glossary/context) as the first argument. --><p>미들웨어는 첫번째 인자로 <a href="https://nuxtjs.org/docs/2.x/internals-glossary/context">the context</a> 를 받습니다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">export default function (context) &#123;</span><br><span class="line">  &#x2F;&#x2F; Add the userAgent property to the context</span><br><span class="line">  context.userAgent &#x3D; process.server</span><br><span class="line">    ? context.req.headers[&#39;user-agent&#39;]</span><br><span class="line">    : navigator.userAgent</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><!-- In universal mode, middlewares will be called once on server-side (on the first request to the Nuxt app, e.g. when directly accessing the app or refreshing the page) and on the client-side when navigating to further routes. With `ssr: false`, middlewares will be called on the client-side in both situations. --><p>universal 모드에서 미들웨어는 (예를 들어 앱에 바로 접속하거나 페이지를 새로고침할때, Nuxt 어플리케이션에서 처음 요청할때) 서버사이드에서 그리고 다른 라우트로 네이게이팅될때 클라이언트 사이드에서 단 한번만 호출됩니다. <code>ssr: false</code>를 설정하면, 미들웨어는 두 가지 상황에서 클라이언트 사이드에서만 호출됩니다.</p><!-- The middleware will be executed in series in this order: --><p>미들웨어는 아래의 순서대로 실행됩니다.</p><ol><li><code>nuxt.config.js</code> (파일 내부 순서대로)</li><li>매칭된 레이아웃</li><li>매칭된 페이지</li></ol><h5 id="Router-Middleware"><a href="#Router-Middleware" class="headerlink" title="Router Middleware"></a>Router Middleware</h5><!-- A middleware can be asynchronous. To do this return a Promise or use async/await. --><p>미들웨어는 비동기적일 수 있으며 이를 위해 <code>Promise</code>를 반환하거나 async/await를 사용해야합니다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- middleware&#x2F;stats.js --&gt;</span><br><span class="line"></span><br><span class="line">import http from &#39;http&#39;</span><br><span class="line"></span><br><span class="line">export default function (&#123; route &#125;) &#123;</span><br><span class="line">  return http.post(&#39;http:&#x2F;&#x2F;my-stats-api.com&#39;, &#123;</span><br><span class="line">    url: route.fullPath</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><!-- Then, in your nuxt.config.js, use the router.middleware key. --><p>그러고나서 <code>nuxt.config.js</code>에서 <code>router.middleware</code> key를 사용해야 합니다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- nuxt.config.js --&gt;</span><br><span class="line"></span><br><span class="line">export default &#123;</span><br><span class="line">  router: &#123;</span><br><span class="line">    middleware: &#39;stats&#39;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><!-- Now the stats middleware will be called for every route change. You can add your middleware (even multiple) to a specific layout or page as well. --><p>이제 모든 라우트 변경에 대해 <code>stats</code> 미들웨어가 호출됩니다. 또한 특정 레이아웃 또는 페이지에 대한 (복수의) 미들웨어를 추가할 수 있습니다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- pages&#x2F;index.vue &#x2F; layouts&#x2F;default.vue --&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  middleware: [&#39;auth&#39;, &#39;stats&#39;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="Named-middleware"><a href="#Named-middleware" class="headerlink" title="Named middleware"></a>Named middleware</h5><!-- You can create named middleware by creating a file inside the  middleware/ directory, the file name will be the middleware name. --><p><code>middleware/</code> 디렉토리 내부에 파일을 생성함으로써 named 디렉토리를 생성할 수 있으며 미들웨어 이름이 될 것입니다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- middleware&#x2F;authenticated.js --&gt;</span><br><span class="line"></span><br><span class="line">export default function (&#123; store, redirect &#125;) &#123;</span><br><span class="line">  &#x2F;&#x2F; If the user is not authenticated</span><br><span class="line">  if (!store.state.authenticated) &#123;</span><br><span class="line">    return redirect(&#39;&#x2F;login&#39;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- pages&#x2F;secret.vue --&gt;</span><br><span class="line"></span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;h1&gt;Secret page&lt;&#x2F;h1&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">  export default &#123;</span><br><span class="line">    middleware: &#39;authenticated&#39;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure><h5 id="Anonymous-middleware"><a href="#Anonymous-middleware" class="headerlink" title="Anonymous middleware"></a>Anonymous middleware</h5><!-- If you need to use a middleware only for a specific page, you can directly use a function for it (or an array of functions): --><p>만약 오직 특정 페이지만을 위한 미들웨어를 사용하고자 한다면 직접 함수(또는 함수 배열)를 사용할 수 있습니다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- pages&#x2F;secret.vue --&gt;</span><br><span class="line"></span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;h1&gt;Secret page&lt;&#x2F;h1&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">  export default &#123;</span><br><span class="line">    middleware(&#123; store, redirect &#125;) &#123;</span><br><span class="line">      &#x2F;&#x2F; If the user is not authenticated</span><br><span class="line">      if (!store.state.authenticated) &#123;</span><br><span class="line">        return redirect(&#39;&#x2F;login&#39;)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;1-Nuxt-프로젝트-디렉토리&quot;&gt;&lt;a href=&quot;#1-Nuxt-프로젝트-디렉토리&quot; class=&quot;headerlink&quot; title=&quot;1.Nuxt 프로젝트 디렉토리&quot;&gt;&lt;/a&gt;1.Nuxt 프로젝트 디렉토리&lt;/h3&gt;&lt;p&gt;막 생성된 nuxt 프로젝</summary>
      
    
    
    
    <category term="Programming" scheme="https://joontae-kim.github.io/categories/Programming/"/>
    
    <category term="nuxt" scheme="https://joontae-kim.github.io/categories/Programming/nuxt/"/>
    
    
    <category term="vue.js" scheme="https://joontae-kim.github.io/tags/vue-js/"/>
    
    <category term="nuxt.js" scheme="https://joontae-kim.github.io/tags/nuxt-js/"/>
    
    <category term="vue" scheme="https://joontae-kim.github.io/tags/vue/"/>
    
    <category term="nuxt" scheme="https://joontae-kim.github.io/tags/nuxt/"/>
    
  </entry>
  
  <entry>
    <title>nuxt.js - 시작하기</title>
    <link href="https://joontae-kim.github.io/2021/03/18/nuxt-intro/"/>
    <id>https://joontae-kim.github.io/2021/03/18/nuxt-intro/</id>
    <published>2021-03-17T17:08:33.000Z</published>
    <updated>2021-03-18T04:00:50.336Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/nuxt.png" alt="Nuxt.js"></p><p>포트폴리오용 nuxt 앱이 필요했던 참에 신규 프로젝트에서 nuxt로 어플리케이션을 제작해야해서 정리 및 공부겸 포스팅을 하기로 했다.</p><h3 id="1-Nuxt란"><a href="#1-Nuxt란" class="headerlink" title="1.Nuxt란?"></a>1.Nuxt란?</h3><p>Nuxt란 NuxtJS를 사용하여 신뢰 있는 Vue.js 애플리케이션을 구축하세요. 웹 개발을 간단하고 강력하게 만드는 오픈 소스 프레임워크로 서버 사이드 렌더링 (SSR)과 정적 사이트 생성을 지원해준다.</p><h4 id="1-소개"><a href="#1-소개" class="headerlink" title="1) 소개"></a>1) 소개</h4><p>Nuxt.js의 소개를 본다면 이렇게 명시하고 있다.</p><blockquote><ul><li>주요 범위는 UI Rendering이며, 클라이언트/서버 배포를 추상화한다.</li><li>Nuxt.js의 목표는 기본 프로젝트 베이스로 사용할 수 있으며 Node.js 기반의 프로젝트를 유연하게 사용할 수 있는 프레임 워크를  만드는 것이다.</li><li>Nuxt.js는 서버 사이드 렌더링 된 Vue.js 응용 프로그램의 개발을 위해 이에 필요한 모든 구성을 사전 설정한다.</li><li>Nuxt.js는 nuxt generate 라는 배포 옵션을 제공한다. nuxt gererate를 통해 vue.js를 정적인 응용 프로그램으로 빌드한다. - 우리는 이 옵션이 마이크로 서비스가 있는 웹 응용 프로그램 개발의 다음 단계일 수 있다고 생각한다.</li><li>Nuxt.js는 단일 응용 페이지(SPA)를 신속하게 만들 수 있다.</li><li>Nuxt.js는 비동기 데이터, 미들웨어, 레이아웃 등과 같이 클라이언트 측과 서버 측 사이에서 개발하는 데 도움이 되는 많은 기능을 제공한다.</li><li>Nuxt.js 설치만으로 이미 scaffolding(프로젝트 구조화)을 해주므로 딱히 프로젝트 구조에 대해서 고민할 필요가 없다.</li><li>Vue.js 하나하나 잡아줘야 할 라우팅을 Nuxt.js에서 파일을 생성하는 것만으로 라우팅을 자동으로 생성해 준다.</li><li>layout, store, middleware와 같은 요소들을 이미 구분을 지어주고 필요한 항목들을 처리해주기 때문에 순전히 개발에만 집중하면 된다.</li><li>Server-Side-Rendering에 필요한 요소가 이미 준비가 되어있다.</li><li>webpack을 통한 빌드 시스템이 이미 구현되어 있다. 그저 npm run만 해주면 된다.</li></ul></blockquote><h4 id="2-특징"><a href="#2-특징" class="headerlink" title="2) 특징"></a>2) 특징</h4><ul><li>Vue 파일 작성</li><li>코드 분할 자동화</li><li>서버사이드 렌더링</li><li>강력한 비동기 데이터 기반 라우팅 시스템</li><li>정적 파일 전송</li><li>ES6/ES7 지원</li><li>JS &amp; CSS 코드 번들링 및 압축</li><li>html의 head 태그 관리</li><li>Hot reloading의 지원</li><li>SASS, LESS, Stylus 등의 전처리기 지원</li></ul><h4 id="일단-위-소개만-보면-안-쓸-이유가-없다"><a href="#일단-위-소개만-보면-안-쓸-이유가-없다" class="headerlink" title="일단 위 소개만 보면 안 쓸 이유가 없다."></a><em>일단 위 소개만 보면 안 쓸 이유가 없다.</em></h4><h3 id="2-Nuxt-시작하기"><a href="#2-Nuxt-시작하기" class="headerlink" title="2.Nuxt 시작하기"></a>2.Nuxt 시작하기</h3><p>Nuxt 기반의 application을 생성하기 위해서는 Vue CLI가 설치되어 있어야 한다.</p><h4 id="1-프로젝트-생성"><a href="#1-프로젝트-생성" class="headerlink" title="1) 프로젝트 생성"></a>1) 프로젝트 생성</h4><p>프로젝트 생성에는 총 3가지 방법이 있습니다.</p><h5 id="vue-cli를-통한-nuxt-js-설치"><a href="#vue-cli를-통한-nuxt-js-설치" class="headerlink" title="vue-cli를 통한 nuxt.js 설치"></a>vue-cli를 통한 nuxt.js 설치</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- vue cli 설치 --&gt;</span><br><span class="line">npm i -g @vue&#x2F;cli</span><br><span class="line">npm i -g @vue&#x2F;cli-init</span><br><span class="line"></span><br><span class="line">&lt;!-- nuxt 프로젝트 생성 및 의존성 모듈 설치 --&gt;</span><br><span class="line">vue init nuxt-community&#x2F;starter-template &lt;project-name&gt;</span><br><span class="line">cd &lt;project-name&gt;</span><br><span class="line">npm i</span><br><span class="line"></span><br><span class="line">&lt;!-- 패키지 매니저를 통한 nuxt 프로젝트 생성 --&gt;</span><br><span class="line">npx create-nuxt-app &lt;project-name&gt; </span><br><span class="line">yarn create nuxt-app &lt;project-name&gt;</span><br><span class="line">npm init nuxt-app &lt;project-name&gt;</span><br></pre></td></tr></table></figure><p>저는 vue-cli가 이미 설치된 환경에서 작업하고 있으므로 npx 패키지 매니저를 통해 nuxt application을 생성해보겠습니다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npx create-nuxt-app [프로젝트명]</span><br></pre></td></tr></table></figure><h4 id="2-프로젝트-설정"><a href="#2-프로젝트-설정" class="headerlink" title="2) 프로젝트 설정"></a>2) 프로젝트 설정</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">? Project name: [프로젝트명]</span><br><span class="line">? Programming language:</span><br><span class="line">&gt; JavaScript</span><br><span class="line">  TypeScript</span><br><span class="line">? Package manager:</span><br><span class="line">  Yarn</span><br><span class="line">&gt; Npm</span><br><span class="line">? UI framework:</span><br><span class="line">&gt; None</span><br><span class="line">  Ant Design Vue</span><br><span class="line">  Bootstrap Vue</span><br><span class="line">  Buefy</span><br><span class="line">  Bulma</span><br><span class="line">  Element</span><br><span class="line">  Framevuerk</span><br><span class="line">  iView</span><br><span class="line">  Tachyons</span><br><span class="line">  Tailwind CSS</span><br><span class="line">  Vuesax</span><br><span class="line">  Vuetify.js</span><br><span class="line">? Nuxt.js modules:</span><br><span class="line">? Choose custom server framework &lt;None (Recommended)&gt;</span><br><span class="line">&gt; None (Recommended)</span><br><span class="line">  AdonisJs</span><br><span class="line">  Express</span><br><span class="line">  Fastify</span><br><span class="line">  Feathers</span><br><span class="line">  hapi</span><br><span class="line">  Koa</span><br><span class="line">  Micro</span><br><span class="line">? Linting tools:</span><br><span class="line">(*) ESLint</span><br><span class="line">( ) Prettier</span><br><span class="line">( ) Lint staged files</span><br><span class="line">( ) StyleLint</span><br><span class="line">? Testing framework:</span><br><span class="line">  None</span><br><span class="line">&gt; Jest</span><br><span class="line">  AVA</span><br><span class="line">? Rendering mode: Universal (SSR &#x2F; SSG)</span><br><span class="line">&gt; Universal (SSR)</span><br><span class="line">  Single Page App</span><br><span class="line">? Deployment target: Server (Node.js hosting)</span><br><span class="line">? Development tools: (Press &lt;space&gt; to select, &lt;a&gt; to toggle all, &lt;i&gt; to invert selection)</span><br><span class="line">? Continuous integration: None</span><br><span class="line">? Version control system:</span><br><span class="line">&gt; Git</span><br><span class="line">  None</span><br></pre></td></tr></table></figure><h4 id="3-프로젝트-실행"><a href="#3-프로젝트-실행" class="headerlink" title="3) 프로젝트 실행"></a>3) 프로젝트 실행</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Successfully created project [프로젝트명]</span><br><span class="line"></span><br><span class="line">  To get started:</span><br><span class="line">cd [디렉토리명]</span><br><span class="line">npm run dev</span><br><span class="line"></span><br><span class="line">  To build &amp; start for production:</span><br><span class="line">cd [디렉토리명]</span><br><span class="line">npm run build</span><br><span class="line">npm run start</span><br><span class="line"></span><br><span class="line">  To test:</span><br><span class="line">cd [디렉토리명]</span><br><span class="line">npm run test</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">cd [디렉토리명] &amp;&amp; npm run dev</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="4-프로젝트-생성-디렉토리"><a href="#4-프로젝트-생성-디렉토리" class="headerlink" title="4) 프로젝트 생성 디렉토리"></a>4) 프로젝트 생성 디렉토리</h4><p>막 생성된 nuxt 프로젝트의 디렉토리는 아래와 같다. 디렉토리에 대한 정의를 잘 몰라도 이미 Vue.js를 사용했던 개발자라면 비슷한 구조이며 스캐폴딩이 이미 되어있다는 생각이 들것이다.<br><img src="/images/nuxt-directory.png" alt="nuxt 프로젝트 디렉토리"></p><p>여기까지 nuxt 프로젝트의 생성과 막 생성된 디렉토리까지 살펴봤습니다. 다음 포스트에서는 프로젝트의 디렉토리에 대해 살펴보겠습니다.</p><hr><h2 id="참조"><a href="#참조" class="headerlink" title="참조"></a>참조</h2><ul><li><a href="https://nuxtjs.org/docs/2.x/get-started/installation">Installation - Official NuxtJS</a></li><li><a href="https://kdydesign.github.io/2019/04/10/nuxtjs-tutorial/">[Nuxt.js] 개념부터 설치까지 빠르게 배우기</a></li><li><a href="https://adrian0220.tistory.com/195?category=813348">12.[Nuxt.js] 프로젝트, 설정, 라우팅</a></li><li><a href="https://khwan.kr/blog/vue/2020-03-02-nuxt-spa-ssr/">Nuxt로 알아보는 SPA, SSR 그리고 Static Web</a></li><li><a href="https://medium.com/vue-mastery/free-nuxt-js-tutorial-creating-an-app-1a531bc6045">Free Nuxt.js Tutorial — Vue Mastery Course</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;/images/nuxt.png&quot; alt=&quot;Nuxt.js&quot;&gt;&lt;/p&gt;
&lt;p&gt;포트폴리오용 nuxt 앱이 필요했던 참에 신규 프로젝트에서 nuxt로 어플리케이션을 제작해야해서 정리 및 공부겸 포스팅을 하기로 했다.&lt;/p&gt;
&lt;h3 id=</summary>
      
    
    
    
    <category term="Programming" scheme="https://joontae-kim.github.io/categories/Programming/"/>
    
    <category term="nuxt" scheme="https://joontae-kim.github.io/categories/Programming/nuxt/"/>
    
    
    <category term="vue.js" scheme="https://joontae-kim.github.io/tags/vue-js/"/>
    
    <category term="nuxt.js" scheme="https://joontae-kim.github.io/tags/nuxt-js/"/>
    
    <category term="vue" scheme="https://joontae-kim.github.io/tags/vue/"/>
    
    <category term="nuxt" scheme="https://joontae-kim.github.io/tags/nuxt/"/>
    
  </entry>
  
</feed>
