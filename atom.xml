<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>dev and dev</title>
  
  <subtitle>내가 볼려고 만든 깃헙 블로그</subtitle>
  <link href="https://joontae-kim.github.io/atom.xml" rel="self"/>
  
  <link href="https://joontae-kim.github.io/"/>
  <updated>2020-10-04T20:17:04.241Z</updated>
  <id>https://joontae-kim.github.io/</id>
  
  <author>
    <name>Joontae Kim</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>자바스크립트란?</title>
    <link href="https://joontae-kim.github.io/2020/10/03/with-javascript/"/>
    <id>https://joontae-kim.github.io/2020/10/03/with-javascript/</id>
    <published>2020-10-02T17:06:39.000Z</published>
    <updated>2020-10-04T20:17:04.241Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/javascript.png"></p><p>여러 프로젝트를 개발하면서 Javascript를 사용해왔고 그렇게 3년이 지나고 어느새 5년이라는 시간이 지났다. 그럼에도 불구하고 아직까지 Javascript에 대해 설명하려면 “어렵지만, 쉬운” 언어라는 말이 먼저 나오고, 공부를 하면 할수록 “내가 알고 있는것이 맞는가?”, “얼마나 알아야 기본은 아는것일까?”라는 당혹감?에 빠져 있었다. </p><p>그래서 이참에 내가 사용해왔고 알아왔던 <strong>Javascript</strong>에 대해 더 알아보려고 한다. 그리고 친해져보려고 한다.</p><h1 id="Javascript의-탄생"><a href="#Javascript의-탄생" class="headerlink" title="Javascript의 탄생"></a>Javascript의 탄생</h1><p> Javascript의 시작은 미국의 <a href="https://ko.wikipedia.org/wiki/%EB%84%B7%EC%8A%A4%EC%BC%80%EC%9D%B4%ED%94%84">넷스케이프 커뮤니케이션스(Netscape Communications)</a>가 1994년 말 출시한 모자이크 넷스케이프가 1990년대에 주된 웹 브라우저로 자리잡기 시작하자 웹이 더 동적으로 변화할 필요을 느끼며 이를 위한 글루 언어(glue language) 개발을 위해  <a href="https://ko.wikipedia.org/wiki/%EB%B8%8C%EB%A0%8C%EB%8D%98_%EC%95%84%EC%9D%B4%ED%81%AC">브렌던 아이크</a>를 영입하고 개발한 언어가 지금의 Javascript이다.</p><p> 사실 Javascript는 개발 당시 <strong>모카</strong>(Mocha)라는 이름으로 불려졌다. 그러나 1995년 9월 넷스케이프 내비게이터 2.0 브라우저의 베타 릴리스 때는 <strong>라이브스크립트</strong>(LiveScript)로 바뀌었고 그해 12월 넷스케이프 내비게이터 2.0 베타 3 릴리스 때 우리가 알고 있는 <strong>Javascript</strong>라는 이름으로 정식 채택되었다.</p><p>개발에 대해 모르거나 시작하는 사람들이 대게 햇갈려하는 Java와 Javascript의 혼란은 넷스케이프가 당시 인기있는 웹 프로그래밍 언어로서 자바스크립트를 내밀기 위한 것으로 마케팅적인 선택으로 보여진다. 그러나 기술적으론 Javascript와 Java는 객체 모델을 갖는다는 거외에는 근본적으로 다르다.</p><h3 id="표준화를-위한-작업-ECMAScript와-Javascript"><a href="#표준화를-위한-작업-ECMAScript와-Javascript" class="headerlink" title="표준화를 위한 작업, ECMAScript와 Javascript"></a>표준화를 위한 작업, ECMAScript와 Javascript</h3><p>Javascript의 동적 웹 페이지 조작이 흥행하자 Microsoft는 자신들의 브라우저인 Internet Explerer를 지원하기 위해 <a href="https://ko.wikipedia.org/wiki/J%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8">J스크립트</a>를 개발했고 1996년 8월에 출시된 <a href="https://ko.wikipedia.org/wiki/%EC%9D%B8%ED%84%B0%EB%84%B7_%EC%9D%B5%EC%8A%A4%ED%94%8C%EB%A1%9C%EB%9F%AC">인터넷 익스플로러</a> 브라우저 3.0부터 적용하기 시작합니다. 이는 경쟁적 위치를 선점하며 자신들의 브라우저에서만 동작하는 기능들을 추가하기 시작했다는 것을 의미하며 <strong>크로스 브라우징 이슈</strong>의 말초가 된다. 즉, Javascript의 파편화가 시작된 것이다. 이러한 현상은 Javascript의 발전을 저해하며 사용자들이 공통된 경험을 누리지 못하는 불편을 야기했다.</p><p> 바로 이러한 점을 해소하기 위해 만들어진 것이 <strong>ECMAScript</strong> 그리고 <strong>ECMA-262</strong> 로, Javascript의 표준 명세서로써 프로그래밍 언어의 타입, 값, 객체와 프로퍼티, 함수, 빌트인 객체 등 <em>핵심 문법(core syntax)</em> 을 규정하며 브라우저 제조사는 이를 준수하여 <strong>브라우저 내장 자바스크립트 엔진</strong>을 구현해야 한다. (<em><strong>ECMAScript</strong>에 대한 자세한 내용은 추후 포스팅하겠습니다</em>)</p><h1 id="Javascript의-발전"><a href="#Javascript의-발전" class="headerlink" title="Javascript의 발전"></a>Javascript의 발전</h1><p>JavaScript는 XMLHttpRequest, JSON, Ajax과 같은 기술들이 개발됨에 따라 버튼의 클릭에 따른 UI 변경, Form 유효성 검증과 같은 단순한 작업에서 XMLHttpRequest의 브라우저(IE5) 도입에 따른서버와 브라우저 간의 비동기 데이터 통신을 시작으로 활용 가능성이 넓어지기 시작했다.</p><ul><li>1999년, <strong>XMLHttpRequest</strong> API가 IE5에 도입됨</li><li>2001년, 더글러스 크락포드가 자바스크립트의 기존 텍스트 형식의 데이터 저장을 ‘<strong>JSON</strong>(Javascript Object Notation)’이라는 객체 문법의 구조화된 문자기 반의 표준 포맷을 개발</li><li>2005년, <strong>Ajax</strong>를 이용해 구글이 구글Maps를 소개. 불필요한 렌더링을 줄이며 서버로부터 필요한 데이터만을 요청해 갱신이 필요한 부분만 리렌더링하는 방식을 선보임</li><li>2006년, <strong>jQuery</strong>의 등장으로 핸들링 하기 어려웠던 DOM의 한계를 극복했으며 크로스 브라우징 이슈가 해결됨</li><li>2008년, 구글이 <strong>크롬 웹브라우저</strong> 함께 <strong>V8</strong>이라는 자바스크립트 엔진 발표하면서 보다 웹 어플리케이션 또한 데스크톱 어플리케이션과 유사한 사용자 경험을 제공할 수 있게 됨</li><li>2009년, <strong>Node.js</strong> 라는 Server-side에서도 활용할 수 있는 Javascript가 개발됨에 따라 Client-side에 한정된 Javascript의 영역을 확대함</li></ul><h1 id="Javascript의-정의와-특징"><a href="#Javascript의-정의와-특징" class="headerlink" title="Javascript의 정의와 특징"></a>Javascript의 정의와 특징</h1><p>Javascript는 <strong>“웹 브라우저에서 실행되는 유일한 클라이언트 사이드 프로그래밍 언어”</strong> 로써 쉽게 배우고, 빠르게 개발할 수 있다는 강력한 장점을 제공하지만 Javascript의 성격과 패러다임 그리고 어떤 기능적 특징을 갖고 있는지 이해하는 것은 여간 어려운 것이 아니다. 왜냐하면 기본 문법은 C, Java와 유사하고 프로토타입 기반의 상속은 Self에서, 일급 함수의 개념은 Scheme에서 차용하였듯 기존의 프로그래밍 언어에서 많은 영향을 받았기 때문이다.</p><blockquote><p>프로토타입 기반, 다중 패러다임 스크립트 언어이며, 동적이고 명령어, 객체 지향, 함수 프로그래밍 스타일을 지원한다.</p><footer><strong>JavaScript란 무엇인가?</strong><cite><a href="https://developer.mozilla.org/ko/docs/Web/JavaScript/About">developer.mozilla.org/ko/docs/Web/JavaScript/About</a></cite></footer></blockquote><h3 id="Javascript의-정의"><a href="#Javascript의-정의" class="headerlink" title="Javascript의 정의"></a>Javascript의 정의</h3><p>Javascript는 가벼운 인터프리터 또는 <a href="https://ko.wikipedia.org/wiki/JIT_%EC%BB%B4%ED%8C%8C%EC%9D%BC">JIT 컴파일</a> 프로그래밍 언어로 <a href="https://ko.wikipedia.org/wiki/%ED%94%84%EB%A1%9C%ED%86%A0%ED%83%80%EC%9E%85_%EA%B8%B0%EB%B0%98_%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D">prototype 기반의 객체 지향</a> 패러다임을 바탕으로 하는 인터프리터 언어이자 기존의 웹 브라우저 뿐만이 아니라 서버사이드에서도 작동하는 크로스 플랫폼 언어이다.</p><h3 id="Javascript의-특징"><a href="#Javascript의-특징" class="headerlink" title="Javascript의 특징"></a>Javascript의 특징</h3><ol><li>일급 함수 사용<ul><li>Scheme의 일급 함수 개념을 차용했으며 이를 통해 <strong>고차 함수(high order function)</strong> 가 가능하다. </li><li>즉,  Javascript의 Array Method 중 each, filter, map과 같은 함수의 인자로 함수를 받는 형태를 말한다. </li></ul></li><li>가벼운 인터프리터 또는 <a href="https://ko.wikipedia.org/wiki/JIT_%EC%BB%B4%ED%8C%8C%EC%9D%BC">JIT 컴파일</a> 프로그래밍 언어<ul><li>Javascript는 인터프리터 언어로서 브라우저에서 동작하기 전에 다른 컴파일러를 통해 코드를 변환할 필요가 없으며 코드가 위에서 아래로 순차적으로 실행되고 결과를 즉시 반환한다.</li><li>모던 웹 브라우저에 JIT 컴파일러(Just In Time Compiler)가 내장되어 실행 시점에서 인터프리트 방식으로 기계어 코드를 생성하면서 그 코드를 캐싱하여, 같은 함수가 여러 번 불릴 때 매번 기계어 코드를 생성하는 것을 방지한다.</li></ul></li><li>프로토타입 기반의 객체 지향 언어<ul><li>클래스가 없으며 클래스 기반 언어에서 상속을 사용하는 것과 다르게 <a href="https://ko.wikipedia.org/wiki/%EA%B0%9D%EC%B2%B4_(%EC%BB%B4%ED%93%A8%ED%84%B0_%EA%B3%BC%ED%95%99)">객체</a>를 원형으로 하여 복제의 과정을 통해 객체의 동작 방식을 다시 사용할 수 있다. 이는 클래스 기반 프로그래밍 언어인 Java와도 다른 점이다.</li><li>객체 생성 시에 클래스로부터 그 내용을 상속받아서 객체를 만드는 것이 아니라, 객체로부터 그 특성을 복제하여 새로운 객체를 생성하기 때문에 런타임 중에도 객체의 속성과 값을 추가하거나 변경하고, 삭제까지 가능합니다. </li></ul></li><li><a href="https://ko.wikipedia.org/wiki/%EB%AA%85%EB%A0%B9%ED%98%95_%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D">명령형(imperative)</a>, <a href="https://ko.wikipedia.org/wiki/%ED%95%A8%EC%88%98%ED%98%95_%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D">함수형(functional)</a>을 지원하는 다중 패러다임 스크립트 언어</li><li>동적이고 명령어, 객체 지향, 함수 프로그래밍 스타일을 지원<ul><li>Javascript는 다른 언어들과 다르게 변수, 매개변수 및 함수의 반환 값의 타입을 명시적으로 지정하지 않아도 된다는 특징을 가지며 이는 프로토타입 기반 모델이 동적 상속을 제공하기 때문이다. 따라서 함수는 객체의 속성이나 타입이 느슨하게 지정된채 실행되는 메소드가 될 수 있다.</li></ul></li><li><a href="http://www.instantweb.com/~foldoc/foldoc.cgi?query=procedural&action=Search">절차지향 (procedural)</a> 언어와 <a href="http://www.instantweb.com/~foldoc/foldoc.cgi?query=object+oriented&action=Search">객체지향 (object oriented)</a> 언어 두가지 형태로 개발 가능함</li></ol><hr><h2 id="참고"><a href="#참고" class="headerlink" title="참고"></a>참고</h2><ul><li><p><a href="https://ko.wikipedia.org/wiki/%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8">자바스크립트 - wikipedia.org</a></p></li><li><p><a href="https://developer.mozilla.org/ko/docs/Web/JavaScript/Guide/%EC%86%8C%EA%B0%9C">자바스크립트 Guide 소개 - mdn</a></p></li><li><p><a href="https://ko.javascript.info/intro#ref-390">자바스크립트란? - ko.javascript.info</a></p></li><li><p><a href="https://ko.wikipedia.org/wiki/ECMA%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8">ECMA스크립트 - wikipedia.org</a></p></li><li><p><a href="https://poiemaweb.com/js-introduction">자바스크립트란? - poiemaweb</a></p></li><li><p><a href="https://kangax.github.io/compat-table/es6/">es6 compatibility table - compat-table</a></p></li><li><p><a href="https://valuefactory.tistory.com/610">Javascript 버전별 표준</a></p></li><li><p><a href="https://en.wikipedia.org/wiki/ECMAScript">ECMAScript - en.wikipedia.org</a></p></li><li><p><a href="https://en.wikipedia.org/wiki/XMLHttpRequest#History">XMLHttpRequest - en.wikipedia.org</a></p></li><li><p><a href="https://edu.goorm.io/learn/lecture/557/%ED%95%9C-%EB%88%88%EC%97%90-%EB%81%9D%EB%82%B4%EB%8A%94-node-js/lesson/174353/%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8%EC%9D%98-%EC%97%AD%EC%82%AC">자바스크립트의 역사 - edu.goorm.io</a></p></li><li><p><a href="https://ko.wikipedia.org/wiki/%ED%94%84%EB%A1%9C%ED%86%A0%ED%83%80%EC%9E%85_%EA%B8%B0%EB%B0%98_%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D">프로토타입 기반 프로그래밍 - wikipedia.org</a></p></li><li><p><a href="https://brownbears.tistory.com/407">절차지향 vs 객체지향</a></p></li><li><p><a href="https://ko.wikipedia.org/wiki/JIT_%EC%BB%B4%ED%8C%8C%EC%9D%BC">JIT 컴파일 - wikipedia.org</a></p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;/images/javascript.png&quot;&gt;&lt;/p&gt;
&lt;p&gt;여러 프로젝트를 개발하면서 Javascript를 사용해왔고 그렇게 3년이 지나고 어느새 5년이라는 시간이 지났다. 그럼에도 불구하고 아직까지 Javascript에 대해 설</summary>
      
    
    
    
    <category term="Programming" scheme="https://joontae-kim.github.io/categories/Programming/"/>
    
    <category term="Javascript" scheme="https://joontae-kim.github.io/categories/Programming/Javascript/"/>
    
    
    <category term="javascript" scheme="https://joontae-kim.github.io/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>01. javascript</title>
    <link href="https://joontae-kim.github.io/2020/10/01/node-all-in-one-javascript-1/"/>
    <id>https://joontae-kim.github.io/2020/10/01/node-all-in-one-javascript-1/</id>
    <published>2020-10-01T08:07:32.000Z</published>
    <updated>2020-10-01T11:13:58.120Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/course.png"></p><h4 id="01-Javascript-란"><a href="#01-Javascript-란" class="headerlink" title="01. Javascript  란"></a>01. Javascript  란</h4><ul><li><p>브라우저를 제어하기 위한 넷스케이프에서 개발한 언어</p></li><li><p>사용자의 클릭, 계산기 등의 이벤트 조작에 대응하기 위한 언어</p></li><li><p>자바스크립트의 확대</p><ul><li>Ajax 활용 (구글맵)</li><li>디버깅툴의 발전<ul><li>파이어폭스의 콘솔로그</li></ul></li><li>크롬의 V8 엔진 개발</li><li>V8 엔진 기반의 서버 사이드 javascript 개발<ul><li>Node.js</li></ul></li><li>여러 플랫폼에서 js 기반의 환경 조성<ul><li>Desktop, IOT 등에서</li></ul></li></ul></li><li><p>변수형</p><ul><li><p>js는 동적언어이므로 자료형을 선언할 필요가 없음</p></li><li><p>기본 자료형과 객체(Object) 두가지로 나뉨</p><table><thead><tr><th>기본자료형</th><th>설명</th></tr></thead><tbody><tr><td>Boolean</td><td>논리적 요소 (true / false)</td></tr><tr><td>Null</td><td>객체 값이 존재하지 않는다는 의미</td></tr><tr><td>Undefined</td><td>값을 할당하지 않음</td></tr><tr><td>Number</td><td>숫자형</td></tr><tr><td>String</td><td>문자형</td></tr><tr><td>Symblo</td><td>ECMAScript 6에서 추가, 유일하고 변경 불가</td></tr></tbody></table></li></ul></li></ul><hr><h4 id="02-배열"><a href="#02-배열" class="headerlink" title="02. 배열"></a>02. 배열</h4><ul><li>배열도 기본 자료형 중에 하나</li><li>예제: <code>[&#39;안녕&#39;, &#39;Node.js&#39;, 55, &#39;Hello&#39;]</code></li><li>위와 같이, 문자형과 숫자형이 섞여있든 요소에 대한 자료형이 통일되지 않아도 되는 구조</li><li>배열에는 인덱싱이라는게 있음<ul><li>예제의 <code>&#39;안녕&#39;</code>을 기준으로 인덱싱이 <code>0</code> 이 되며 차례대로 1,2,3 ….</li></ul></li><li>배열의 인덱싱을 통해 <strong>overwrite</strong> 가능<ul><li><code>example[0] = &#39;Hi&#39;</code></li></ul></li></ul><hr><h4 id="03-반복문"><a href="#03-반복문" class="headerlink" title="03. 반복문"></a>03. 반복문</h4><ul><li><p>대표적으로 <code>for</code>, <code>while</code>, <code>do-while</code> 문이 있음</p></li><li><p>for 문</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i&lt;<span class="number">10</span>; i++) &#123;</span><br><span class="line">  <span class="comment">// .....</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>while 문</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> i = <span class="number">0</span> <span class="comment">// 초기화 조건</span></span><br><span class="line"><span class="keyword">while</span> (i &lt; <span class="number">10</span>) &#123;</span><br><span class="line">  <span class="comment">// .....</span></span><br><span class="line">  i = i+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>do .. while 문</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">  <span class="comment">// .....</span></span><br><span class="line">  i = i + <span class="number">1</span>;</span><br><span class="line">&#125; <span class="keyword">while</span> (i &lt; <span class="number">5</span>)</span><br></pre></td></tr></table></figure></li><li><p><code>while</code> 문과 <code>do ... while</code> 문의 차이는 </p><ul><li><code>while</code> 의 조건문을 언제 시작하느냐</li><li><code>do ... while</code> 의 경우 일단 <code>do &#123; ... &#125;</code> 문을 실행한 뒤 <code>while</code>  문을 실행</li></ul></li></ul><hr><h4 id="04-함수"><a href="#04-함수" class="headerlink" title="04. 함수"></a>04. 함수</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Car 라는 틀(prototype) 생성</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Car</span> (<span class="params">a, b, c</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// function의 member 선언</span></span><br><span class="line">  <span class="comment">// this는 public 변수</span></span><br><span class="line">  <span class="built_in">this</span>.name = a;</span><br><span class="line">  <span class="built_in">this</span>.color = b;</span><br><span class="line">  <span class="comment">// var 등 함수내에서 선언된 변수들은 private 변수라 함.</span></span><br><span class="line">  <span class="keyword">var</span> move = c</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 객체 생성 , 변수 a는 Car의 인스턴스</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> Car(<span class="string">&#x27;현대&#x27;</span>, <span class="string">&#x27;노랑&#x27;</span>, <span class="string">&#x27;전진&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(a.name)</span><br><span class="line"><span class="comment">// 현대</span></span><br><span class="line"><span class="built_in">console</span>.log(a.color)</span><br><span class="line"><span class="comment">// 노랑</span></span><br><span class="line"><span class="built_in">console</span>.log(a.move)</span><br><span class="line"><span class="comment">// undefined =&gt; 왜냐하면 private 변수로 선언되었기 때문</span></span><br></pre></td></tr></table></figure><hr><h4 id="05-프로토타입"><a href="#05-프로토타입" class="headerlink" title="05. 프로토타입"></a>05. 프로토타입</h4><ul><li><p>js는 프로토타입 기반 언어이다.</p></li><li><p>예제</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Car</span> (<span class="params">a, b, c</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// function의 member 선언</span></span><br><span class="line">  <span class="comment">// this는 public 변수</span></span><br><span class="line">  <span class="built_in">this</span>.name = a;</span><br><span class="line">  <span class="built_in">this</span>.color = b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 객체 생성 , 변수 a는 Car의 인스턴스</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> Car(<span class="string">&#x27;현대&#x27;</span>, <span class="string">&#x27;노랑&#x27;</span>);</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>자바스크립트는 <code>Car</code> 에 <strong>프로토타입</strong> 이라는 것이 있음</p><ul><li><p><strong>프로토타입</strong>을 기준으로 <strong>객체</strong>. 즉, <strong>인스턴스</strong>를 생성</p></li><li><p>예제</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Car.prototype.move = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// Car의 prototype에 접근해 함수를 추가</span></span><br><span class="line">   <span class="built_in">console</span>.log(<span class="built_in">this</span>.name + <span class="string">&#x27;차이고&#x27;</span>+ <span class="built_in">this</span>.name + <span class="string">&#x27;색이다&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">a.move()</span><br><span class="line"><span class="comment">// 현대차이고 노랑색입니다.</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Car.prototype.move = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// Car의 prototype에 접근해 함수를 추가</span></span><br><span class="line">   <span class="built_in">console</span>.log(<span class="built_in">this</span>.name + <span class="string">&#x27;차이고&#x27;</span>+ <span class="built_in">this</span>.name + <span class="string">&#x27;색이다&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">a.move()</span><br><span class="line"><span class="comment">// 현대차이고 노랑색입니다.</span></span><br></pre></td></tr></table></figure></li></ul></li></ul><ul><li><p>예제</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>]</span><br><span class="line"><span class="comment">// 배열의 prototype에 접근해 커스텀 함수 추가</span></span><br><span class="line"><span class="built_in">Array</span>.prototype.print = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">0</span>;i &lt; <span class="built_in">this</span>.length; i++) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>[i])</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">a.print()</span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 3</span></span><br><span class="line"><span class="comment">// 5</span></span><br><span class="line"><span class="comment">// 7</span></span><br><span class="line"><span class="comment">// 9</span></span><br></pre></td></tr></table></figure></li></ul><hr><h3 id="보충해서-볼것"><a href="#보충해서-볼것" class="headerlink" title="보충해서 볼것"></a>보충해서 볼것</h3><ul><li>변수형</li><li>프로토타입</li><li>함수 선언식과 표현식</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;/images/course.png&quot;&gt;&lt;/p&gt;
&lt;h4 id=&quot;01-Javascript-란&quot;&gt;&lt;a href=&quot;#01-Javascript-란&quot; class=&quot;headerlink&quot; title=&quot;01. Javascript  란&quot;&gt;&lt;/a&gt;0</summary>
      
    
    
    
    <category term="course" scheme="https://joontae-kim.github.io/categories/course/"/>
    
    <category term="node_all_in_one" scheme="https://joontae-kim.github.io/categories/course/node-all-in-one/"/>
    
    
    <category term="course,javascript" scheme="https://joontae-kim.github.io/tags/course-javascript/"/>
    
  </entry>
  
  <entry>
    <title>Hexo로 글 작성하기</title>
    <link href="https://joontae-kim.github.io/2020/09/29/hexo-writing/"/>
    <id>https://joontae-kim.github.io/2020/09/29/hexo-writing/</id>
    <published>2020-09-29T12:16:43.000Z</published>
    <updated>2020-10-01T07:40:40.849Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/hello_hexo.png"></p><p>Hexo는 간단하고 파워풀한 프레임워크로써, 마크다운 문법을 통해 포스트를 작성하면 theme와 함께 정적 웹사이트를 만들 수 있습니다. 설치와 설정 그리고 theme 등 공식문서를 잘 읽어보면 더 유용한 기능들이 많으며 이번 포스팅에서는 Hexo 명령어를 통해서 글 작성하는 법 즉, 포스트를 생성하고 배포하는 법을 다뤄보겠습니다.</p><h3 id="명령어"><a href="#명령어" class="headerlink" title="명령어"></a>명령어</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hexo <span class="keyword">new</span> [layout] &lt;title&gt;</span><br><span class="line">hexo <span class="keyword">new</span> &lt;title&gt; <span class="comment">// layout을 생략할 경우 default_layout으로 새로운 마크다운 파일이 생성됨.</span></span><br></pre></td></tr></table></figure><p>Hexo 에서 새 포스트나 페이지를 생성하기 위한 명령어로 기본 <code>layout</code> 은 <strong>post</strong> 이지만 블로그의 <code>_config.yml</code> 에서 <code>default_layout</code> 을 변경하면 기본 생성 layout 유형이 바뀝니다.</p><h3 id="Layout"><a href="#Layout" class="headerlink" title="Layout"></a>Layout</h3><p>Hexo에서는 아래와 같이 3개의 기본 레이아웃을 제공하며 생성된 파일들은 서로 다른 경로에 저장됩니다.</p><table><thead><tr><th>종류</th><th>정의</th><th>생성 경로</th></tr></thead><tbody><tr><td>post</td><td>블로그에 바로 발행 가능한 레이아웃</td><td><code>source/_posts</code></td></tr><tr><td>draft</td><td>post 처럼 바로 게시하지 않고 작성할 수 있는 초안</td><td><code>source/_drafts</code></td></tr><tr><td>page</td><td>post 처럼 하나의 게시물이 아닌 하나의 페이지를 생성</td><td><code>source</code></td></tr></tbody></table><h3 id="Scaffold-레이아웃-파일-생성"><a href="#Scaffold-레이아웃-파일-생성" class="headerlink" title="Scaffold - 레이아웃 파일 생성"></a>Scaffold - 레이아웃 파일 생성</h3><p>포스트 생성 시 Hexo는 <code>scaffolds</code> 폴더 내의 적당한 파일을 기반으로 구성하며 기본적으로 각 레이아웃 이름의 마크다운 문서 이름을 참고한다. 예를 들어 <code>hexo new post &quot;newPost&quot; </code> 라는 명령어는 <code>scaffolds/post</code> 파일의 placeholder를 사용하여 새로운 마크다운 문서를 생성할 수 있습니다.</p><p>예를 들어,  <code>scaffolds/post.md</code> 파일이 아래와 같다면,  <code>hexo new post &quot;newPost&quot; </code>  를 통해 <code>newPost.md</code> 가 생성된</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">title:</span> &#123;&#123; <span class="string">title</span> &#125;&#125;</span><br><span class="line"><span class="attr">categories:</span> &#123;&#123; <span class="string">categories</span> &#125;&#125;</span><br><span class="line"><span class="attr">tags:</span> &#123;&#123; <span class="string">tags</span> &#125;&#125;</span><br><span class="line"><span class="attr">date:</span> &#123;&#123; <span class="string">date</span> &#125;&#125;</span><br><span class="line"><span class="attr">thumbnail:</span> &#123;&#123; <span class="string">thumbnail</span> &#125;&#125;</span><br></pre></td></tr></table></figure><p>파일의 <em>placeholder</em> 는 아래와 같이 채워진다. 즉, 레이아웃에 따른 common yaml 포맷 또는 placeholder가 있다면 scaffolds의 레이아웃 폴더에 기재함으로써 편리하고 공통의 포맷을 유지할 수 있다.</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">title:</span> <span class="string">newPost</span></span><br><span class="line"><span class="attr">date:</span> <span class="number">2020-09-29 21:16:43</span></span><br><span class="line"><span class="attr">subtitle:</span> </span><br><span class="line"><span class="attr">categories:</span></span><br><span class="line"><span class="attr">tags:</span></span><br><span class="line"><span class="attr">thumbnail:</span></span><br></pre></td></tr></table></figure><h3 id="Draft에-대해서"><a href="#Draft에-대해서" class="headerlink" title="Draft에 대해서"></a>Draft에 대해서</h3><p>위에서 설명했듯이 <code>Draft</code>는 바로 게시하지 않고 작성할 수 있는 초안입니다. <code>Draft</code>를 사용하며 편리했던 점은 연속으로 게시해야 되는 포스트를 한번에 작성한 후 순차적으로 게시해야 할때 <code>hexo publish (파일 이름)</code> 명령어로 하나씩 <code>Post</code>로 발행해 배포하면 된다는 점입니다.</p><p>아래는 제가 설정했던 <code>Draft</code> 관련 설정과 명령어 입니다.</p><ul><li><p><strong><code>Draft</code>를 기본 레이아웃으로 변경하기</strong><br>_config.yml에서 <code># Writing</code>이라는 주석처리된 섹션에서 <code>default_layout</code> 필드를 초기값인 <code>post</code>에서 <code>draft</code>로 변경하면 됩니다.<br><img src="https://i.imgur.com/ziwu8zX.png" alt="스크린샷 2018-08-27 오후 7.07.45"></p></li><li><p><strong>로컬 서버에서 <code>Draft</code> 문서 띄우기</strong><br>작성 중인 Draft 문서를 확인할 수 있는데 아래와 같이 <code>--draft</code> 옵션을 주면 로컬 서버에서도 확인할 수 있습니다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo server --draft</span><br></pre></td></tr></table></figure></li></ul><h3 id="Draft-발행하기"><a href="#Draft-발행하기" class="headerlink" title="Draft 발행하기"></a>Draft 발행하기</h3><p>Draft 작성이 완료되었다면 이제 발행해야 하는데 아래의 순서와 같이 진행하면 된다.</p><ul><li><p><strong><code>Draft</code> 문서를 <code>Post</code> 레이아웃으로 변환하기</strong><br>사실 변환이라고 대단한건 아니고 그저 <code>_drafts</code> 디렉토리에서 <code>_posts</code> 디렉토리로 이동하면서 작성일시가 추가되는 것이 전부이다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo publish (Draft 이름)</span><br></pre></td></tr></table></figure></li></ul><ul><li><p><strong>배포하기</strong><br>아래 명령어를 통해 배포 가능하다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo deploy 또는 hexo g -d</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;/images/hello_hexo.png&quot;&gt;&lt;/p&gt;
&lt;p&gt;Hexo는 간단하고 파워풀한 프레임워크로써, 마크다운 문법을 통해 포스트를 작성하면 theme와 함께 정적 웹사이트를 만들 수 있습니다. 설치와 설정 그리고 theme 등</summary>
      
    
    
    
    <category term="Blog" scheme="https://joontae-kim.github.io/categories/Blog/"/>
    
    <category term="Hexo" scheme="https://joontae-kim.github.io/categories/Blog/Hexo/"/>
    
    
    <category term="Hexo" scheme="https://joontae-kim.github.io/tags/Hexo/"/>
    
    <category term="Blog" scheme="https://joontae-kim.github.io/tags/Blog/"/>
    
    <category term="draft" scheme="https://joontae-kim.github.io/tags/draft/"/>
    
  </entry>
  
  <entry>
    <title>Critical Rendering Path</title>
    <link href="https://joontae-kim.github.io/2020/09/27/critical-rendering-path/"/>
    <id>https://joontae-kim.github.io/2020/09/27/critical-rendering-path/</id>
    <published>2020-09-26T17:50:58.000Z</published>
    <updated>2020-09-28T18:54:52.957Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/browser_work.png"></p><blockquote><p>본 글은 <a href="https://developer.mozilla.org/en-US/"><strong>mdn web docs</strong></a>의 <a href="https://developer.mozilla.org/en-US/docs/Web/Performance/Critical_rendering_path#Understanding_CRP">Critical Rendering Path</a>를 번역한 글입니다.</p></blockquote><p>현재 작성일자(2020년 9월 27일) 기준으로 아직 한글로 번역되지 않아 본 번역 포스팅을 완료하면 해당 페이지를 한국어로 옮겨놓을 예정입니다. 수정 및 보완사항이 있다면 본 포스팅 하단 댓글에 작성 부탁드립니다.</p><hr><p>브라우저 작동 원리 또는 렌더링에 관해 공부하고, 포스팅하고 싶은 마음이 있었는데 mdn에 좋은 게시물이 많이 있었고 그중 몇 가지를 연재로 번역하면서 공부해보는 시간을 가져볼려고 합니다.</p><h4 id="연재할-MDN-docs"><a href="#연재할-MDN-docs" class="headerlink" title="연재할 MDN docs"></a>연재할 MDN docs</h4><ol><li><a href="https://developer.mozilla.org/ko/docs/Web/Performance/%EB%B8%8C%EB%9D%BC%EC%9A%B0%EC%A0%80%EB%8A%94_%EC%96%B4%EB%96%BB%EA%B2%8C_%EB%8F%99%EC%9E%91%ED%95%98%EB%8A%94%EA%B0%80">Populating the page: how browsers work</a></li><li><a href="https://developer.mozilla.org/en-US/docs/Web/Performance/Critical_rendering_path#Understanding_CRP"><strong>Critical rendering path</strong></a></li></ol><hr><h1 id="중요-렌더링-경로"><a href="#중요-렌더링-경로" class="headerlink" title="중요 렌더링 경로"></a>중요 렌더링 경로</h1><p>중요 렌더링 경로 (<em>Critical Rendering Path</em>)는 브라우저가 HTML, CSS, Javascipt를 화면에 픽셀로 변화하는 일련의 단계를 말하며 이를 최적화하는 것은 렌더링 성능을 향상시킵니다. 중요 렌더링 경로는  <a href="https://developer.mozilla.org/en-US/docs/Web/API/Document_Object_Model">Document Object Model </a>(DOM), <a href="https://developer.mozilla.org/en-US/docs/Web/API/CSS_Object_Model">CSS Object Model </a>(CSSOM), 렌더 트리 그리고 레이아웃을 포함합니다.</p><p>도큐먼트 오브젝트 모델은 HTML을 분석함으로써 만들어집니다. HTML은 Javascript를 요청할 수 있으며, 이 경우 DOM 이 변경될 수 있습니다. HTML은 차례대로 CSS 오브젝트 모델을 만들기 위한 스타일에 대한 요청을 만들거나 포함합니다. 브라우저 엔진은 이 두가지를 결합하여 렌더 트리를 생성하며 레이아웃은 페이지의 모든 것에 대한 크기와 위치를 결정합니다. 일단 레이아웃이 결정되면 화면에 픽셀을 그립니다.</p><p>중요 렌더링 경로 최적화는 첫번째 렌더링의 시간을 개선시킵니다. 중요 렌더링 경로를 이해하고, 최적화 하는 것은 뛰어난 사용자 상호작용을 보장하며 버벅거림을 피할 수 있도록 하고, 1초당 60 프레임에 리플로우와 리페인트가 발생할 수 있도록 하는데 중요합니다.</p><h2 id="CRP-이해하기"><a href="#CRP-이해하기" class="headerlink" title="CRP 이해하기"></a>CRP 이해하기</h2><p>웹 성능은 서버의 요청과 응답, 로딩, 스크립팅, 렌더링, 레이아웃 그리고 화면에 픽셀 그리기를 포함합니다.</p><p>웹 페이지 또는 어플리케이션에 대한 요청은 HTML 요청으로 시작됩니다. 서버는 응답 헤더 또는 데이터로 HTML을 반환합니다. 그리고 나서 브라우저는 HTML을 분석하고 수신된 바이츠를 DOM 트리로 변환하기 시작합니다. 브라우저는 스타일시트, 스크립트 또는 포함된 이미지 참조인 외부 자원에 대한 링크를 찾을때마다 요청을 시작합니다. 불러온 에셋을 다룰 때까지 나머지 HTML을 분석하는 작업하는 일부 요청은 중단되며 차단됩니다. 브라우저는 CSS 오브젝트 모델을 구축하는 작업이 끝날때까지 요청을 만들고 DOM을 생성하는 HTML을 계속해서 분석합니다. DOM과 CSSOM이 완료되면 브라우저는 렌더 트리를 생성하고 보여지는 컨텐츠를 위해 스타일을 계산합니다. 렌더트리가 완료된 후 모든 렌더 트리 요소들에 대한 위치와 크기가 정의된 레이아웃이 만들어집니다. 일단 완료되면 레이지는 렌더링되거나 또는 화면에 ‘그려집니다(<em>painted</em>)’.</p><h3 id="Document-Object-Model"><a href="#Document-Object-Model" class="headerlink" title="Document Object Model"></a>Document Object Model</h3><p>DOM 구성은 점진적으로 증가합니다. HTML 응답은 토큰으로, 토큰은 노드로, 노드는 DOM 트리로 변환됩니다.1개의 DOM 노드는 시작태그 토큰으로 시작해서 끝태그 토큰으로 끝납니다. 노드들은 HTML 요소에 대한 모두 연관성 있는 정보를 포함하고 있습니다. 그 정보는 토큰을 통해 설명됩니다. 노드들은 토큰의 위계서열을 기반으로 DOM 트리안에 연결됩니다. 만약 또 다른 시작태그와 끝태그의 묶음이 한 세트의 시작태그와 끝태그 사이에 있다면, 여러분은 DOM 트리의 위계서열을 정의하는 방법으로 노드 안에 노드를 가지게 됩니다.</p><p>많은 수의 노드는 중요 렌더링 경로에서 다음의 이벤트를 더 오래 발생시킬 것입니다. 측정하세요! 몇 개의 추가 노드는 차이를 만들지 않지만 전염은 버벅거림을 유발할 수 있습니다.</p><h3 id="CSS-Object-Model"><a href="#CSS-Object-Model" class="headerlink" title="CSS Object Model"></a>CSS Object Model</h3><p>DOM은 페이지의 모든 컨텐츠를 포함하고, CSSOM은 DOM을 스타일링 하기 위한 페이지의 모든 스타일 정보를 포함합니다. CSSOM은 DOM과 유사하지만 다릅니다. DOM의 구조는 점진적으로 증가하는 반면에 CSSOM은 그렇지 않습니다. CSS는 렌더링을 막습니다: 브라우저는 모든 CSS를 처리하고 수신할때까지 페이지 렌더링을 막습니다. CSS는 규칙을 덮어쓸수 있기 때문에 렌더링을 막습니다. 그러므로 CSSOM이 완료될때까지 콘텐츠를 렌더링 할 수 없습니다.</p><p>CSS는 유효한 토크들은 인식하기 위해 스스로 규칙 세트를 가지고 있습니다. CSS의 C가 ‘Cascade(종속 또는 폭포)’라는 의미를 기억해두세요. CSS 규칙은 아래로 종속됩니다. 분석기는 토큰을 노드로 변환할때, 하위 노드가 스타일을 상속합니다. 연속적인 규칙들이 이전의 규칙들에 덮어쓰여질 수 있기 때문에, 증감 처리 기술은 HTML 처럼 CSS에 적용되지는 않습니다. CSS 개체 모델은 CSS를 분석할 때 빌드되지만 나중에 분석되 덮어쓸 스타일들은 화면에 렌더링 할 수 없기 때문에 완전히 분석될 때까지 렌더 트리를 생성하는데 사용할 수 없습니다. </p><p>선택자 성능 측면에서, 덜 구체적인 선택자는 더 구체적인 선택자보다 더 빠릅니다. 예를 들어, 브라우저가 <code>.foo</code> 찾을때,  <code>.foo &#123;&#125;</code> 는  <code>.bar .foo &#123;&#125;</code> 보다 빠릅니다. 왜냐하면 두번째 시나리오에서, <code>.foo</code> 가 부모 객체인 <code>.bar</code> 를 가지고 있는지 확인하기 위해 DOM을 거슬러 올라가기 때문입니다. 더 구체적인 태그는 브라우저에게 더 많은 작업을 요구하지만 이러한 패널티는 최적화 할 가치가 없습니다.</p><p>만약 CSS 분석 시간을 측정한다면, 브라우저들이 정말 빠르다는 것에 놀랄 것입니다. 규칙이 구체적일수록 DOM 트리 안에서 더 많은 노드들은 지나야 하기 때문에 더 높은 비용이 듭니다. 그러나 추가적인 비용은 일반적으로 최소입니다. 첫번째는 측정입니다. 필요할때 최적화하세요. 특정 짓는 것은 쉬운 일이 아닙니다. CSS 측면에서, 선택자 성능 최적화와 개선은 오직 microsecond 밖에 되지 않될 것입니다. 축소화와 미디어 쿼리를 사용함으로써 지연된 CSS를 논-블로킹 요청으로 분리하는 것과 같은 <a href="https://developer.mozilla.org/en-US/docs/Learn/Performance/CSS_performance">CSS 최적화</a>를 위한 다른 방법이 있습니다.</p><h3 id="렌더-트리"><a href="#렌더-트리" class="headerlink" title="렌더 트리"></a>렌더 트리</h3><p>렌터 트리는 콘텐츠와 스타일 둘다 캡쳐합니다. DOM과 CSSOM 트리는 렌더 트리에 결합됩니다. 렌더 트리를 구성하기 위해 브라우저는 DOM 트리의 root에서 시작해 모든 노드는 확인하면서 어떤 CSS 규칙들을 첨부할지 결정합니다.</p><p>렌더 트리는 오직 보여지는 콘텐츠만은 캡쳐합니다. (일반적으로) 헤드 섹션은 보여지는 정보를 포함하고 있지 않으므로 렌더트리 안에 포함되지 않습니다. 만약 요소에 <code> display: none</code> 이 적용되어 있다면, 해당 요소 또는 하위 요소는 포함되지 않습니다.</p><h3 id="레이아웃"><a href="#레이아웃" class="headerlink" title="레이아웃"></a>레이아웃</h3><p>일단 렌더 트리가 생성되고 나면, 레이아웃은 가능해지며 화면의 크기에 의존합니다. 레이아웃 단계는 요소들이 페이지에서 배치되는 위치와 방법, 각 요소의 너비와 높이 그리고 서로 관련된 위치를 결정합니다.</p><p>요소의 너비는 무엇일까요? 정의에 따르면, 블럭 수준의 요소들은 그 부모 너비의 기본 너비값의 100% 입니다. 50%의 너비를 갖는 요소는 부모 요소의  절반일 것입니다. 비록 그렇게 정의되어 있지 않더라고, <code>body</code> 는 뷰포트 너비의 100%를 의미하는 너비 입니다. 디바이스의 너비는 레이아웃에 영향을 미칩니다.</p><p>뷰포트 메타 태그는 레이아웃에 영향을 미치는 뷰포트 레이아웃의 너비로 정의합니다. 이 태그 없다면, 브라우저는 뷰포트 기본값을 사용합니다. 브라우저의 full screen 기본값은 일반적으로 960px 입니다. 기본적으로 브라우저의 full screen에서, 스마트폰의 브라우저와 같은 너비는 <code>&lt;meta name=&quot;Viewport&quot; content=&quot;width=device-witdh&quot;&gt;</code> 로 세팅함으로써 기본 뷰포트 너비 대신에 디바이스의 너비를 사용합니다. 디바이스 너비는 사용자가 디비이스를 가로(landscapre) 또는 세로(portrait) 모드 사이로 돌릴때마다 바뀝니다. 레이아웃은 디바이스가 회전하거나 브라우저의 사이즈가 조정될 때마다 발생합니다.</p><p>레이아웃 성능은 DOM의 영향을 받습니다. 노드의 수가 많을수록 레이아웃은 더 길어지며 스크롤링 또는 다른 애니메이션들이 필요하다면 레이아웃에 쟁크(jank)를 일으키는 병목현상이 발생할 수 있습니다. 로딩 또는 방향 전환에 20ms 정도 밀릴 수 있지만 애니메이션 또는 스크롤에 쟁크(jank) 유발할 수 있습니다. 노드에 박스 모델 업데이트, 콘텐츠 대체 그리고 노드 추가와 같은 수정은 언제든지 렌더 트리를 수정할 수 있으며 레이아웃을 형성합니다. 레이아웃 이벤드의 반복과 형성시간을 줄이기 위해서 일괄 업데이트 해야하고, 박스 모델 속성을 애니메이션화 하지 말아야 합니다.</p><h3 id="페인트"><a href="#페인트" class="headerlink" title="페인트"></a>페인트</h3><p>마자믹 단계는 화면에 픽셀을 그리는 것입니다. 일단 렌더 트리가 생성되고 레이아웃나 나타나기 시작하면, 화면에 픽셀을 그릴수 있습니다. 로드시, 전체 화면을 그립니다. 그 후에는 브라우저가 필요한 최소 영역만을 다시 그리도록 최적화되어 있기 때문에 영향을 받는 영역만을 화면에 다시 그립니다. 그리는 시간은 렌터 트리에 적용되는 업데이트의 종류가 무엇있냐에 따라 달라집니다. 페인팅인 매우 빠르게 진행되는 과정이기 때문에 성능 향상에 집중해야 하는 가장 큰 영향있는 부분이 아닐 수 있지만, 애니메이션 프레임 소요시간을 측정할때, 레이아웃과 리페인트 시간을 모두 고려하는 것이 중요합니다. 각 노드에 적용된 스타일은 페인트 시간을 증가시키지만 페인트 시간을 0.001ms 증가시키는 스타일을 제거하는 것은 여러분의 최적화 비용이 매우 커지는 것을 막지 못할 수 있습니다. 첫째는 측정하는 것을 기억하고, 최적화 우선순위를 정해야할지 말지를 결정해야 합니다.</p><h2 id="CRP-최적화"><a href="#CRP-최적화" class="headerlink" title="CRP 최적화"></a>CRP 최적화</h2><p>자원 로드 순서를 관리하고, 파일 사이즈를 줄이며 어떤 자원을 먼저 로드할지 정함으로써 페이지 로드 속도를 개선하세요. 성능 팁으로는 1) 자원 다운로드를 연기함으로써 중요 자원들의 수를 최소화하기 , 2) 각 요청에 대한 파일 사이즈에 따라 필수적인 요청 횟수 최적하하기, 3) 다운받을 중요 에셋의 우선순위를 정함으로써 중요 자원 불러오는 순서 최적화하고, 중요 경로 길이 최소화하기</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;/images/browser_work.png&quot;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;본 글은 &lt;a href=&quot;https://developer.mozilla.org/en-US/&quot;&gt;&lt;strong&gt;mdn web docs&lt;/strong</summary>
      
    
    
    
    <category term="Web" scheme="https://joontae-kim.github.io/categories/Web/"/>
    
    <category term="Browser" scheme="https://joontae-kim.github.io/categories/Web/Browser/"/>
    
    
    <category term="mdn" scheme="https://joontae-kim.github.io/tags/mdn/"/>
    
    <category term="Browser" scheme="https://joontae-kim.github.io/tags/Browser/"/>
    
    <category term="Rendering" scheme="https://joontae-kim.github.io/tags/Rendering/"/>
    
    <category term="Critical Rendering path" scheme="https://joontae-kim.github.io/tags/Critical-Rendering-path/"/>
    
  </entry>
  
  <entry>
    <title>페이지 채우기: 브라우저가 작동하는 방법 - 2</title>
    <link href="https://joontae-kim.github.io/2020/09/25/browser-work-2/"/>
    <id>https://joontae-kim.github.io/2020/09/25/browser-work-2/</id>
    <published>2020-09-25T10:14:46.000Z</published>
    <updated>2020-09-26T17:55:48.978Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/browser_work.png"></p><blockquote><p>본 글은 <a href="https://developer.mozilla.org/en-US/"><strong>mdn web docs</strong></a>의 <a href="https://developer.mozilla.org/en-US/docs/Web/Performance/How_browsers_work">Populating the page: how browsers work</a>를 번역한 글입니다.</p></blockquote><p>현재 작성일자(2020년 9월 25일) 기준으로 아직 한글로 번역되지 않아 본 번역 포스팅을 완료하면 해당 페이지를 한국어로 옮겨놓을 예정입니다. 수정 및 보완사항이 있다면 본 포스팅 하단 댓글에 작성 부탁드립니다.</p><hr><p>브라우저 작동 원리 또는 렌더링에 관해 공부하고, 포스팅하고 싶은 마음이 있었는데 mdn에 좋은 게시물이 많이 있었고 그중 몇 가지를 연재로 번역하면서 공부해보는 시간을 가져볼려고 합니다.</p><h4 id="연재할-MDN-docs"><a href="#연재할-MDN-docs" class="headerlink" title="연재할 MDN docs"></a>연재할 MDN docs</h4><ol><li><a href="https://developer.mozilla.org/ko/docs/Web/Performance/%EB%B8%8C%EB%9D%BC%EC%9A%B0%EC%A0%80%EB%8A%94_%EC%96%B4%EB%96%BB%EA%B2%8C_%EB%8F%99%EC%9E%91%ED%95%98%EB%8A%94%EA%B0%80"><strong>Populating the page: how browsers work</strong></a></li><li><a href="https://developer.mozilla.org/en-US/docs/Web/Performance/Critical_rendering_path#Understanding_CRP">Critical rendering path</a></li></ol><hr><h1 id="페이지-채우기-브라우저-작동원리"><a href="#페이지-채우기-브라우저-작동원리" class="headerlink" title="페이지 채우기: 브라우저 작동원리"></a>페이지 채우기: 브라우저 작동원리</h1><p>사용자들은 컨텐츠가 빠르게 로드되고 상호작용이 부드러운 웹 경험을 원합니다. 그러므로 개발자들은 이 두가지 목표를 성취하기 위해서 노력해야만 합니다.</p><p>성능과 감지된 성능을 개선하는 방법을 이해하기 위해서는 브라우저가 어떻게 동작하는지 이해하는 것이 도움을 줄 수 있습니다.</p><br><h2 id="파싱-Parsing"><a href="#파싱-Parsing" class="headerlink" title="파싱 (Parsing)"></a>파싱 (Parsing)</h2><p>일단 브라우저가 첫번째 데이터 청크를 받고나면, 받은 정보를 분석하기 시작합니다. <a href="https://developer.mozilla.org/en-US/docs/Glossary/speculative_parsing">Parsing</a> 은 네트워크를 통해 전송된 데이터를 <a href="https://developer.mozilla.org/en-US/docs/Glossary/DOM">DOM</a> 과 <a href="https://developer.mozilla.org/en-US/docs/Glossary/CSSOM">CSSOM</a> 으로 변환해야할 단계이며, 렌더러가 화면에 페이지를 그리는데 사용됩니다.</p><p>DOM은 브라우저의 마크업을 내부적으로 표현한 것입니다. 또한, 외부적으론 Javascript에서 다양한 API들을 통해 재생산될 수도 있습니다.</p><p>비록 요청된 페이지의 HTML 사이즈가 초기 14KB 패킷보다 훨씬 클지라도, 브라우저는 분석을 시작할 것이며 데이터를 기반으로 경험을 렌더링하려고 시도할 것입니다. 웹 퍼포먼스 최적화가 중요한 이유는 브라우저가 페이지 또는 적어도 페이지의 템플릿(첫 번째 렌더링에 필요한 CSS와 HTML)을 렌더링하기 위해 필요한 모든 것을 초기 14kb 안에 포함해야 하기 때문입니다. 그러나 화면에 어떠한 것이든 렌더링하기 전에 HTML, CSS 그리고 Javascript를 분석해야만 합니다.</p><h3 id="DOM-트리-구성하기-Building-the-DOM-tree"><a href="#DOM-트리-구성하기-Building-the-DOM-tree" class="headerlink" title="DOM 트리 구성하기(Building the DOM tree)"></a>DOM 트리 구성하기(Building the DOM tree)</h3><p>우리는 <a href="https://developer.mozilla.org/en-US/docs/Web/Performance/Critical_rendering_path">중요 렌더링 경로</a> 에 5 단계로 설명해놨습니다.</p><p>첫 번째 단계로 HTML 마크업을 처리하고 DOM 트리를 구성하는 것입니다. HTML 파싱은  <a href="https://developer.mozilla.org/en-US/docs/Web/API/DOMTokenList">tokenization</a> 과 트리 구조를 포함합니다. HTML 토큰은 속성(attribute) 이름과 값 뿐만 아니라 태크의 시작과 끝을 포함하고 있습니다.  만약 도큐먼트(document)가 잘 짜여져 있다면, 파싱은 간단하고 더 빠르게 될 것입니다. 분석기(Parser)는 도큐먼트 내에 도큐먼트 트리로 구성되어진 토큰 처리된 input을 분석합니다.</p><p>DOM 트리는 도큐먼트의 컨텐츠를 설명합니다. <code>&lt;html&gt;</code> 요소는 첫번째 태그이자 도큐먼트 트리의 root 노드이며  다른 태그들 사이에서 관계성과 위계구조를 반영해줍니다. 다른 태그들 사이에 중첩된 태그들은 자식 노드들입니다. DOM 노드의 수가 많을수록 DOM 트리를 구조화하는 시간은 더 소요됩니다.</p><p><img src="https://mdn.mozillademos.org/files/16759/DOM.gif"></p><p>분석기가 이미지와 같은 비차단(non-blocking) 자원을 찾으면 브라우저는 이 자원을 요청하고 계속해서 분석합니다. 파싱은 CSS file을 만났을때도 계속되지만 특히 <code> async</code> 또는 <code> defer</code> 속성이 없는  <code>&lt;script&gt;</code> 태그를 만났을 경우에는 렌더링을 멈추고 HTML 파싱을 중단합니다. 비록 브라우저의 프리로드(preload) 스캐너가 이 과정을 가속화하지만 과도한 스크립트는 여전히 심각한 병목현상이 될 수 있습니다.</p><h3 id="Preload-scanner"><a href="#Preload-scanner" class="headerlink" title="Preload scanner"></a>Preload scanner</h3><p>브라우저가 DOM 트리를 구성하는 동안, 이 프로세스는 메인 스레드에서 발생합니다. 이 현상 때문에 <em>Preload scanner</em> 는 사용 가능한 콘텐츠를 분석하고 CSS, Javascript 그리고 웹 폰트와 같은 선순위의 자원을 요청합니다. Preload scanner 덕분에 우리는 분석기가 선순위의 자원을 요청하기 위해 외부 자원에 대한 참조를 찾을때까지 대기하고 있지 않습니다. 메인 HTML 분석기가 요청된 에셋에 도달할 때에는 이미 전송중이거나 또는 이미 다운로드 되었을 수 있도록 백그라운드에서 자원을 획득할 것입니다. Preload scanner의 최적화는 차단시간을 줄여줍니다.</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">src</span>=<span class="string">&quot;styles.css&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;myscript.js&quot;</span> <span class="attr">async</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;myimage.jpg&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;image description&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;anotherscript.js&quot;</span> <span class="attr">async</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>이와 같이, 메인 스레드가 HTML, CSS를 분석하는 동안 Preload scanner는 스크립트와 이미지를 검색할 것이고 다운로드 받기 시작할 것입니다. 스크립트가 DOM 트리 구성 프로세스를 막지 않도록 보장하기 위해, 만약 Javascript 파싱 또는 실행 순서가 중요하지 않다면 <code>async</code> 또는 <code>defer</code> 속성을 추가해야 합니다.</p><p>CSS를 받기 위해 대기하는 것은 HTML 분석 또는 다운로딩은 막지 않지만 Javascript는 종종 HTML 요소에서 CSS 속성을 조회하는데 영향을 끼치기 때문에 막습니다.</p><h3 id="CSSOM-구성하기"><a href="#CSSOM-구성하기" class="headerlink" title="CSSOM 구성하기"></a>CSSOM 구성하기</h3><p>중요 렌더링 경로의 두번째 단계는 CSS를 처리하고 CSSOM 트리를 구성하는 것입니다.  DOM과 CSSOM은 둘다 트리 구조로, CSS object model은 DOM과 유사합니다. 이 둘은 독립적인 데이터 구조이며 브라우저는 CSS 규칙을 이해할 수 있고 작동할 수 있는 스타일 맵으로  변환합니다. 브라우저는 CSS의 각 규칙 세트를 거치면서 CSS 선택자를 기반으로 부모, 자식 그리고 형제 관계에 있는 노드의 트리를 만듭니다.</p><p>HTML도 마찬가지로, 브라우저는 수신된 CSS 규칙을 무언가를 작업할 수 있는 것으로 변환해야 합니다. 따라서, HTML-to-object 프로세스를 반복하지만 CSS 또한 반복합니다. </p><p>CSSOM 트리는 유저 에이전트 스타일시트의 스타일을 포함합니다. 브라우저는 노드에 적용가능한 가장 일반적인 규칙으로 시작하고 보다 구체적인 규칙을 적용함으로써 계산된 스타일을 반복적으로 재조정합니다. 다르게 말해, 속성값은 계단식을 표현됩니다.</p><p>CSSOM 구축은 매우 매우 빠르고 현재 개발자 도구에서 단일 색상으로 표시되지 않습니다. 대신 개발자 도구의 “보정된 스타일”은 CSS를 분석하고, CSSOM 트리를 구축하며 회귀적으로 처리된 스타일을 계산하기 위한 모든 시간을 보여줍니다. CSSOM을 만드는 시간이 일반적으로 한개의 DNS 조회를 위해 걸리는 시간보다 덜 걸리기 때문에 웹 퍼포먼스 최적화의 측면에서는 더 쉽다.</p><h3 id="다른-프로세스들"><a href="#다른-프로세스들" class="headerlink" title="다른 프로세스들"></a>다른 프로세스들</h3><h4 id="자바스크립트-컴파일"><a href="#자바스크립트-컴파일" class="headerlink" title="자바스크립트 컴파일"></a>자바스크립트 컴파일</h4><p>CSS가 분석되고, CSSOM이 만들어지는 동안 자바스크립 파일을 포함한 다른 에셋들을 다운로드하고 있을 것입니다.(preload scanner 덕분에). 자바스크립트는 해석되고, 변환되며 분석한 후 실행됩니다. 스크립트는 추상적인 문법 트리안에서 분석되고 몇몇의 브라우저 엔진들은 <em>Abstract Syntax Tree(추상적 문법 트리)</em> 를 가지고 있으며 이를 인터프리터 안으로 전달하여 메인 쓰레드에서 실행할 바이트 코드를 출력합니다.</p><h4 id="접근성-트리-구성하기"><a href="#접근성-트리-구성하기" class="headerlink" title="접근성 트리 구성하기"></a>접근성 트리 구성하기</h4><p>브라우저는 또한 보조 장치가 콘텐츠를 분석하고 해석하기 위해 사용되는 접근성 트리를 구성합니다. 접근성 오브젝트 모델(The accessibility object model, AOM)은 DOM의 시멘틱 버전과 같습니다. 브라우저는 DOM이 업데이트 될때 접근성 트리도 업데이트 합니다. 접근성 트리는 보조 기술 그 자체로는 수정할 수 없다. AOM이 구성될떄, 콘텐츠는 <a href="https://developer.mozilla.org/en-US/docs/Web/Accessibility/ARIA/ARIA_Screen_Reader_Implementors_Guide">screen reader</a>에서 접근할 수 없습니다.</p><br><h2 id="렌더-Render"><a href="#렌더-Render" class="headerlink" title="렌더(Render)"></a>렌더(Render)</h2><p>렌더링 단계는 스타일, 레이아웃, 그리기 그리고 경우에 따라서 합성(compositing)하는 것을 포함합니다. 파싱 단계에서 생성된 CSSOM과 DOM 트리들은 렌더 트리에서 결합되며, 렌더 크리는 표시되는 모든 요소의 레이아웃을 처리하는데 사용되며 화면을 그립니다. 몇 가지 경우에 따라서, 콘텐츠를 그들 스스로의 레이어로 승격하고 합성할 수 있으며 CPU 대신 GPU에서 화면의 일부를 그림으로써 메인 스레드를 확보하여 성능을 향상시킬 수 있습니다.</p><h3 id="스타일"><a href="#스타일" class="headerlink" title="스타일"></a>스타일</h3><p>주요 렌더링 경로의 세번째 단계는 렌더 트리 안에서 DOM과 CSSOM을 결합하는 것입니다. 계산된 스타일 트리 또는 렌더 트리 구조는 각각의 표시되는 노드를 가로지르는 DOM 트리의 root로 시작됩니다.</p><p> <code>&lt;head&gt;</code> 와 같은 보여지지 않는 태그들과 이 자식 노드들 그리고 유저 에이전트 스타일시트에서 찾아볼수 있는  <code>script &#123; display: none; &#125;</code> 와 같이 <code>display: none</code> 으로 설정되어 있는 특정 노드들은 그들은 렌더된 결과물로써 나타나지 않을것이기 때문에 렌더 트리에 포함되지 않습니다. <code>visibility: hidden</code> 가 적용된 노드들은 공간을 차지함으로써 렌더 트리안에 포함됩니다. 우리는 유저 에이전트 기본값을 덮어쓰기 위한 어떠한 지시사항도 주지 않으므로, 위의 코드 예제에서 <code>script</code> 노드는 렌더 트리에 포함되지 않을 것입니다.</p><p>각각의 표시되는 노드들은 적용되는 CSSOM 규칙을 가지고 있습니다. 렌더 트리는 계산된 스타일과 컨텐츠와 함께 표시되는 모든 노드들을 보유하고 있습니다. DOM 트리 안에서 표시되는 모든 노드에 모든 관련 스타일들을 일치시키고, <a href="https://developer.mozilla.org/en-US/docs/Web/CSS/Cascade">CSS cascade</a> 를 기반으로 계산된 스타일들을 결정합니다. </p><h3 id="레이아웃"><a href="#레이아웃" class="headerlink" title="레이아웃"></a>레이아웃</h3><p>주요 렌더링 경로의 네번째 단계는 각 노드의 위치를 계산하기 위해 렌더 트리에서 레이아웃을 작동시키는 것입니다. <em>레이아웃</em> 은 너비, 높이 그리고 렌더 트리 안에서 모든 노드들의 위치를 결정하는 과정이며 페이지 안에서 각 오브젝트의 크기와 위치에 대한 결정도 추가됩니다. <em>리플로우</em> 페이지의 특정 부분 또는 전체 도큐먼트의 어떤 연속적인 크기와 위치에 대한 결정입니다.</p><p>일단 렌터 트리가 구성되나면 레이아웃이 시작됩니다.</p><p>렌더 트리는 (심지어 보이지 않을지라도) 각 노드들의 계산된 스타일들에 따라 어떤 노드들을 배치할지 인식하지만 각 노드의 차원이나 위치는 아닙니다. 각 오브젝트의 정확한 사이즈나 위치를 결정하기 위해서 브라우저는 렌더 트리의 root에서 시작하며 순회합니다.</p><p>웹 페이지 상에서 대부분의 것들은 상자입니다. 디바이스와 데스크탑의 기본 설정이 다르면 뷰포트 크기가 무제한으로 달라질 수 있습니다. 이 단계에선 뷰포트 크기를 고려하여 브라우저가 화면에 표시되는 다양한 상자의 크기를 결정합니다. 뷰포트의 크기를 기준으로 하여 일반적으로 레이아웃은 본문에서 시작하여 각 요소의 박스 모델 속성들에 따라 본문의 모든 하위 자식의 치수를 나열하고, 이미지와 같이 치수를 알지 못하는 대체될 요소를 위해 플레이스홀더 공간을 제공합니다.</p><p>노드들의 크기와 위치가 처음으로 결정되면 <em>레이아웃 (layout)</em> 이라고 부른다. 노드 사이와 위치에 대한 연속적인 재계산을 <em>리플로우 (reflow)</em> 라고 부른다. 예를 들어, 초기 레이아웃은 이미지를 불러오기 전에 발생한다고 할 수 있다. 왜냐하면 우리는 이미지의 크기를 결정할 수 없기 때문에, 일단 이미지의 사이즈를 알았을때 리플로우 될 것입니다.</p><h3 id="페인트"><a href="#페인트" class="headerlink" title="페인트"></a>페인트</h3><p>주요 렌더링 경로의 마지막 단계로 화면에서 <a href="https://developer.mozilla.org/en-US/docs/Glossary/first_meaningful_paint">first meaningful paint</a> 라 불리는 첫번째 현상으로, 각 노드들을 그리는 것입니다. 페인팅 또는 레스터화 단계에서 브라우저는 레이아웃 단계에서 처리된 각 박스를 실제 픽셀로 변환합니다. 페인팅은 화면에서 텍스트, 색깔, 선, 그림자 그리고 버튼이나 이미지와 같은 대체되는 요소들을 포함하는 보여지는 모든 요소를 그리는 것을 포함합니다. 브라우저는 이것을 매우 빠르게 할 필요가 있습니다.</p><p>부드러운 스크롤링과 애니메이션을 보장하기 위해서 리플로우와 페인트에 따라 스타일 계산을 포함해 메인 스레드가 담당하는 모든 것이 브라우저에서 16.67ms 미만으로 처리되어야만 한다. 2048 X 1536 크기에서는, iPad는 스크린에 페인트 하기 위해서 3,145,000 이상의 픽셀을 가지고 있으며 매우 빨리 페인트 되어야 하는 많은 픽셀입니다. 리페인팅이 초기 페인트보다 훨씬 빠르게 끝내는 것을 보장하기 위해 일반적으로 스크린에 그리는 것을 몇개의 레이어로 나누고 이를 위해 컴포지팅(compositing)이 필수적입니다.</p><p>페인팅은 레이아웃 트리의 요소를 레이어로 나눌 수 있으며 콘텐츠를 CPU의 메인 스레드가 아닌 GPU의 레이어로 승격하면 페인트 및 리페인트 성능이 향상됩니다. 레이어를 인스턴스화 하는 특정 특성과 요소가 있으며 이는  <code>&lt;video&gt;</code> 와 <code>&lt;canvas&gt;</code>, 그리고  CSS 속성 중 <code>opacity</code> 또는 3D <code>transform</code>, <code>will-change</code> 그리고 몇 안되는 다른 요소들을 포함합니다. 이러한 노드는 하위 항목이 위의 이유 중 하나 (또는 그 이상)로 인해 자체 레이어를 필요로하지 않는 한 하위 항목과 함께 자체 레이어에 페인팅됩니다.</p><p>레이어들은 성능을 개선하지만 메모리 관리에 있어서는 비용이 따릅니다. 따라서, 웹 성능 최적화 전략의 한 부분으로써 과도하게 사용하지 말아야만 한다.</p><h3 id="컴포지팅"><a href="#컴포지팅" class="headerlink" title="컴포지팅"></a>컴포지팅</h3><p>도큐먼트의 섹션들이 서로 겹쳐서 서로 다른 레이어에서 그려질 때, 컴포지팅은 화면상에서 올바른 순서로 그려지고 콘텐츠가 올바르게 렌더링 되도록 보장하는 것이 필수적입니다.</p><p>페이지가 에셋들을 계속해서 불러옴으로써 리플로우가 발생될 수 있다(예제에서 늦게 도착한 이미지를 다시 호출하기 위해).  리플로우는 리페인팅과 리컴포지 하도록 합니다. 만약 우리가 이미지의 크기를 정했다면, 리플로우는 필요하지 않을 것이며 오직 리페인팅될 필요가 있는 레이어를 리페인팅할 것이며 필요할 경우 합성할 수 있습니다. 그러나 우리는 이미지 크기를 포함하고 있지 않습니다! 그 이미지가 서버에서 받았을때 렌더링 과정은 레이아웃 스텝 다시 돌아가고 다시 시작한다.</p><br><h2 id="상호운용성"><a href="#상호운용성" class="headerlink" title="상호운용성"></a>상호운용성</h2><p>일단 메인 쓰레드가 페이지 그리기를 완료하면, 여러분은 “모든 것”을 갖췄다고 생각했겠지만, 꼭 그런것만은 아닙니다. 만약 불러오기에 정확하게는 지연되고 오직 <code>onload</code> 이벤트에 후에 실행되는 자바스크립트를 포함하고 있을 경우, 메인 스레드는 바빠지고 스크롤링, 터치 그리고 다른 상호작용은 불가능해질지도 모른다.</p><p><a href="https://developer.mozilla.org/ko/docs/Glossary/Time_to_Interactive">Time to Interactive</a> (TTI)는 페이지가 상호작용할때 DNS 조회와 SSL 연결에 의한 첫번째 요청에서 <a href="https://developer.mozilla.org/ko/docs/Glossary/First_Contentful_Paint">First Contentful Paint</a> 이후로 50ms 안에 즉시 페이지가 상호작용할때 까지의 시간을 측정한 것입니다. 만약 메인 스레드가 분석, 컴파일링 그리고 자바스크립트 실행까지 담당하고 있다면 이것은 가능하지 않으며 (50ms 미만으로) 제때에 사용자 상호작용에 반응할 수 없습니다.</p><p>예를 들어, 아마 이미지가 빠르게 로드 되었다 할지라도,  <code>anotherscript.js</code> 파일은 2MB이고 사용자의 네트워크 연결은 느려졌다. 이러한 경우 사용자는 페이지를 매우 빠르게 볼수 있었겠지만 스크립트가 다운로드 될때까지 잰크(jank) 없이는 스크롤할 수 없을 것이고, 좋지 못한 사용자 경험이 됩니다. WebPageTest 예제에서 설명하듯 메인 스레드를 차지하는 것을 피해야 합니다.</p><p><img src="https://mdn.mozillademos.org/files/16760/visa_network.png"></p><p>이 예제의 DOM 콘텐츠 로드 과정은 1.5 초 이상 소요됐고 메인 스레드는 전체 시간동안 가득 찼으며 스크린 탭 또는 클릭 이벤트에 반응하지 않습니다.</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;/images/browser_work.png&quot;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;본 글은 &lt;a href=&quot;https://developer.mozilla.org/en-US/&quot;&gt;&lt;strong&gt;mdn web docs&lt;/strong</summary>
      
    
    
    
    <category term="Web" scheme="https://joontae-kim.github.io/categories/Web/"/>
    
    <category term="Browser" scheme="https://joontae-kim.github.io/categories/Web/Browser/"/>
    
    
    <category term="mdn" scheme="https://joontae-kim.github.io/tags/mdn/"/>
    
    <category term="Browser" scheme="https://joontae-kim.github.io/tags/Browser/"/>
    
  </entry>
  
  <entry>
    <title>페이지 채우기: 브라우저가 작동하는 방법 - 1</title>
    <link href="https://joontae-kim.github.io/2020/09/25/browser-work/"/>
    <id>https://joontae-kim.github.io/2020/09/25/browser-work/</id>
    <published>2020-09-25T06:54:56.000Z</published>
    <updated>2020-09-26T17:55:55.806Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/browser_work.png"></p><blockquote><p>본 글은 <a href="https://developer.mozilla.org/en-US/"><strong>mdn web docs</strong></a>의 <a href="https://developer.mozilla.org/en-US/docs/Web/Performance/How_browsers_work">Populating the page: how browsers work</a>를 번역한 글입니다.</p></blockquote><p>현재 작성일자(2020년 9월 25일) 기준으로 아직 한글로 번역되지 않아 본 번역 포스팅을 완료하면 해당 페이지를 한국어로 옮겨놓을 예정입니다. 수정 및 보완사항이 있다면 본 포스팅 하단 댓글에 작성 부탁드립니다.</p><hr><p>브라우저 작동 원리 또는 렌더링에 관해 공부하고, 포스팅하고 싶은 마음이 있었는데 mdn에 좋은 게시물이 많이 있었고 그중 몇 가지를 연재로 번역하면서 공부해보는 시간을 가져볼려고 합니다.</p><h4 id="연재할-MDN-docs"><a href="#연재할-MDN-docs" class="headerlink" title="연재할 MDN docs"></a>연재할 MDN docs</h4><ol><li><a href="https://developer.mozilla.org/ko/docs/Web/Performance/%EB%B8%8C%EB%9D%BC%EC%9A%B0%EC%A0%80%EB%8A%94_%EC%96%B4%EB%96%BB%EA%B2%8C_%EB%8F%99%EC%9E%91%ED%95%98%EB%8A%94%EA%B0%80"><strong>Populating the page: how browsers work</strong></a></li><li><a href="https://developer.mozilla.org/en-US/docs/Web/Performance/Critical_rendering_path#Understanding_CRP">Critical rendering path</a></li></ol><hr><h1 id="페이지-채우기-브라우저-작동원리"><a href="#페이지-채우기-브라우저-작동원리" class="headerlink" title="페이지 채우기: 브라우저 작동원리"></a>페이지 채우기: 브라우저 작동원리</h1><p>사용자들은 컨텐츠가 빠르게 로드되고 상호작용이 부드러운 웹 경험을 원합니다. 그러므로 개발자들은 이 두가지 목표를 성취하기 위해서 노력해야만 합니다.</p><p>성능과 감지된 성능을 개선하는 방법을 이해하기 위해서는 브라우저가 어떻게 동작하는지 이해하는 것이 도움을 줄 수 있습니다.</p><br><h2 id="개요"><a href="#개요" class="headerlink" title="개요"></a>개요</h2><p>빠른 사이트들은 더 나은 사용자 경험을 제공한다. 사용자들은 컨텐츠와 함께 빠르게 로드되고 상호작용이 부드러운 웹 경험을 예상하고 바랍니다.</p><p>웹 퍼포먼스에서 두가지 주요한 이슈로는 지연시간(latency)에서 경험하게 될 이슈와 브라우저가 단일 쓰레드로서 갖는 주요한 사실에서 갖는 이슈들입니다.</p><p>지연시간은 빠른 로드를 보장하기 위해 극복해야하는 우리의 주요한 위협입니다. 로드을 빠르게 하기 위해 개발자의 목표로는 가능하 한 빠르게 또는 적어도 보기에 매우 빠른 속도로 요청된 정보를 보내는 것을 포함함니다. 네트워크 지연은 바이트(bytes)를 무선에서 컴퓨터로 전송하는 시간을 얘기합니다. 웹 퍼포먼스는 가능한 한 빠르게 페이지 로드가 될 수 있도록 우리가 해야만 하는  가능한 빠르게 되도록 우리가 해야 하는 것입니다.</p><p>대부분은 브라우저들은 단일 쓰레드로 간주됩니다. 부드러운 상호작용을 위해 개발자들의 목표는 부드러운 스크롤링에서부터 터치에 반응하는 것까지 효율적인 사이트 상호작용을 보장하는 것입니다. 렌더링 시간의 핵심은 우리가 부여한 모든 작업을 메인 쓰레드가 완료할 수 있도록 보장하는 것과 항상 사용자 상호작용에  대처할 수 있도록 하는것입니다. 웹 퍼포먼스는 브라우저의 단일 쓰레드의 성질을 이해하고, 메인 쓰레드의 업무를 부드러운 렌더링과 상호작용에 즉시 반응할 수 있도록 보장하기 위해 가능한 그리고 적절한 범위내로 최소화함으로써 개선할 수 있습니다. </p><br><h2 id="네비게이션"><a href="#네비게이션" class="headerlink" title="네비게이션"></a>네비게이션</h2><p>네비게이션은 웹 페이지 로딩에 있어서 첫번째 단계입니다. 언제든지 사용자가 주소바에 URL을 입력함으로써 페이지를 요청할때, 링크를 클릭할때, 폼을 제출하거나 다른 행동을 취할때마다 발생합니다.</p><p>웹 퍼포먼스의 첫번째 목표는 탐색이 완료되는 시간을 최소화 하는 것입니다. 이상적인 조건에서는 이건 보통 오래 걸리지 않지만 지연시간과 인터넷 접속 속도는 지연을 야기할 수 있는 적입니다.</p><h3 id="DNS-조회"><a href="#DNS-조회" class="headerlink" title="DNS 조회"></a>DNS 조회</h3><p>웹 페이지를 탐색하는 첫번째 단계는 페이지에 배치되어 있는 자산(asset)들이 어디에 있는지 찾는 것입니다. 여러분이 <code>https://example.com</code> 를 탐색한다면, HTML 페이지는 <code>93.184.216.34</code> 라는 IP 주소에 서버를 두고 있을것입니다. 만약 여러분이 이 사이트를 절대로 방문하지 않았었다면, DNS 조회는 반드시 발생해야만 합니다.</p><p>여러분의 브라우저는 차례대로 IP 주소에 의해 반응하기 위해 최종적으로 네임서버에 지정된 DNS 조회를 요청할 것입니다. 이러한 초기 요청 이후, IP는 지속적인 요청 속도를 올리기 위해서 네임서버로 다시 접속하는 대신 캐시로부터 IP 주소를 획득함으로써 한동안 캐시될 것입니다.</p><p>DNS 조회는 보통 페이지 로드를 위해 호스트네임 당 오직 한번만 수행될 필요가 있습니다. 하지만 DNS 조회는 요청된 페이지 참조의 각각의 유일한 호스트네임을 위해 완료되야만 합니다.</p><p>만약 당신의 폰트, 이미지, 스크립트, 광고 그리고 메트릭스 등 모든 것들이 다른 호스트네임을 갖고 있다면, DNS 조회는 각각의 것들을 위해 이루어져야 합니다.</p><p><img src="https://mdn.mozillademos.org/files/16743/latency.jpg"></p><p>이러한 작업은 특히 모바일 네트워크 환경에서 성능에 있어서 문제를 유발할 수 있습니다. 사용자가 모바일 네트워크 환경에 있다면, 각각의 DNS 조회는 권한이 있는 DNS 서버에 도달하기 위해 휴대전화에서 기지국까지 가야만 합니다. 휴대전화, 기지국 그리고 네임서버 간의 거리는 막대한 지연시간을 추가합니다.</p><h3 id="TCP-핸드쉐이크-TCP-Handshake"><a href="#TCP-핸드쉐이크-TCP-Handshake" class="headerlink" title="TCP 핸드쉐이크 (TCP Handshake)"></a>TCP 핸드쉐이크 (TCP Handshake)</h3><p>일단 IP 주소를 알고 있다면, 브라우저는 <a href="https://developer.mozilla.org/en-US/docs/Glossary/TCP_handshake">TCP three-way handshake</a> 를 통해 서버 연결을 설정합니다. 이러한 메커니즘은 두개의 엔터티가 소통하기 위한 설계입니다–브라우저와 서버의 경우에– 종종 <a href="https://developer.mozilla.org/en-US/docs/Glossary/HTTPS">HTTPS</a> 를 거쳐 네트워크 TCP 소켓 연결의 매개변수(parameter)를 협상할 수 있습니다.</p><p>TCP’s three way handshaking 기술은 종종 “SYN-SYN-ACK”(또는 더 정확하게는 SYN, SYN-ACK, ACK)이라고 부릅니다. 왜냐하면 그리고 시작하기 위해 두 컴퓨터 사이에서 TCP 세션을 시작하고 협상하기 위해 TCP에 의해 전송된 세가지 메시지가 있기 때문입니다. 즉, 세가지 이상의 메시지들이 각각의 서버 사이에서 오고 간다는 것을 의미하며 해당 요청은 아직 완료되지 않았다는 것입니다.</p><h3 id="TLS-협상"><a href="#TLS-협상" class="headerlink" title="TLS 협상"></a><a href="https://developer.mozilla.org/en-US/docs/Glossary/TLS">TLS</a> 협상</h3><p>HTTPS를 통해 설정된 안전한 연결을 위해서 또 다른 “Handshake”이 필요합니다. 이 Handshake 또는 TLS Negotiation은 통신을 암호화하고, 서버를 식별하며 데이터의 전송이 실질적으로 이루어지기 전에 제때 안전한 연결(secure connection)이 설정되도록 사용할 암호(cipher)를 결정합니다. 이러한 작업들은 요청된 콘텐츠가 실제로 전송되기 전에 서버에 3회 이상의 왕복을 요구합니다.</p><p><img src="https://mdn.mozillademos.org/files/16746/ssl.jpg"></p><p>통신을 보안화하는것이 페이지 로드에 시간을 추가하는 반면에, 브라우저와 웹 서버 사이에 전송된 데이터가 서드 파티(third party)에 의해 암호 해독이 될수 없으므로 보안화된 연결(secure connection)의 시간지연 비용은 가치있다.</p><p>8번의 왕복 이후에 브라우저는 최종적으로 요청을 완료할 수 있다.</p><br><h2 id="응답"><a href="#응답" class="headerlink" title="응답"></a>응답</h2><p>일단 우리가 웹 서버와 접근을 설정하고 있다면 , 브라우저는 유저를 대신해 초기 <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Methods">HTTP <code>GET</code> request</a> 를 전송합니다. 웹사이트의 경우 HTML 파일이 대부분 입니다. 일단 웹 서버가 요청을 받으면, 관련 응답(response) 헤더와 HTML 콘텐츠를 응답할 것입니다.</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!doctype <span class="meta-keyword">HTML</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>My simple page<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">src</span>=<span class="string">&quot;styles.css&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;myscript.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h1</span> <span class="attr">class</span>=<span class="string">&quot;heading&quot;</span>&gt;</span>My Page<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>A paragraph with a <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;https://example.com/about&quot;</span>&gt;</span>link<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;myimage.jpg&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;image description&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;anotherscript.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>초기 요청에 대한 응답은 획득한 데이터의 첫번째 바이트를 포함하고 있습니다. <a href="https://developer.mozilla.org/en-US/docs/Glossary/Time_to_First_Byte">Time to First Byte</a> (TTFB)는 사용자가 요청한 시간(링크를 클릭함으로써)과 HTML의 첫번째 패킷의 수신 사이의 시간입니다. 첫번째 콘텐츠의 청크는 보통 데이터의 14kb 입니다.</p><p>위 예제에서, 요청은 확실히 14Kb 미만이지만 다음에서 언급할 분석(parsing) 중에는  브라우저가 링크를 찾을때까지 연결된 리소스는 요청되지 않습니다.</p><h3 id="TCP-Slow-Start-14kb-rule"><a href="#TCP-Slow-Start-14kb-rule" class="headerlink" title="TCP Slow Start / 14kb rule"></a>TCP Slow Start / 14kb rule</h3><p>첫번째 응답 패킷은 14kb 일것입니다. 이건 네트워크 연결 속도의 균형을 잡기위한 알고리즘인 <a href="https://developer.mozilla.org/en-US/docs/Glossary/TCP_slow_start">TCP slow start</a> 의 일부분입니다. Slow Start는 네트워크의 최대 대역폭이 결정될때까지 전송되는 데이터의 양을 점진적으로 증가시킵니다.</p><p>초기 패킷의 수신 이후에 TCP slow start 에서, 서버는 다음 패킷를 약 28kb 까지 두배로 키웁니다. 미리 지정된 스레드홀드에 도달하거나 정체가 발생할때까지 후속 패킷의 크기는 증가할 것입니다.</p><p><img src="https://mdn.mozillademos.org/files/16754/congestioncontrol.jpg"></p><p>만약 여러분이 초기 페이지 로드에 대한 14kb 규칙을 들은적이 있다면, TCP Slow Start는 초기 응답이 14kb인 이유이기도 하며 웹 퍼포먼스 최적화가 이러한 초기 14kb 응답을 염두에 두고 최적화에 초점을 맞춰야하는 이유이기도 합니다. TCP slow start는 혼잡을 피하기 위한 네트워크 수용능력을 위해 점진적으로 전송 속도를 알맞게 구성합니다.</p><h3 id="혼잡-관리"><a href="#혼잡-관리" class="headerlink" title="혼잡 관리"></a>혼잡 관리</h3><p>서버가 TCP 패킷에 데이터를 보낼때, 사용자의 클라이언트는 승인 또는 ACK를 반환하여 전달을 확인합니다. 이 연결은 하드웨어와 네트워크 조건에 따라 제한된 수용력을 가지고 있다. 만약 서버가 매우 빠르게 매우 많은 패킷을 보낸다면, 그들은 멈출것입니다. 즉, 인식하지 못할것입니다. 서버는 이것을 분실된 ACK(missing ACKs)로 등록합니다. 혼잡 관리 알고리즘(Congestion control algorithms)은  전송된 패킷과 ACK의 흐름을 사용하여 전송 속도를 결정합니다.</p><br><hr><p> mdn 원본 페이지의 콘텐츠가 너무 길다고 판단되어 DOM과 CSSSOM에 대한 내용을 다룰 <strong>Parsing</strong> 부분은 ‘페이지 채우기: 브라우저가 작동하는 방법 - 2’ 에서 다루겠습니다.</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;/images/browser_work.png&quot;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;본 글은 &lt;a href=&quot;https://developer.mozilla.org/en-US/&quot;&gt;&lt;strong&gt;mdn web docs&lt;/strong</summary>
      
    
    
    
    <category term="Web" scheme="https://joontae-kim.github.io/categories/Web/"/>
    
    <category term="Browser" scheme="https://joontae-kim.github.io/categories/Web/Browser/"/>
    
    
    <category term="mdn" scheme="https://joontae-kim.github.io/tags/mdn/"/>
    
    <category term="Browser" scheme="https://joontae-kim.github.io/tags/Browser/"/>
    
  </entry>
  
  <entry>
    <title>assignment</title>
    <link href="https://joontae-kim.github.io/2020/09/25/assignment/"/>
    <id>https://joontae-kim.github.io/2020/09/25/assignment/</id>
    <published>2020-09-24T16:32:27.000Z</published>
    <updated>2020-09-24T16:59:44.459Z</updated>
    
    <content type="html"><![CDATA[<p>Private Assignment</p><ul><li>Post<ul><li><input disabled="" type="checkbox"> google analytics &amp; console 연동하기<ul><li><a href="https://futurecreator.github.io/2016/06/15/hexo-google-site-search-console-analytics/">https://futurecreator.github.io/2016/06/15/hexo-google-site-search-console-analytics/</a></li><li><a href="https://github.com/ppoffice/hexo-theme-hueman/wiki/Plugins#google-analytics">https://github.com/ppoffice/hexo-theme-hueman/wiki/Plugins#google-analytics</a></li><li><a href="https://futurecreator.github.io/2016/06/17/google-search-how-to-work/">https://futurecreator.github.io/2016/06/17/google-search-how-to-work/</a></li></ul></li><li><input disabled="" type="checkbox"> Hexo Generator Alias<ul><li><a href="https://simhyejin.github.io/2016/06/30/hexo-generator-alias/">https://simhyejin.github.io/2016/06/30/hexo-generator-alias/</a></li><li><a href="https://github.com/hexojs/hexo-generator-alias">https://github.com/hexojs/hexo-generator-alias</a></li></ul></li><li><input disabled="" type="checkbox"> Hexo Server Auto Restart<ul><li><a href="https://hexo.io/docs/commands#server">https://hexo.io/docs/commands#server</a></li><li><a href="https://januszhou.github.io/2016/10/19/auto-restart-hexo-server/">https://januszhou.github.io/2016/10/19/auto-restart-hexo-server/</a></li><li>script in package.json</li></ul></li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Private Assignment&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Post&lt;ul&gt;
&lt;li&gt;&lt;input disabled=&quot;&quot; type=&quot;checkbox&quot;&gt; google analytics &amp;amp; console 연동하기&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;htt</summary>
      
    
    
    
    <category term="assignment" scheme="https://joontae-kim.github.io/categories/assignment/"/>
    
    
    <category term="assignment" scheme="https://joontae-kim.github.io/tags/assignment/"/>
    
  </entry>
  
  <entry>
    <title>seo-friendly - Again Hello</title>
    <link href="https://joontae-kim.github.io/2020/09/24/seo-friendly/"/>
    <id>https://joontae-kim.github.io/2020/09/24/seo-friendly/</id>
    <published>2020-09-24T06:51:47.000Z</published>
    <updated>2020-09-29T12:48:02.975Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/hello_hexo.png"></p><p>자. 이번 포스팅은 Github 블로그의 검색엔진 최적화에 대해 다뤄보도록 하겠습니다. <a href="https://hexo.io/plugins/">hexo plugin</a> 에는 SEO 작업을 위해 아래와 같은 plugin이 존재하고 저는 제가 필요로 하는 몇가지만 세팅해봤습니다.</p><ul><li><p>hexo-generator-feed</p></li><li><p>hexo-generator-seo-friendly-sitemap</p></li><li><p>hexo-generator-robotstxt</p></li><li><p>hexo-auto-canonical</p></li></ul><p>그럼 오늘도 시작해봅시다!</p><h3 id="1-hexo-generator-feed"><a href="#1-hexo-generator-feed" class="headerlink" title="1. hexo-generator-feed"></a>1. <a href="https://github.com/hexojs/hexo-generator-feed">hexo-generator-feed</a></h3><p>hexo-generator-feed는 Atom 1.0 또는 RSS 2.0 형식의 feed를 생성해주는 자동 생성해주는 Plugin으로 Atom, RSS 그리고 Feed의 의미는 대략 아래와 같다.</p><blockquote><p>Feed는 자주 업데이트되는 디지털 컨텐츠를 사용자에게 제공하는데 사용하는 문서 포멧으로 배포를 목적으로 Feed를생성함으로써 Syndicate(배급) 및 Publish(출판) 한다. Feed는 읽거나 Subscribe(구독)한다. 다양한 형식으로 Feed가 제공될 수 있으나 일반적으로 RSS 2.0, ATOM 1.0, RSS 1.0이 사용된다.</p><footer><strong>@네이버블로그_G1Soft</strong><cite><a href="https://m.blog.naver.com/PostView.nhn?blogId=estern&logNo=110145610169&proxyReferer=https:%2F%2Fwww.google.com%2F">m.blog.naver.com/PostView.nhn?blogId=estern&logNo=110145610169&proxyReferer=https:%2F%2Fwww.google.com%2F</a></cite></footer></blockquote><h5 id="일단-설치해봅니다"><a href="#일단-설치해봅니다" class="headerlink" title="일단 설치해봅니다."></a>일단 설치해봅니다.</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-generator-feed --save</span><br></pre></td></tr></table></figure><h5 id="설정"><a href="#설정" class="headerlink" title="설정"></a>설정</h5><p> 문제 없이 설치가 완료됐다면 <strong>블로그 디렉토리  root level</strong>에 있는 <code>_config.yml</code> 에 아래와 같이 세팅해보겠습니다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># RSS, ATOM auto generator</span><br><span class="line">feed:</span><br><span class="line">  type:</span><br><span class="line">    - atom</span><br><span class="line">    - rss2</span><br><span class="line">  path:</span><br><span class="line">    - atom.xml</span><br><span class="line">    - rss2.xml</span><br><span class="line">  limit: 20</span><br></pre></td></tr></table></figure><p>위 설정들은 아래와 같고 <code>hexo generate</code> 명령어를 통해 publish 해주면 <code>public</code> 폴더안에 다음의 이미지와 같이 생성되는 것을 확인하실 수 있을겁니다. (<em>git ignore 상태라 파일이름이 흐린점 양해부탁 드립니다.</em>)</p><pre><code>- type: 생성할 feed 유형- path: feed 파일을 생성할 위치 _(generate 될때의 디렉토리 기준 )_- limit: 각 feed 유형에 담길 content의 개수</code></pre><p><img src="/images/feed_atom.png" alt="atom.xml"></p><p><img src="/images/feed_rss.png" alt="rss2.xml"></p><p>⚠️  그리고 여기서 주의할 점이 만약 <strong>블로그 디렉토리  root level</strong>에 있는 <code>_config.yml</code> 에서 아래 사진과 같이 자신으 <em>github blog url</em> 로 설정해주지 않으면 feed xml 파일이 생성될때 최초 설정값인 <em><a href="http://example.com/">http://example.com</a></em> 을 참조해서 xml content url을 생성합니다. 그러므로 제가 설정한 아래와 같이 <strong><em>자신의 블로그 url</em></strong> 변경해주셔야 합니다.</p><p><img src="/images/config_default_url.png" alt="change defatul url in _config.yml"></p><br><h3 id="2-hexo-generator-seo-friendly-sitemap"><a href="#2-hexo-generator-seo-friendly-sitemap" class="headerlink" title="2. hexo-generator-seo-friendly-sitemap"></a>2. <a href="https://github.com/ludoviclefevre/hexo-generator-seo-friendly-sitemap">hexo-generator-seo-friendly-sitemap</a></h3><p>구글이나 네이버 검색엔진이 블로그의 전체적인 구조를 알 수 있도록 하려면 사이트맵 XML 파일을 제출해야 하는데 <code>deploy</code> 할때마다 <code>sitemap.xml</code> 을 생성해주는 plugin입니다.</p><h5 id="설치"><a href="#설치" class="headerlink" title="설치"></a>설치</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-generator-seo-friendly-sitemap --save</span><br></pre></td></tr></table></figure><h5 id="설정-1"><a href="#설정-1" class="headerlink" title="설정"></a>설정</h5><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">sitemap:</span></span><br><span class="line">    <span class="attr">path:</span> <span class="string">sitemap.xml</span></span><br></pre></td></tr></table></figure><p>기본 옵션 구성은 위와 같으며 <code>sitemap</code> 생성시 페이지, 포스트, 카테고리, 태그에 대한 내용까지 생성해주며, 별도로 생성하고 싶지 않은 부분이 있다면 아래와 같이 설정할 수 있습니다.</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">sitemap:</span></span><br><span class="line">    <span class="attr">path:</span> <span class="string">sitemap.xml</span></span><br><span class="line">    <span class="attr">tag:</span> <span class="literal">false</span></span><br><span class="line">    <span class="attr">category:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure><br><h3 id="3-hexo-generator-robotstxt"><a href="#3-hexo-generator-robotstxt" class="headerlink" title="3. hexo-generator-robotstxt"></a>3. <a href="https://github.com/leecrossley/hexo-generator-robotstxt">hexo-generator-robotstxt</a></h3><p><code>robots.txt</code> 또한 <code>sitemap.xml</code> 과 같이 SEO에 있어서 기본적인 부분입니다. 간략히 의미와 역할에 대해 짚고가자면,</p><blockquote><p>robots.txt 는 웹사이트에 대한 검색엔진 로봇들의 접근을 조절해주고 제어해주는 역할, 그리고 로봇들에게 웹사이트의 사이트맵이 어디 있는지 알려주는 역할을 합니다. 주의하실 점은 여기서 말하는 사이트 맵은 수집 로봇을 위한 XML 사이트 맵을 말하며, 웹사이트의 메뉴 전체를 보여주는 사이트 맵을 의마하는 것은 아닙니다.</p><p>robots.txt 파일을 설정하지 않으면 구글, 네이버 등 각종 검색엔진 로봇들이 웹사이트에서 찾을 수 있는 모든 정보를 크롤링하여 검색엔진 검색결과에 노출시킵니다. 만약 웹사이트 내 특정 페이지가 검색엔진에 노출되지 않기를 바란다면 robots.txt파일을 설정하여 이를 제어할 수 있습니다.</p><footer><strong>@Robots.txt와 Sitemap.xml 알아보기 G1Soft</strong><cite><a href="https://www.twinword.co.kr/blog/basic-technical-seo/">www.twinword.co.kr/blog/basic-technical-seo</a></cite></footer></blockquote><p>이제 <code>robot.txt</code> 에 대한 설정에 대해 보자면 기본적으로 아래의 값들을 이용해 수집 허용 또는 비허용을 설정할 수 있습니다.</p><ul><li>User-agent</li><li>Allow</li><li>Disallow</li></ul><h5 id="robots-txt-규칙-예제"><a href="#robots-txt-규칙-예제" class="headerlink" title="robots.txt 규칙 예제"></a><a href="https://searchadvisor.naver.com/guide/seo-basic-robots">robots.txt 규칙 예제</a></h5><ul><li><p>다른 검색엔진의 로봇에 대하여 수집을 허용하지 않고 네이버 검색로봇만 수집 허용으로 설정합니다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">User-agent: *</span><br><span class="line">Disallow: &#x2F;</span><br><span class="line">User-agent: Yeti</span><br><span class="line">Allow: &#x2F;</span><br></pre></td></tr></table></figure></li><li><p>모든 검색엔진의 로봇에 대하여 수집 허용으로 설정합니다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">User-agent: *</span><br><span class="line">Allow: &#x2F;</span><br></pre></td></tr></table></figure></li><li><p>사이트의 루트 페이지만 수집 허용으로 설정합니다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">User-agent: *</span><br><span class="line">Disallow: &#x2F;</span><br><span class="line">Allow: &#x2F;$</span><br></pre></td></tr></table></figure></li><li><p>관리자 페이지, 개인 정보 페이지와 같이 검색로봇 방문을 허용하면 안 되는 웹 페이지는 수집 비허용으로 설정해주세요. 아래 예제는 네이버 검색로봇에게 /private-image, /private-video 등은 수집하면 안 된다고 알려줍니다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">User-agent: Yeti</span><br><span class="line">Disallow: &#x2F;private*&#x2F;</span><br></pre></td></tr></table></figure></li><li><p>모든 검색로봇에게 사이트의 모든 페이지에 대하여 수집을 허용하지 않는다고 알려줍니다. 이 예제는 사이트의 어떠한 페이지도 수집 대상에 포함되지 않으므로 권장하지 않습니다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">User-agent: *</span><br><span class="line">Disallow: &#x2F;</span><br></pre></td></tr></table></figure></li><li><p>sitemap.xml 지정<br>내 사이트에 있는 페이지들의 목록이 담겨있는 <a href="https://searchadvisor.naver.com/guide/request-feed">sitemap.xml</a>의 위치를 robots.txt에 기록해서 검색 로봇이 내 사이트의 콘텐츠를 더 잘 수집할 수 있도록 도울 수 있습니다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">User-agent: *</span><br><span class="line">Allow: &#x2F;</span><br><span class="line">Sitemap: http:&#x2F;&#x2F;www.example.com&#x2F;sitemap.xml</span><br></pre></td></tr></table></figure></li></ul><br><h5 id="자-이제-설치를-해봅시다"><a href="#자-이제-설치를-해봅시다" class="headerlink" title="자 이제 설치를 해봅시다."></a>자 이제 설치를 해봅시다.</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-generator-robotstxt --save</span><br></pre></td></tr></table></figure><h5 id="설정-2"><a href="#설정-2" class="headerlink" title="설정"></a>설정</h5><p>먼저 <strong>블로그 디렉토리  root level</strong>에 있는 <code>_config.yml</code> 의 plugins에 <code>hexo-generator-robotstxt</code> 를 추가해 활성해주고 <code>robots.txt</code> 를 생성할때 참고할 속성들을 그 밑에 추가해줍니다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">robotstxt:</span><br><span class="line">  useragent: &quot;*&quot;</span><br><span class="line">  allow:</span><br><span class="line">  sitemap: &#x2F;sitemap.xml</span><br></pre></td></tr></table></figure><br><h3 id="4-hexo-auto-canonical"><a href="#4-hexo-auto-canonical" class="headerlink" title="4. hexo-auto-canonical"></a>4. <a href="https://github.com/HyunSeob/hexo-auto-canonical">hexo-auto-canonical</a></h3><p>hexo로 만들어진 블로그의 SEO를 위한 표준 링크(canonical link)를 <code>HEAD 태그</code> 내에 삽입해주는 plugin 입니다.</p><h5 id="설치-1"><a href="#설치-1" class="headerlink" title="설치"></a>설치</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save hexo-auto-canonical</span><br></pre></td></tr></table></figure><h5 id="설정-3"><a href="#설정-3" class="headerlink" title="설정"></a>설정</h5><p><code>hueman</code> 테마의 경우 <code>themes/hueman/layout/common/head.ejs</code> 안에 아래의 코드를 삽입하면 됩니다.</p><p><img src="/images/head_crononical.png"></p><h4 id="참조"><a href="#참조" class="headerlink" title="참조"></a>참조</h4><ul><li><a href="https://github.com/ppoffice/hexo-theme-hueman/wiki/Installation">https://github.com/ppoffice/hexo-theme-hueman/wiki/Installation</a></li><li><a href="https://alleyful.github.io/2019/08/10/tools/hexo/hexo-guide-03/">https://alleyful.github.io/2019/08/10/tools/hexo/hexo-guide-03/</a></li><li><a href="https://futurecreator.github.io/2016/06/23/search-engine-optimization-hexo-plugins/">https://futurecreator.github.io/2016/06/23/search-engine-optimization-hexo-plugins/</a></li><li><a href="https://www.twinword.co.kr/blog/basic-technical-seo/">https://www.twinword.co.kr/blog/basic-technical-seo/</a></li><li><a href="https://searchadvisor.naver.com/guide/seo-basic-robots">https://searchadvisor.naver.com/guide/seo-basic-robots</a></li><li><a href="https://github.com/HyunSeob/hexo-auto-canonical">https://github.com/HyunSeob/hexo-auto-canonical</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;/images/hello_hexo.png&quot;&gt;&lt;/p&gt;
&lt;p&gt;자. 이번 포스팅은 Github 블로그의 검색엔진 최적화에 대해 다뤄보도록 하겠습니다. &lt;a href=&quot;https://hexo.io/plugins/&quot;&gt;hexo plugin</summary>
      
    
    
    
    <category term="Blog" scheme="https://joontae-kim.github.io/categories/Blog/"/>
    
    <category term="Hexo" scheme="https://joontae-kim.github.io/categories/Blog/Hexo/"/>
    
    
    <category term="Hexo" scheme="https://joontae-kim.github.io/tags/Hexo/"/>
    
    <category term="Blog" scheme="https://joontae-kim.github.io/tags/Blog/"/>
    
    <category term="SEO" scheme="https://joontae-kim.github.io/tags/SEO/"/>
    
  </entry>
  
  <entry>
    <title>Change theme - Again Hello</title>
    <link href="https://joontae-kim.github.io/2020/09/24/change-theme/"/>
    <id>https://joontae-kim.github.io/2020/09/24/change-theme/</id>
    <published>2020-09-23T17:09:20.000Z</published>
    <updated>2020-09-29T12:48:42.536Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/hello_hexo.png"></p><p>먼저 theme를 바꾸는 작업을 어렵지 않았습니다. hexo cli를 통해 생성된 모든 블로그 폴더내에는 <strong>theme</strong> 라는 폴더를 가지고 있고 이 안에 변경할 theme를 내려받으면 됩니다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https:&#x2F;&#x2F;github.com&#x2F;ppoffice&#x2F;hexo-theme-hueman.git themes&#x2F;hueman</span><br></pre></td></tr></table></figure><p><img src="/images/install_theme_hueman.png" alt="themes 폴더에 추가된 hueman 테마"></p><p>그리고 블로그의 theme를 변경하려면 블로그 디렉토리의  root level에 있는 <code>_config.yml</code> 에서 theme를 hueman으로 변경한 다음 <strong>hueman</strong> 디렉토리에서 theme 환경설정을 위해  <code>_config.yml.example</code> 파일을 <strong><em>복붙</em></strong> 해서  <code>_config.yml</code> 을 생성해줍니다. 그럼 아래와 같이 <em>두개</em> 가 생성됩니다.</p><ul><li>blog 를 위한 <code>_config.yml</code> </li><li>theme/hueman 을 위한 <code>_config.yml</code> </li></ul><p>이제 테마가 잘 연결되었는지 확인!</p><p><img src="/images/hello_hueman.png" alt="성공!"></p><p>theme는 항상 느끼는거지만 고르는게 어려웠고, 그보다 더 어려웠던건 역시</p><h4 id="Setting…"><a href="#Setting…" class="headerlink" title="Setting…"></a>Setting…</h4><p>개발하다보면 항상 Setup과 Setting 이 오래걸리고 복잡해서 시간을 많이 잡아먹는거 같다. 일단 <strong>hueman</strong> 의 <a href="https://github.com/ppoffice/hexo-theme-hueman/wiki/Theme">공식문서</a>를 참고해보면 기본적으로 <code>menu</code>와 <code>customize</code> 로 구분한다. 먼저 <strong>메뉴</strong> 란 블로그에 접속했을때 유저가 직접적으로 접근할 수 있는 네비게이션바와 같은 역할로 <strong>hueman</strong> 디렉토리 레벨에서의 <code>_config.yml</code>에서 추가 및 삭제할 수 있다.</p><p><img src="/images/hueman_menu.png" alt="메뉴바"></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Menus</span></span><br><span class="line"><span class="attr">menu:</span></span><br><span class="line">    <span class="attr">Home:</span> <span class="string">/</span></span><br><span class="line">    <span class="comment"># Delete this row if you don&#x27;t want categories in your header nav bar</span></span><br><span class="line">    <span class="comment"># Categories:</span></span><br><span class="line">    <span class="attr">About:</span> <span class="string">/about/index.html</span></span><br><span class="line"><span class="string">+</span>   <span class="attr">GitHub:</span> <span class="string">https://github.com</span></span><br><span class="line"><span class="comment"># 주소는 절대주소 또는 상대주소 모두 사용할 수 있다.</span></span><br></pre></td></tr></table></figure><p><strong>theme 커스터마이징</strong>을 해보자. <a href="https://github.com/ppoffice/hexo-theme-hueman/wiki/Theme">공식문서</a> 를 통해 확인해보면 Logo, Theme Color, Sidebar 등등 여러 가지를 수정할 수 있다고 합니다. 먼저 검색 기능을 시작으로 몇 가지만 수정해보도록 하겠습니다.</p><h5 id="검색기능"><a href="#검색기능" class="headerlink" title="검색기능"></a>검색기능</h5><p>위 메뉴바 이미지의 우측에 보면 검색 기능을 확인할 수 있습니다. 기본적으로  <a href="https://github.com/ppoffice/hexo-theme-hueman/wiki/Search#insight-search">Insight Search</a> 기능을 제공해주고, 활용하기 위해서는 아래의 plugin을 설치한 후 <strong>hueman</strong> 디렉토리 레벨의 <code>_config.yml</code> 에서 검색기능을 설정되있는지 확인 또는 활성화해줘야 합니다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -S hexo-generator-json-content</span><br></pre></td></tr></table></figure><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Search</span></span><br><span class="line"><span class="attr">search:</span></span><br><span class="line">    <span class="attr">insight:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">swiftype:</span></span><br><span class="line">    <span class="attr">baidu:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure><br><h5 id="로고"><a href="#로고" class="headerlink" title="로고"></a>로고</h5><p>로고는 사실 있어도 되고 없어도 되지만 일단 블로그의 명패 같은 역할이니 간단하게라도 만들어서 넣어보는것도 좋을거 같습니다. 일단 저는 여기서 약간 헷갈린것이 logo의 파일 위치와 크기였는 <code>themes/hueman -&gt; source -&gt; css -&gt; images</code> 위치에 있으며 대체할 logo 이미지도 같은 위치에 저장 후 url을 수정해주면 될거 같습니다. <code>width</code>와 <code>height</code>는 로고의 위치와 크기를 잡기 위한 약간의 삽질이 필요합니다.</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">logo:</span></span><br><span class="line">    <span class="attr">width:</span> <span class="number">165</span></span><br><span class="line">    <span class="attr">height:</span> <span class="number">60</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">images/logo-header.png</span></span><br></pre></td></tr></table></figure><br><h5 id="썸네일"><a href="#썸네일" class="headerlink" title="썸네일"></a>썸네일</h5><p>블로그 내에서 포스트의 썸네일을 사용할지 말지를 정할 수 있습니다. 마찬가지로 <strong>hueman</strong> 디렉토리 레벨의 <code>_config.yml</code> 에서 수정 가능합니다. </p><p><img src="/images/hueman_thumbnail.png" alt="thumnail 설정"></p><p>썸네일을 활성화 했을경우 post의 <a href="https://hexo.io/docs/front-matter.html">front-matter</a>에 추가함으로써 해당 포스트의 thumbnail으로 작동합니다.</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">title:</span> <span class="string">Hello</span> <span class="string">World</span></span><br><span class="line"><span class="attr">date:</span> <span class="number">2013</span><span class="string">/7/13</span> <span class="number">20</span><span class="string">:46:25</span></span><br><span class="line"><span class="string">+</span> <span class="attr">thumbnail:</span> <span class="string">https://example.com/image.jpg</span></span><br></pre></td></tr></table></figure><br><h5 id="위젯"><a href="#위젯" class="headerlink" title="위젯"></a>위젯</h5><p>위젯 또한 <strong>hueman</strong> 디렉토리 레벨의 <code>_config.yml</code>에서 수정가능하다.</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">widgets:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">recent_posts</span> <span class="comment"># 최근 포스트</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">category</span> <span class="comment"># 카테고리</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">archive</span> <span class="comment"># 어카이브</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">tag</span> <span class="comment"># 태그</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">tagcloud</span> <span class="comment"># 태그클라우드. 사용된 태그들을 빈도수에 따라 구름처럼 표시</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">links</span> <span class="comment"># 링크</span></span><br></pre></td></tr></table></figure><br><h5 id="disqus"><a href="#disqus" class="headerlink" title="disqus"></a>disqus</h5><p>github 블로그에 댓글 기능을 제공하기 위해서 대표적인 서비스인 <a href="https://disqus.com/">disqus</a> 를 세팅해줍니다.</p><ol><li>먼저 계정이 없다면 계정을 생성합니다.</li><li><strong><em>GET STARTED</em></strong> 버튼을 클릭한 후</li><li><strong>hueman</strong> 디렉토리 레벨의 <code>_config.yml</code> 에서 <em>disqus</em> 에 입력하기 위한 <strong>short_name</strong> 으로  블로그 이름 설정합니다.</li></ol><p>(자세한 과정은 <a href="https://simhyejin.github.io/2016/06/24/hexo-themes/">https://simhyejin.github.io/2016/06/24/hexo-themes/</a> 에서 <code>Disqus</code> 파트 참조)</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Comment</span></span><br><span class="line"><span class="attr">comment:</span></span><br><span class="line">    <span class="attr">disqus:</span> [<span class="string">example_short_name</span>] <span class="comment"># enter disqus shortname here</span></span><br><span class="line">    <span class="attr">duoshuo:</span> <span class="comment"># enter duoshuo shortname here</span></span><br><span class="line">    <span class="attr">youyan:</span> <span class="comment"># enter youyan uid here</span></span><br></pre></td></tr></table></figure><p>이상으로 <strong>hueman</strong> 테마를 사용하면서 기본적으로 갖춰볼만한 설정들을 모두 했고, 다음으로는 구글에서 잘 검색되도록 하기위한 세팅들을 다뤄보겠습니다.</p><br><h4 id="참조"><a href="#참조" class="headerlink" title="참조"></a>참조</h4><ul><li><a href="https://github.com/ppoffice/hexo-theme-hueman/wiki/Installation">https://github.com/ppoffice/hexo-theme-hueman/wiki/Installation</a></li><li><a href="https://simhyejin.github.io/2016/06/24/hexo-themes/">https://simhyejin.github.io/2016/06/24/hexo-themes/</a></li><li><a href="https://simhyejin.github.io/2016/06/24/hexo-themes/">https://simhyejin.github.io/2016/06/24/hexo-themes/</a> </li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;/images/hello_hexo.png&quot;&gt;&lt;/p&gt;
&lt;p&gt;먼저 theme를 바꾸는 작업을 어렵지 않았습니다. hexo cli를 통해 생성된 모든 블로그 폴더내에는 &lt;strong&gt;theme&lt;/strong&gt; 라는 폴더를 가지고 있고</summary>
      
    
    
    
    <category term="Blog" scheme="https://joontae-kim.github.io/categories/Blog/"/>
    
    <category term="Hexo" scheme="https://joontae-kim.github.io/categories/Blog/Hexo/"/>
    
    
    <category term="Hexo" scheme="https://joontae-kim.github.io/tags/Hexo/"/>
    
    <category term="Theme" scheme="https://joontae-kim.github.io/tags/Theme/"/>
    
  </entry>
  
  <entry>
    <title>Again Hello</title>
    <link href="https://joontae-kim.github.io/2020/09/23/Again-Hello/"/>
    <id>https://joontae-kim.github.io/2020/09/23/Again-Hello/</id>
    <published>2020-09-23T07:49:07.000Z</published>
    <updated>2020-09-29T12:50:28.211Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/hello_hexo.png"></p><h4 id="고민고민-끝에-GitHub-블로그를-Renewal-해버리게-되었다"><a href="#고민고민-끝에-GitHub-블로그를-Renewal-해버리게-되었다" class="headerlink" title="고민고민 끝에 GitHub 블로그를  Renewal 해버리게 되었다."></a>고민고민 끝에 GitHub 블로그를  Renewal 해버리게 되었다.</h4><p>개인플젝 개발을 마무리하고 블로그에 공부할것 &amp; 공부했던 것들을 정리해야지 했지만 아무리 봐도 이전에 수정하다가 실패한 <em>clean-blog theme</em> 스타일 때문에 거슬려서 이참에 theme를 변경했다.</p><p><strong><em>아니 아예 갈아엎었고, 백업 환경까지 구성했습니다.</em></strong></p><p>작업을 하면서도 의구심이 들었다. “괜히 일만 더 키우는게 아닐까?”, “이럴 시간에 공부한거 정리하던가 강의 들으면서 정리하는게 낫지 않을까?”. 하지만 그래도 다 하고보니 개운해서 다행이다. 그렇다면 어디서부터 어디까지 갈아엎은걸까? 나중에 위해서라도 또는 다른 분들을 위해서라도 정리해보겠습니다.</p><h4 id="Renewal-범위"><a href="#Renewal-범위" class="headerlink" title="Renewal 범위"></a>Renewal 범위</h4><ol><li>theme 변경<ul><li><a href="https://github.com/klugjo/hexo-theme-clean-blog">clean-blog</a> -&gt; <a href="https://github.com/ppoffice/hexo-theme-hueman">hueman</a></li></ul></li><li>hueman 테마 커스터마이징</li><li>blog root &amp; theme 백업하기 (형상관리 by github)</li><li>About 페이지 만들기</li><li>구글 Analytics &amp; Search Console 등록하기</li><li>blog 파일 in root 수정시 hexo server 자동 재시작하기</li></ol><p>사실 위의 과정은 구글에서 검색해보면 좋은 포스팅들이 많고 잘 따라해보면 쉽지만… 막상 따라하다보면 이게 이걸 말하는건가 싶은 점이 있어서 날 위해 그리고 앞으로 하실 분들을 위해 정리해보려고 합니다.</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;/images/hello_hexo.png&quot;&gt;&lt;/p&gt;
&lt;h4 id=&quot;고민고민-끝에-GitHub-블로그를-Renewal-해버리게-되었다&quot;&gt;&lt;a href=&quot;#고민고민-끝에-GitHub-블로그를-Renewal-해버리게-되었다&quot; clas</summary>
      
    
    
    
    <category term="Blog" scheme="https://joontae-kim.github.io/categories/Blog/"/>
    
    <category term="Hexo" scheme="https://joontae-kim.github.io/categories/Blog/Hexo/"/>
    
    
    <category term="Hexo" scheme="https://joontae-kim.github.io/tags/Hexo/"/>
    
    <category term="Renewal" scheme="https://joontae-kim.github.io/tags/Renewal/"/>
    
    <category term="Theme" scheme="https://joontae-kim.github.io/tags/Theme/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="https://joontae-kim.github.io/2020/09/22/hello-world/"/>
    <id>https://joontae-kim.github.io/2020/09/22/hello-world/</id>
    <published>2020-09-22T10:51:30.861Z</published>
    <updated>2020-09-29T12:51:00.912Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot;&gt;documentation&lt;/a&gt; for</summary>
      
    
    
    
    <category term="Blog" scheme="https://joontae-kim.github.io/categories/Blog/"/>
    
    <category term="Hexo" scheme="https://joontae-kim.github.io/categories/Blog/Hexo/"/>
    
    
    <category term="Hello World" scheme="https://joontae-kim.github.io/tags/Hello-World/"/>
    
  </entry>
  
</feed>
