<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>dev and dev</title>
    <link>https://joontae-kim.github.io/</link>
    
    <atom:link href="https://joontae-kim.github.io/rss2.xml" rel="self" type="application/rss+xml"/>
    
    <description>내가 볼려고 만든 깃헙 블로그</description>
    <pubDate>Mon, 26 Oct 2020 07:56:45 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title>프론트엔드 면접 질문 목록</title>
      <link>https://joontae-kim.github.io/2020/10/26/interview-question-list/</link>
      <guid>https://joontae-kim.github.io/2020/10/26/interview-question-list/</guid>
      <pubDate>Mon, 26 Oct 2020 05:38:17 GMT</pubDate>
      
        
        
      <description>&lt;p&gt;&lt;img src=&quot;/images/job_thumbnail.jpeg&quot; alt=&quot;면접!&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;Interview-Question-Summary&quot;&gt;&lt;a href=&quot;#Interview-Question-Summary&quot; class=&quot;hea</description>
        
      
      
      
      <content:encoded><![CDATA[<p><img src="/images/job_thumbnail.jpeg" alt="면접!"></p><h2 id="Interview-Question-Summary"><a href="#Interview-Question-Summary" class="headerlink" title="Interview Question Summary"></a>Interview Question Summary</h2><h4 id="프론트엔드-면접-준비를-위한-질문-리스트-정리"><a href="#프론트엔드-면접-준비를-위한-질문-리스트-정리" class="headerlink" title="프론트엔드 면접 준비를 위한 질문 리스트 정리!"></a>프론트엔드 면접 준비를 위한 질문 리스트 정리!</h4><p>아래 질문 리스트를 기반으로 면접 질문 &amp; 답변 목록을 작성할 예정이고, 지속적으로 보충 or 보수할 계획입니다.</p><p>업데이트 날짜</p><ul><li>2020-10-26</li></ul><h3 id="FE"><a href="#FE" class="headerlink" title="FE"></a>FE</h3><ul><li>브라우저의 렌더링 과정에 대해서 상세하게 설명해달라</li><li>DOM (Document Object Model)<ul><li>이벤트 버블링(Event Bubbling), 이벤트 캡쳐링(Event Capturing)에 대해서 설명하세요.</li><li>이벤트 위임(event delegation)에 대해 설명하세요.</li></ul></li><li>DOM을 건드리는 방식과 아닌 방식들의 차이</li><li>클라이언트 개발시 보안 관련 이슈<ul><li>보안은 서버쪽에서 많이 신경쓰고 있지만, 프론트엔드 개발에서 보안관련 이슈는 어떠한 것들이 있는가</li><li>Wireshark 에 대해 알고 있는가</li><li>HTTP 통신의 문제점에 대해서 아는대로 말해달라</li><li>CORS(Cross-Origin Resource Sharing)는 무엇인가 왜 이러한 방법이 정의 되었으며, 본인이 코드를 작성하면서 CORS와 관련하여서 경험하였던 이슈는 무엇인가</li><li>간단한 데이터를 클라이언트로만 관리 할수 있는가, 이와 관련해서 브라우저 에서 어떠한 것들을 지원하고 있는가, 예를 들면 소셜 로그인같은 것들에 대한 브라우저 종료시 발생하는 문제에 대응 경험이 있는가</li></ul></li><li>라이브러리와 프레임워크에 대해서 설명</li><li>프로세스와 스레드의 차이</li><li>CSR과 SSR의 차이</li></ul><h3 id="Network"><a href="#Network" class="headerlink" title="Network"></a>Network</h3><ul><li>Http와 Https 통신 방식의 차이?</li><li>웹 프로토콜이란</li><li>CORS(Cross-Origin Resource Sharing)는 무엇인가 왜 이러한 방법이 정의 되었으며, 본인이 코드를 작성하면서 CORS와 관련하여서 경험하였던 이슈는 무엇인가</li><li>RESTful API 가 무엇인가, 아는대로 다 말해달라</li></ul><h3 id="Programming"><a href="#Programming" class="headerlink" title="Programming"></a>Programming</h3><ul><li><p>가비지컬렉터의 역할은? 어떻게 동작?</p></li><li><p>타입스크립트를 사용해본 경험이 있는가, 타입스크립트에 대한 본인의 생각과 도입시의 장점을 말해달라</p></li><li><p>메소드 체이닝이란 무엇이며, 이것의 장단점은 무엇인가?</p></li><li><p>메모라이제이션이란</p></li><li><p>배포를 해본적이 있는가?</p><ul><li>어떻게 배포를 해보았나</li></ul></li><li><p>적응형과 반응형 디자인과 차이를 아는가</p></li><li><p>반응형 프로그래밍</p></li><li><p>Call by value &amp; call by ref</p></li><li><p>쓰로틀링과 디바운스</p></li><li><p>디자인 패턴</p></li></ul><h3 id="JS"><a href="#JS" class="headerlink" title="JS"></a>JS</h3><ul><li><p>실행 컨텍스트(Execution Context)에 대해 설명해달라</p></li><li><p>Javascript Scope Chaining</p></li><li><p>전역 scope를 사용했을 때 장단점에 관해 설명해주세요.</p></li><li><p>이벤트 루프와 동시성 모델에 대해서 설명</p></li><li><p>document load와 DOM Content Loaded의 차이</p><ul><li>document load : DOM을 비롯한 모든 asset이 로드된 후 발생</li><li>DOM Content Loaded : 초기 html 문서가 완전히 로드되고 나면 파싱 후 발생</li></ul></li><li><p>attribute와 property</p><ul><li>attribute : HTML 마크업에서 정의</li><li>property : DOM에서 정의</li></ul></li><li><p>호스트 객체(Host Objects)와 네이티브 객체(Native Objects)의 차이점은 무엇인가요?</p><ul><li>호스트 객체 : 빌트인 또는 네이티브 객체에 포함되지 않은 사용자에 의해 생성된 객체 ⇒ js는 빌트인 및 네이티브 객체 구성 후 호스트 객체를 해석</li><li>네이티브 객체 : 브라우저 혹은 구동 엔진에 내장되어 있는 객체 DOM이 이에 해당 ⇒ 구동앤잔 별 사용성이 달라서 크로스 브라우징 문제를 바랭시키기도 함</li></ul></li><li><p>자바스크립트의 원시 타입(Primitive Data Type)은 몇가지이며, 전부 말해달라</p><ul><li>Number, String, Boolean, Null, Undefined, (Symbol)</li></ul></li><li><p>null vs undefined</p></li><li><p>use strict 은 무엇이고, 사용했을 때 장단점에 관해서 설명해주세요.</p></li><li><p>클로져(Closure)는 무엇이며, </p></li><li><p>자바스크립트의 Number Type은 다른 언어들과 차이점이 무엇인가, 왜 하나만 존재하는가</p></li><li><p>자바스크립트의 순환참조란? 어떤게 문제이고 해결방법은?</p></li><li><p><code>function foo() &#123;&#125;</code> 와 <code>var foo = function() &#123;&#125;</code> 에서 foo 의 차이가 무엇인지 설명해보세요.</p></li><li><p>ES6에서 화살표 함수와 일반 함수의 차이는</p></li><li><p>자바스크립트의 배열(Array)이 실제 자료구조 배열이 아닌데 그 이유는?</p></li><li><p>자바스크립트의 호이스팅(Hoisting)은 어떻게 이루어져 있는가</p></li><li><p>클로저(Closure)란 무엇이며, 어떻게 사용하는지, 왜 이러한 패턴을 사용하는가</p></li><li><p>This</p><ul><li>자바스크립트에서 This는 몇가지로 추론 될수 있는가, 아는대로 말해달라</li><li>일반함수의 this와 화살표 함수의 this는 어떻게 다른가?</li><li>Call, Apply, Bind 함수에 대해 설명해달라</li><li>use strict모드에서의 this?</li></ul></li><li><p>프로토타입이란</p></li><li><p>객체 지향 프로그래밍(Object Oriented Programming)</p><ul><li>OOP에 특징에 대해 설명해달라(상속, 캡슐화 등등…)</li><li>현실에 상황을 예로 들어 OOP의 개념으로 설계과정을 설명해달라<br>ex) 축구를 게임으로 만든다거나, 기타 어떠한 상황이라도 좋다</li><li>프로토타입 상속이 이루어지는 법</li></ul></li><li><p>함수형 프로그래밍(Function Programming)</p><ul><li>함수형 프로그래밍에 대해 설명해달라</li><li>함수형 프로그래밍에 개념에서 순수함수란 무엇인가</li><li>OOP와 함수형 프로그래밍의 가장 큰 차이점은 무엇인가</li></ul></li><li><p>OOP와 함수형 프로그래밍의 차이</p></li><li><p>ES6</p><ul><li>크롬 정도의 브라우저를 제외하곤 ES6 스펙에 대한 지원이 완벽하지 않다. 해결방법은 무엇인가</li><li>Babel이란? babel은 컴파일러 인가 ? 트랜스파일러인가</li><li>ES6 에서 추가된 스펙에 대해 아는대로 다 말해달라</li><li>var 와 let, const의 차이점은 무엇인가 (function scope와 block scope의 개념에서)</li><li>Class 는 무엇이고, Prototype, fucntion의 ES5 스펙만으로 Class를 구현할수 있는가</li></ul></li><li><p>익명함수와 함수 즉시 호출</p></li><li><p>비동기 프로그래밍</p><ul><li>동기 함수와 비동기 함수</li><li>AJAX란 무엇인가</li><li>Callback 함수란</li><li>Promise 함수</li><li>Promise와 Callback의 차이점은 무엇이며 각각의 장단점에 대해 설명해달라</li><li>Promise란 무엇이며 코드가 어떻게 구성되어있는가</li><li>async, await는 무엇이며 Promise의 차이는</li></ul></li><li><p>고차함수 (High-Order Function)</p></li><li><p>JSON이 무엇이며 사용하면 어떠한 장점이 있나요?</p></li><li><p>JSONP의 동작</p><ul><li>크로스 도메인 이슈에 의해 ajax 요청이 허용 되지 않아 우회용으로 많이 쓰임 ⇒ script 태그를 통해 callback 쿼리 매게 변수를 요청함</li></ul></li><li><p>모듈 패턴과 전통적 상속, 각각의 장단점을</p></li></ul><h3 id="CSS"><a href="#CSS" class="headerlink" title="CSS"></a>CSS</h3><ul><li>CSS cascading system</li><li>CSS 적용 우선순위</li><li>CSS selector 동작원리</li><li>선택자<ul><li>하위 선택자 : 부모요소에 포함딘 모든 하위 요소에 스타일 적용</li><li>자식 선택자 : 부모 바로 아래 자식 요소에만 적용</li></ul></li><li>float</li><li>float 속성 해제 방법</li><li>이미지 대체</li><li>컨텐츠 이미지 숨기기</li><li>inline vs inline-box</li><li>px and em</li><li>inline vs inline block</li><li>Progressive Rendering</li><li>개발사 접두어</li><li>반응형과 적응형 웹</li><li>반응형 웹의 3요소<ul><li>미디어 쿼리, 플루이드 그리드, flexible img</li></ul></li><li>@media속성</li><li>모바일 우선 전략</li><li>w3c box iebox</li><li>Position 요소</li><li>자식 중앙 정렬</li><li><em>And 나머지는 여기서</em> =&gt; <a href="https://yangshun.github.io/front-end-interview-handbook/kr/css-questions">https://yangshun.github.io/front-end-interview-handbook/kr/css-questions</a></li></ul><h3 id="HTML"><a href="#HTML" class="headerlink" title="HTML"></a>HTML</h3><ul><li><p>Doctype</p></li><li><p>표준모드와 쿼크모드</p></li><li><p>다국어 서비스 제공방법</p></li><li><p><a href="https://yangshun.github.io/front-end-interview-handbook/kr/html-questions/#html5%EB%A5%BC-%EA%B0%9C%EB%B0%A9%ED%98%95-%EC%9B%B9-%ED%94%8C%EB%9E%AB%ED%8F%BC%EC%9C%BC%EB%A1%9C-%EA%B0%84%EC%A3%BC%ED%95%A0-%EB%95%8C-html5%EC%9D%98-%EA%B5%AC%EC%84%B1-%EC%9A%94%EC%86%8C%EB%8A%94-%EB%AC%B4%EC%97%87%EC%9D%B8%EA%B0%80%EC%9A%94">HTML5를 개방형 웹 플랫폼으로 간주할 때, HTML5의 구성 요소는 무엇인가요?</a> </p></li><li><p><a href="https://yangshun.github.io/front-end-interview-handbook/kr/html-questions/#script-script-async-script-defer-%EC%82%AC%EC%9D%B4%EC%9D%98-%EC%B0%A8%EC%9D%B4%EC%A0%90%EC%9D%84-%EC%84%A4%EB%AA%85%ED%95%98%EC%84%B8%EC%9A%94"><code>&lt;script async&gt;</code>, <code>&lt;script defer&gt;</code> 사이의 차이점을 설명하세요.</a></p><ul><li>script async : 페이지 파싱과 동시에 비동기적으로 진행</li><li>script defer : html 구문 분석이 끝나면 스크립트 파일 실행</li><li>script : html 파싱 도중 정지하고 실행</li></ul></li><li><p>window 객체란 무엇입니까?</p></li><li><p>DOM</p></li><li><p>블록요소와 인라인요소</p></li><li><p>웹 스토리지</p><ul><li>쿠키, 로컬 스토리지, 세션 스토리지의 정의와 차이점</li></ul></li><li><p>FOUC</p><ul><li>브라우저로 웹 문서에 접근할 때 CSS 스타일이 미적용된 모습이 화면에 노출되며 생기는 깜빡임</li><li>CSS를 <code>&lt;head&gt;</code> 안에 import하고 <code>@import</code> 사용 자제</li><li>FOUC를 보여주는 요소를 js를 통해 숨긴 후 script가 모두 적용된 후 보여줌</li></ul></li><li><p>XML과 HTML</p><ul><li>XML은 웹 브라우저 외에도 포괄적으로 사용되는 형식으로 데이터 교환에 특화되어 있으며 이것 만으론 데이터를 가지고 있을 뿐 화면에 표시되지 않는다. HTML은 웹 브라우저에서 사용하는 문서 형식이며 XHTML은 HTML규격이 가진 문제를 극복하고 확장기능을 제공한다.</li></ul></li><li><p>CSS와 JS 문서의 위치</p><ul><li>CSS를 <head>안에 넣으면 페이지 로딩 중 스타일 적용이 안 된 DOM의 모습을 안보이게 하고 js를 <body> 앞에 놓으면 CSS로딩 직후 로딩 되어 사용자가 조금 빠르다고 느낄 수 있다.</li></ul></li><li><p>기능이 제한된 브라우저 페이지 만들기</p><ul><li>우아한 퇴보, 점진적 향상</li></ul></li><li><p>Single Page Application</p><ul><li>최초 한 번 페이지를 전체 로드한 후 데이터만 변경하여 사용 가능한 어플리케이션<ul><li>클라이언트 사이드 랜더링 : 서버는 JSON 파일만 보내주고 html을 그리는 건 자바스크립트가 담당</li><li>html 다운로드 ⇒ js 다운로드 및 해석 ⇒ Fetch Data</li><li>서버 사이드 랜더링 : html 다운로드 ⇒ 사용자가 봄</li></ul></li></ul></li></ul><h3 id="Vue"><a href="#Vue" class="headerlink" title="Vue"></a>Vue</h3><ul><li>Vue를 선택한 이유</li><li>Vue의 장점</li><li>vue에서의 라이프사이클?</li><li>vue와 React의 차이?</li><li>가상돔 (virtual DOM)</li><li>면접관을 Vue.js 비사용자라고 가정하고 Vue.js에 설명하고 장단점을 말해달라</li><li>Vue.js의 Life-cycle에 대해 아는대로 말해달라</li><li>Vue.js 에서 DOM은 어느 시점에 생성되나</li><li>Computed와 Methods의 차이점은 무엇인가</li><li>가상돔(Virtual DOM) 개념은 무엇이며, DOM과의 차이점 가상돔의 개념이 사용되게된 배경은 무엇인가</li><li>최근의 프레임워크를 사용할때 외부 라이브러리와의 결합시에 더 나은 코드 작성법을 고민해본적이 있는가</li><li>DOM을 직접 조작하는 D3.js 같은 라이브러리와의 결합시에 예상되는 문제점이 있는가</li><li>State 관리</li><li>Vuex 상태 관리 &amp; Redux</li></ul><h3 id="개발외-질문-목록"><a href="#개발외-질문-목록" class="headerlink" title="개발외 질문 목록"></a>개발외 질문 목록</h3><ul><li><p>왜 개발자가 되려고 하는가</p></li><li><p>개발자로서의 본인의 비전을 이야기 해달라</p></li><li><p>비전공자로써 갖고 있는 컴플렉스가 있는가</p></li><li><p>운영체제같은 컴퓨터공학(cs)에 대한 기초지식이 있는가</p></li><li><p>최근에 관심갖거나 공부 하고 싶은 개발 기술은 무엇인가</p></li><li><p>프로젝트 협업 과정을 경험한 적이 있는가</p></li><li><p>공부 방법</p><ul><li>개발자가 되기 위해서 어떻게 공부하였는가</li><li>학습시 주로 이용하는 웹페이지나, 동영상 강좌 페이지는 어디인가</li><li>최근의 읽은 개발 관련 서적은 무엇인가</li><li>즐겨 보는 개발 관련 유튜브가 있는가</li><li>회사 기술 스택에 맞추어 단기간 내에 언어와 프레임워크를 학습 하여야 할 때, 어떻게 공부하고 해결할 것인가</li></ul></li><li><p>포트폴리오 제작시에 비인기 라이브러리를 사용한 경험이 있는가</p></li><li><p>이러한 비인기 라이브러리에 대한 정보를 어디서 얻는가 왜 활용하였는가</p></li></ul><h3 id="FE-개발-환경"><a href="#FE-개발-환경" class="headerlink" title="FE 개발 환경"></a>FE 개발 환경</h3><ul><li>Eslint가 무엇인가요</li><li>Webpack이란</li><li>패키지매니저로 어떤거 사용? npm<ul><li>npm과 yarn은 어떤게 다른가</li></ul></li><li>AMP<ul><li>AMP의 개념은 무엇이고 기존의 것에 비해 장점은 무엇인가</li><li>최근의 프레임워크들과의 조합을 고려해 본적이 있는가 ex) vue-amp..</li></ul></li><li>package.json 파일의 역할</li><li>package.json에서 dependencies와 devDependencies의 차이는</li></ul><h3 id="git"><a href="#git" class="headerlink" title="git"></a>git</h3><ul><li>두 명의 프론트엔드 개발자가 있다 git을 관리하는 방식?</li><li>git pull request rebase 와 다른 방법</li></ul><h3 id="자료구조-Data-Structure-amp-알고리즘"><a href="#자료구조-Data-Structure-amp-알고리즘" class="headerlink" title="자료구조(Data Structure) &amp; 알고리즘"></a>자료구조(Data Structure) &amp; 알고리즘</h3><ul><li>자료구조에 대해 공부한 적이 있는가</li><li>Binary Search Tree 에 대해 알고 있는가, 설명해달라</li><li>Graph 에서 다른 노드를 참조하는 구조를 코드로 구현 할수 있는가</li><li><a href="https://daniel-park.tistory.com/category/Alogorithm?page=1">https://daniel-park.tistory.com/category/Alogorithm?page=1</a></li><li><a href="https://www.educative.io/blog/javascript-data-structures">https://www.educative.io/blog/javascript-data-structures</a></li></ul><hr><h2 id="리스트-관련-링크"><a href="#리스트-관련-링크" class="headerlink" title="리스트 관련 링크"></a>리스트 관련 링크</h2><ul><li><a href="https://velog.io/@honeysuckle/%EC%8B%A0%EC%9E%85-%ED%94%84%EB%A1%A0%ED%8A%B8%EC%97%94%EB%93%9C-%EB%A9%B4%EC%A0%91-%EC%A7%88%EB%AC%B8-%EB%AA%A8%EC%9D%8C">https://velog.io/@honeysuckle/%EC%8B%A0%EC%9E%85-%ED%94%84%EB%A1%A0%ED%8A%B8%EC%97%94%EB%93%9C-%EB%A9%B4%EC%A0%91-%EC%A7%88%EB%AC%B8-%EB%AA%A8%EC%9D%8C</a></li><li><a href="https://mber.tistory.com/2">https://mber.tistory.com/2</a></li><li><a href="https://sunnykim91.tistory.com/121">https://sunnykim91.tistory.com/121</a></li><li><a href="https://devowen.com/283">https://devowen.com/283</a></li><li><a href="https://devowen.com/276">https://devowen.com/276</a></li><li></li></ul><h2 id="인터뷰-관련-링크"><a href="#인터뷰-관련-링크" class="headerlink" title="인터뷰 관련 링크"></a>인터뷰 관련 링크</h2><ul><li>브라우저는 어떻게 동작하는가? <a href="http://d2.naver.com/helloworld/59361">http://d2.naver.com/helloworld/59361</a></li><li>최신 웹사이트와 꼼꼼한 개발자들을 위한 완벽 프론트엔드 체크리스트 <a href="https://github.com/kesuskim/Front-End-Checklist">https://github.com/kesuskim/Front-End-Checklist</a></li><li>예비 개발자들의 기술 면접 준비를 위한 자료 <a href="https://github.com/JaeYeopHan/Interview_Question_for_Beginner">https://github.com/JaeYeopHan/Interview_Question_for_Beginner</a></li><li>프론트엔드 인터뷰 핸드북 <a href="https://github.com/yangshun/front-end-interview-handbook/tree/master/Translations/Korean">https://github.com/yangshun/front-end-interview-handbook/tree/master/Translations/Korean</a></li><li>Awesome Interview Questions <a href="https://github.com/MaximAbramchuck/awesome-interview-questions">https://github.com/MaximAbramchuck/awesome-interview-questions</a></li><li>프론트엔드 면접 문제 은행 <a href="https://github.com/h5bp/Front-end-Developer-Interview-Questions/tree/master/Translations/Korean">https://github.com/h5bp/Front-end-Developer-Interview-Questions/tree/master/Translations/Korean</a></li></ul>]]></content:encoded>
      
      
      <category domain="https://joontae-kim.github.io/categories/Blog/">Blog</category>
      
      <category domain="https://joontae-kim.github.io/categories/Blog/Job/">Job</category>
      
      
      <category domain="https://joontae-kim.github.io/tags/Front-end/">Front-end</category>
      
      <category domain="https://joontae-kim.github.io/tags/Interview/">Interview</category>
      
      <category domain="https://joontae-kim.github.io/tags/Job/">Job</category>
      
      
      <comments>https://joontae-kim.github.io/2020/10/26/interview-question-list/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>함수 (function)</title>
      <link>https://joontae-kim.github.io/2020/10/20/js-function/</link>
      <guid>https://joontae-kim.github.io/2020/10/20/js-function/</guid>
      <pubDate>Tue, 20 Oct 2020 09:21:06 GMT</pubDate>
      
        
        
      <description>&lt;p&gt;&lt;img src=&quot;/images/javascript.png&quot; alt=&quot;Javascript&quot;&gt;&lt;/p&gt;
&lt;p&gt;기본적으로 함수란 특정 기능을 구현한 집합체, 특정 문제 또는 필요로 하는 요구사항를 해결하기 위해 수행하는 코드의 묶음 또는 블록으로,  </description>
        
      
      
      
      <content:encoded><![CDATA[<p><img src="/images/javascript.png" alt="Javascript"></p><p>기본적으로 함수란 특정 기능을 구현한 집합체, 특정 문제 또는 필요로 하는 요구사항를 해결하기 위해 수행하는 코드의 묶음 또는 블록으로,  Javascript에서 함수는 한번 구현해놓으면 재호출해 코드의 재사용성을 높일 수 있으며 함수 내 특정 변수를 숨기기 위한 캡슐화와 기능을 세분화해 코드의 유지보수의 용이성과 확장성을 높힐 수 있습니다.</p><p> Javascript 함수(Function)의 구조는 아래와 같이 구성되어 있습니다. </p><ul><li><strong>함수명(function name)</strong></li><li>함수블록 내에서 처리하기 위해 전달되는 <strong>매개변수들(Parameter)과 인자(Argument)</strong></li><li>함수의 기능을 구현하기 위한 <strong>몸체(function body) 또는 구문(statement)</strong></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 함수 정의</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">name</span>(<span class="params">para, meter</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// statement</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 함수 호출</span></span><br><span class="line">name(<span class="string">&#x27;argue&#x27;</span>, <span class="string">&#x27;ment&#x27;</span>)</span><br></pre></td></tr></table></figure><p>Javascript에서 함수(Function)은 원시값과 객체 데이터 타입 중 객체(Object)에 속하는 타입으로, 특히 Javascript의 함수는 <strong>일급 객체(First-class object)</strong> 로써 동적 생성과 리터럴 방식으로 함수를 생성할 수 있으며 변수(Variable), 배열(Array) 내 요소, 객체의 프로퍼티(Property) 등에 할당 가능하다는 특징을 가지고 있습니다.</p><h2 id="함수-정의하기"><a href="#함수-정의하기" class="headerlink" title="함수 정의하기"></a>함수 정의하기</h2><p>Javascript에서 함수를 정의하기 위한 방법으로는 여러가지가 있으며 대표적으로는 함수 선언문(Declarations), 표현식(expressions) 그리고 ECMAScript 6에서 추가된 화살표 함수(Arrow function)이 있다.</p><p><strong>비고 :</strong>  <code>Function</code> 생성자(constructor)로 함수를 정의하는 것은 JS 엔진 최적화를 방해 또는 기타 다른 문제를 유발할 수 있는 이유로 권장되지 않는 방식입니다.</p><h4 id="함수-선언문-Declarations"><a href="#함수-선언문-Declarations" class="headerlink" title="함수 선언문(Declarations)"></a>함수 선언문(Declarations)</h4><p>Javascript에서 함수를 정의하기 위해 사용되는 가장 대표적인 방법으로, 서두에서 언급한 함수 구조를 띄고 있다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 함수 정의</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">decFunction</span>(<span class="params">para, meter</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> para + meter</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 함수 호출</span></span><br><span class="line">decFunction(<span class="string">&#x27;argu&#x27;</span>, <span class="string">&#x27;ment&#x27;</span>) <span class="comment">// &#x27;argument&#x27;</span></span><br></pre></td></tr></table></figure><ul><li><strong>함수명 :</strong> 함수 또는 구현된 기능을 대표하기 위한 함수의 이름으로 일반적 함수 호출, 재귀적 호출 그리고 실행 컨텍스트에서 memory 상에 함수를 올리기 위한 식별자(Identifier)의 목적으로 함수 선언문에서는 생략할 수 없는 필수요소이다.</li><li><strong>매개변수 :</strong> 함수 등에서 사용되는 전달된 값을 받는 변수로써, 함수의 기능상 외부 환경에서 데이터를 받아 가공 및 반환이 필요할 경우 함수 내부로 전달하는 역할을 하며 <code>콤마(,)</code> 로 구분하여 최대 255개까지 받을 수 있습니다.</li><li><strong>함수 구문 :</strong> 함수의 로직을 담당하는 부분으로 <code>중괄호 &#123;&#125;</code> 안에 매개변수를 받아 데이터를 처리하거나 DOM을 조작하는 등 필요에 따른 특정 기능을 담고 있는 중추적 부분입니다.</li><li>인자: 함수에 전달되는 인수의 배열집합으로써, 정확히는 유사배열 객체로 <code>arguments</code> 객체라 칭하며 매개변수를 통해 전달받은 함수 외부환경의 값, 변수 또는 참조</li><li>반환값 : 함수 내부에서 처리된 값으로 <code>return</code> 키워드를 통해 처리된 값을 반환할 수 있다. 또한 함수의 코드상 종료시점에 <code>return</code>  구문이 없다면 함수는 <code>undefined</code>  를 반환하도록 Javascript에서는 설계되어 있다.</li></ul><h4 id="함수-표현식-expressions"><a href="#함수-표현식-expressions" class="headerlink" title="함수 표현식(expressions)"></a>함수 표현식(expressions)</h4><p>함수 선언문(Declarations)과 다르게 함수를 변수에 할당한다는 점이 다른 점으로 함수의 <strong>일급 객체(First-Class Object)</strong> 의 특성을 이용한 함수식이다.</p><p>구조적 요소는 함수 표현식과 같으나 코드상 구조는 변수에 할당한다는 점이 다르다. 아래를 보자.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Anonymous function expression (익명 함수 표현)</span></span><br><span class="line"><span class="keyword">var</span> expFunction = <span class="function"><span class="keyword">function</span> (<span class="params">para, meter</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> para + meter</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Named function expression (기명 함수 표현)</span></span><br><span class="line"><span class="keyword">var</span> expNamedFunction = <span class="function"><span class="keyword">function</span> <span class="title">namedFunction</span> (<span class="params">para, meter</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> para + meter</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(expFunction(<span class="string">&#x27;argu&#x27;</span>, <span class="string">&#x27;ment&#x27;</span>)); <span class="comment">// &#x27;argument&#x27;</span></span><br><span class="line"><span class="built_in">console</span>.log(expNamedFunction(<span class="string">&#x27;argu&#x27;</span>, <span class="string">&#x27;ment&#x27;</span>)); <span class="comment">// &#x27;argument&#x27;</span></span><br><span class="line"><span class="built_in">console</span>.log(namedFunction(<span class="string">&#x27;argu&#x27;</span>, <span class="string">&#x27;ment&#x27;</span>)); <span class="comment">// Uncaught ReferenceError: expNamedFunction is not defined</span></span><br></pre></td></tr></table></figure><p>함수 표현식은 함수명을 생략하는 익명 함수 방식의 선언이 일반적이지만 기명 함수 표현으로 생성했을 경우, 스택 트레이스에 함수 이름이 포함되어 <em>오류의 원인을 쉽게 찾을 수 있다는 이점</em> 이 있습니다.</p><p>그리고 함수를 할당 받은 변수는 기명 함수라고 할지라도 함수명을 저장하는 것이 아니라 기명이든 익명이든 함수의 참조값을 저장하게 된다.</p><p><strong>위 두개의 함수 정의문은 모두 <em>함수 리터럴 방식</em> 의 함수생성법으로 결국 Function Contstructor 함수로 함수 정의 방식을 단축화한 것으로 *일종의 축약법(short-way)*이라고 할 수 있다.</strong></p><h2 id="클로저"><a href="#클로저" class="headerlink" title="클로저"></a>클로저</h2><p><em>(Javascript의 클로저 개념은 다룰게 많기때문에 여기서는 함수와 클로저의 관계와 중심적 내용만 다루고 넘어가겠습니다. 자세한 내용은 포스팅할 예정입니다.)</em></p><p>Javascript의 함수를 언급할때 빠지지 않는 것이 있다면 바로 <strong>Closure</strong> 일 것이다. <strong>Closer</strong> 란 무엇인지 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Closures">MDN에서 정의한 Closure</a> 에 대한 내용을 보자.</p><blockquote><p>A <strong>closure</strong> is the combination of a function bundled together (enclosed) with references to its surrounding state (the <strong>lexical environment</strong>). In other words, a closure gives you access to an outer function’s scope from an inner function. In JavaScript, closures are created every time a function is created, at function creation time.</p><hr><p><strong>closure</strong> 는 주변 상태에 대한 참조와 함께 번들로 묶인 (포함된) 함수의 조합입니다. (<strong>lexical environment</strong>). 다른 말로, 클로저는 내부 함수에게 외부 변수의 스코프에 접근할 수 있도록 해주는 것이다. Javascript에서 클로저는 함수가 생성될 때마다 생성된다. </p></blockquote><p>이전에 포스팅한 <a href="https://joontae-kim.github.io/2020/10/12/excution-context/">자바스크립트 실행 컨텍스트(Execution Context)</a> 에 대해 알고 있다면 대략 무슨 뜻인지 이해할 수 있다. 즉, <strong>함수와 함수의 참조 환경인 Lexical Environment의 조합으로 구성된 함수</strong>로써 자식함수가 부모함수의 Scope를 <strong>Outer Lexical Environment</strong> 로 참조(Reference)함으로써 Closer의 장점인 <strong>은닉화, 캡슐화</strong> 등의 장점을 통해 <strong>Public/Private 메서드</strong> 를 흉내낼 수 있다.</p><p>이해를 돕기 위해 예제를 보자.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isUnder30</span> (<span class="params">age</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> min = <span class="number">30</span>;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">checkAge</span> (<span class="params">age</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> age &lt; min;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> checkAge(age)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">isUnder30(<span class="number">29</span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>위 예제는 중첩 함수로써, 위에서 말한 클로저의 정의와 환경에 충족하고 있다. 실행 환경을 분석해보자.</p><ol><li>실행 컨텍스트 스택에 전역 실행 컨텍스트 push</li><li><strong>isUnder30</strong> 가 호출 및 실행되면서 isUnder30 함수의 실행 컨텍스트가 push<ol><li>Lexical Environment에 변수 min, 내부함수 checkAge 그리고 Outer Lexical Environment로써 전역 실행 컨텍스트가 정의 및 참조되고</li><li>외부함수로 정의 가능한 isUnder30 함수가 checkAge 함수를 return 하면서 </li><li>checkAge 함수를 호출하고 isUnder30 함수의 함수 실행 컨텍스트는 종료된다.</li></ol></li><li>그리고 내부함수인 <strong>checkAge</strong> 가 호출 및 실행되면서 checkAge 함수의 함수 실행 컨텍스트가 push<ol><li>Lexical Environment에 변수 min, 인자 age 그리고 Outer Lexical Environment로써 isUnder30 함수 실행 컨텍스트가 정의 및 참조되고</li><li>실행되는 동안 min 변수 값을 내부 스코프에서 검색하지 못함으로써 Outer Lexical Environment에서 검색해서 값을 가지고 와서</li><li><code>return age &lt; min;</code> 결과값을 반환(return) 하면서</li><li>checkAge 함수의 실행 컨텍스트 또한 종료된다.</li></ol></li></ol><p>위 순서를 보면 checkAge 가 isUnder30 보다 오래 유지되었고, checkAge가 실행되는 동안 isUnder30의 지역 스코프을 참조해 값을 반환하고 종료되었다. 이처럼 내부함수가 외부함수보다 오래 유지되었고, 내부함수가 외부함수의 지역 스코프(=Outer Lexical Environment)를 참조 및 접근할 수 있는 함수를 **클로저(Closure)**라고 한다.</p><h2 id="함수-호이스팅"><a href="#함수-호이스팅" class="headerlink" title="함수 호이스팅"></a>함수 호이스팅</h2><p>호이스팅이란 변수와 함수 선언을 코드가 실행되기 이전에 그들의 스코프의 최상위로 옮기는 Javascript 메커니즘으로 함수와 변수가 전역이든 지역 스코프든 그들의 스코프에 상관없이 최상위로 옮겨집니다. 그렇다면 함수는 호이스팅에 어떤 영향을 받으며 함수의 정의 방법에 따른 호이스팅의 차이는 어떻게 될까?</p><h4 id="함수-선언문"><a href="#함수-선언문" class="headerlink" title="함수 선언문"></a>함수 선언문</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">firstDecFn</span>(<span class="params">para, meter</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> para + meter</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">firstDecFn(<span class="string">&#x27;argu&#x27;</span>, <span class="string">&#x27;ment&#x27;</span>) <span class="comment">// &#x27;argument&#x27;</span></span><br><span class="line">secondDecFn(<span class="string">&#x27;argu&#x27;</span>, <span class="string">&#x27;ment&#x27;</span>) <span class="comment">// &#x27;argument&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">secondDecFn</span>(<span class="params">para, meter</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> para + meter</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>기본적으로 함수 선언문은 Javascript 호이스팅의 기본 타겟 중 하나로 위 예제에서  <code>firstDecFn</code> 함수처럼 먼저 선언하고 후에 호출하든 <code>secondDecFn</code> 함수처럼 먼저 호출하고 나중에 선언하든 함수 선언문은 Javascipt의 호이스팅으로 모두 최상위로 끌어올려져 정상작동합니다.</p><h4 id="함수-표현문"><a href="#함수-표현문" class="headerlink" title="함수 표현문"></a>함수 표현문</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> firstDecFn = <span class="function"><span class="keyword">function</span> (<span class="params">para, meter</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> para + meter</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">firstDecFn(<span class="string">&#x27;argu&#x27;</span>, <span class="string">&#x27;ment&#x27;</span>) <span class="comment">// &#x27;argument&#x27;</span></span><br><span class="line">secondDecFn(<span class="string">&#x27;argu&#x27;</span>, <span class="string">&#x27;ment&#x27;</span>) <span class="comment">// Uncaught TypeError: secondDecFn is not a function</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> secondDecFn = <span class="function"><span class="keyword">function</span> (<span class="params">para, meter</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> para + meter</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>결론부터 말하면 함수 표현문은 <em>hoisting(끌어올림)</em> 되지 않는다. 왜냐하면 Javascript Engine의 Parser 부분을 이해하면 쉬운데 Parser는 스크립트 내 변수를 분석할때 변수의 선언과 할당이 분리해 실행한다. 설명을 위해 간단한 변수 호이스팅을 예를 들어보자.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 우리가 작성한 코드</span></span><br><span class="line"><span class="built_in">console</span>.log(x);</span><br><span class="line"><span class="keyword">var</span> x = <span class="number">100</span>;</span><br><span class="line">-----------------------------------------------------------------------------------</span><br><span class="line"><span class="comment">// JavaScript Parser가 해석한 코드</span></span><br><span class="line"><span class="keyword">var</span> x;</span><br><span class="line"><span class="built_in">console</span>.log(x);</span><br><span class="line">x = <span class="number">100</span>;</span><br></pre></td></tr></table></figure><p>위 예제에서 <strong>“우리가 작성한 코드”</strong> 부분을 보면 <code>console.log(x)</code> 에서 변수 x를 호출하고, 다음줄에 <code>var x = 100</code>  이라고 선언했다. 그러나 <strong>“JavaScript Parser가 해석한 코드”</strong> 를 보면 <em>선언과 할당</em> 이 분리되어 있음을 볼 수 있다. 이러한 원리가 바로 Hoisting이고 함수 표현식으로 작성된 함수 또한 이 원리를 따르며 함수표현식의 예제를 Javascript가 해석한 코드로 변환하면 아래와 같다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> firstDecFn;</span><br><span class="line"><span class="keyword">var</span> secondDecFn;</span><br><span class="line">firstDecFn = <span class="function"><span class="keyword">function</span> (<span class="params">para, meter</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> para + meter</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">firstDecFn(<span class="string">&#x27;argu&#x27;</span>, <span class="string">&#x27;ment&#x27;</span>) <span class="comment">// &#x27;argument&#x27;</span></span><br><span class="line">secondDecFn(<span class="string">&#x27;argu&#x27;</span>, <span class="string">&#x27;ment&#x27;</span>) <span class="comment">// Uncaught TypeError: secondDecFn is not a function</span></span><br><span class="line"></span><br><span class="line">secondDecFn = <span class="function"><span class="keyword">function</span> (<span class="params">para, meter</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> para + meter</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>그렇다면 함수 표현식은 hoisting에 적용받지 못해 TypeError도 나는데 쓰지 말아야할까? 그것은 아니다. 함수 표현식이 가지고 있는 장점 또한 있다. </p><ul><li>클로저 사용</li><li>콜백 함수 (함수의 인자로서 함수표현식으로 선언된 함수를 전달)</li><li>즉시 실행 함수 (IIFE)</li></ul><h2 id="매개변수-Parameter-와-인자-Argument"><a href="#매개변수-Parameter-와-인자-Argument" class="headerlink" title="매개변수(Parameter)와 인자(Argument)"></a>매개변수(Parameter)와 인자(Argument)</h2><p>설명을 위해 예제 함수를 만들어보자.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">example</span>(<span class="params">pa,ra,me,ter</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> pa + ra + me + ter</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">example(<span class="string">&#x27;ar&#x27;</span>, <span class="string">&#x27;gu&#x27;</span>, <span class="string">&#x27;me&#x27;</span>, <span class="string">&#x27;nt&#x27;</span>)</span><br></pre></td></tr></table></figure><p>위 예제를 보면 <code>example</code> 함수는 <code>pa,ra,me,ter</code> 라는 데이터를 받아 반환(return)하고, <code>example</code> 함수가 호출될때 <code>&#39;ar&#39;, &#39;gu&#39;, &#39;me&#39;, &#39;nt&#39;</code> 이라는 데이터를 넘겨줬다.</p><p>쉽게 정의하자면, <strong>함수내에서 활용하느냐</strong>와 <strong>함수안으로 넘겨주느냐</strong> 의 차이이다. 편의상 이렇게 정의 가능하며 정확한 정의는 <strong>함수 정의하기</strong> 섹션의 <strong>함수 선언문</strong> 에서 정의한 내용이다. </p><ul><li>매개변수 : 함수 등에서 사용되는 전달된 값을 받는 변수로써, 함수의 기능상 외부 환경에서 데이터를 받아 가공 및 반환이 필요할 경우 함수 내부로 전달하는 역할을 하며 <code>콤마(,)</code> 로 구분하여 최대 255개까지 받을 수 있습니다.</li><li>인자: 함수에 전달되는 인수의 배열집합으로써, 정확히는 유사배열 객체로 <code>arguments</code> 객체라 칭하며 매개변수를 통해 전달받은 함수 외부환경의 값, 변수 또는 참조이다.</li></ul><h4 id="매개변수-Parameter"><a href="#매개변수-Parameter" class="headerlink" title="매개변수 (Parameter)"></a>매개변수 (Parameter)</h4><p>매개변수란 <strong>‘함수 등에서 사용되는 전달된 값을 받는 변수’</strong> 로, 함수에서 정의한 매개변수가 충분히 오지 않으면 <code>undefined</code> 로 정의되며 <strong>ECMAScript 6</strong> 부터는 <em>Default Parameter</em> 와 <em>Rest Parameter</em> 가 추가 되었다.</p><h5 id="매개변수-기본-처리방식"><a href="#매개변수-기본-처리방식" class="headerlink" title="매개변수 기본 처리방식"></a>매개변수 기본 처리방식</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">example</span>(<span class="params">pa,ra,me,ter</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`me =&gt; <span class="subst">$&#123;me&#125;</span>, ter =&gt; <span class="subst">$&#123;ter&#125;</span>`</span>) <span class="comment">// me =&gt; undefined, ter =&gt; undefined</span></span><br><span class="line">  <span class="keyword">return</span> pa + ra + me + ter</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">example(<span class="string">&#x27;argu&#x27;</span>, <span class="string">&#x27;ment&#x27;</span>) <span class="comment">// argumentundefinedundefined</span></span><br></pre></td></tr></table></figure><h5 id="Default-Parameter-기본-매개변수"><a href="#Default-Parameter-기본-매개변수" class="headerlink" title="Default Parameter (기본 매개변수)"></a>Default Parameter (기본 매개변수)</h5><p>전달값이 없거나 <code>undefined</code> 인 경우 파라미터에 기본값으로 초기화 될 값을 할당</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">example</span>(<span class="params">pa,ra,me = <span class="string">&#x27;me&#x27;</span>,ter = <span class="string">&#x27;nt&#x27;</span></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`me =&gt; <span class="subst">$&#123;me&#125;</span>, ter =&gt; <span class="subst">$&#123;ter&#125;</span>`</span>) <span class="comment">// me =&gt; me, ter =&gt; nt</span></span><br><span class="line">  <span class="keyword">return</span> pa + ra + me + ter</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">example(<span class="string">&#x27;ar&#x27;</span>, <span class="string">&#x27;gu&#x27;</span>) <span class="comment">// argument</span></span><br></pre></td></tr></table></figure><h5 id="Rest-Parameter-나머지-매개변수"><a href="#Rest-Parameter-나머지-매개변수" class="headerlink" title="Rest Parameter (나머지 매개변수)"></a>Rest Parameter (나머지 매개변수)</h5><p>파라미터의 갯수가 불확실해 <code>Array (배열)</code> 로 인수를 넘길때 사용할 수 있다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">double</span>(<span class="params">...theArgs</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> theArgs.map(<span class="function"><span class="params">x</span> =&gt;</span> x + x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">double(<span class="number">2</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>); <span class="comment">// [4, 2, 4, 6]</span></span><br><span class="line">double(<span class="number">2</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">9</span>, <span class="number">5</span>);  <span class="comment">// [4, 2, 4, 6, 18, 10]</span></span><br></pre></td></tr></table></figure><h4 id="인자-Argument"><a href="#인자-Argument" class="headerlink" title="인자 (Argument)"></a>인자 (Argument)</h4><p>인자(Argument)는 <strong>함수에 전달되는 인수의 배열집합</strong> 또는 <strong>모든 함수 내에서 이용 가능한 지역변수</strong> 로서 함수 호출시 전달되는 값을 할당 또는 참조해 함수 내에서 사용할 수 있습니다. </p><p>함수 내에서는 <code>arguments</code> 로 호출할 수 있으며 정확시는 <strong>유사객체 배열(array-like object)</strong> 에 속한다. 따라서 Javascript의 built-in function 중 Array 관련 메서드를 사용할 수 없으며 <code>length</code> 속성은 사용 가능합니다.</p><p><code>argument</code> 객체는 배열과 같이 인덱스로 접근가능합니다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">arg</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">arguments</span>.length)</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>; i&lt;<span class="built_in">arguments</span>.length; i++) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">arguments</span>[i])</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">arg(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="comment">// 3</span></span><br></pre></td></tr></table></figure><h5 id="arguments-를-Array-로-변환하기"><a href="#arguments-를-Array-로-변환하기" class="headerlink" title="arguments 를 Array 로 변환하기"></a><code>arguments</code> 를 <code>Array</code> 로 변환하기</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> args = <span class="built_in">Array</span>.from(<span class="built_in">arguments</span>);</span><br><span class="line"><span class="keyword">var</span> args = [...arguments];</span><br></pre></td></tr></table></figure><h2 id="Function-프로토타입-객체와-프로퍼티"><a href="#Function-프로토타입-객체와-프로퍼티" class="headerlink" title="Function 프로토타입 객체와 프로퍼티"></a>Function 프로토타입 객체와 프로퍼티</h2><p>JavaScript에 함수는 Data Type에서 객체(Object)에 속하며, 모든 JavaScript 함수는 사실 <code>Function</code> 객체입니다. </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 함수 정의</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">square</span>(<span class="params">number</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> number * number;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 함수 프로퍼티 추가 Case</span></span><br><span class="line">square.x = <span class="number">10</span>;</span><br><span class="line">square.y = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(square.x, square.y); <span class="comment">// 10, 20</span></span><br></pre></td></tr></table></figure><p>아래의 함수 생성법들은 모두 <code>true</code>  를 반환하며 전역 <code>Function</code> 객체는 자신만의 메서드 또는 속성이 없으나 그 자체로 함수이기에 <a href="https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Function/prototype"><code>Function.prototype</code></a>에서 프로토타입 체인을 통해 일부 메서드 및 속성을 상속 받습니다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 즉시 실행 함수 (IIFE)</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;).constructor === <span class="built_in">Function</span> <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 함수 선언식</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">deFn</span> (<span class="params"></span>) </span>&#123; <span class="keyword">return</span> <span class="string">&#x27;body&#x27;</span> &#125;</span><br><span class="line">deFn.constructor === <span class="built_in">Function</span> <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 함수 표현식</span></span><br><span class="line"><span class="keyword">var</span> exFn = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="keyword">return</span> <span class="string">&#x27;body&#x27;</span> &#125;</span><br><span class="line">exFn.constructor === <span class="built_in">Function</span> <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>또한, 함수는 일반 객체와 다른 함수만의 프로퍼티와 메서드를 갖습니다.</p><h5 id="Function-프로토타입-객체"><a href="#Function-프로토타입-객체" class="headerlink" title="Function 프로토타입 객체"></a><code>Function</code> 프로토타입 객체</h5><ul><li><a href="https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Function/length"><code>Function.length</code></a> : 함수에 의해 기대되는 인수의 수 지정</li><li><a href="https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Function/name"><code>Function.name</code></a> : 함수명</li><li><code>Function.prototype.constructor</code> : 객체의 프로토타입을 만드는 함수 지정</li><li><a href="https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Function/arguments"><code>Function.arguments</code></a> <em>(deprecated)</em></li></ul><h5 id="메서드"><a href="#메서드" class="headerlink" title="메서드"></a>메서드</h5><ul><li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/apply"><code>Function.prototype.apply(this, [arg1, arg2, ... argn])</code></a> : 함수를 호출하고 함수의 <code>this</code> 객체에 제공된 <code>thisArg</code> 를 설정합니다. 인자는 <code>Arrat</code> 객체로 전달할 수 있습니다.</li><li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/bind"><code>Function.prototype.bind(this, binding object)</code></a> :  호출될때, 함수의 <code>this</code> 가 제공된 <code>thisArg</code> 로 설정된 새로운 함수가 생성된다. 선택적으로, 주어진 일련의 인자(arguments)는 새로 바인딩 된 함수가 호출되는 경우 인수보다 우선적으로 추가됩니다.</li><li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/call"><code>Function.prototype.call(this, arg1, arg2, ... argN)</code></a> : 주어진 <code>this</code> 값과 개별적으로 제공되는 인수를 사용하여 함수를 호출한다.</li></ul><h2 id="화살표-함수-Arrow-Function"><a href="#화살표-함수-Arrow-Function" class="headerlink" title="화살표 함수 (Arrow Function)"></a>화살표 함수 (Arrow Function)</h2><p><strong>ES6</strong> 부터 함수를 생성하는 방법으로 함수 표현식보다 단순하고 간결한 화살표 함수 <code>=&gt;</code> 가 추가되었다.</p><h4 id="특징"><a href="#특징" class="headerlink" title="특징"></a>특징</h4><ul><li>함수 표현식보다 구문이 짧고,</li><li>자신의  <a href="https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Operators/this">this</a>, <a href="https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Functions/arguments">arguments</a>, <a href="https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Operators/super">super</a> 또는 <a href="https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Operators/new.target">new.target</a>을 바인딩 하지 않는다</li><li>항상 익명 함수이다.</li><li>메소드 함수가 아닌 곳에 즉, 인자로서 부모 함수가 넘겨줄 callback 함수에 적합하다.</li><li>함수 생성자 (function constructor)로서 사용할 수 없다.</li><li>반환해야 할 값이 있을때 <code>return</code>  과 <code>&#123;&#125;</code> 를 생략할 수 있다.</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">double</span> (<span class="params">n</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> n * <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> double = <span class="function"><span class="params">n</span> =&gt;</span> n * <span class="number">2</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> numbers = [<span class="number">0</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>];</span><br><span class="line"><span class="keyword">let</span> double = <span class="function"><span class="params">n</span> =&gt;</span> n * <span class="number">2</span></span><br><span class="line"><span class="built_in">console</span>.log(numbers.map(double));</span><br><span class="line"><span class="built_in">console</span>.log(numbers.map(<span class="function"><span class="params">number</span> =&gt;</span> number * <span class="number">2</span>));</span><br><span class="line"><span class="comment">// expected output: Array [0, 4, 8, 12, 16]</span></span><br></pre></td></tr></table></figure><h4 id="기본-구문"><a href="#기본-구문" class="headerlink" title="기본 구문"></a>기본 구문</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">(param1, param2, …, paramN) =&gt; &#123; statements &#125;</span><br><span class="line">(param1, param2, …, paramN) =&gt; expression</span><br><span class="line"><span class="comment">// 다음과 동일함:  =&gt; &#123; return expression; &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 매개변수가 하나뿐인 경우 괄호는 선택사항:</span></span><br><span class="line">(singleParam) =&gt; &#123; statements &#125;</span><br><span class="line">singleParam =&gt; &#123; statements &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 매개변수가 없는 함수는 괄호가 필요:</span></span><br><span class="line">() =&gt; &#123; statements &#125;</span><br></pre></td></tr></table></figure><h4 id="고급-구문"><a href="#고급-구문" class="headerlink" title="고급 구문"></a>고급 구문</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 객체 리터럴 표현을 반환하기 위해서는 함수 본문(body)을 괄호 속에 넣음:</span></span><br><span class="line">params =&gt; (&#123;<span class="attr">foo</span>: bar&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 나머지 매개변수 및 기본 매개변수를 지원함</span></span><br><span class="line">(param1, param2, ...rest) =&gt; &#123; statements &#125;</span><br><span class="line">(param1 = defaultValue1, param2, …, paramN = defaultValueN) =&gt; &#123; statements &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 매개변수 목록 내 구조분해할당도 지원됨</span></span><br><span class="line"><span class="keyword">var</span> f = <span class="function">(<span class="params">[a, b] = [<span class="number">1</span>, <span class="number">2</span>], &#123;x: c&#125; = &#123;x: a + b&#125;</span>) =&gt;</span> a + b + c;</span><br><span class="line">f();  <span class="comment">// 6</span></span><br></pre></td></tr></table></figure><p><em>(화살표 함수의 자세한 내용에 대해서는 추후 포스팅할 예정입니다.)</em></p><hr><h2 id="참조"><a href="#참조" class="headerlink" title="참조"></a>참조</h2><ul><li><a href="https://ko.javascript.info/function-basics">https://ko.javascript.info/function-basics</a></li><li><a href="https://developer.mozilla.org/ko/docs/Web/JavaScript/Guide">https://developer.mozilla.org/ko/docs/Web/JavaScript/Guide</a></li><li><a href="https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Functions">https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Functions</a></li><li><a href="https://poiemaweb.com/js-function">https://poiemaweb.com/js-function</a></li><li><a href="https://joshua1988.github.io/web-development/javascript/function-expressions-vs-declarations/">https://joshua1988.github.io/web-development/javascript/function-expressions-vs-declarations/</a></li><li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Closures">https://developer.mozilla.org/en-US/docs/Web/JavaScript/Closures</a></li><li><a href="https://ko.javascript.info/arrow-functions-basics">https://ko.javascript.info/arrow-functions-basics</a></li></ul>]]></content:encoded>
      
      
      <category domain="https://joontae-kim.github.io/categories/Programming/">Programming</category>
      
      <category domain="https://joontae-kim.github.io/categories/Programming/Javascript/">Javascript</category>
      
      
      <category domain="https://joontae-kim.github.io/tags/javascript/">javascript</category>
      
      <category domain="https://joontae-kim.github.io/tags/function/">function</category>
      
      <category domain="https://joontae-kim.github.io/tags/arrow-function/">arrow function</category>
      
      
      <comments>https://joontae-kim.github.io/2020/10/20/js-function/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>front-end interview link collection</title>
      <link>https://joontae-kim.github.io/2020/10/20/front-end-interview-link-collection/</link>
      <guid>https://joontae-kim.github.io/2020/10/20/front-end-interview-link-collection/</guid>
      <pubDate>Tue, 20 Oct 2020 04:40:20 GMT</pubDate>
      
        
        
      <description>&lt;p&gt;&lt;img src=&quot;/images/job_thumbnail.jpeg&quot; alt=&quot;면접!&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;프론트엔드-지원-관련-링크-모음&quot;&gt;&lt;a href=&quot;#프론트엔드-지원-관련-링크-모음&quot; class=&quot;headerlink&quot; title=&quot;프론</description>
        
      
      
      
      <content:encoded><![CDATA[<p><img src="/images/job_thumbnail.jpeg" alt="면접!"></p><h2 id="프론트엔드-지원-관련-링크-모음"><a href="#프론트엔드-지원-관련-링크-모음" class="headerlink" title="프론트엔드 지원 관련 링크 모음"></a>프론트엔드 지원 관련 링크 모음</h2><blockquote><p>분류는 추후 정리 예정입니다.</p></blockquote><ul><li>프론트엔드 개발자 면접 질문(기술면접) 정리 - <a href="https://sunnykim91.tistory.com/121">https://sunnykim91.tistory.com/121</a></li><li>프론트엔드 개발자 면접 질문 모음 - <a href="https://mber.tistory.com/2">https://mber.tistory.com/2</a></li><li>JavaScript 질문 | Front End Interview Handbook - <a href="https://yangshun.github.io/front-end-interview-handbook/kr/javascript-questions">https://yangshun.github.io/front-end-interview-handbook/kr/javascript-questions</a></li><li>프론트엔드 면접 질문 모음 - <a href="https://velog.io/@honeysuckle/%EC%8B%A0%EC%9E%85-%ED%94%84%EB%A1%A0%ED%8A%B8%EC%97%94%EB%93%9C-%EB%A9%B4%EC%A0%91-%EC%A7%88%EB%AC%B8-%EB%AA%A8%EC%9D%8C">https://velog.io/@honeysuckle/%EC%8B%A0%EC%9E%85-%ED%94%84%EB%A1%A0%ED%8A%B8%EC%97%94%EB%93%9C-%EB%A9%B4%EC%A0%91-%EC%A7%88%EB%AC%B8-%EB%AA%A8%EC%9D%8C</a></li><li>이번 기술 면접 중 기억나는 질문과 답변들 (프론트엔드). 이번에 이직하게 된 회사 기술 면접에서 주고 받았던 질문과 답변들 중… | by Jim Kim | Medium - <a href="https://medium.com/@jimkimau/%EC%9D%B4%EB%B2%88-%EA%B8%B0%EC%88%A0-%EB%A9%B4%EC%A0%91-%EC%A4%91-%EA%B8%B0%EC%96%B5%EB%82%98%EB%8A%94-%EC%A7%88%EB%AC%B8%EA%B3%BC-%EB%8B%B5%EB%B3%80%EB%93%A4-712daa9a2dc">https://medium.com/@jimkimau/%EC%9D%B4%EB%B2%88-%EA%B8%B0%EC%88%A0-%EB%A9%B4%EC%A0%91-%EC%A4%91-%EA%B8%B0%EC%96%B5%EB%82%98%EB%8A%94-%EC%A7%88%EB%AC%B8%EA%B3%BC-%EB%8B%B5%EB%B3%80%EB%93%A4-712daa9a2dc</a></li><li>DevOwen의 구직 이야기 Ch1. 마음가짐 :: DevOwen - <a href="https://devowen.com/287">https://devowen.com/287</a></li><li>이직을 준비하면서 - Today I Learned - <a href="https://vallista.kr/2019/07/03/%EC%9D%B4%EC%A7%81%EC%9D%84-%EC%A4%80%EB%B9%84%ED%95%98%EB%A9%B4%EC%84%9C/">https://vallista.kr/2019/07/03/%EC%9D%B4%EC%A7%81%EC%9D%84-%EC%A4%80%EB%B9%84%ED%95%98%EB%A9%B4%EC%84%9C/</a></li><li>주니어 개발자 경력기술서 작성하기 :: GoGo - <a href="https://gogomalibu.tistory.com/119">https://gogomalibu.tistory.com/119</a></li><li>[Interview] 인터뷰 경험 - 프론트 (야놀자) - <a href="https://daniel-park.tistory.com/42">https://daniel-park.tistory.com/42</a></li><li>28세 요우의 개발자 이직 대탐험 - <a href="https://luckyyowu.tistory.com/382">https://luckyyowu.tistory.com/382</a></li><li>2018 종합선물세트 for 취준생 - <a href="https://www.slideshare.net/LuckyYoWu/2018-for">https://www.slideshare.net/LuckyYoWu/2018-for</a></li><li>‘Alogorithm’ 카테고리의 글 목록 - <a href="https://daniel-park.tistory.com/">https://daniel-park.tistory.com/</a></li><li>스타트업 면접 전에 점검해야 하는 10가지 | ㅍㅍㅅㅅ - <a href="https://ppss.kr/archives/227105">https://ppss.kr/archives/227105</a></li></ul>]]></content:encoded>
      
      
      <category domain="https://joontae-kim.github.io/categories/Blog/">Blog</category>
      
      <category domain="https://joontae-kim.github.io/categories/Blog/Job/">Job</category>
      
      
      <category domain="https://joontae-kim.github.io/tags/Front-end/">Front-end</category>
      
      <category domain="https://joontae-kim.github.io/tags/Interview/">Interview</category>
      
      <category domain="https://joontae-kim.github.io/tags/Job/">Job</category>
      
      
      <comments>https://joontae-kim.github.io/2020/10/20/front-end-interview-link-collection/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>자바스크립트 실행 컨텍스트(Execution Context) 3 - 실행 컨텍스트의 생성과 실행</title>
      <link>https://joontae-kim.github.io/2020/10/18/execution-context-example/</link>
      <guid>https://joontae-kim.github.io/2020/10/18/execution-context-example/</guid>
      <pubDate>Sun, 18 Oct 2020 11:33:00 GMT</pubDate>
      
        
        
      <description>&lt;p&gt;실행 컨텍스트 관련 첫번째 포스트인 &lt;a href=&quot;https://joontae-kim.github.io/2020/10/12/excution-context/&quot;&gt;자바스크립트 실행 컨텍스트(Execution Context)&lt;/a&gt; 에서는 실행 컨텍스</description>
        
      
      
      
      <content:encoded><![CDATA[<p>실행 컨텍스트 관련 첫번째 포스트인 <a href="https://joontae-kim.github.io/2020/10/12/excution-context/">자바스크립트 실행 컨텍스트(Execution Context)</a> 에서는 실행 컨텍스트란 무엇인지 그리고 유형은 어떠한 것들이 있으며  Javascript 엔진이 실행 컨텍스트를 어떻게 관리하는지 알아보았습니다.</p><p>실행 컨텍스트 관련 두번째 포스트인 <a href="/2020/10/15/excution-context-2/">자바스크립트 실행 컨텍스트(Execution Context) 2 - 정의와 구조</a> 에서는 실행 컨텍스트의 정의와 ES5 이후의 Scope Chain의 변화 그리고 실행 컨텍스트의 세부구조에 대해 다뤄봤습니다.</p><p>그리고 마지막 포스트로는 <strong>실행 컨텍스트의 생성과 실행 과정</strong>에 대해 참고중이던 영문 포스트의 일부분을 번역하면서 구조와 각 세부 프로퍼티에 대해 정리해보고, <strong>Creation Phase</strong> 와 <strong>Execution Phase</strong> 에 대해서 알아보며 끝마치도록 하겠습니다.</p><p>참고 영문 포스트: <a href="https://blog.bitsrc.io/understanding-execution-context-and-execution-stack-in-javascript-1c9ea8642dd0">Understanding Execution Context and Execution Stack in Javascript</a></p><p>번역 포스트의 <strong>“How is the Execution Context created?”</strong> 부분만 발췌하여 번역하였음을 알려드립니다.</p><hr><h1 id="Javascript-실행-컨텍스트와-실행-스택-이해하기"><a href="#Javascript-실행-컨텍스트와-실행-스택-이해하기" class="headerlink" title="Javascript 실행 컨텍스트와 실행 스택 이해하기"></a>Javascript 실행 컨텍스트와 실행 스택 이해하기</h1><h5 id="Javascript-프로그램이-내부적으로-실행되는-방법-학습하기"><a href="#Javascript-프로그램이-내부적으로-실행되는-방법-학습하기" class="headerlink" title="Javascript 프로그램이 내부적으로 실행되는 방법 학습하기"></a>Javascript 프로그램이 내부적으로 실행되는 방법 학습하기</h5><h1 id="How-is-the-Execution-Context-created"><a href="#How-is-the-Execution-Context-created" class="headerlink" title="How is the Execution Context created?"></a>How is the Execution Context created?</h1><p>지금까지, 우리는 Javascript 엔진이 실행 컨텍스트를 어떻게 관리하는지 살펴봤습니다. 그럼 지금부터는 Javascript 엔진이 실행 컨텍스트를 생성하는 방법에 대해 이해해보록 하겠습니다.</p><p>실행 컨텍스트는 두 단계로 나뉘어 생성됩니다: <strong>1) 생성 단계 (Creation Phase)</strong> 그리고 <strong>2) 실행 단계 (Execution Phase)</strong></p><h1 id="생성-단계"><a href="#생성-단계" class="headerlink" title="생성 단계"></a>생성 단계</h1><p>실행 컨텍스트는 생성 단계 동안 생성되며 아래의 컨포넌트가 발생합니다:</p><ol><li><strong>LexicalEnvironment</strong> 컴포넌트가 생성된다.</li><li><strong>VariableEnvironment</strong> 컴포넌트가 생성된다.</li></ol><p>그럼 실행 컨텍스트는 개념적으론 아래와 같이 나타낼 수 있다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ExecutionContext &#x3D; &#123;</span><br><span class="line">  LexicalEnvironment &#x3D; &lt;ref. to LexicalEnvironment in memory&gt;,</span><br><span class="line">  VariableEnvironment &#x3D; &lt;ref. to VariableEnvironment in  memory&gt;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Lexical-Environment"><a href="#Lexical-Environment" class="headerlink" title="Lexical Environment"></a>Lexical Environment</h2><p>The <a href="http://ecma-international.org/ecma-262/6.0/">official ES6</a> 문서에 정의된 Lexical Environment 는</p><blockquote><p><em>Lexical Environment는 ECMAScript 코드의 lexical 중첩 구조 상에서 특정 변수와 함수에 대한 인식자(Identifier)들을 정의하는데 사용되는 명세 유형입니다. Lexical Environment는 Environment Record와 outer Lexical Environment에 대한 가능한한 null 참조로 구성되어 있다.</em></p></blockquote><p>간단하게 말해, <em>lexical environment</em> 는 <strong>인식자(identifier)-변수(variable) 매핑(mapping)</strong> 을 유지하고 있는 구조입니다. (여기서 <strong>identifier</strong> 란 변수/함수들의 이름을 참고하는 것이고, <strong>variable</strong> 은 [함수 객체와 배열 객체를 포함하는] 실질적 객체 또는 기본값에 대한 참조값이다.)</p><p>예를 들어, 아래의 코드 조각을 생각해보자.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">20</span>;</span><br><span class="line"><span class="keyword">var</span> b = <span class="number">40</span>;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;bar&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>위 코드 조각의 lexical environment는 아래와 같이 나타낼 수 있다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">lexicalEnvironment = &#123;</span><br><span class="line">a: <span class="number">20</span>,</span><br><span class="line">b: <span class="number">40</span>,</span><br><span class="line">foo: <span class="xml"><span class="tag">&lt;<span class="name">ref.</span> <span class="attr">to</span> <span class="attr">foo</span> <span class="attr">function</span>&gt;</span></span></span><br><span class="line"><span class="xml">&#125;</span></span><br></pre></td></tr></table></figure><p>각 Lexical Environment는 세가지 컴포넌트를 가지고 있다.</p><ol><li>Environment Record</li><li>Reference to the outer environment</li><li>This binding</li></ol><h2 id="Environment-Record"><a href="#Environment-Record" class="headerlink" title="Environment Record"></a><strong>Environment Record</strong></h2><p>Environment Record는 lexical environment 안에 저장된 변수와 함수의 선언이 있는 곳이다.</p><p>또한, <em>environment record</em> 는 두가지 타입이 있습니다.</p><ul><li><strong>Declarative environment record —</strong> 이름에서 알 수 있듯이 변수와 함수의 선언에 대한 것으로 추측할 수 있다. 함수 코드에 대한 lexical environment는 declarative environment record를 포함하고 있다.</li><li><strong>Object environment record —</strong> 전역(global) 코드의 lexical environment는 objective environment record를 포함하고 있다. 변수와 함수에 대한 선언과 구분지어, object environment record는 또한 전역 바인딩 객체(global binding object) (browser의 경우 window 객체)를 저장한다. 그리고 바인딩된 객체에 대한 각각의 속성(브라우저의 경우, window 객체에 browser에 의해 제공되는 속성과 메서드들이 포함된다)에 대해 새로운 엔트리가 레코드 안에 생성된다.</li></ul><p><strong>Note —</strong> <strong>함수 코드</strong> 를 위해서, <em>Environment Record</em> 는 또한 인덱스와 함수에 전달된 인자 사이의 관계에 대한 매핑과 함수로 전달된 인자들에 대한 <em>길이(숫자, number)</em> 에 대한 정보를 담고있는 <code>인자(arguments)</code> 객체를 포함한다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> c = a + b;</span><br><span class="line">&#125;</span><br><span class="line">foo(<span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line"><span class="comment">// argument object</span></span><br><span class="line">Arguments: &#123;<span class="number">0</span>: <span class="number">2</span>, <span class="number">1</span>: <span class="number">3</span>, <span class="attr">length</span>: <span class="number">2</span>&#125;,</span><br></pre></td></tr></table></figure><h2 id="Reference-to-the-Outer-Environment"><a href="#Reference-to-the-Outer-Environment" class="headerlink" title="Reference to the Outer Environment"></a>Reference to the Outer Environment</h2><p><strong>reference to the outer environment</strong> 는 현재 실행 컨텍스트의 외부(outer) lexical environment에 대해 접근하는 것을 의미합니다. 이것은 JavaScript engine이 현재 lexical environment에서 변수를 찾지 못한다면 외부 환경(outer environment)에서 찾을 수 있음을 의미합니다.</p><h2 id="This-Binding"><a href="#This-Binding" class="headerlink" title="This Binding"></a>This Binding</h2><p>이 컴포넌트에서는 <code>this</code> 의 값을 결정하거나 설정합니다.</p><p>전역(global) 실행 컨텍스트에서 <code>this</code> 는 전역 객체를 참조합니다. (브라우저에서 <code>this</code> 는 Window 객체를 참조한다.)</p><p>함수 실행 컨텍스트에서 <code>this</code> 는 함수가 호출되는 방식에 따라 달라진다. 만약 객체 참조 방식에 따라 함수가 호출될 경우,  <code>this</code> 값은 해당 객체로 설정되고 그렇지 않으면 <code>this</code>  는 전역 객체 또는 (strict mode 에서는) <code>undefined</code> 로 설정된다. 예를 들어,</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> person = &#123;</span><br><span class="line">  name: <span class="string">&#x27;peter&#x27;</span>,</span><br><span class="line">  birthYear: <span class="number">1994</span>,</span><br><span class="line">  calcAge: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">2018</span> - <span class="built_in">this</span>.birthYear);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">person.calcAge(); </span><br><span class="line"><span class="comment">// &#x27;calcAge&#x27;가 &#x27;person&#x27; 객체 참조로 호출됐기 때문에 &#x27;this&#x27;는 &#x27;person&#x27;를 참조한다.</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> calculateAge = person.calcAge;</span><br><span class="line">calculateAge();</span><br><span class="line"><span class="comment">// 어떠한 객체 참조도 주어지지 않았기 때문에 &#x27;this&#x27;는 전역 window 객체를 참조한다. </span></span><br></pre></td></tr></table></figure><p>추상적으로, lexical environment는 아래와 같은 가상의 코드로 나타낼 수 있다:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">GlobalExectionContext &#x3D; &#123;</span><br><span class="line">  LexicalEnvironment: &#123;</span><br><span class="line">    EnvironmentRecord: &#123;</span><br><span class="line">      Type: &quot;Object&quot;,</span><br><span class="line">      &#x2F;&#x2F; 인식자(Identifier) binding은 여기로 이동한다.</span><br><span class="line">    &#125;</span><br><span class="line">    outer: &lt;null&gt;,</span><br><span class="line">    this: &lt;global object&gt;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">FunctionExectionContext &#x3D; &#123;</span><br><span class="line">  LexicalEnvironment: &#123;</span><br><span class="line">    EnvironmentRecord: &#123;</span><br><span class="line">      Type: &quot;Declarative&quot;,</span><br><span class="line">      &#x2F;&#x2F; 인식자(Identifier) binding은 여기로 이동한다.</span><br><span class="line">    &#125;</span><br><span class="line">    outer: &lt;Global or outer function environment reference&gt;,</span><br><span class="line">    this: &lt;depends on how function is called&gt;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Variable-Environment"><a href="#Variable-Environment" class="headerlink" title="Variable Environment:"></a>Variable Environment:</h2><p>또한 Environment Record는 실행 컨텍스트에서 <em>VariableStatements</em> 에 의해 생성된 binding을 보관하는 Lexical Environment 이다.</p><p>즉, Variable Environment 또한 Lexical Environment이며 위에서 정의한 것처럼 Lexical Environment의 모든 속성과 컴포넌트들을 가지고 있다.</p><p>ES6에서 <strong>LexicalEnvironment</strong> 컴포넌트 and the <strong>VariableEnvironment</strong> 컴포넌트의 한가지 차이점은 <strong>LexicalEnvironment</strong> 는 함수 선언과 변수 (<code>let</code> 과 <code>const</code>) 바인딩을 저장하는데 사용되고, <strong>VariableEnvironment</strong> 는 오직 변수 (<code>var</code>) 바인딩을 저장하는데 사용된다.</p><h1 id="실행-단계"><a href="#실행-단계" class="headerlink" title="실행 단계"></a>실행 단계</h1><p>이 단계에서는, 모든 변수에 대한 할당이 끝났으며 마침내 코드가 실행된다.</p><h1 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h1><p>이상의 개념을 이해하기 위해 몇 가지 예를 보자.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="number">20</span>;</span><br><span class="line"><span class="keyword">const</span> b = <span class="number">30</span>;</span><br><span class="line"><span class="keyword">var</span> c;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">multiply</span>(<span class="params">e, f</span>) </span>&#123;</span><br><span class="line"> <span class="keyword">var</span> g = <span class="number">20</span>;</span><br><span class="line"> <span class="keyword">return</span> e * f * g;</span><br><span class="line">&#125;</span><br><span class="line">c = multiply(<span class="number">20</span>, <span class="number">30</span>);</span><br></pre></td></tr></table></figure><p> 이 코드를 실행시키면, Javascript 엔진은 전역(global) 코드를 실행하기 위한 전역 실행 컨텍스트를 생성한다. 그럼 생성 단계에서 전역 실행 컨텍스트는 아래와 같은 가상의 코드처럼 될 것이다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">GlobalExectionContext = &#123;</span><br><span class="line">  LexicalEnvironment: &#123;</span><br><span class="line">    EnvironmentRecord: &#123;</span><br><span class="line">      Type: <span class="string">&quot;Object&quot;</span>,</span><br><span class="line">      <span class="comment">// 인식자(Identifier) binding은 여기로 이동한다.</span></span><br><span class="line">      a: &lt; uninitialized &gt;,</span><br><span class="line">      b: &lt; uninitialized &gt;,</span><br><span class="line">      multiply: &lt; func &gt;</span><br><span class="line">    &#125;</span><br><span class="line">    outer: <span class="xml"><span class="tag">&lt;<span class="name">null</span>&gt;</span>,</span></span><br><span class="line">    ThisBinding: &lt;Global Object&gt;</span><br><span class="line">  &#125;,</span><br><span class="line">  VariableEnvironment: &#123;</span><br><span class="line">    EnvironmentRecord: &#123;</span><br><span class="line">      Type: &quot;Object&quot;,</span><br><span class="line">      // 인식자(Identifier) binding은 여기로 이동한다.</span><br><span class="line">      c: undefined,</span><br><span class="line">    &#125;</span><br><span class="line">    outer: &lt;null&gt;,</span><br><span class="line">    ThisBinding: &lt;Global Object&gt;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>실행 단계 동안에는, 변수 할당이 끝났으며 전역 실행 컨텍스트는 아래와 같은 가상의 코드처럼 될 것입니다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">GlobalExectionContext = &#123;</span><br><span class="line">  LexicalEnvironment: &#123;</span><br><span class="line">    EnvironmentRecord: &#123;</span><br><span class="line">      Type: <span class="string">&quot;Object&quot;</span>,</span><br><span class="line">      <span class="comment">// 인식자(Identifier) binding은 여기로 이동한다.</span></span><br><span class="line">      a: <span class="number">20</span>,</span><br><span class="line">      b: <span class="number">30</span>,</span><br><span class="line">      multiply: &lt; func &gt;</span><br><span class="line">    &#125;</span><br><span class="line">    outer: <span class="xml"><span class="tag">&lt;<span class="name">null</span>&gt;</span>,</span></span><br><span class="line">    ThisBinding: &lt;Global Object&gt;</span><br><span class="line">  &#125;,</span><br><span class="line">  VariableEnvironment: &#123;</span><br><span class="line">    EnvironmentRecord: &#123;</span><br><span class="line">      Type: &quot;Object&quot;,</span><br><span class="line">      // 인식자(Identifier) binding은 여기로 이동한다.</span><br><span class="line">      c: undefined,</span><br><span class="line">    &#125;</span><br><span class="line">    outer: &lt;null&gt;,</span><br><span class="line">    ThisBinding: &lt;Global Object&gt;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>multiply(20, 30)</code> 함수에 대한 호출이 발생했을때, 새로운 함수(function) 실행 컨텍스트가 함수 코드를 실행하기 위해 생성된다. 그리고 함수 실행 컨텍스트는 생성 단계동안 아래와 같은 가상의 코드처럼 될 것입니다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">FunctionExectionContext = &#123;</span><br><span class="line">  LexicalEnvironment: &#123;</span><br><span class="line">    EnvironmentRecord: &#123;</span><br><span class="line">      Type: <span class="string">&quot;Declarative&quot;</span>,</span><br><span class="line">      <span class="comment">// 인식자(Identifier) binding은 여기로 이동한다.</span></span><br><span class="line">      Arguments: &#123;<span class="number">0</span>: <span class="number">20</span>, <span class="number">1</span>: <span class="number">30</span>, <span class="attr">length</span>: <span class="number">2</span>&#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">    outer: <span class="xml"><span class="tag">&lt;<span class="name">GlobalLexicalEnvironment</span>&gt;</span>,</span></span><br><span class="line">    ThisBinding: &lt;Global Object or undefined&gt;,</span><br><span class="line">  &#125;,</span><br><span class="line">  VariableEnvironment: &#123;</span><br><span class="line">    EnvironmentRecord: &#123;</span><br><span class="line">      Type: &quot;Declarative&quot;,</span><br><span class="line">      // 인식자(Identifier) binding은 여기로 이동한다.</span><br><span class="line">      g: undefined</span><br><span class="line">    &#125;,</span><br><span class="line">    outer: &lt;GlobalLexicalEnvironment&gt;,</span><br><span class="line">    ThisBinding: &lt;Global Object or undefined&gt;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>이후, 실행 컨텍스트는 함수(function) 내에서 변수 할당이 끝났다는 의미로 실행 단계를 거치고 함수 실행 컨텍스트는 실행 단계동안 아래와 같은 가상의 코드처럼 될 것입니다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">FunctionExectionContext = &#123;</span><br><span class="line">  LexicalEnvironment: &#123;</span><br><span class="line">    EnvironmentRecord: &#123;</span><br><span class="line">      Type: <span class="string">&quot;Declarative&quot;</span>,</span><br><span class="line">      <span class="comment">// 인식자(Identifier) binding은 여기로 이동한다.</span></span><br><span class="line">      Arguments: &#123;<span class="number">0</span>: <span class="number">20</span>, <span class="number">1</span>: <span class="number">30</span>, <span class="attr">length</span>: <span class="number">2</span>&#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">    outer: <span class="xml"><span class="tag">&lt;<span class="name">GlobalLexicalEnvironment</span>&gt;</span>,</span></span><br><span class="line">    ThisBinding: &lt;Global Object or undefined&gt;,</span><br><span class="line">  &#125;,</span><br><span class="line">  VariableEnvironment: &#123;</span><br><span class="line">    EnvironmentRecord: &#123;</span><br><span class="line">      Type: &quot;Declarative&quot;,</span><br><span class="line">      // 인식자(Identifier) binding은 여기로 이동한다.</span><br><span class="line">      g: 20</span><br><span class="line">    &#125;,</span><br><span class="line">    outer: &lt;GlobalLexicalEnvironment&gt;,</span><br><span class="line">    ThisBinding: &lt;Global Object or undefined&gt;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>함수가 완료된 후에, 반환된 값은 <code>c</code> 에 저장되고, 전역(global) lexical environment가 업데이트 됩니다. 그 후, 전역 코크는 완료되고, 프로그램은 끝난다.</p><p><strong>Note —</strong> 여러분은 <code>let</code> 과 <code>const</code> 로 정의된 변수는 생성 단계 동안에 그 어떠한 값(value)도 연결되지 않으며 <code>var</code>  로 정의된 변수는 <code>undefined</code> 로 설정된다는 것을 주의해야 합니다.</p><p>이것은 생성 단계에서 코드에서 변수와 함수 선언에 대해 스캔하고, 함수 선언이 환경에 함수 전체적으로 저장되는 동안, 변수는 처음에 (<code>var</code> 의 경우) <code>undefined</code>  로 설정되거나 (<code>let</code> 과 <code>const</code> 의 경우) 비초기화(uninitialized) 상태로 유지되기 때문입니다.</p><p>이게 여러분이 <code>let</code> 과 <code>const</code> 변수가 선언되기 전에 접근하려고 할때 참조 에러(reference error)가 발생하는 것과 달리 <code>var</code> 로 선언된 변수는 (<code>undefined</code> 로) 선언되기 전에 접근할 수 있는 이유입니다. </p><p>이것이 바로, 우리가 호이스팅(hoisting) 이라고 부르는 것입니다.</p><p><strong>Note —</strong> 실행단계 동안에, Javascript 엔진이 소스 코드(source code) 상에서 선언한 실제 위치에서 <code> let</code>  변수에 대한 값을 찾지 못한다면 이 변수에는  <code>undefined</code>  값이 할당될 것입니다.</p><h1 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h1><p>우리는 Javascript 프로그램들이 내부적으로 어떻게 실행되는지 살펴봤습니다. 여려분이 멋진 Javascript 개발자가 되기 위해 이러한 모든 개념들을 배울 필요는 없지만, 위와 같은 개념에 대한 왠만한 이해력은 Hoisting, Scope, and Closure 와 같은 다른 개념들도 더 쉽고 더 깊게 이해할 수 있도록 도울 것입니다. </p>]]></content:encoded>
      
      
      <category domain="https://joontae-kim.github.io/categories/Programming/">Programming</category>
      
      <category domain="https://joontae-kim.github.io/categories/Programming/Javascript/">Javascript</category>
      
      
      <category domain="https://joontae-kim.github.io/tags/javascript/">javascript</category>
      
      <category domain="https://joontae-kim.github.io/tags/javascript-engine/">javascript engine</category>
      
      <category domain="https://joontae-kim.github.io/tags/execution-context/">execution context</category>
      
      <category domain="https://joontae-kim.github.io/tags/execution/">execution</category>
      
      <category domain="https://joontae-kim.github.io/tags/context/">context</category>
      
      
      <comments>https://joontae-kim.github.io/2020/10/18/execution-context-example/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>자바스크립트 실행 컨텍스트(Execution Context) 2 - 정의와 구조</title>
      <link>https://joontae-kim.github.io/2020/10/15/excution-context-2/</link>
      <guid>https://joontae-kim.github.io/2020/10/15/excution-context-2/</guid>
      <pubDate>Wed, 14 Oct 2020 16:40:35 GMT</pubDate>
      
        
        
      <description>&lt;p&gt;실행 컨텍스트 관련 첫번째 포스트인 &lt;a href=&quot;https://joontae-kim.github.io/2020/10/12/excution-context/&quot;&gt;자바스크립트 실행 컨텍스트(Execution Context)&lt;/a&gt; 에서는 실행 컨텍스</description>
        
      
      
      
      <content:encoded><![CDATA[<p>실행 컨텍스트 관련 첫번째 포스트인 <a href="https://joontae-kim.github.io/2020/10/12/excution-context/">자바스크립트 실행 컨텍스트(Execution Context)</a> 에서는 실행 컨텍스트란 무엇인지 그리고 유형은 어떠한 것들이 있으며  Javascript 엔진이 실행 컨텍스트를 어떻게 관리하는지 알아보았습니다. 이번 포스트에서는 Javascript 엔진이 실행 컨텍스트를 어떻게 생성하며 실행 컨텍스트는 어떠한 구조로 이루어져 있는지 알아보겠습니다.</p><p>실행 컨텍스트의 물리적 구조를 설명하기에 앞서 일부 블로그의 내용이 ECMAScript의 ES5 이전의 개념으로 작성되어 있었습니다. 그래서 ES5 이전의 내용과 ES5 이후의 구조를 비교하기 위해 많은 블로그와 ECMAScript 의 공식 문서(ecma-262)의 <a href="http://ecma-international.org/ecma-262/6.0/#sec-executable-code-and-execution-contexts">Executable Code and Execution Contexts</a> 내용을 참고하였고 용어 및 구조에 있어서 변경사항이 있었습니다.</p><h2 id="ES5-이전과-이후"><a href="#ES5-이전과-이후" class="headerlink" title="ES5 이전과 이후"></a>ES5 이전과 이후</h2><p>ES5 이전과 이후의 차이가 크진 않습니다. 그러나 최신 스펙으로 공부하고 알고 있는것이 맞다고 생각되었고 짧게나마 제가 공부하면서 알게된 변경사항에 대해 정리해보았습니다.</p><h4 id="실행-컨텍스트를-실행하기-위해-보유하는-프로퍼티"><a href="#실행-컨텍스트를-실행하기-위해-보유하는-프로퍼티" class="headerlink" title="실행 컨텍스트를 실행하기 위해 보유하는 프로퍼티"></a>실행 컨텍스트를 실행하기 위해 보유하는 프로퍼티</h4><ul><li>ES5 이전:<ul><li>변수 객체 (Variable Object)</li><li>Scope Chain</li><li>this (Context Object)</li></ul></li><li>ES5 이후<ul><li>Lexical Environment</li><li>Variable Environment</li></ul></li><li>Variable Object, Activation Object, Scope Chain 등의 개념이 Lexical Environment로 변경됨</li></ul><h3 id="실행-컨텍스트에서-“this”를-관리하는-주체"><a href="#실행-컨텍스트에서-“this”를-관리하는-주체" class="headerlink" title="실행 컨텍스트에서 “this”를 관리하는 주체"></a>실행 컨텍스트에서 “this”를 관리하는 주체</h3><ul><li>ES5 이전:<ul><li>실행 컨텍스트 객체가 직접</li></ul></li><li>ES5 이후<ul><li>Lexical Environment</li></ul></li></ul><h4 id="“Scope-Chain”의-변화"><a href="#“Scope-Chain”의-변화" class="headerlink" title="“Scope Chain”의 변화"></a>“Scope Chain”의 변화</h4><ul><li>Javascript는 <strong>Lexical Scope</strong>를 갖는 언어로써, <strong>식별자 탐색을 위한 참조</strong>가 ES5 이후 아래와 같이 변경되었다.</li><li>ES5 이전:<ul><li>Scope Chain</li></ul></li><li>ES5 이후<ul><li>Lexical nesting structure</li><li>Logical nesting of Lexical Environment values</li></ul></li><li><strong>Chain(사슬)</strong> 의 구조보다는 <strong>nesting(중첩)</strong> 의 의미를 강조에 의미를 둠</li></ul><h2 id="실행-컨텍스트와-그-구조"><a href="#실행-컨텍스트와-그-구조" class="headerlink" title="실행 컨텍스트와 그 구조"></a>실행 컨텍스트와 그 구조</h2><p>실행 컨텍스트 1편인 <a href="https://joontae-kim.github.io/2020/10/12/excution-context/">자바스크립트 실행 컨텍스트(Execution Context)</a> 에서 정의했듯이 “실행 가능한 코드를 <strong>형상화</strong> 하고 <strong>구분</strong> 하는 추상적인 개념으로 코드가 실행되고 있는 <strong>구역 또는 범위</strong>“ 로써 각 실행 컨텍스트는 아래와 같은 모양을 갖으며 이는 ES5 이전의 구조인 실행 컨텍스트 안에 3개의 프로퍼티(변수객체(Variable Object), Scope Chain, this Object)를 갖는 구조와 다르다.</p><p><img src="/images/Execution_context_construction.png" alt="Execution context 구조"></p><h4 id="1-실행-컨텍스트"><a href="#1-실행-컨텍스트" class="headerlink" title="1. 실행 컨텍스트"></a>1. 실행 컨텍스트</h4><p>그림의 가장 좌측에 그리고 최상위 개념인 <strong>실행 컨텍스트</strong> 는 “코드가 실행되고 있는 <strong>구역</strong> 또는 <strong>범위</strong>“ 라는 정의에 맞게 아래와 같이 어느 영역에서 호출 및 실행되고 있느냐에 따라 구분할 수 있으며 각 컨텍스트에 따라서 하위 개념 및 구조 또한 달라진다.</p><ul><li><strong>전역(Global) 영역</strong> 에서 실행되고 있으면 <strong>전역 실행 컨텍스트</strong> </li><li>전역 컨텍스트에서 호출 및 실행된 <strong>함수(Function)의 영역</strong> 에서 실행되고 있으면 <strong>함수 실행 컨텍스트</strong>  </li></ul><p>그리고 모든 실행 컨텍스트는 아래와 같은 공통된 구조를 갖으며, 짧게 정의하자면, <strong>변수의 참조를 기록하는 환경</strong>이라 할 수 있겠다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ExecutionContext = &#123;</span><br><span class="line">  LexicalEnvironment = <span class="xml"><span class="tag">&lt;<span class="name">ref.</span> <span class="attr">to</span> <span class="attr">LexicalEnvironment</span> <span class="attr">in</span> <span class="attr">memory</span>&gt;</span>,</span></span><br><span class="line">  VariableEnvironment = &lt;ref. to VariableEnvironment in  memory&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>위 두개의 프로퍼티는 초기화 시에는 같은 객체를 바라보고 있으며 실행 컨텍스트가 호출 및 실행 영역에 따라 구분되는 것과 마찬가지로 각 바라보는 또는 Linked Object가 달라진다.</p><ul><li><strong>전역(Global) 실행 컨텍스트</strong> 의 프로퍼티라면<ul><li>Global Lexical Environment / Global Variable Environment</li></ul></li><li>일반 <strong>함수(Function) 실행 컨텍스트</strong> 의 프로퍼티라면<ul><li>Lexical Environment / Variable Environment</li></ul></li></ul><h4 id="2-Lexical-Environment"><a href="#2-Lexical-Environment" class="headerlink" title="2. Lexical Environment"></a>2. Lexical Environment</h4><p>한글로 “어휘적 환경” 또는 “정적 환경”라고 할 수 있으며 <strong>Javascirpt 코드에서 변수 또는 함수 식별자를 맵핑(identifier-variable mapping)하는데 사용되는 객체</strong>로 아래와 같은 환경으로 구성되어 있다. (여기서 <strong>식별자(identifier)</strong> 란 참조 대상 식별자로써 변수나 함수의 이름을 참조하며 <strong>변수</strong> 는 함수 객체와 배열 객체를 포함한 실제 객체 또는 원시값에 대한 참조이다.)</p><ul><li><strong>Lexical Environment</strong><ul><li>Outer Environment Reference 또는 Reference to the outer environment</li><li>Environment Record</li></ul></li></ul><h5 id="2-1-Outer-Environment-Reference"><a href="#2-1-Outer-Environment-Reference" class="headerlink" title="2.1 Outer Environment Reference"></a>2.1 Outer Environment Reference</h5><p><strong>식별자(identifier) 검색을 위해 외부 Lexical Environment를 참조하는 포인터</strong>로 중첩된 Javascript 코드에서 스코프 탐색을 위해 사용된다.</p><ul><li><strong>Global Lexical Environment</strong> 의 Outer Environment Reference 값은 <code>null</code> </li><li><strong>일반 Function 환경에서의 Lexical Environment</strong> 의 Outer Environment Reference 값은 해당 실행환경(Execution Context)의 <code>상위 실행환경의 Lexical Environment</code>를 참조</li></ul><h5 id="2-2-Environment-Record"><a href="#2-2-Environment-Record" class="headerlink" title="2.2 Environment Record"></a>2.2 Environment Record</h5><p>현재 유효범위 내의 값에 식별자들의 바인딩을 기록하는 객체로 모든 지역 변수(변수, 함수 등)를 프로퍼티로 저장하며  <code>this</code> 와 같은 기타 정보도 여기에 저장된다. </p><p>현재 레코드 타입가 포함된 실행 컨텍스트(Execution Context)에 따라 <strong>Global Environment Record</strong> 와 <strong>일반 Function 환경에서의 Environment Record</strong> 으로 구분할 수 있으며 담고 있는 데이터에 대한 속성 또한 달라진다.</p><p>해당 Record 타입의 구조는 실행 컨텍스트의 영역을 불문하고 아래의 레코드 타입을 갖는다:</p><ul><li><p><strong>Environment Record</strong></p><ul><li>Object Environment Record</li><li>Declarative Environment Record</li></ul></li></ul><h5 id="2-2-1-Object-Environment-Record"><a href="#2-2-1-Object-Environment-Record" class="headerlink" title="2.2.1 Object Environment Record"></a>2.2.1 Object Environment Record</h5><p>with 문과 같이 식별자(Identifier)를 특정 객체의 속성으로 취급할때 사용되며, 이를 위해 binding Object라는 속성으로 특정 객체를 가리킨다. 현재 레코드는 Environment Record를 상속한 서브 클래스이다.</p><p><strong>전역(Global) 실행 컨텍스트의 Object Environment Record (in Environment Record)</strong> 는 브라우저 환경의 경우 전역 객체로서 <code>window</code> 객체를 저장한다. 따라서 일반적인 함수(Function) 실행 컨텍스트와 다르게 Object, Array, Function과 같은 built-in global 객체와 전역 코드에서의 함수/변수 선언에 의해 생성된 모든 식별자 정보를 저장하며 찾을 수 있다. (이는 함수 실행 컨텍스트의 Environment Record와 다른 점이다.)</p><h5 id="2-2-2-Declarative-Environment-Record"><a href="#2-2-2-Declarative-Environment-Record" class="headerlink" title="2.2.2 Declarative Environment Record"></a>2.2.2 Declarative Environment Record</h5><p>이름에서 알 수 있듯이 <strong>변수 선언, 함수 선언, catch 절과 같은 문법요소의 효과</strong> 와 같은 정보를 정의하기 위해 사용된다. 즉, 식별자(Indentifier) 정보를 해당 레코드 타입에서 찾을 수 있다는 말이다. <strong>함수 코드에 대한 lexical environment</strong>는 해당 레코드 타입을 포함하며 하위 레코드 타입으로는 아래와 같다.</p><ul><li>Declarative Environment Record<ul><li>Function Environment Record</li><li>Module Environment Record</li></ul></li></ul><p><strong>전역(Global) 실행 컨텍스트의 Declarative Environment Record (in Environment Record)</strong> 는 함수(Function) 실행 컨텍스트의 Declarative Environment Record와 다르게 전역 코드에서 object Environment Record에 포함되지 않은 식별자 정보만 보유한다. 왜냐하면 하단 전역 환경에서의 object Environment Record가 해당 레코드의 역할을 가져가 버렸기 때문이다. </p><h4 id="3-Variable-Environment"><a href="#3-Variable-Environment" class="headerlink" title="3. Variable Environment"></a>3. Variable Environment</h4><p>LexicalEnvironment 와 funtion, 변수 식별자가 binding 되는 점을 포함해 동일하다. VariableEnvironment 또한 Lexical Environment이다. 그러나 만들어진 변수 선언 및 함수 선언에 대해 바인딩을 유지한다.</p><ul><li>LexicalEnvironment는 코드 실행 중에 실행 컨텍스트 내에서 변경될 수 있지만 VariableEnvironment는 항상 값을 유지한다.<ul><li>LexicalEnvironment는 일시적으로 LexicalEnvironment 하위에 새로운 환경을 가리킵니다.</li><li>이 새로운 환경은 임시 바인딩을 보유합니다.</li><li>그리고 임시 범위를 벗어나면 VariableEnvironment가 참조하고 있는 값으로 LexicalEnvironment를 복구합니다.</li></ul></li></ul><p>ES6 에서 LexicalEnvironment와 VariableEnvironment 둘의 차이점은 전자가 함수 선언과 변수 (<code>let</code>과 <code>const</code>)의 바인딩을 저장하고 후자는 변수 <code>var</code> 만 저장한다.</p><h4 id="4-정리-실행-컨텍스트의-구조"><a href="#4-정리-실행-컨텍스트의-구조" class="headerlink" title="4. 정리 - 실행 컨텍스트의 구조"></a>4. 정리 - 실행 컨텍스트의 구조</h4><h5 id="실행-컨텍스트-하위-구조"><a href="#실행-컨텍스트-하위-구조" class="headerlink" title="실행 컨텍스트 하위 구조"></a>실행 컨텍스트 하위 구조</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ExecutionContext &#x3D; &#123;</span><br><span class="line">  LexicalEnvironment &#x3D; &lt;ref. to LexicalEnvironment in memory&gt;,</span><br><span class="line">  VariableEnvironment &#x3D; &lt;ref. to VariableEnvironment in  memory&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="Lexical-Environment-구조"><a href="#Lexical-Environment-구조" class="headerlink" title="Lexical Environment 구조"></a>Lexical Environment 구조</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Lexical Environment &#x3D; &#123;</span><br><span class="line">  Outer Environment Reference,</span><br><span class="line">  Environment Record: &#123;</span><br><span class="line">    Object Environment Record,</span><br><span class="line">    Declarative Environment Record: &#123;</span><br><span class="line">      Function Environment Record,</span><br><span class="line">      Module Environment Record</span><br><span class="line">    &#125;,</span><br><span class="line">    This Binding</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="Variable-Environment-구조"><a href="#Variable-Environment-구조" class="headerlink" title="Variable Environment 구조"></a>Variable Environment 구조</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">EnvironmentRecord: &#123;</span><br><span class="line">  Outer Environment Reference,</span><br><span class="line">  Environment Record: &#123;</span><br><span class="line">    Object Environment Record,</span><br><span class="line">    Declarative Environment Record,</span><br><span class="line">    This Binding</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>여기까지 ES5 이전과 이후의 실행 컨텍스트(Execution Context)의 변화와 구조에 대해 알아봤습니다. 다음 포스트에서는 실제 예제를 가지고 위의 실행 컨텍스트 구조가 어떻게 형성되고 실행되는지 알아보겠습니다.</p><hr><h2 id="참조"><a href="#참조" class="headerlink" title="참조"></a>참조</h2><ul><li><a href="https://blog.bitsrc.io/understanding-execution-context-and-execution-stack-in-javascript-1c9ea8642dd0">Understanding Execution Context and Execution Stack in Javascript</a></li><li><a href="http://ecma-international.org/ecma-262/6.0/#sec-executable-code-and-execution-contexts">Executable Code and Execution Contexts - ecma-262 from ECMAScript</a></li><li><a href="https://iamsjy17.github.io/javascript/2019/06/10/js33_execution_context.html">[Javascript] Execution Context와 Lexical Environment - https://iamsjy17.github.io</a></li><li><a href="https://velog.io/@imacoolgirlyo/JS-%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8%EC%9D%98-Hoisting-The-Execution-Context-%ED%98%B8%EC%9D%B4%EC%8A%A4%ED%8C%85-%EC%8B%A4%ED%96%89-%EC%BB%A8%ED%85%8D%EC%8A%A4%ED%8A%B8-6bjsmmlmgy">[JS] 자바스크립트의 The Execution Context (실행 컨텍스트) 와 Hoisting (호이스팅) - https://velog.io/@imacoolgirlyo</a></li><li><a href="https://meetup.toast.com/posts/129">자바스크립트 함수 (3) - Lexical Environment - meetup.toast.com</a></li><li><a href="https://meetup.toast.com/posts/86">자바스크립트의 스코프와 클로저 - meetup.toast.com</a></li><li><a href="https://ko.javascript.info/closure#ref-2405">변수의 유효범위와 클로저 - https://ko.javascript.info</a></li></ul>]]></content:encoded>
      
      
      <category domain="https://joontae-kim.github.io/categories/Programming/">Programming</category>
      
      <category domain="https://joontae-kim.github.io/categories/Programming/Javascript/">Javascript</category>
      
      
      <category domain="https://joontae-kim.github.io/tags/javascript/">javascript</category>
      
      <category domain="https://joontae-kim.github.io/tags/javascript-engine/">javascript engine</category>
      
      <category domain="https://joontae-kim.github.io/tags/execution-context/">execution context</category>
      
      <category domain="https://joontae-kim.github.io/tags/execution/">execution</category>
      
      <category domain="https://joontae-kim.github.io/tags/context/">context</category>
      
      
      <comments>https://joontae-kim.github.io/2020/10/15/excution-context-2/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>Dev To Read</title>
      <link>https://joontae-kim.github.io/2020/10/14/Blog-to-read/</link>
      <guid>https://joontae-kim.github.io/2020/10/14/Blog-to-read/</guid>
      <pubDate>Tue, 13 Oct 2020 17:40:15 GMT</pubDate>
      
        
        
      <description>&lt;h3 id=&quot;Blog-To-Read-In-Dev&quot;&gt;&lt;a href=&quot;#Blog-To-Read-In-Dev&quot; class=&quot;headerlink&quot; title=&quot;Blog To Read In Dev&quot;&gt;&lt;/a&gt;Blog To Read In Dev&lt;/h3&gt;&lt;ul&gt;
</description>
        
      
      
      
      <content:encoded><![CDATA[<h3 id="Blog-To-Read-In-Dev"><a href="#Blog-To-Read-In-Dev" class="headerlink" title="Blog To Read In Dev"></a>Blog To Read In Dev</h3><ul><li><p>Blocking-NonBlocking-Synchronous-Asynchronous</p><ul><li><a href="https://homoefficio.github.io/2017/02/19/Blocking-NonBlocking-Synchronous-Asynchronous/">https://homoefficio.github.io/2017/02/19/Blocking-NonBlocking-Synchronous-Asynchronous/</a></li></ul></li><li><p>GET이냐 POST냐 그것이 문제로다</p><ul><li><a href="https://homoefficio.github.io/2019/12/25/GET%EC%9D%B4%EB%83%90-POST%EB%83%90-%EA%B7%B8%EA%B2%83%EC%9D%B4-%EB%AC%B8%EC%A0%9C%EB%A1%9C%EB%8B%A4/">https://homoefficio.github.io/2019/12/25/GET%EC%9D%B4%EB%83%90-POST%EB%83%90-%EA%B7%B8%EA%B2%83%EC%9D%B4-%EB%AC%B8%EC%A0%9C%EB%A1%9C%EB%8B%A4/</a></li></ul></li><li><p>객체 지향 프로그래밍과 메시징</p><ul><li><a href="https://homoefficio.github.io/2019/07/04/%EA%B0%9D%EC%B2%B4-%EC%A7%80%ED%96%A5-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D%EA%B3%BC-%EB%A9%94%EC%8B%9C%EC%A7%95/">https://homoefficio.github.io/2019/07/04/%EA%B0%9D%EC%B2%B4-%EC%A7%80%ED%96%A5-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D%EA%B3%BC-%EB%A9%94%EC%8B%9C%EC%A7%95/</a></li></ul></li><li><p>Back to the Essence - Concurrency vs Parallelism</p><ul><li><a href="https://homoefficio.github.io/2019/02/02/Back-to-the-Essence-Concurrency-vs-Parallelism/">https://homoefficio.github.io/2019/02/02/Back-to-the-Essence-Concurrency-vs-Parallelism/</a></li></ul></li><li><p>Client-Side Rendering (CSR)</p><ul><li><a href="https://advancedweb.dev/client-side-rendering">https://advancedweb.dev/client-side-rendering</a></li></ul></li><li><p>Cracking The Frontend interview, Part 4: Javascript</p><ul><li><a href="https://advancedweb.dev/frontend-interview-part-4-javascript">https://advancedweb.dev/frontend-interview-part-4-javascript</a></li></ul></li><li><p>Intro to ES6</p><ul><li><a href="https://andrew.hedges.name/es6/">https://andrew.hedges.name/es6/</a></li></ul></li><li><p>Introducing the new features that ECMAScript 2016 (ES7) adds to JavaScript</p><ul><li><a href="https://www.freecodecamp.org/news/ecmascript-2016-es7-features-86903c5cab70/">https://www.freecodecamp.org/news/ecmascript-2016-es7-features-86903c5cab70/</a></li></ul></li><li><p>2020년 상반기 회고</p><ul><li><a href="https://medium.com/@pks2974/2020%EB%85%84-%EC%83%81%EB%B0%98%EA%B8%B0-%ED%9A%8C%EA%B3%A0-6db69bd77bfe">https://medium.com/@pks2974/2020%EB%85%84-%EC%83%81%EB%B0%98%EA%B8%B0-%ED%9A%8C%EA%B3%A0-6db69bd77bfe</a></li></ul></li><li><p>동기식 처리 모델 vs 비동기식 처리 모델</p><ul><li><a href="https://poiemaweb.com/js-async">https://poiemaweb.com/js-async</a></li></ul></li></ul>]]></content:encoded>
      
      
      <category domain="https://joontae-kim.github.io/categories/Blog/">Blog</category>
      
      <category domain="https://joontae-kim.github.io/categories/Blog/Blog-To-Read/">Blog To Read</category>
      
      
      
      <comments>https://joontae-kim.github.io/2020/10/14/Blog-to-read/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>자바스크립트 실행 컨텍스트(Execution Context)</title>
      <link>https://joontae-kim.github.io/2020/10/12/excution-context/</link>
      <guid>https://joontae-kim.github.io/2020/10/12/excution-context/</guid>
      <pubDate>Mon, 12 Oct 2020 07:25:31 GMT</pubDate>
      
        
        
      <description>&lt;p&gt;&lt;img src=&quot;/images/javascript.png&quot; alt=&quot;Javascript&quot;&gt;&lt;/p&gt;
&lt;p&gt;기본적으로 Front-End 개발자라면 Javascript를 통해 각종 기능을 개발하고 그 안에는 UI 제어, 사용자 데이터 처리 또는 연산</description>
        
      
      
      
      <content:encoded><![CDATA[<p><img src="/images/javascript.png" alt="Javascript"></p><p>기본적으로 Front-End 개발자라면 Javascript를 통해 각종 기능을 개발하고 그 안에는 UI 제어, 사용자 데이터 처리 또는 연산 그리고 서버와의 데이터 통신 등이 있을것이다. 그렇다면 이러한 기능들은 Javascript 엔진에서는 어떤 환경에서 어떻게 실행되는것일까? </p><p>그 중심에는 이번에 다룰 Javascript의 핵심원리인 실행 컨텍스트(Execution Context)가 있으며 Scope, Hoisting, this, function, closure 등의 동작원리를 담고 있는 총체적 개념이라고 할 수 있다.</p><p>그렇다면 실행 컨텍스트란 무엇이며, 어떠한 구조로 이루어져 있고, 어떻게 작동하는지 알아보자.</p><h2 id="실행-컨텍스트-Execution-Context"><a href="#실행-컨텍스트-Execution-Context" class="headerlink" title="실행 컨텍스트 (Execution Context)"></a>실행 컨텍스트 (Execution Context)</h2><p>서두에서 말했듯이 <strong><em>실행 컨텍스트</em></strong> 란 Javascript의 핵심원리로서, 실행 가능한 코드를 <strong>형상화</strong> 하고 <strong>구분</strong> 하는 추상적인 개념으로 코드가 실행되고 있는 <strong>구역 또는 범위</strong>라고 정의할 수 있다.</p><p>Javascript 엔진은 코드를 실행하기 위해 여러가지 정보를 알고 있어야 하며 다음에 얘기할 <strong>실행 컨텍스트의 유형</strong>에 따라서 달라질 수 있음을 기억하고 있어야 한다.</p><ul><li>Variable: 전역 변수, 지역 변수, 매개 변수, 객체의 프로퍼티</li><li>Argument(인자) 객체</li><li>Scope (변수의 유효범위)</li><li>This</li></ul><p>위와 같이 실행에 필요한 정보를 형상화하고 구분하기 위해서 JS 엔진은 실행 컨텍스트를 물리적 객체의 형태로 관리.</p><h2 id="실행-컨텍스트의-유형"><a href="#실행-컨텍스트의-유형" class="headerlink" title="실행 컨텍스트의 유형"></a>실행 컨텍스트의 유형</h2><p><strong>실행 구역 또는 범위</strong>에 따라 실행 컨텍스트의 유형을 구분할 수 있음</p><ol><li>전역 컨텍스트 (Global Execution Context)</li><li>함수 컨텍스트 (Functional Execution Context)</li><li>Eval 함수 컨텍스트 (Eval Function Execution Context)</li></ol><h4 id="전역-실행-컨텍스트-Global-Execution-Context"><a href="#전역-실행-컨텍스트-Global-Execution-Context" class="headerlink" title="전역 실행 컨텍스트 (Global Execution Context)"></a>전역 실행 컨텍스트 (Global Execution Context)</h4><p>실행 컨텍스트의 가장 기초가 되는 구간 또는 범위로, <code>함수</code> 구간 안에서 실행되는 코드가 아니라면 대부분 전역 컨텍스트 안에서 실행된다. 전역 컨텍스트에서는  두 가지 작업이 발생된다.</p><ol><li><code>window</code> 객체인 전역 컨텍스트 생성</li><li><code>this</code> 를 전역 객체로 할당</li></ol><h4 id="함수-실행-컨텍스트-Functional-Execution-Context"><a href="#함수-실행-컨텍스트-Functional-Execution-Context" class="headerlink" title="함수 실행 컨텍스트 (Functional Execution Context)"></a>함수 실행 컨텍스트 (Functional Execution Context)</h4><p>함수가 실행될때마다 해당 함수의 실행 컨텍스트가 생성된다. 즉, <code>호출</code> 이 발생될때마다 각 함수의 함수 컨텍스트가 생성되는 것이다.</p><h4 id="Eval-함수-실행-컨텍스트-Eval-Function-Execution-Context"><a href="#Eval-함수-실행-컨텍스트-Eval-Function-Execution-Context" class="headerlink" title="Eval 함수 실행 컨텍스트 (Eval Function Execution Context)"></a>Eval 함수 실행 컨텍스트 (Eval Function Execution Context)</h4><p><code>eval</code> 함수 또한 함수 컨텍스트와 동일하게 실행 컨텍스트를 갖지만 많이 사용하지 않는 함수이며 지양해야할 기능이므로 생략하겠다.</p><h2 id="실행-컨텍스트의-생성과-실행-관리"><a href="#실행-컨텍스트의-생성과-실행-관리" class="headerlink" title="실행 컨텍스트의 생성과 실행 관리"></a>실행 컨텍스트의 생성과 실행 관리</h2><p>실행 컨텍스트의 생성 및 실행을 이해하기 위해서는 <strong>실행 스택(Execution Stack)</strong> 과 <strong>제어권(Control)</strong> 에 대한 개념을 숙지해야한다.</p><p>먼저 <strong>호출 스택(Execution Stack)</strong> 이란 다른 언어 또는 파트에서도 나오는 <em>호출 스택(Call Stack)*과 같은 *</em>LIFO (Last In, First Out)** 의 자료구조로 코드 또는 함수가 실행되면서 생성되는 각각의 <strong>실행 컨텍스트를 저장하는 구조적 집합체</strong> 이다.</p><p>Javascript 엔진이 <code> script</code> 태그를 만나면,</p><ol><li>실행 가능한 코드로 <strong>제어권(control)</strong> 이 이동하면 논리적 스택 구조를 가지는 빈 실행 컨텍스트 스택이 생성</li><li><strong>제어권</strong> 이 전역 코드로 이동하면 <strong>전역 실행 컨텍스트</strong> 가 생성되며 비어있는 컨텍스트 스택에 <em>push</em></li><li>그리고 전역환경에서 함수를 호출하면 <strong>제어권</strong> 이 함수 코드로 이동하면서 호출된 함수의 <strong>함수 컨텍스트</strong> 가 생성 및 <strong>실행 스택</strong>에 <em>push</em>. 즉, 스택의 가장 마지막 순서로 <em>삽입됨</em></li><li>Javascript 엔진은 <strong>실행 스택</strong> 에서 가장 상단에 있는 <strong>실행 컨텍스트</strong> 부터 <em>실행</em></li><li>각 <strong>실행 컨텍스트</strong> 가 종료되고 나면 <strong>실행 스택</strong> 에서 <em>제거 (pop)</em> 되고, <strong><em>LIFO</em></strong>의 순서에 맞춰서 <strong>제어권</strong>이 이동한다.</li></ol><h5 id="아래의-예제를-보자"><a href="#아래의-예제를-보자" class="headerlink" title="아래의 예제를 보자"></a>아래의 예제를 보자</h5><p>우리는 <code>main.js</code> 라는 javascript file을 갖고 있으며 <code>script</code> 태그를 통해 첨부했다고 가정하자. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 전역 context</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">var</span> b = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// sum 함수 context</span></span><br><span class="line">  <span class="keyword">var</span> c = <span class="number">3</span>;</span><br><span class="line">  <span class="keyword">var</span> d = a + b + c;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">print</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// print 함수 context</span></span><br><span class="line">    <span class="built_in">console</span>.log(d)</span><br><span class="line">  &#125;</span><br><span class="line">  print();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sum()</span><br></pre></td></tr></table></figure><p><img src="/images/execution_stack.png" alt="[실행 스택 예시]"></p><p><code>main.js</code> 가 로드되면서 Javascript 엔진은 <strong>실행 스택</strong> 을 아래와 같이 분석 및 구분할 것이며 이는 그림 <strong><em>[실행 스택 예시]</em></strong> 와 같을 것이다. <em>(초기 컨텍스트 스택 순서는 생략)</em></p><ol><li><strong>전역 컨텍스트</strong>가 호출되면서 <strong>전역 실행 컨텍스트</strong>가 <strong>실행 스택</strong>에  <em>push</em> 되고</li><li><strong>sum 함수</strong>가 호출 및 실행되면서 sum 함수의 <strong>함수 실행 컨텍스트</strong>가 <strong>실행 스택</strong>에 <em>push</em> </li><li><strong>print 함수</strong>가 호출 및 실행되면서 print 함수의 <strong>함수 실행 컨텍스트</strong>를 <strong>실행 스택</strong>에 push. 그리고 실행이 끝나면 print 함수의 <strong>함수 실행 컨텍스트</strong>는 pop (제거)</li><li>sum 함수의 실행 또한 완료되며 <strong>함수 실행 컨텍스트</strong>가 pop (제거)</li><li><strong>전역 실행 컨텍스트</strong> 만 남게된다. </li></ol><p>여기까지 실행 컨텍스트는 무엇이며 그 유형과 Javascript 엔진이 실행 컨텍스트를 어떻게 생성하고 관리하는지 알아보았습니다. 다음 포스팅에서는 실행 컨텍스트에 대한 구조와 예시에 대해 다뤄보도록 하겠습니다.</p><hr><h2 id="참조"><a href="#참조" class="headerlink" title="참조"></a>참조</h2><ul><li><a href="https://blog.bitsrc.io/understanding-execution-context-and-execution-stack-in-javascript-1c9ea8642dd0">Understanding Execution Context and Execution Stack in Javascript</a></li><li><a href="http://ecma-international.org/ecma-262/6.0/#sec-executable-code-and-execution-contexts">Executable Code and Execution Contexts - ecma-262 from ECMAScript</a></li><li><a href="https://iamsjy17.github.io/javascript/2019/06/10/js33_execution_context.html">[Javascript] Execution Context와 Lexical Environment - https://iamsjy17.github.io</a></li><li><a href="https://velog.io/@imacoolgirlyo/JS-%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8%EC%9D%98-Hoisting-The-Execution-Context-%ED%98%B8%EC%9D%B4%EC%8A%A4%ED%8C%85-%EC%8B%A4%ED%96%89-%EC%BB%A8%ED%85%8D%EC%8A%A4%ED%8A%B8-6bjsmmlmgy">[JS] 자바스크립트의 The Execution Context (실행 컨텍스트) 와 Hoisting (호이스팅) - https://velog.io/@imacoolgirlyo</a></li><li><a href="https://meetup.toast.com/posts/129">자바스크립트 함수 (3) - Lexical Environment - meetup.toast.com</a></li><li><a href="https://meetup.toast.com/posts/86">자바스크립트의 스코프와 클로저 - meetup.toast.com</a></li></ul>]]></content:encoded>
      
      
      <category domain="https://joontae-kim.github.io/categories/Programming/">Programming</category>
      
      <category domain="https://joontae-kim.github.io/categories/Programming/Javascript/">Javascript</category>
      
      
      <category domain="https://joontae-kim.github.io/tags/javascript/">javascript</category>
      
      <category domain="https://joontae-kim.github.io/tags/javascript-engine/">javascript engine</category>
      
      <category domain="https://joontae-kim.github.io/tags/execution-context/">execution context</category>
      
      <category domain="https://joontae-kim.github.io/tags/execution/">execution</category>
      
      <category domain="https://joontae-kim.github.io/tags/context/">context</category>
      
      
      <comments>https://joontae-kim.github.io/2020/10/12/excution-context/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>데이터 유형 (type)</title>
      <link>https://joontae-kim.github.io/2020/10/11/javascript-types-intro/</link>
      <guid>https://joontae-kim.github.io/2020/10/11/javascript-types-intro/</guid>
      <pubDate>Sat, 10 Oct 2020 20:16:20 GMT</pubDate>
      
        
        
      <description>&lt;p&gt;&lt;img src=&quot;/images/javascript.png&quot; alt=&quot;Javascript&quot;&gt;&lt;/p&gt;
&lt;p&gt;프로그래밍 언어에서 &lt;strong&gt;자료형(types) 또는 데이터 타입(data type)&lt;/strong&gt; 이란 숫자형(정수형, 실수형), </description>
        
      
      
      
      <content:encoded><![CDATA[<p><img src="/images/javascript.png" alt="Javascript"></p><p>프로그래밍 언어에서 <strong>자료형(types) 또는 데이터 타입(data type)</strong> 이란 숫자형(정수형, 실수형), 논리값(Boolean), 문자(String) 등의 데이터를 식별하는 분류 (<em>indentifier</em>) 로서, 해당 자료형에 대한 가능한 값, 해당 자료형에서 수행을 마칠 수 있는 명령들, 데이터의 의미, 값의 저장하는 방식을 결정한다.</p><p>이렇듯 자료형이란 개발자가 특정 기능 또는 함수 내에서 어떤 형태의 데이터를 다룰 것이며 이를 통해 가능한 작업은 어떤 것인지 정의할 수 있는 역할을 한다. 그렇다면 Javascript의 데이터 타입(Type)에는 무엇이 있을까?</p><h2 id="프로그래밍에서의-자료"><a href="#프로그래밍에서의-자료" class="headerlink" title="프로그래밍에서의 자료"></a>프로그래밍에서의 자료</h2><ol><li><p>자료형의 구성</p><ul><li>변수들이 가질 수 있는 값의 범위/크기 및 연산 가능한 형태와 규칙</li><li>값의 <code>집합/범위/크기</code> 및 이 값에 적용가능한 <code>연산</code>에 따라 다르게 규정</li></ul></li><li><p>자료형의 구분</p><ul><li>원시형 또는 기본형 (Primitive Type) 또는 내장 자료형 (Built-in Type)<ul><li>시스템/컴파일러/인터프리터 등이 직접 제공 및 직접 해석 가능한 데이터 타입</li><li>정수 및 실수형, 논리값(Boolean), 문자형(String) 등 단순한 구조의 타입</li></ul></li><li>파생 자료형 (Derived Type)<ul><li>원시형 또는 타 유형의 데이터로부터 또는 개발자에 의해 유도된 구조화된 데이터 타입</li><li>문자열, 배열, 레코드, 리스트 등의 데이터 타입</li></ul></li><li>참조형 (Reference Type)<ul><li>변수 선언과 메모리 생성이 분리되는 데이터 타입</li><li>배열 참조형, 클래스 참조형 등의 데이터 타입</li></ul></li></ul></li><li><p>정적 타입 언어 vs 동적 타입 언어</p><p>Javascript 개발자라면 모두들 변수의 type에 의해 힘들었던 경험들이 있었을 것이다. Java 개발자인 친구 또한 Javascript를 공부하면서 변수의 특성에 대해 “형 지정도 없고, 됐다고 해도 쉽게 바뀐다.”라는 의미에서 약간 변태 같다고 했었다…  그렇다면 이러한 성질을 뭐라고 할까?</p><ul><li>정적 타입 언어와 동적 타입 언어의 차이는 <strong>데이터 타입 결정하는 시기</strong> 라고 할 수 있다.</li><li>정적 언어: <code>컴파일</code> 시에 결정.<ul><li>C, C#, C++, Java 등의 언어가 있음</li><li>장점:<ul><li>컴파일 시 타입에 대한 정보를 결정하기 때문에 런타임 시 속도가 빠름</li><li>컴파일 시 타입에 대한 검증을 하기 때문에 타입 안정성 높음</li></ul></li><li>단점<ul><li>변수의 타입이 이미 컴파일 이전에 정해지기 때문에 변수의 활용성이 떨어짐</li></ul></li></ul></li><li>동적 언어: <code>런타임(실행)</code> 시에 결정<ul><li>Perl, Ruby, Python, PHP, JavaScript 등의 언어가 있음</li><li>장점:<ul><li>런타임 시 까지 변수의 타입을 선언하지 않아도 되 활용 유연성이 높음</li><li>개발자 입장에서 변수의 타입 선언 걱정없이 빠르게 구현 및 이용 가능</li></ul></li><li>단점<ul><li>예상치 못한 타입이 지정되어 <code>TypeError</code> 또는 예상치 못한 처리에러가 날 수 있음</li></ul></li></ul></li></ul></li></ol><hr><h2 id="참고"><a href="#참고" class="headerlink" title="참고"></a>참고</h2><ul><li><p><a href="">자료형</a></p></li><li><p><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures">원시 값</a></p></li><li><p><a href="https://kkumalog.tistory.com/66">Pass By Value / Pass By Reference</a></p></li><li><p><a href="https://gmlwjd9405.github.io/2019/04/18/javascript-variable-and-type.html">자바스크립트의 변수, 연산자, 타입의 종료</a></p></li><li><p><a href="https://itmining.tistory.com/65">정적언어(타입)과 동적언어(타입)</a></p></li><li><p><a href="http://blog.naver.com/tkandrea92/80014134498">동적타입 vs 정적타입</a></p></li><li><p><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures">Data and Structure types</a></p></li></ul>]]></content:encoded>
      
      
      <category domain="https://joontae-kim.github.io/categories/Programming/">Programming</category>
      
      <category domain="https://joontae-kim.github.io/categories/Programming/Basic/">Basic</category>
      
      
      <category domain="https://joontae-kim.github.io/tags/javascript/">javascript</category>
      
      <category domain="https://joontae-kim.github.io/tags/type/">type</category>
      
      <category domain="https://joontae-kim.github.io/tags/types/">types</category>
      
      
      <comments>https://joontae-kim.github.io/2020/10/11/javascript-types-intro/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>변수, 스코프 그리고 호이스팅 in Javascript</title>
      <link>https://joontae-kim.github.io/2020/10/09/javascript-hoisting-closure/</link>
      <guid>https://joontae-kim.github.io/2020/10/09/javascript-hoisting-closure/</guid>
      <pubDate>Fri, 09 Oct 2020 04:10:52 GMT</pubDate>
      
        
        
      <description>&lt;p&gt;&lt;img src=&quot;/images/javascript.png&quot; alt=&quot;Javascript&quot;&gt;&lt;/p&gt;
&lt;p&gt;직전 3개의 포스트는 사실 Javascript의 스코프와 호이스팅을 더 잘 이해하기 위한 Javascipt 엔진의 함수와 변수를 처리하는 실</description>
        
      
      
      
      <content:encoded><![CDATA[<p><img src="/images/javascript.png" alt="Javascript"></p><p>직전 3개의 포스트는 사실 Javascript의 스코프와 호이스팅을 더 잘 이해하기 위한 Javascipt 엔진의 함수와 변수를 처리하는 실행 컨텍스트에 대해 공부해봤습니다. 사실 이전 (<em>블로그를 리뉴얼하기 전에도</em>) 다룬적 있지만 사실 그땐 음.. 이해했다기 보단 그저 암기를 했다고 생각했습니다. 그렇다면… 이번에는 잘 이해할 수 있을지 궁금합니다.</p><p>이번 주제는 공부하면서 참고했던 <a href="https://www.digitalocean.com/community/users/taniarascia">Tania Rascia</a> 의 <a href="https://www.digitalocean.com/community/tutorials/understanding-hoisting-in-javascript">Understanding Variables, Scope, and Hoisting in JavaScript</a> 를 번역하고 정리해보는 것으로 진행해보겠습니다.</p><p><em>2018년 2월에 게재되었다고 하지만 구독 횟수?가 무려 <strong>143.4k</strong> 이다…</em></p><p><img src="/images/image-20201019191043253.png" alt="image-20201019191043253"></p><hr><h1 id="변수-스코프-호이스팅-이해하기"><a href="#변수-스코프-호이스팅-이해하기" class="headerlink" title="변수, 스코프, 호이스팅 이해하기"></a>변수, 스코프, 호이스팅 이해하기</h1><h3 id="소개"><a href="#소개" class="headerlink" title="소개"></a>소개</h3><p><em>변수 (Variables)</em> 는 많은 프로그래밍 언어에서 기초적인 부분이며 초보 코더(coder)들이 배워야할 첫번째이자 가장 중요한 개념이다.</p><p>Javascript에는 변수의 이름을 지을때 따라야하는 몇가지 규칙 뿐만 아니라 많은 다양한 속성들이 있다. Javascript에서 변수를 선언하기 위해 사용되는 키워드로는 <code>var</code>, <code>let</code> 그리고 <code>const</code> 가 있으며 각 키워드들은 코드가 변수를 다르게 해석하도록 영향을 끼친다.</p><p>이 튜토리얼은 변수는 무엇이며, 선언과 변수명 정하는 법 그리고  <code>var</code>, <code>let</code> 그리고 <code>const</code> 의 차이점을 면밀히 살펴볼 것입니다. 또한, 호이스팅의 효과와 변수의 동작에 대한 전역 그리고 지역 스코프에 대한 중요성도 살펴볼 것입니다.</p><h2 id="변수-이해하기"><a href="#변수-이해하기" class="headerlink" title="변수 이해하기"></a>변수 이해하기</h2><p> <a href="https://developer.mozilla.org/en-US/docs/Glossary/Variable">변수(variable)</a> 란 값을 저장하기 위해 사용되는 이름을 가진 컨테이너이며, 여러번 참조할지 모르는 일부 정보를 나중에 사용하거나 수정하기 위해 변수 안에 저장할 수 있습니다. Javascript에서 변수에 포함된 값은 숫자, 문자열 또는 객체를 포함하는 특정 <a href="https://www.digitalocean.com/community/tutorials/understanding-data-types-in-javascript">JavaScript 데아이터 타입</a> 이 될 수 있습니다.</p><p>오늘날 Javascript의 바탕이 되는 <a href="http://www.ecma-international.org/ecma-262/6.0/">ECMAScript 2015 (ES6)</a> 언어 스펙 이전에는 오직 <code>var</code>   키워드를 사용하는 것이 변수를 선언하는 유일한 방법이었습니다. 결과적으로 대부분의 낡은 코드와 학습 리소스들은 오직 <code>var</code> 만을 사용할 것입니다. 우리는 <strong>“<code>var</code>, <code>let</code>, and <code>const</code>의 차이점” 섹션</strong> 에서   <code>var</code>, <code>let</code> 그리고 <code>const</code> 키워드의 차이점을 살펴보겠습니다.</p><p>변수 자체의 개념을 설명하기 위해서 우리는 <code>var</code> 을 사용할 수 있습니다. 아래의 예제어서 우리는 변수를 <em>선언할 것</em> 이고, 값을 <em>할당할 것</em> 입니다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 문자열 값 Sammy를 username 식별자에 할당합니다.</span></span><br><span class="line"><span class="keyword">var</span> username = <span class="string">&quot;sammy_shark&quot;</span>;</span><br></pre></td></tr></table></figure><p>위 문장은 몇 가지 부분으로 구성되어 있습니다:</p><ul><li><code>var</code> 키워드를 사용한 변수 선언</li><li><code>username</code>  변수 이름 (또는 식별자(identifier))</li><li><code>=</code> 문법으로 표현되는 할당 식별자</li><li>할당된 값, <code>sammy_shark</code></li></ul><p>현재 코드상에서 우리는 <code>username</code> 을 사용할 수 있습니다. Javascript는 문자열 값 <code>sammy_shark</code> 을 나타내는 ``username` 을 기억할 것입니다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 변수가 값과 동일한지 확인해봅시다</span></span><br><span class="line"><span class="keyword">if</span> (username === <span class="string">&quot;sammy_shark&quot;</span>) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="literal">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Output</span></span><br><span class="line"><span class="literal">true</span></span><br></pre></td></tr></table></figure><p>이전에 언급했던 것처럼, 변수는 Javascript 데이터 타입으로 나타낼 수 있습니다. 예와 같이 우리는 문자열(String), 숫자(Number), 객체(Object), 논리값(Boolean) 그리고 null 값으로 변수를 선언할 수 있습니다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 다양한 변수 할당</span></span><br><span class="line"><span class="keyword">var</span> name = <span class="string">&quot;Sammy&quot;</span>;</span><br><span class="line"><span class="keyword">var</span> spartans = <span class="number">300</span>;</span><br><span class="line"><span class="keyword">var</span> kingdoms = [ <span class="string">&quot;mammals&quot;</span>, <span class="string">&quot;birds&quot;</span>, <span class="string">&quot;fish&quot;</span> ];</span><br><span class="line"><span class="keyword">var</span> poem = &#123; <span class="attr">roses</span>: <span class="string">&quot;red&quot;</span>, <span class="attr">violets</span>: <span class="string">&quot;blue&quot;</span> &#125;;</span><br><span class="line"><span class="keyword">var</span> success = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">var</span> nothing = <span class="literal">null</span>;</span><br></pre></td></tr></table></figure><p>우리는 <code>console.log</code> 을 사용해 특정 변수에 담긴 값을 볼 수 있습니다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// spartans 변수를 console에 전송</span></span><br><span class="line"><span class="built_in">console</span>.log(spartans);</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Output</span></span><br><span class="line"><span class="number">300</span></span><br></pre></td></tr></table></figure><p>변수는 추후에 접근하거나 수정할 수 있는 메모리에 데이터를 저장하고, 또한 새로운 값으로 재할당하거 지정할 수도 있습니다. 아래의 간단한 예제는 비밀번호를 변수에 저장하고 업데이트 하는 방법을 설명합니다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// password 변수에 값을 할당</span></span><br><span class="line"><span class="keyword">var</span> password = <span class="string">&quot;hunter2&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 새로운 값을 변수 값에 재할당</span></span><br><span class="line">password = <span class="string">&quot;hunter3&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(password);</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Output</span></span><br><span class="line"><span class="string">&#x27;hunter3&#x27;</span></span><br></pre></td></tr></table></figure><h2 id="변수-이름짓기"><a href="#변수-이름짓기" class="headerlink" title="변수 이름짓기"></a>변수 이름짓기</h2><p>변수 이름은 JavaScript에서 <em>식별자 (identifier)</em> 로 알려져있습니다. <a href="https://www.digitalocean.com/community/tutorials/understanding-syntax-and-code-structure-in-javascript">Understanding Syntax and Code Structure in JavaScript</a> 에서 식별자 이름 짓기에 대한 몇 가지 규칙에 대해 논했으며, 아래와 같이 요약할 수 있습니다:</p><ul><li>변수 이름은 오직 문자(<code>a-z</code>), 숫자(<code>0-9</code>), 달러 기호(<code>$</code>) 그리고 언더스코어(<code>_</code>)</li><li>변수 이름은 어떠한 빈칸(tab 또는 space)도 포함할 수 없습니다.</li><li>숫자로 변수 이름을 시작할 수 없습니다.</li><li>변수 이름으로 사용할 수 없는 몇 가지 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Lexical_grammar#Reserved_keywords_as_of_ECMAScript_2015">예약어</a> 가 있습니다.</li><li>변수 이름은 대소문자를 구분합니다.</li></ul><p>또한, JavaScript는 <code>var</code> 또는 <code>let</code> 으로 선언된 함수 또는 변수의 이름에 카멜 케이스(camel case, 때때론 camelCase)를 사용하는 규칙이 있습니다. 이것은 첫번째 글자는 소문자이고 그 이후의 글자는 공백없이 모든 후속 단어의 첫글자를 대문자로 쓰는 관행입니다. 상수(constant)가 아닌 대부분의 변수는 몇 가지 예외와 함께 이 규칙을 따라야합니다.  <code>const</code>  키워드로 선언된 상수(constant)인 변수의 이름은 전형적으로 모두 대문자로 작성합니다.</p><p>배워야 할 규칙들이 많아보이겠지만, 이와 같은 관습들은 유효하고 규칙에 맞는 변수 이름을 작성하기 위한 제 2의 본성이 매우 빠르게 될 것입니다.</p><h2 id="var-let-and-const-차이점"><a href="#var-let-and-const-차이점" class="headerlink" title="var, let, and const 차이점"></a><code>var</code>, <code>let</code>, and <code>const</code> 차이점</h2><p>JavaScript는 변수를 선언하기 위해 언어의 복잡성을 더하는 세개의 다른 키워드가 있습니다.  3개의 키워드 차이점은 스코프(scope), 호이스팅(hoisting) 그리고 재할당(reassignment)에 바탕을 두고 있습니다.</p><table><thead><tr><th>Keyword</th><th>Scope</th><th>Hoisting</th><th>Can Be Reassigned</th><th>Can Be Redeclared</th></tr></thead><tbody><tr><td><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/var"><code>var</code></a></td><td>Function scope</td><td>Yes</td><td>Yes</td><td>Yes</td></tr><tr><td><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/let"><code>let</code></a></td><td>Block scope</td><td>No</td><td>Yes</td><td>No</td></tr><tr><td><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/const"><code>const</code></a></td><td>Block scope</td><td>No</td><td>No</td><td>No</td></tr></tbody></table><p>여러분은 자신의 프로그램에 세 가지중 어떤 것을 사용해야만 하는지 궁금해할지도 모릅니다. 흔히, 받아들여지는 관행은 가능하 한 <code>const</code> 를, 반복문과 재할당의 경우에는 <code>let</code> 를 사용하도록 하는 것입니다. 일반적으로, <code>var</code> 은 작동하고 있는 레거시 코드 외부에서 피할 수 있습니다.</p><h2 id="Variable-Scope-변수-스코프"><a href="#Variable-Scope-변수-스코프" class="headerlink" title="Variable Scope (변수 스코프)"></a>Variable Scope (변수 스코프)</h2><p>JavaScript에서 <em>Scope</em> 는 JavaScript에게 변수 접근성을 결정하는 코드의 현재 컨텍스트를 참조합니다. 스코프에는 두가지 타입으로, <em>지역(local)</em> 과 <em>전역(global)</em> 이 있습니다.</p><ul><li><strong>Global variables :</strong> 블록 밖에 선언된 변수</li><li><strong>Local variables :</strong> 블록 안에 선언된 변수</li></ul><p>아래 예제처럼, 우리는 전역 변수를 생성할 수 있다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 전역변수 초기화</span></span><br><span class="line"><span class="keyword">var</span> creature = <span class="string">&quot;wolf&quot;</span>;</span><br></pre></td></tr></table></figure><p>우리는 변수가 재할당 가능하다고 배웠습니다. 지역 변수를 사용함으로써 우리는 원래 값을 변경하거나 재할당 없이 외부 스코프에 있는 변수와 같은 이름으로 새로운 변수를 생성할 수 있습니다.</p><p>아래 예제에서 우리는 전역 <code>species</code> 변수를 생성했고, 함수 안에 같은 이름으로 지역 변수가 또 있습니다. 이 코드를 콘솔에 전송함으로써 우리는 변수의 값이 스코프에 따라 어떻게 다르며, 원래 값은 변하지 않는다는 것을 볼 수 있습니다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Initialize a global variable</span></span><br><span class="line"><span class="keyword">var</span> species = <span class="string">&quot;human&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">transform</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// Initialize a local, function-scoped variable</span></span><br><span class="line">  <span class="keyword">var</span> species = <span class="string">&quot;werewolf&quot;</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(species);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Log the global and local variable</span></span><br><span class="line"><span class="built_in">console</span>.log(species);</span><br><span class="line">transform();</span><br><span class="line"><span class="built_in">console</span>.log(species);</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Output</span></span><br><span class="line">human</span><br><span class="line">werewolf</span><br><span class="line">human</span><br></pre></td></tr></table></figure><p>예제에서, 지역 변수는 <em>함수 스코프(function-scoped)</em> 이다. <code>var</code> 키워드로 선언된 변수들은 구분된 스코프를 가짐으로써 변수들이 함수를 인지한다는 의미에서 항상 함수 스코프이다. 따라서, 이러한 지역적 스코프 변수는 전역 스코프에서 접근할 수 없다.</p><p>하지만 새로운 키워드인 <code> let</code> 과 <code>const</code> 는 <em>블록 스코프(block-scoped)</em> 인데, 함수 블록, <code>if</code> 구문 그리고 <code>for</code> 과 <code>while</code> 반복문을 포함한 특정 종류의 블록으로 생성된 새로운 지역 스코프를 의미한다.</p><p>함수 스코프(function-scoped)와 블로 스코프(block-scoped) 내 변수의 차이를 형상화하기 위해서  <code> let</code> 을 사용해 <code>if</code> 블록 안에 새로운 변수를 할당할 것 입니다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> fullMoon = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Initialize a global variable</span></span><br><span class="line"><span class="keyword">let</span> species = <span class="string">&quot;human&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (fullMoon) &#123;</span><br><span class="line">  <span class="comment">// Initialize a block-scoped variable</span></span><br><span class="line">  <span class="keyword">let</span> species = <span class="string">&quot;werewolf&quot;</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`It is a full moon. Lupin is currently a <span class="subst">$&#123;species&#125;</span>.`</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">`It is not a full moon. Lupin is currently a <span class="subst">$&#123;species&#125;</span>.`</span>);</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Output</span></span><br><span class="line">It is a full moon. Lupin is currently a werewolf.</span><br><span class="line">It is not a full moon. Lupin is currently a human.</span><br></pre></td></tr></table></figure><p>위 예에서 보듯이, <code>species</code> 변수는 전역적으로 하나의 값(<code>human</code>)만, 지역적으로 <code>werewolf</code> 라는 다른 값을 가집니다. 만약 우리가 <code>var</code> 을 사용했다면, 다른 결과를 만들 것입니다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Use var to initialize a variable</span></span><br><span class="line"><span class="keyword">var</span> species = <span class="string">&quot;human&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (fullMoon) &#123;</span><br><span class="line">  <span class="comment">// Attempt to create a new variable in a block</span></span><br><span class="line">  <span class="keyword">var</span> species = <span class="string">&quot;werewolf&quot;</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`It is a full moon. Lupin is currently a <span class="subst">$&#123;species&#125;</span>.`</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">`It is not a full moon. Lupin is currently a <span class="subst">$&#123;species&#125;</span>.`</span>);</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Output</span></span><br><span class="line">It is a full moon. Lupin is currently a werewolf.</span><br><span class="line">It is not a full moon. Lupin is currently a werewolf.</span><br></pre></td></tr></table></figure><p>결과적으로, 전역 변수와 블록 스코프 변수 둘다 <code>werewolf</code> 라는 같은 값으로 끝났습니다. 이것은 <code>var</code>  로 새로운 지역 변수를 생성하는 것 대신에, 같은 스코프안에서 같은 변수에 재할당했기 때문입니다. <code>var</code> 은 <code>if</code> 조건문을 다른 부분으로 즉, 새로운 스코프로 인식하지 않습니다. 의도치 않게 변수 값을 덮어쓰는 것과 같은 코드를 덜 생산하기 위해, 일반적으로 블록 스코프로 변수를 선언하기를 추천합니다.</p><h2 id="Hoisting-호이스팅"><a href="#Hoisting-호이스팅" class="headerlink" title="Hoisting (호이스팅)"></a>Hoisting (호이스팅)</h2><p>지금까지 대부분의 예제에서 우리는 변수를 <em>선언하기</em> 위해 <code>var</code> 을 사용했었고, 값으로 <em>초기화</em> 했습니다. 선언과 초기화 이후에 우리는 값을 접근하거나 재할당할 수 있습니다.</p><p>만약 우리가 변수가 선언되고 초기화되기 전에 사용하려고 시도한다면, 이것은 <code>undefined</code> 를 반환할 것입니다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 변수가 선언되기 전에 사용 시도</span></span><br><span class="line"><span class="built_in">console</span>.log(x);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 변수 할당</span></span><br><span class="line"><span class="keyword">var</span> x = <span class="number">100</span>;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Output</span></span><br><span class="line"><span class="literal">undefined</span></span><br></pre></td></tr></table></figure><p>그러나, 만약 우리가 <code>var</code>  키워드를 생략했다면, 우리는 더이상 변수를 선언할 수 없으며 오직 초기화만 할 수 있을 것입니다. 이것은 <code>ReferenceError</code> 를 반환할 것이고 스크립트의 실행을 중단합니다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Attempt to use a variable before declaring it</span></span><br><span class="line"><span class="built_in">console</span>.log(x);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Variable assignment without var</span></span><br><span class="line">x = <span class="number">100</span>;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Output</span></span><br><span class="line"><span class="built_in">ReferenceError</span>: x is not defined</span><br></pre></td></tr></table></figure><p>이런 이유는 <em>호이스팅(hoisting)</em> 으로, 변수와 함수 선언을 해당 스코프의 가장 위로 옮기는 Javascript의 동작입니다. 초기화가 아닌 실제 선언만 끌어올려지기(hoist) 때문에 첫 번째 예제의 값은 <code>undefined</code> 를 반환합니다.</p><p>이 개념을 더 확실하게 설명하기 위해, Javascript가 실제로 어떻게 해석하는지 아래의 코드에 작성해보았습니다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 우리가 작성한 코드</span></span><br><span class="line"><span class="built_in">console</span>.log(x);</span><br><span class="line"><span class="keyword">var</span> x = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// JavaScript가 해석한 방법</span></span><br><span class="line"><span class="keyword">var</span> x;</span><br><span class="line"><span class="built_in">console</span>.log(x);</span><br><span class="line">x = <span class="number">100</span>;</span><br></pre></td></tr></table></figure><p>JavaScript는 스크립트를 실행하기 전에 변수로써 <code>x</code> 를 메모리에 저장한다. 정의되기 전에 여전히 <code>x</code> 를 호출하기 때문에 결과는 <code>100</code> 아닌 <code>undefined</code> 이다. 하지만, <code>ReferenceError</code>  가 발생하지 않고 스크립트가 중단된다. 비록 <code>var</code>  키워드가 실제로 <code>var</code> 의 위치를 변경하지는 않았지만, hoisting의 작동 장식에 대한 유용한 코드입니다. 그러나 이 코드를 작성한 프로그래머가 <code>x</code>의 결과값이 <code>undefined</code> 일때,   <code>true</code> 일 것이라고 예상하기 때문에, 이러한 동작은 이슈를 유발할 수 있습니다.</p><p>또한 다음 예제에서 우리는 호이스팅이 예상치 못한 결과를 어떻게 유발할 수 있는지 볼 수 있습니다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 전역 스코프에 변수 x 초기화</span></span><br><span class="line"><span class="keyword">var</span> x = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">hoist</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 코드 결과에 아무런 영향을 주지 않아야하는 조건문</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="literal">false</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> x = <span class="number">200</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">console</span>.log(x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">hoist();</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Output</span></span><br><span class="line"><span class="literal">undefined</span></span><br></pre></td></tr></table></figure><p>이 예제에서, 우리는 전역적으로 <code>x</code> 에 <code>100</code> 이 되도록 선언했습니다. <code>if</code> 선언문에 따라 <code>x</code> 는 <code>200</code> 으로 변할수도 있었지만 그 조건문이 <code>false</code> 이기 때문에 <code>x</code> 의 값에 영향을 주지 못했습니다. 대신에 <code>x</code> 는 <code>hoist()</code> 함수의 가장 꼭대기로 끌어올려지고, 값은 <code>undefined</code> 가 됐습니다.</p><p>이러한 예상치 못한 작동의 유형은 잠재적으로 프로그램에 버그들을 유발할 수 있습니다. <code>let</code>과 <code>const</code>는 블록 스코프(block-scoped)이기 때문에, 아래와 같이 이러한 문법에서는 끌어올려지지 않을 것입니다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Initialize x in the global scope</span></span><br><span class="line"><span class="keyword">let</span> x = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">hoist</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// Initialize x in the function scope</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="number">3</span> === <span class="number">4</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> x = <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">console</span>.log(x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">hoist();</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Output</span></span><br><span class="line"><span class="literal">true</span></span><br></pre></td></tr></table></figure><p><code>var</code> 로 가능한 변수 중복 선언은 <code>let</code> 과 <code>const</code> 에서는 에러를 던질 것입니다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// var 으로 선언된 변수 덮어쓰기 시도</span></span><br><span class="line"><span class="keyword">var</span> x = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">var</span> x = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(x);</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Output</span></span><br><span class="line"><span class="number">2</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// let 으로 선언된 변수 덮어쓰기 시도</span></span><br><span class="line"><span class="keyword">let</span> y = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">let</span> y = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(y);</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Output</span></span><br><span class="line">Uncaught <span class="built_in">SyntaxError</span>: Identifier <span class="string">&#x27;y&#x27;</span> has already been declared</span><br></pre></td></tr></table></figure><p>요약하자면, <code>var</code> 로 도입된 변수는 메모리에 변수 선언을 저장하는 Javascript 메커니즘인 호이스팅에 의해 영향을 잠재적으로 받게 됩니다. 이러한 메커니즘은 정의되지 않은 변수가 생길 수 있습니다. <code>let</code> 과 <code>const</code> 의 도입은 변수를 선언하기 전 사용하려고 하거나 한번 이상 선언하려고 할때 에러를 던짐으로써 이러한 이슈를 해결해줍니다.</p><h2 id="Constants-상수"><a href="#Constants-상수" class="headerlink" title="Constants (상수)"></a>Constants (상수)</h2><p>많은 프로그래밍 언어는 값을 수정하거나 변경할 수 없는 <em>상수 (constant)</em> 라는 기능이 있습니다. Javascript에서 <code>const</code> 식별자는 상수(Constants) 이후에 따라서 만들어졌으며, <code>const</code> 에 할당된 값은 재할당할 수 없습니다.</p><p>모든 <code> const</code> 식별자 대문자로 작성하는 것이 일반적인 규범이며 다른 변수 값과 쉽게 구별할 수 있도록 표시합니다.</p><p>아래의 예제에서, 우리는 <code>const</code> 키워드로 상수로써 <code>SPECIES</code> 변수를 초기화했고, 변수를 재할당하려고 할때 결과가 에러일 것입니다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// const에 값 할당</span></span><br><span class="line"><span class="keyword">const</span> SPECIES = <span class="string">&quot;human&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 값 재할당 시도</span></span><br><span class="line">SPECIES = <span class="string">&quot;werewolf&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(SPECIES);</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Output</span></span><br><span class="line">Uncaught <span class="built_in">TypeError</span>: Assignment to constant variable.</span><br></pre></td></tr></table></figure><p><code>const</code> 값은 재할당할 수 없기 때문에, 선언과 초기화가 동시에 될 필요가 있거나 에러를 던질 것입니다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// const 초기화 없이 선언</span></span><br><span class="line"><span class="keyword">const</span> TODO;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(TODO);</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Output</span></span><br><span class="line">Uncaught <span class="built_in">SyntaxError</span>: Missing initializer <span class="keyword">in</span> <span class="keyword">const</span> declaration</span><br></pre></td></tr></table></figure><p>프로그래밍에서 변경할 수 있는 변수는 <em>mutable (변경 가능한 또는 변하기 쉬운)</em> 인 반면에, 변경할 수 없는 값들은 <em>immutable(불변의)</em> 로 알려져 있습니다. 비록 <code>const</code> 값은 재할당할 수 없지만, <code>const</code> 로 선언된 객체의 속성을 수정하는 것은 변경 가능(mutable)하다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// CAR 객체에 두개의 속성 생성</span></span><br><span class="line"><span class="keyword">const</span> CAR = &#123;</span><br><span class="line">    color: <span class="string">&quot;blue&quot;</span>,</span><br><span class="line">    price: <span class="number">15000</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// CAR 속성 수정</span></span><br><span class="line">CAR.price = <span class="number">20000</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(CAR);</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Output</span></span><br><span class="line">&#123; <span class="attr">color</span>: <span class="string">&#x27;blue&#x27;</span>, <span class="attr">price</span>: <span class="number">20000</span> &#125;</span><br></pre></td></tr></table></figure><p>상수(Constants)는 프로젝트에서 미래의 여러분 자신과 다른 개발자들에게 변수가 재할당될 수 없는 의도를 명확히 하는데 유용합니다. 만약 미래에 변수가 수정될지도 모른다고 예상한다면, 여러분은 대신에  <code>let</code> 을 사용해 변수를 선언하기를 원할 것입니다.</p><h2 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h2><p>튜토리얼에서, 우리는 변수는 무엇이며 변수명 짓기의 규칙과 변수값을 할당하는 법에 대해 살펴봤으며 또한, 스코프(scope) 와 호이스팅(hoisting), <code>var</code> 키워드의 몇가지 한계 뿐만 아니라 <code>let</code> 과 <code>const</code>  가 <code>var</code>  키워드에 의한 이슈들을 해결하는 방법에 대해서도 학습해봤습니다.</p><hr><h2 id="번역을-마치며"><a href="#번역을-마치며" class="headerlink" title="번역을 마치며"></a>번역을 마치며</h2><p>이상 Javascript의 변수와 지역/전역 스코프에 따른 변수 처리 그리고 변수를 선언하기 위한 <code>var</code>, <code>let</code>  그리고 <code>const</code> 키워드의 차이와 각 선언 키워드의 스코프에 대해서 배워봤습니다. </p><p>다음으로는 <a href="https://ko.javascript.info/closure">ko.javascript.info의 closure</a> 파트의 연습문제를 풀어보며 Javascript의 lexical Environment, 스코프, 호이스팅 그리고 <code>var</code>, <code>let</code>, <code>const</code>  에 대해 복습해보도록 하겠습니다.</p><blockquote><p>본 포스트는  <a href="https://www.digitalocean.com/community/users/taniarascia">Tania Rascia</a> 의 <a href="https://www.digitalocean.com/community/tutorials/understanding-hoisting-in-javascript">Understanding Variables, Scope, and Hoisting in JavaScript</a> 를 번역했음을 알려드립니다.</p></blockquote>]]></content:encoded>
      
      
      <category domain="https://joontae-kim.github.io/categories/Programming/">Programming</category>
      
      <category domain="https://joontae-kim.github.io/categories/Programming/Javascript/">Javascript</category>
      
      
      <category domain="https://joontae-kim.github.io/tags/javascript/">javascript</category>
      
      <category domain="https://joontae-kim.github.io/tags/Variable/">Variable</category>
      
      <category domain="https://joontae-kim.github.io/tags/Hoisting/">Hoisting</category>
      
      <category domain="https://joontae-kim.github.io/tags/Scope/">Scope</category>
      
      
      <comments>https://joontae-kim.github.io/2020/10/09/javascript-hoisting-closure/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>javascript types</title>
      <link>https://joontae-kim.github.io/2020/10/09/javascript-types/</link>
      <guid>https://joontae-kim.github.io/2020/10/09/javascript-types/</guid>
      <pubDate>Thu, 08 Oct 2020 17:02:43 GMT</pubDate>
      
        
        
      <description>&lt;p&gt;&lt;img src=&quot;/images/javascript.png&quot; alt=&quot;Javascript&quot;&gt;&lt;/p&gt;
&lt;p&gt;프로그래밍 언어에서 &lt;strong&gt;자료형(types) 또는 데이터 타입(data type)&lt;/strong&gt; 이란 숫자형(정수형, 실수형), </description>
        
      
      
      
      <content:encoded><![CDATA[<p><img src="/images/javascript.png" alt="Javascript"></p><p>프로그래밍 언어에서 <strong>자료형(types) 또는 데이터 타입(data type)</strong> 이란 숫자형(정수형, 실수형), 논리값(Boolean), 문자(String) 등의 데이터를 식별하는 분류 (<em>indentifier</em>) 로서, 해당 자료형에 대한 가능한 값, 해당 자료형에서 수행을 마칠 수 있는 명령들, 데이터의 의미, 값의 저장하는 방식을 결정한다.</p><p>이렇듯 자료형이란 개발자가 특정 기능 또는 함수 내에서 어떤 형태의 데이터를 다룰 것이며 이를 통해 가능한 작업은 어떤 것인지 정의할 수 있는 역할을 한다. 그렇다면 Javascript의 데이터 타입(Type)에는 무엇이 있을까?</p><h2 id="Javascript의-Data-Type-분류"><a href="#Javascript의-Data-Type-분류" class="headerlink" title="Javascript의 Data Type 분류"></a>Javascript의 Data Type 분류</h2><p>Javascript의 데이터 형태 분류는 기본적으로 <strong>Primitives(원시형 또는 기본형)</strong> / <strong>Reference (참조형)</strong> 으로 나뉜다.</p><h4 id="Primitives-Type-원시형-또는-기본형"><a href="#Primitives-Type-원시형-또는-기본형" class="headerlink" title="Primitives Type (원시형 또는 기본형)"></a>Primitives Type (원시형 또는 기본형)</h4><ul><li><p><strong>단 하나의 값만</strong> 가질 수 있음</p></li><li><p>변수에 할당될 때 <strong>스택 메모리</strong> 상에 <strong>고정된 크기</strong>로 저장</p></li><li><p>모든 원시 값은 <strong>불변 (immutable</strong>)의 성질로 변형 불가</p><ul><li><p>즉, 원시값을 교체할 수는 있지만, 직접 변형할 수는 없음</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 문자열 메서드는 문자열을 변형하지 않음</span></span><br><span class="line"><span class="keyword">var</span> bar = <span class="string">&quot;baz&quot;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(bar);        <span class="comment">// baz</span></span><br><span class="line">bar.toUpperCase();</span><br><span class="line"><span class="built_in">console</span>.log(bar);        <span class="comment">// baz</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 배열 메소드는 배열을 변형함</span></span><br><span class="line"><span class="keyword">var</span> foo = [];</span><br><span class="line"><span class="built_in">console</span>.log(foo);        <span class="comment">// []</span></span><br><span class="line">foo.push(<span class="string">&quot;plugh&quot;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(foo);        <span class="comment">// [&quot;plugh&quot;]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 할당은 원시 값에 새로운 값을 부여 (변형이 아님)</span></span><br><span class="line">bar = bar.toUpperCase(); <span class="comment">// BAZ</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>객체가 아니면서 메서드도 가지지 않는 데이터</p></li><li><p>null의 경우, 겉보기엔 원시 값처럼 보이는  있지만,  사실 <strong>Object</strong> 이며, 모든 구조화된 자료형은 <code>prototype chain</code> 에 따라 null의 자손이다.</p></li><li><p>대부분의 경우, 원시 값은 언어 구현체의 가장 저수준(low level) 에서 나타남.</p></li><li><p>원시 값 자체와, 원시값을 할당한 변수를 혼동하지 않는 것이 중요!</p><ul><li>변수: 새로운 값을 다시 할당 가능</li><li>원시값: 객체, 배열, 함수와 달리 변형 불가능</li></ul></li><li><p><strong>값에 의한 전달 (pass-by-value) 방식</strong>으로 전달</p></li></ul><h4 id="Reference-Type-참조형"><a href="#Reference-Type-참조형" class="headerlink" title="Reference Type (참조형)"></a>Reference Type (참조형)</h4><ul><li><strong>객체는</strong> 데이터와 그 데이터에 관련한 동작(절차, 방법, 기능)을 모두 포함할 수 있는 개념적 존재<ul><li>즉, <strong>Property</strong>와 <strong>Method</strong>를 포함할 수 있는 독립적 주체이자 <strong>복합적 구조의 데이터</strong></li></ul></li><li>데이터가 동적 바인딩 되므로 실행중에도 그 값이 변동될 수 있으며, 선언될때 이미 크기가 정해져 있지 않음</li><li>JavaScript는 객체 기반의 스크립트 언어로써 JavaScript를 이루고 있는 거의 모든 것이 객체이다.<ul><li>원시 타입을 제외한 <strong>나머지 값들(배열, 함수, 정규표현식 등)은 모두 객체</strong>이다.</li></ul></li><li>참조 타입은 변수의 값이 저장된 메모리 블럭의 주소를 가지고 있고 자바스크립트 엔진이 <strong>변수가 가지고 있는 메모리 주소를 이용해서 변수의 값에 접근</strong>한다.<ul><li>변수에 할당이 될 때 <strong>값이 직접 해당 변수에 저장될 수 없으며 변수에는 데이터에 대한 참조만 저장</strong></li><li>변수의 값이 저장된 <strong>힙 메모리의 주소값을 저장</strong></li></ul></li><li><strong>객체</strong>와 <strong>함수</strong> 는 언어의 다른 기본 요소임.<ul><li>객체 <code>=&gt;</code> 값을 위한 컨테이너</li><li>함수 <code>=&gt;</code> 어플리케이션이 수행할 수 있는 절차 (procedure)</li></ul></li><li><strong>참조에 의한 전달 (pass-by-reference) 방식</strong>으로 전달</li></ul><hr><h2 id="Pass-by-Value-VS-Pass-by-Reference"><a href="#Pass-by-Value-VS-Pass-by-Reference" class="headerlink" title="Pass by Value VS Pass by Reference"></a>Pass by Value VS Pass by Reference</h2><h4 id="Pass-by-Value"><a href="#Pass-by-Value" class="headerlink" title="Pass by Value"></a>Pass by Value</h4><p>먼저, Pass by Value를 살펴보면, <strong>Function</strong>은 인수로써 <strong>변수값을 직접 전달받아 호출</strong>한다. 함수 내에서 인수를 변경하는 것은 함수 밖에 있는 변수에 영향을 끼치지 않는다.</p><p><strong>Javascript는 항상 값에 의한 전달</strong> 이므로 변수값을 변경해도 기본 요소(문자열 또는 숫자)가 변경되지 않는다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">callByValue</span>(<span class="params">varOne, varTwo</span>) </span>&#123; </span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;Inside Call by Value Method&quot;</span>); </span><br><span class="line">  varOne = <span class="number">100</span>; </span><br><span class="line">  varTwo = <span class="number">200</span>; </span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;varOne =&quot;</span> + varOne +<span class="string">&quot;varTwo =&quot;</span> +varTwo); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> varOne = <span class="number">10</span>; </span><br><span class="line"><span class="keyword">let</span> varTwo = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;Before Call by Value Method&quot;</span>); </span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;varOne =&quot;</span> + varOne +<span class="string">&quot;varTwo =&quot;</span> +varTwo); </span><br><span class="line"></span><br><span class="line">callByValue(varOne, varTwo) </span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;After Call by Value Method&quot;</span>); </span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;varOne =&quot;</span> + varOne +<span class="string">&quot;varTwo =&quot;</span> +varTwo); </span><br><span class="line"></span><br><span class="line">output will be : </span><br><span class="line">--------------- </span><br><span class="line">Before Call by Value Method </span><br><span class="line">varOne =<span class="number">10</span> varTwo =<span class="number">20</span> </span><br><span class="line">Inside Call by Value Method </span><br><span class="line">varOne =<span class="number">100</span> varTwo =<span class="number">200</span> </span><br><span class="line">After Call by Value Method </span><br><span class="line">varOne =<span class="number">10</span> varTwo =<span class="number">20</span></span><br></pre></td></tr></table></figure><p>그러나, 변수가 배열(Array)을 포함한 객체(Object)를 참조할때는 값은 객체에 대한 참조값이다.</p><h4 id="Pass-by-Reference"><a href="#Pass-by-Reference" class="headerlink" title="Pass by Reference"></a>Pass by Reference</h4><p>Pass by Reference를 살펴보면, <strong>Function</strong>은 인자로써 전달받은 <strong>변수의 참조나 주소(reference/address)를 호출</strong>한다. 함수 내에서 인자를 변경하는 것은 함수 밖에 있는 인자에 영향을 끼친다. Javascript 객체와 배열은 참조에 의한 전달을 따른다.</p><p>그러나 만약 우리가 메서드에 인자로써 객체 또는 배열을 전달한다면 객체의 값을 변경할 수 있는 가능성이 생긴다.</p><hr><h2 id="Primitives-and-Reference-Type-분류"><a href="#Primitives-and-Reference-Type-분류" class="headerlink" title="Primitives and Reference Type 분류"></a>Primitives and Reference Type 분류</h2><p>가장 기본적인 분류법으로 ECMAScript 표준에는 7가지 type으로 정의한다.</p><ul><li><p><strong>Primitives</strong>: 6가지 타입</p><ul><li><a href="https://developer.mozilla.org/en-US/docs/Glossary/Boolean">Boolean</a></li><li><a href="https://developer.mozilla.org/en-US/docs/Glossary/null">null</a></li><li><a href="https://developer.mozilla.org/en-US/docs/Glossary/undefined">undefined</a></li><li><a href="https://developer.mozilla.org/en-US/docs/Glossary/Number">Number</a></li><li><a href="https://developer.mozilla.org/en-US/docs/Glossary/BigInt">BigInt</a></li><li><a href="https://developer.mozilla.org/en-US/docs/Glossary/Symbol">Symbol</a> <em>(ECMAScript 6에 신규 추가됨)</em></li></ul></li><li><p><strong>Reference</strong>: 1가지 타입, 값이 저장된 주소값을 할당</p><ul><li><a href="https://developer.mozilla.org/en-US/docs/Glossary/Object">Object</a></li><li>Object 타입의 데이터 종류: <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array">Array</a>, <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map">Map</a>, <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Set">Set</a>, <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/WeakMap">WeakMap</a>,  <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/WeakSet">WeakSet</a>, <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date">Date</a> 등</li><li>Object와 Function<ul><li>typeof <strong>Object</strong> =&gt; <code>object</code> 반환</li><li>typeof <strong>function</strong> =&gt; <code>function</code>  반환</li></ul></li></ul></li></ul><hr><h2 id="Primitive-Type-원시형-데이터"><a href="#Primitive-Type-원시형-데이터" class="headerlink" title="Primitive Type (원시형 데이터)"></a>Primitive Type (원시형 데이터)</h2><h4 id="Boolean"><a href="#Boolean" class="headerlink" title="Boolean"></a>Boolean</h4><p>논리적 데이터 유형으로, <code> true</code> 와 <code>false</code>  리터럴 값만 가질 수 있음.</p><h4 id="null"><a href="#null" class="headerlink" title="null"></a>null</h4><p>일반적으로 존재하지 않거나 유효하지 않은 object를 의미하며 의도적으로 비어있는 값을 나타내기 위해서도 사용할 수 있다. 그리고 Javascript에서는 대소문자를 구분하므로 Null 또는 NULL과는 다르다.</p><h4 id="undefined"><a href="#undefined" class="headerlink" title="undefined"></a>undefined</h4><p>변수 선언 후 값을 할당하지 않은 혹은 주어짖 않은 인수에 자동 할당된다. 그리고 동등 연산자(<code>==</code>)와 일치 연산자(<code>===</code>)로 비교할 때 그 결과값이 다르므로 주의해야 한다.</p><h4 id="Number"><a href="#Number" class="headerlink" title="Number"></a>Number</h4><p>정수, 부동 소수점, 복식 또는 대수와 같은 데이터 타입이 존재하는 다른 언어들과 다르게, Javascript 에서는 숫자 데이터 타입을 <code>64비트 부동소수점</code> 으로 표현한다. <strong>즉, 정수만을 표현하기 위한 특별한 자료형은 없다.</strong> 그리고 Number 타입에는 세 가지 유의미한 상징적 값들이 있는데 이는 <code>+/-Infinity</code> 와  <code>Nan</code> 이다. </p><p><code>Nan</code> 은 전역 스코프 변수로써 <em>숫자가 아님</em> 을 의미하며, <code>Nan</code>을 반환하는 다섯 가지 종료로는 아래와 같다.</p><ul><li>숫자로서 읽을 수 없음 (<code>parseInt(&quot;어쩌구&quot;)</code>, <code>Number(undefined)</code>)</li><li>결과가 허수인 수학 계산식 (<code>Math.sqrt(-1)</code>)</li><li>피연산자가 <code>NaN</code> (<code>7 ** NaN</code>)</li><li>정의할 수 없는 계산식 (<code>0 * Infinity</code>)</li><li>문자열을 포함하면서 덧셈이 아닌 계산식 (<code>&quot;가&quot; / 3</code>)</li></ul><h4 id="String"><a href="#String" class="headerlink" title="String"></a>String</h4><p>Javascript에서 문자열은 페이지 인코딩 방식과 상관없이 항상 <a href="https://en.wikipedia.org/wiki/UTF-16">UTF-16</a> 형식을 따르며  <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String"><code>String</code></a>  객체는 문자열 원시값을 둘러싼 wrapper 객체이다.</p><h4 id="Symbol"><a href="#Symbol" class="headerlink" title="Symbol"></a>Symbol</h4><p>ECMAScript 2015에서 추가된 <code>Symbol</code>은 인스턴스가 고유하고 불변의 값을 할당할때 사용하는 데이터 타입으로, <strong>Symbol</strong> 의 값은 “Symbol 값(value)” 로서 참조될 수 있다.</p><p>Javascript 런타임 환경에서 Symbol 값은 고유하고 불변의 값을 생산하기 위해  <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Symbol"><code>Symbol</code></a> 함수가 선언하여 동적으로 생성된다. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 동일한 description으로 선언된 두개의 symbol이 있다.</span></span><br><span class="line"><span class="keyword">let</span> Sym1 = <span class="built_in">Symbol</span>(<span class="string">&quot;Sym&quot;</span>)</span><br><span class="line"><span class="keyword">let</span> Sym2 = <span class="built_in">Symbol</span>(<span class="string">&quot;Sym&quot;</span>)</span><br><span class="line">  </span><br><span class="line"><span class="built_in">console</span>.log(Sym1 === Sym2) <span class="comment">// returns &quot;false&quot;</span></span><br><span class="line"><span class="comment">// 동일한 description으로 많은 symbol을 생성하더라도 서로 다르기 때문에</span></span><br><span class="line"><span class="comment">// Symbol은 고유한 성질을 보장한다.</span></span><br></pre></td></tr></table></figure><hr><h2 id="Reference-Type"><a href="#Reference-Type" class="headerlink" title="Reference Type"></a>Reference Type</h2><p><strong>Object</strong>에 대한 내용은 워낙 방대하므로 추후 포스팅으로 자세히 다뤄 보도록 하겠습니다.</p><hr><h2 id="참고"><a href="#참고" class="headerlink" title="참고"></a>참고</h2><ul><li><a href="https://ko.wikipedia.org/wiki/%EC%9E%90%EB%A3%8C%ED%98%95">자료형 - ko.wikipedia.org</a></li><li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures">원시 값 - developer.mozilla.org/en-US</a></li><li><a href="https://developer.mozilla.org/ko/docs/Web/JavaScript/Data_structures">자바스크립트의 자료형 - developer.mozilla.org/ko</a></li><li><a href="https://kkumalog.tistory.com/66">Pass By Value / Pass By Reference - kkumalog.tistory.com</a></li><li><a href="https://gmlwjd9405.github.io/2019/04/18/javascript-variable-and-type.html">자바스크립트의 변수, 연산자, 타입의 종료 - gmlwjd9405.github.io</a></li><li><a href="https://itmining.tistory.com/65">정적언어(타입)과 동적언어(타입) - itmining.tistory.com</a></li><li><a href="http://blog.naver.com/tkandrea92/80014134498">동적타입 vs 정적타입 - blog.naver.com/tkandrea92</a></li><li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures">Data and Structure types - developer.mozilla.org/en-US</a></li><li><a href="https://velog.io/@surim014/%EC%9B%B9%EC%9D%84-%EC%9B%80%EC%A7%81%EC%9D%B4%EB%8A%94-%EA%B7%BC%EC%9C%A1-JavaScript%EB%9E%80-%EB%AC%B4%EC%97%87%EC%9D%B8%EA%B0%80-part.2">JavaScript - 데이터 타입(Data Type)에 대해 알아보자 - velog.io/@surim014</a></li><li><a href="https://medium.com/nodesimplified/javascript-pass-by-value-and-pass-by-reference-in-javascript-fcf10305aa9c">[Javascript] Pass By Value And Pass By Reference In JavaScript - by Raghuraman Kesavan</a></li></ul>]]></content:encoded>
      
      
      <category domain="https://joontae-kim.github.io/categories/Programming/">Programming</category>
      
      <category domain="https://joontae-kim.github.io/categories/Programming/Javascript/">Javascript</category>
      
      
      <category domain="https://joontae-kim.github.io/tags/javascript/">javascript</category>
      
      <category domain="https://joontae-kim.github.io/tags/type/">type</category>
      
      <category domain="https://joontae-kim.github.io/tags/types/">types</category>
      
      
      <comments>https://joontae-kim.github.io/2020/10/09/javascript-types/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>javascript 작동원리</title>
      <link>https://joontae-kim.github.io/2020/10/09/javascript-operation/</link>
      <guid>https://joontae-kim.github.io/2020/10/09/javascript-operation/</guid>
      <pubDate>Thu, 08 Oct 2020 16:39:50 GMT</pubDate>
      
        
        
      <description>&lt;p&gt;&lt;img src=&quot;/images/javascript.png&quot; alt=&quot;Javascript&quot;&gt;&lt;/p&gt;
&lt;p&gt;Javascript는 Java, C, Python 등의 언어와 다르게 싱글 스레드 기반의 언어로써 한번에 단 하나의 작업만을 처리할 수 있다</description>
        
      
      
      
      <content:encoded><![CDATA[<p><img src="/images/javascript.png" alt="Javascript"></p><p>Javascript는 Java, C, Python 등의 언어와 다르게 싱글 스레드 기반의 언어로써 한번에 단 하나의 작업만을 처리할 수 있다. 즉, 비동기 처리 언어라는 것이다. 그러난 이는 Javascript 엔진에 국한된 얘기이다. 응? 무슨 소리인가? Javascript는 비동기 언어지만 이건 Javascript 엔진에 국한된 얘기라니? 실제로 Javascript를 구동시키기 위한 런타임 환경에는 Javascript Engine과 Web APIs, Envent Loop, Callback Queue가 존재하며 전체 런타임 환경에서 보면 동기 작동의 상황이 펼쳐지기도 한다.</p><h2 id="Javascript-Engine"><a href="#Javascript-Engine" class="headerlink" title="Javascript Engine"></a>Javascript Engine</h2><p>가장 대표적인 Javascript Engine으로 구글에서 개발한 V8은 Chrome과 Node.js에서 사용한다. 아래의 사진은 V8 엔진의 구조도를 간단히 나타내고 있다.</p><p><img src="https://joshua1988.github.io/images/posts/web/translation/how-js-works/js-engine-structure.png" alt="javascript engine structure"></p><p>위 사진과 같이 V8 엔진은 Memory Heap과 Call Stack으로 구성되어 있으며 정의는 아래와 같다.</p><ul><li><strong>Memory Heap</strong> : 메모리 할당이 일어나는 곳으로서 구조화되지 않은 넓은 메모리 영역을 지칭</li><li><strong>Call Stack</strong> : 코드 실행에 따라 호출 스택이 쌓이는 곳 or 하나의 작업을 완료하기 위해 제공되는 환경<ul><li>호출 스택의 각 단계를 *스택 프레임(Stack Frame)*이라 한다.</li></ul></li></ul><p>서두에서 언급한 <em>“Javascript는 … 싱글 스레드 기반의 언어로써 …”</em> 에서의 싱글 스레드란 위에서 언급한 <strong>Call Stack</strong>을 의미한 것이었다. 따라서 한 번에 한 작업만 처리!</p><p>아래의 코드를 통해 <strong>Call Stack</strong>이 어떻게 작동하는지 보자.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">multiply</span>(<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x * y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">printSquare</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> s = multiply(x, x);</span><br><span class="line">    <span class="built_in">console</span>.log(s);</span><br><span class="line">&#125;</span><br><span class="line">printSquare(<span class="number">5</span>);</span><br></pre></td></tr></table></figure><p>위 코드을 보면 <code>printSquare(5)</code> 가 호출되고 내부 실행 컨택스트인<code>multiply(x,x)</code>와 <code>console.log</code>가 차례대로 호출 및 실행 종료된 후<code>printSquare(5)</code> 가 종료되며 Call Stack이 빈다. 이는 Javascript의 <strong>Run to Completion</strong>이라고 하는데 하나의 함수가 실행되면 이 함수의 실행이 끝날때 까지 다른 어떤 작업도 중간에 끼어들지 못한다는 의미이다.</p><p><img src="https://joshua1988.github.io/images/posts/web/translation/how-js-works/call-stack.png" alt="Call Stack"></p><p>또한, 너무 많은 callback function이나 loop 문을 작동시키면 과도한 <em>Task</em>가 호출 스택에 쌓이게 되어 최대 허용치를 넘기게 되는데 이때 출력되는 에러가 바로 <code>Uncaught RangeError: Macimum call stack size exceeded</code> 이다. 보통 만 개 정도의 Task를 Call Stack에 쌓을 수 (같은 의미로 함수를 만 번 정도 호출할 수 있다는 의미) 있다는 의미로 위 에러가 발생했을시 <em>function call</em> 을 디버깅해봐야 한다.</p><p>그렇다면 서두에서 언급한 <strong>비동기적 상황</strong> 이란 무엇인가? 예를 들면 <code>setTimeout</code>이나 <code>XMLHttpRequest</code> 와 같은 비동기 호출 event 이다. 이러한 비동기 호출은 JS Engine이 아닌 Web API 영역에서 담당하는데 먼저 브라우저에서 Javascript가 작동하는 전체 환경을 보자.</p><p><img src="https://cloud.githubusercontent.com/assets/12269489/16215491/b1493856-379d-11e6-9c16-a9a4cf841567.png" alt="brower-javascript-environment"></p><p> JS Engine과 Web APIs 이외에 Event Loop와 Task Queue가 있는데 이 두 요소가 Web APIs에서 제공하는 함수는 Call Stack에서 비동기로 처리하지만 비동기 작업 후의 <strong>callback function</strong>은 Task Queue로 담기게 된다. 자세한 설명은 아래에서 이어하겠습니다.</p><p>브라우저 환경에서 Javascirpt를 구동시키기 위해서는 JS Engine 뿐만 아니라 Web APIs, Task Queue가 있으며 실제 자바스크립트가 구동되는 환경(브라우저, Node.js등)에서는 주로 여러 개의 스레드가 사용된다. 이러한 구동 환경이 단일 호출 스택을 사용하는 자바 스크립트 엔진과 상호 연동하기 위해 사용하는 장치가 바로 <strong>‘이벤트 루프’</strong> 이다.</p><p><strong>Event Loop</strong>와 <strong>Task Queue</strong>를 설명하기 위해 <strong>Ajax</strong> 통신을 생각해보자. 서버로부터 데이터를 요청하기 위해 Request를 요청하며 Response를 받기 위한 callback function이 있다고 가정해보자. 그렇다면 위 브라우저 환경에 따라 설명해보면 <em>Ajax get</em> 요청은 Call Stack에서 비동기로 처리한 후 Web APIs가 동작하는 별도의 환경에서 실행되어 완료된 후에는 Response를 받기 위한 callback function을 <strong>Task Queue</strong>에 push되어 Call Stack에서 Task가 모두 종료되어 빈 상태가 될까지 기다린 후 <strong>Event Loop</strong>에 의해 다시 <strong>Call Stack</strong>에 push되어 처리됩니다. 이러한 구동방식으로 자바스크립트는 <strong>이벤트 기반 동시성(Concurrency) 모델</strong>을 제공합니다. 이벤트 루프의 동작을 시각적으로 보시기 원하신다면 <a href="https://l.facebook.com/l.php?u=http://latentflip.com/loupe/&h=ATMe077bzkoPDVWiI6fdq3MdzS4HD2BLKkGiYhj1u5aHw1igF4lkW-HIkGepJr8-6lVpGb2x_Uv1X2W9Q4JXv6kSnMfN-vOa9YqQ-GcZ9stoJciMpe16CKusS6p5TrYRp-cUKLdbTRRRHw">http://latentflip.com/loupe/</a> 를 보시기 바랍니다.</p><p>정리하자면,</p><ul><li><strong>Task Queue</strong>: 말 그대로 콜백 함수들이 대기하는 큐(FIFO) 형태의 배열<ul><li>모든 비동기 API들은 작업이 완료되면 콜백 함수를 태스크 큐에 추가한다.</li></ul></li><li><strong>Event Loop</strong>: (함수)호출 스택이 비워질 때마다 큐에서 콜백 함수를 꺼내와서 실행하는 역할을 함<ul><li>‘현재 실행중인 태스크가 없을 때’(주로 호출 스택이 비워졌을 때) 태스크 큐의 첫 번째 태스크를 꺼내와 실행한다.</li><li>언제나 그렇듯이, 함수를 호출하면 그 함수의 사용을 위한 새로운 스택 프레임이 생선된다.</li></ul></li></ul><p>위와 같은 구조적 동작 덕분에 JS Engine은 싱글 쓰레드 기반의 비동기 작업이 보장받지만 반대로 <strong>싱글 쓰레드 기반의 Javascript 작동 원리의 단점</strong> 이 발생하기도 합니다. 바로 <strong>Run-to-completion</strong> 과 <strong>Event Loop</strong> 때문이다. 만약 콜스택 내 함수의 수행시간이 길어져 Task Queue의 콜백 함수들이 수행되지도 못하거나 과도한 콜백 함수들이 연속적으로 수행될 경우 브라우저에서는 아무것도 할 수 없습니다. 이게 바로 <strong><em>블록킹</em></strong> 이 된다고 하는 것입니다. 이럴 경우 브라우저는 장시간 응답이 없을 수 있으며 에러를 일으켜 사용자에게 페이지를 닫을지 물어보기도 합니다. 이와 상황에서의 해결책이 바로 <strong>비동기 콜백(Asynchronous callbacks)</strong> 입니다.</p><h2 id="참조"><a href="#참조" class="headerlink" title="참조"></a>참조</h2><ul><li><a href="https://developer.mozilla.org/ko/docs/Web/JavaScript/Guide/%EC%86%8C%EA%B0%9C#What_is_JavaScript.3F">mozila MDN web docs - Javascript  Introduction</a></li><li><a href="http://webclub.tistory.com/155">객체지향 프로그래밍이란</a></li><li><a href="http://mohwa.github.io/blog/javascript/2015/10/16/prototype/">객체 지향 언어의 두가지 줄기</a></li><li><a href="https://ko.wikipedia.org/wiki/%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8_%EC%97%94%EC%A7%84">자바스크립트 엔진</a></li><li><a href="https://meetup.toast.com/posts/89">자바스크립트와 이벤트 루프</a></li><li><a href="https://joshua1988.github.io/web-development/translation/javascript/how-js-works-inside-engine/">자바스크립트의 동작원리: 엔진, 런타임, 호출 스택</a></li><li><a href="https://engineering.huiseoul.com/%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8%EB%8A%94-%EC%96%B4%EB%96%BB%EA%B2%8C-%EC%9E%91%EB%8F%99%ED%95%98%EB%8A%94%EA%B0%80-%EC%97%94%EC%A7%84-%EB%9F%B0%ED%83%80%EC%9E%84-%EC%BD%9C%EC%8A%A4%ED%83%9D-%EA%B0%9C%EA%B4%80-ea47917c8442">자바스크립트는 어떻게 작동하는가: 엔진, 런타임, 콜스택 개관</a></li><li><a href="https://engineering.huiseoul.com/%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8%EB%8A%94-%EC%96%B4%EB%96%BB%EA%B2%8C-%EC%9E%91%EB%8F%99%ED%95%98%EB%8A%94%EA%B0%80-v8-%EC%97%94%EC%A7%84%EC%9D%98-%EB%82%B4%EB%B6%80-%EC%B5%9C%EC%A0%81%ED%99%94%EB%90%9C-%EC%BD%94%EB%93%9C%EB%A5%BC-%EC%9E%91%EC%84%B1%EC%9D%84-%EC%9C%84%ED%95%9C-%EB%8B%A4%EC%84%AF-%EA%B0%80%EC%A7%80-%ED%8C%81-6c6f9832c1d9">자바스크립트는 어떻게 작동하는가: V8 엔진의 내부 + 최적화된 코드를 작성을 위한 다섯 가지 팁</a></li><li><a href="https://developer.mozilla.org/ko/docs/Web/JavaScript/EventLoop">Concurrency model and Event Loop</a></li><li><a href="http://tbang.tistory.com/165">웹에서 자바스크립트 구동 환경</a></li><li><a href="http://ppig2009.tistory.com/6">자바스크립트 비동기가 되는 원리</a></li><li><a href="https://www.zerocho.com/category/JavaScript/post/597f34bbb428530018e8e6e2">호출 스택과 이벤트 루프</a></li><li><a href="http://hojak99.tistory.com/439">Javascript 동작 원리</a></li><li><a href="http://eine.tistory.com/40">자바스크립트 동시성 모델과 이벤트 루프</a></li><li><a href="https://dongwoo.blog/2015/10/12/%EB%B2%88%EC%97%AD-%EB%B0%94%EB%B3%B4%EB%93%A4%EC%9D%84-%EC%9C%84%ED%95%9C-%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8-%EC%97%94%EC%A7%84-%EA%B0%80%EC%9D%B4%EB%93%9C/">[번역] 바보들을 위한 자바스크립트 엔진 가이드</a></li></ul>]]></content:encoded>
      
      
      <category domain="https://joontae-kim.github.io/categories/Programming/">Programming</category>
      
      <category domain="https://joontae-kim.github.io/categories/Programming/Javascript/">Javascript</category>
      
      
      <category domain="https://joontae-kim.github.io/tags/javascript/">javascript</category>
      
      <category domain="https://joontae-kim.github.io/tags/javascript-engine/">javascript engine</category>
      
      
      <comments>https://joontae-kim.github.io/2020/10/09/javascript-operation/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>ECMAScript 6 (ECMAScript 2015)</title>
      <link>https://joontae-kim.github.io/2020/10/06/ES6/</link>
      <guid>https://joontae-kim.github.io/2020/10/06/ES6/</guid>
      <pubDate>Tue, 06 Oct 2020 10:41:18 GMT</pubDate>
      
        
        
      <description>&lt;p&gt;&lt;img src=&quot;/images/ECMAScript_6.jpeg&quot; alt=&quot;ECMAScript 6&quot;&gt;&lt;/p&gt;
&lt;p&gt;이전 포스트 &lt;a href=&quot;/2020/10/06/Babel/&quot;&gt;ECMAScript와 Babel&lt;/a&gt; 에서 ECMAScript 2</description>
        
      
      
      
      <content:encoded><![CDATA[<p><img src="/images/ECMAScript_6.jpeg" alt="ECMAScript 6"></p><p>이전 포스트 <a href="/2020/10/06/Babel/">ECMAScript와 Babel</a> 에서 ECMAScript 2015+ 의 Javascript 코드를 런타임 환경에 적용하기 위해서는 그에 맞는 버전으로 호환시켜줘야 하며 이를 위한 툴체인으로 <strong>Babel</strong> 이라는 것이 있다는 것까지 정리해보았습니다.</p><p>이번 포스트에서는 그렇다면 ECMAScript 2015에 어떤 syntax가 추가되었는지 까지 알아보는 시간을 가져보려합니다. 이번 주제를 위해 다양한 포스팅을 읽었고 그 중 <em>principal</em> 한 사이트를 번역하는 것이 도움이 될 것 같아 <a href="https://github.com/lukehoban">lukehoban</a> 의 <a href="https://github.com/lukehoban/es6features">es6features</a> 를 번역 했습니다.</p><h1 id="ECMAScript-6-git-io-es6features"><a href="#ECMAScript-6-git-io-es6features" class="headerlink" title="ECMAScript 6 git.io/es6features"></a>ECMAScript 6 <a href="http://git.io/es6features">git.io/es6features</a></h1><h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p>ECMAScript 2015 또는 ECMAScript 6는 ECMAScript 표준의 가장 최신 버전입니다. ES6는 2009년 ES5가 표준화된 이후 중대한 업데이트이자 첫번째 업데이트입니다. 주요 Javascript 엔진에서 이러한 기능의 구현은 <a href="http://kangax.github.io/compat-table/es6/#chrome84">현재 진행 중</a>입니다. </p><p>ECMAScript 6 언어의 전체 사양은 <a href="http://www.ecma-international.org/ecma-262/6.0/">ES6 표준</a>을 참조하세요.</p><p>ES6는 다음의 새로운 기능을 포함합니다.</p><ul><li><a href="https://github.com/lukehoban/es6features#arrows">arrows</a></li><li><a href="https://github.com/lukehoban/es6features#classes">classes</a></li><li><a href="https://github.com/lukehoban/es6features#enhanced-object-literals">enhanced object literals</a></li><li><a href="https://github.com/lukehoban/es6features#template-strings">template strings</a></li><li><a href="https://github.com/lukehoban/es6features#destructuring">destructuring</a></li><li><a href="https://github.com/lukehoban/es6features#default--rest--spread">default + rest + spread</a></li><li><a href="https://github.com/lukehoban/es6features#let--const">let + const</a></li><li><a href="https://github.com/lukehoban/es6features#iterators--forof">iterators + for..of</a></li><li><a href="https://github.com/lukehoban/es6features#generators">generators</a></li><li><a href="https://github.com/lukehoban/es6features#unicode">unicode</a></li><li><a href="https://github.com/lukehoban/es6features#modules">modules</a></li><li><a href="https://github.com/lukehoban/es6features#module-loaders">module loaders</a></li><li><a href="https://github.com/lukehoban/es6features#map--set--weakmap--weakset">map + set + weakmap + weakset</a></li><li><a href="https://github.com/lukehoban/es6features#proxies">proxies</a></li><li><a href="https://github.com/lukehoban/es6features#symbols">symbols</a></li><li><a href="https://github.com/lukehoban/es6features#subclassable-built-ins">subclassable built-ins</a></li><li><a href="https://github.com/lukehoban/es6features#promises">promises</a></li><li><a href="https://github.com/lukehoban/es6features#math--number--string--array--object-apis">math + number + string + array + object APIs</a></li><li><a href="https://github.com/lukehoban/es6features#binary-and-octal-literals">binary and octal literals</a></li><li><a href="https://github.com/lukehoban/es6features#reflect-api">reflect api</a></li><li><a href="https://github.com/lukehoban/es6features#tail-calls">tail calls</a></li></ul><h2 id="ECMAScript-6-기능"><a href="#ECMAScript-6-기능" class="headerlink" title="ECMAScript 6 기능"></a>ECMAScript 6 기능</h2><h3 id="Arrows"><a href="#Arrows" class="headerlink" title="Arrows"></a>Arrows</h3><p>화살표는 <code>=&gt;</code> 문법을 사용하는 함수 단축어이며 문법적으로 C#, Java 8 and CoffeeScript에 있는 관련된 기능과 유사하다. 그들은 함수 구문 블록 본문 뿐만 아니라 함수식의 값을 반환하는 구문 본문 둘다 지원한다. 함수와 달리 화살표는 주변 코드와 동일한 ‘lexical <code>this</code>‘를 공유한다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Expression bodies</span></span><br><span class="line"><span class="keyword">var</span> odds = evens.map(<span class="function"><span class="params">v</span> =&gt;</span> v + <span class="number">1</span>); <span class="comment">// [1, 3, 5, 7, 9]</span></span><br><span class="line"><span class="keyword">var</span> nums = evens.map(<span class="function">(<span class="params">v, i</span>) =&gt;</span> v + i); <span class="comment">// [0, 3, 6, 9, 12]</span></span><br><span class="line"><span class="keyword">var</span> pairs = evens.map(<span class="function"><span class="params">v</span> =&gt;</span> (&#123;<span class="attr">even</span>: v, <span class="attr">odd</span>: v + <span class="number">1</span>&#125;));</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">pairs&#x27;s value</span></span><br><span class="line"><span class="comment">[</span></span><br><span class="line"><span class="comment">  &#123;even: 0, odd: 1&#125;</span></span><br><span class="line"><span class="comment">  &#123;even: 2, odd: 3&#125;</span></span><br><span class="line"><span class="comment">  &#123;even: 4, odd: 5&#125;</span></span><br><span class="line"><span class="comment">  &#123;even: 6, odd: 7&#125;</span></span><br><span class="line"><span class="comment">  &#123;even: 8, odd: 9&#125;</span></span><br><span class="line"><span class="comment">]</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Statement bodies</span></span><br><span class="line">nums.forEach(<span class="function"><span class="params">v</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (v % <span class="number">5</span> === <span class="number">0</span>)</span><br><span class="line">    fives.push(v);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// [0, 0, 0]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Lexical this</span></span><br><span class="line"><span class="keyword">var</span> bob = &#123;</span><br><span class="line">  _name: <span class="string">&quot;Bob&quot;</span>,</span><br><span class="line">  _friends: [],</span><br><span class="line">  printFriends() &#123;</span><br><span class="line">    <span class="built_in">this</span>._friends.forEach(<span class="function"><span class="params">f</span> =&gt;</span></span><br><span class="line">      <span class="built_in">console</span>.log(<span class="built_in">this</span>._name + <span class="string">&quot; knows &quot;</span> + f));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// bob._friends.push(&#x27;karl&#x27;, &#x27;Tom&#x27;)</span></span><br><span class="line"><span class="comment">// bob.printFriends()</span></span><br><span class="line"><span class="comment">// &gt; Bob knows karl</span></span><br><span class="line"><span class="comment">// &gt; Bob knows Tom</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>자세한 정보: <a href="https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Functions/Arrow_functions">MDN Arrow Functions</a></p><h3 id="클래스-Classes"><a href="#클래스-Classes" class="headerlink" title="클래스 (Classes)"></a>클래스 (Classes)</h3><p>ES6 클래스는 prototype 기반의 OO 패턴을 넘어 직관적이다. 단일의 편리한 선언적 폼을 갖는다는 것은 클래스 패턴을 더 쉽게 이용할 수 있도록 하며 상호운용성을 독려한다. 클래스는 prototype 기반의 상속(inheritance), super call, instance and static methods and constructors을 지원한다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SkinnedMesh</span> <span class="keyword">extends</span> <span class="title">THREE</span>.<span class="title">Mesh</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(geometry, materials) &#123;</span><br><span class="line">    <span class="built_in">super</span>(geometry, materials);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">this</span>.idMatrix = SkinnedMesh.defaultMatrix();</span><br><span class="line">    <span class="built_in">this</span>.bones = [];</span><br><span class="line">    <span class="built_in">this</span>.boneMatrices = [];</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">  &#125;</span><br><span class="line">  update(camera) &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="built_in">super</span>.update();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">get</span> <span class="title">boneCount</span>() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.bones.length;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">set</span> <span class="title">matrixType</span>(<span class="params">matrixType</span>) &#123;</span><br><span class="line">    <span class="built_in">this</span>.idMatrix = SkinnedMesh[matrixType]();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">static</span> defaultMatrix() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> THREE.Matrix4();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>더 자세한 정보: <a href="https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Classes">MDN Classes</a></p><h3 id="강화된-객체-리터럴-Enhanced-Object-Literals"><a href="#강화된-객체-리터럴-Enhanced-Object-Literals" class="headerlink" title="강화된 객체 리터럴 (Enhanced Object Literals)"></a>강화된 객체 리터럴 (Enhanced Object Literals)</h3><p>객체 리터럴은 생성 시 prototype 설정, <code>foo: foo</code> 할당에 대한 약축, 메서드 정의, super calls 생성 그리고 함수식으로 속성 이름을 계산하는 것을 지원하도록 확장됩니다. 또한, 이러한 것들은 객체 리터럴과 클래스 선언을 더 가깝게 만들고, 객체 지향 디자인에서 동일한 편의성을 활용할 수 있게 합니다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    <span class="comment">// __proto__</span></span><br><span class="line">    __proto__: theProtoObj,</span><br><span class="line">    <span class="comment">// Shorthand for ‘handler: handler’</span></span><br><span class="line">    handler,</span><br><span class="line">    <span class="comment">// Methods</span></span><br><span class="line">    toString() &#123;</span><br><span class="line">     <span class="comment">// Super calls</span></span><br><span class="line">     <span class="keyword">return</span> <span class="string">&quot;d &quot;</span> + <span class="built_in">super</span>.toString();</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// Computed (dynamic) property names</span></span><br><span class="line">    [ <span class="string">&#x27;prop_&#x27;</span> + (<span class="function">() =&gt;</span> <span class="number">42</span>)() ]: <span class="number">42</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>자세한 정보: <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Grammar_and_types#Object_literals">MDN Grammar and types: Object literals</a></p><h3 id="템플릿-문자열-Template-Strings"><a href="#템플릿-문자열-Template-Strings" class="headerlink" title="템플릿 문자열(Template Strings)"></a>템플릿 문자열(Template Strings)</h3><p>템플릿 문자열은 더 직관적으로 문자열을 구성하도록 하며 Perl, Python 그리고 이외의 언어에서 문자열 보간 기능(string interpolation features)과 유사합니다. 선택적으로, 문자 구성을 커스터마이징하거나 인젝션(Injection) 공격을 피하기 위해 또는 문자 컨텐츠에서 높은 수준의 데이터 구조를 구성하기 위해 태그를 추가할 수 있습니다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Basic literal string creation</span></span><br><span class="line"><span class="string">`In JavaScript &#x27;\n&#x27; is a line-feed.`</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Multiline strings</span></span><br><span class="line"><span class="string">`In JavaScript this is</span></span><br><span class="line"><span class="string"> not legal.`</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// String interpolation</span></span><br><span class="line"><span class="keyword">var</span> name = <span class="string">&quot;Bob&quot;</span>, time = <span class="string">&quot;today&quot;</span>;</span><br><span class="line"><span class="string">`Hello <span class="subst">$&#123;name&#125;</span>, how are you <span class="subst">$&#123;time&#125;</span>?`</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Construct an HTTP request prefix is used to interpret the replacements and construction</span></span><br><span class="line">POST<span class="string">`http://foo.org/bar?a=<span class="subst">$&#123;a&#125;</span>&amp;b=<span class="subst">$&#123;b&#125;</span></span></span><br><span class="line"><span class="string">     Content-Type: application/json</span></span><br><span class="line"><span class="string">     X-Credentials: <span class="subst">$&#123;credentials&#125;</span></span></span><br><span class="line"><span class="string">     &#123; &quot;foo&quot;: <span class="subst">$&#123;foo&#125;</span>,</span></span><br><span class="line"><span class="string">       &quot;bar&quot;: <span class="subst">$&#123;bar&#125;</span>&#125;`</span>(myOnReadyStateChangeHandler);</span><br></pre></td></tr></table></figure><p>자세한 정보: <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/template_strings">MDN Template Strings</a></p><h3 id="Destructuring-비구조화"><a href="#Destructuring-비구조화" class="headerlink" title="Destructuring (비구조화)"></a>Destructuring (비구조화)</h3><p>배열이나 객체의 매칭을 지원하는 비구조화는 패턴 매칭을 통해 바인딩할 수 있도록 하며, 표준 객체 조회 <code>foo[&quot;bar&quot;]</code> 와 유사한 비구조화는 찾을 수 없는 경우, <code>undefined</code> 값을 생성하는  fail-soft 입니다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// list matching</span></span><br><span class="line"><span class="keyword">var</span> [a, , b] = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line"><span class="comment">// a = 1</span></span><br><span class="line"><span class="comment">// b = 3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Add Custom function </span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getASTNode</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;<span class="attr">op</span>: <span class="number">1</span>, <span class="attr">lhs</span>: &#123;<span class="attr">op</span>: <span class="number">2</span>&#125;, <span class="attr">rhs</span>: <span class="number">3</span>&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// object matching</span></span><br><span class="line"><span class="keyword">var</span> &#123; <span class="attr">op</span>: a, <span class="attr">lhs</span>: &#123; <span class="attr">op</span>: b &#125;, <span class="attr">rhs</span>: c &#125;</span><br><span class="line">       = getASTNode()</span><br><span class="line"></span><br><span class="line"><span class="comment">// object matching shorthand</span></span><br><span class="line"><span class="comment">// binds `op`, `lhs` and `rhs` in scope</span></span><br><span class="line"><span class="keyword">var</span> &#123;op, lhs, rhs&#125; = getASTNode()</span><br><span class="line"></span><br><span class="line"><span class="comment">// Can be used in parameter position</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">g</span>(<span class="params">&#123;name: x&#125;</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(x);</span><br><span class="line">&#125;</span><br><span class="line">g(&#123;<span class="attr">name</span>: <span class="number">5</span>&#125;)  <span class="comment">// 5</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Fail-soft destructuring</span></span><br><span class="line"><span class="keyword">var</span> [a] = [];</span><br><span class="line">a === <span class="literal">undefined</span>; <span class="comment">// ture</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Fail-soft destructuring with defaults</span></span><br><span class="line"><span class="keyword">var</span> [a = <span class="number">1</span>] = [];</span><br><span class="line">a === <span class="number">1</span>; <span class="comment">// ture</span></span><br></pre></td></tr></table></figure><p>더 자세한 정보: <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment">MDN Destructuring assignment</a></p><h3 id="Default-파라미터-Rest-파라미터-Spread-연산자"><a href="#Default-파라미터-Rest-파라미터-Spread-연산자" class="headerlink" title="Default 파라미터 + Rest 파라미터 + Spread 연산자"></a>Default 파라미터 + Rest 파라미터 + Spread 연산자</h3><p>Default 파라미터란 현재 실행중인 함수가 평가하는 기본 파라미터 값이며 함수 호출에서 배열을 연속적 인수(argurement)로 변환해고, 후행(trailing) 파라미터를 배열에 바인딩합니다. Rest 파라미터는 <code>인수(argurements)</code>에 대한 필요성을 대체하고, 일반적인 경우들을 보다 직접적으로 다룹니다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Default Parameter</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">x, y=<span class="number">12</span></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// y is 12 if not passed (or passed as undefined)</span></span><br><span class="line">  <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br><span class="line">f(<span class="number">3</span>) == <span class="number">15</span></span><br><span class="line"><span class="comment">// true</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Rest Parameter</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">x, ...y</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// y is an Array</span></span><br><span class="line">  <span class="comment">// y is [&quot;hello&quot;, true]</span></span><br><span class="line">  <span class="keyword">return</span> x * y.length;</span><br><span class="line">&#125;</span><br><span class="line">f(<span class="number">3</span>, <span class="string">&quot;hello&quot;</span>, <span class="literal">true</span>) == <span class="number">6</span></span><br><span class="line"><span class="comment">// true</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Spread Operator</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">x, y, z</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x + y + z;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Pass each elem of array as argument</span></span><br><span class="line">f(...[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]) == <span class="number">6</span></span><br><span class="line"><span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>자세한 정보: <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Default_parameters">Default parameters</a>, <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/rest_parameters">Rest parameters</a>, <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Spread_operator">Spread Operator</a></p><h3 id="Let-Const"><a href="#Let-Const" class="headerlink" title="Let + Const"></a>Let + Const</h3><p>블럭 범위의 바인딩을 구성하며 <code>let</code> 은  새로운 <code>var</code> ,  <code>const</code> 는 상수입니다. 정적 제한은 할당 전에 사용을 방지합니다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">let</span> x;</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">// okay, block scoped name</span></span><br><span class="line">      <span class="keyword">const</span> x = <span class="string">&quot;sneaky&quot;</span>;</span><br><span class="line">      <span class="comment">// error, const</span></span><br><span class="line">      x = <span class="string">&quot;foo&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// error, already declared in block</span></span><br><span class="line">    <span class="keyword">let</span> x = <span class="string">&quot;inner&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>자세한 정보: <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/let">let statement</a>, <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/const">const statement</a></p><h3 id="Iterators-For-Of"><a href="#Iterators-For-Of" class="headerlink" title="Iterators + For..Of"></a>Iterators + For..Of</h3><p><code>Iterator objects</code>는 CLR IEnumerable 또는 Java Iterable과 유사한 커스텀 반복문(iteration)을 가능하게 합니다. <code>for..in</code> 을  <code>for..of</code> 를 사용한 사용자가 정의한 반복기 기반의 반복문으로 일반화합니다.  배열을 구현할 필요가 없으며 LINQ와 같은 지연(lazy) 디자인 패턴이 사용 가능하다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> fibonacci = &#123;</span><br><span class="line">  [<span class="built_in">Symbol</span>.iterator]() &#123;</span><br><span class="line">    <span class="keyword">let</span> pre = <span class="number">0</span>, cur = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      next() &#123;</span><br><span class="line">        [pre, cur] = [cur, pre + cur];</span><br><span class="line">        <span class="keyword">return</span> &#123; <span class="attr">done</span>: <span class="literal">false</span>, <span class="attr">value</span>: cur &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> n <span class="keyword">of</span> fibonacci) &#123;</span><br><span class="line">  <span class="comment">// truncate the sequence at 1000</span></span><br><span class="line">  <span class="keyword">if</span> (n &gt; <span class="number">1000</span>)</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>반복문은 이와 같은 duck 타입 인터페이스에 기초합니다. (오직 설명을 위해 <a href="http://typescriptlang.org/">TypeScript</a>을 사용합니다.)</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">interface IteratorResult &#123;</span><br><span class="line">  done: boolean;</span><br><span class="line">  value: any;</span><br><span class="line">&#125;</span><br><span class="line">interface Iterator &#123;</span><br><span class="line">  next(): IteratorResult;</span><br><span class="line">&#125;</span><br><span class="line">interface Iterable &#123;</span><br><span class="line">  [<span class="built_in">Symbol</span>.iterator](): Iterator</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>자세한 정보: <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/for...of">MDN for…of</a></p><h3 id="Generators"><a href="#Generators" class="headerlink" title="Generators"></a>Generators</h3><p>Generator는  <code>function*</code> and <code>yield</code> 를 사용해 반복기 작성을 단순화 하고, 함수는 Generator 인스턴스를 반환하는 <code>function *</code>로써 선언됩니다.. Generator는 추가적인 <code>next</code> 와 <code>throw</code>를 포함하는 반복기의 서브타입(subtype)이며, Generator 안에서 다시 돌아가기 위한 값이 될 수 있다.  그러나 <code>yield</code> 는 값을 반환하기 위한 또는 던지기(throw) 하기 위한 수식 양식(form) 입니다.</p><p>주의: 또한 <code>async</code> 프로그래밍과 같이 <code>await</code> 도 사용 가능합니다. ES7의 <code>await </code> 제안을 봅시다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> fibonacci = &#123;</span><br><span class="line">  [<span class="built_in">Symbol</span>.iterator]: <span class="function"><span class="keyword">function</span>*(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> pre = <span class="number">0</span>, cur = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">      <span class="keyword">var</span> temp = pre;</span><br><span class="line">      pre = cur;</span><br><span class="line">      cur += temp;</span><br><span class="line">      <span class="keyword">yield</span> cur;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> n <span class="keyword">of</span> fibonacci) &#123;</span><br><span class="line">  <span class="comment">// truncate the sequence at 1000</span></span><br><span class="line">  <span class="keyword">if</span> (n &gt; <span class="number">1000</span>)</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Generator 인터페이스는 (오직 설명을 위한 <a href="http://typescriptlang.org/">TypeScript</a> type syntax를 사용했다):</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">interface Generator <span class="keyword">extends</span> Iterator &#123;</span><br><span class="line">    next(value?: any): IteratorResult;</span><br><span class="line">    <span class="keyword">throw</span>(exception: any);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>자세한 정보: <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols">MDN Iteration protocols</a></p><h3 id="유니코드-Unicode"><a href="#유니코드-Unicode" class="headerlink" title="유니코드(Unicode)"></a>유니코드(Unicode)</h3><p>문자열에서 새로운 유니코드 리터럴 폼과 코드 포인트를 다루기 위한 새로운 RegExp <code>u</code>  모드 뿐만 아니라 21bit 코드 포인트 레벨에서 문자열을 처리하기 위한 새로운 API 를 포함하는 모든 유니코드를 지원하기 위한 논-블로킹 추가입니다. 이러한 추가는 Javascipt에서 세계적인 어플리케이션 구축을 지원합니다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// same as ES5.1</span></span><br><span class="line"><span class="string">&quot;𠮷&quot;</span>.length == <span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// new RegExp behaviour, opt-in ‘u’</span></span><br><span class="line"><span class="string">&quot;𠮷&quot;</span>.match(<span class="regexp">/./u</span>)[<span class="number">0</span>].length == <span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// new form</span></span><br><span class="line"><span class="string">&quot;\u&#123;20BB7&#125;&quot;</span>==<span class="string">&quot;𠮷&quot;</span>==<span class="string">&quot;\uD842\uDFB7&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// new String ops</span></span><br><span class="line"><span class="string">&quot;𠮷&quot;</span>.codePointAt(<span class="number">0</span>) == <span class="number">0x20BB7</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// for-of iterates code points</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> c <span class="keyword">of</span> <span class="string">&quot;𠮷&quot;</span>) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>자세한 정보: <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RegExp/unicode">MDN RegExp.prototype.unicode</a></p><h3 id="Modules"><a href="#Modules" class="headerlink" title="Modules"></a>Modules</h3><p>컴포넌트 정의를 위한 모듈을 위한 언어 수준에서 지원하며 인기있는 Javascript 모듈 로더(AMD, CommonJS)가 패턴을 코드화합니다. 런타임 실행은 호스트가 정의한 기본 로더에 의해 정의되고, 암시적 비동기 모델입니다. - 요청된 모듈들이 처리되고 사용가능해질 때까지 어떠한 코드도 실행되지 않는다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// lib/math.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">var</span> pi = <span class="number">3.141593</span>;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// app.js</span></span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> math <span class="keyword">from</span> <span class="string">&quot;lib/math&quot;</span>;</span><br><span class="line">alert(<span class="string">&quot;2π = &quot;</span> + math.sum(math.pi, math.pi));</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// otherApp.js</span></span><br><span class="line"><span class="keyword">import</span> &#123;sum, pi&#125; <span class="keyword">from</span> <span class="string">&quot;lib/math&quot;</span>;</span><br><span class="line">alert(<span class="string">&quot;2π = &quot;</span> + sum(pi, pi));</span><br></pre></td></tr></table></figure><p>몇 가지 추가적인 기능으로는 <code>export default</code> 과 <code>export *</code>이 있다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// lib/mathplusplus.js</span></span><br><span class="line"><span class="keyword">export</span> * <span class="keyword">from</span> <span class="string">&quot;lib/math&quot;</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">var</span> e = <span class="number">2.71828182846</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Math</span>.log(x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// app.js</span></span><br><span class="line"><span class="keyword">import</span> ln, &#123;pi, e&#125; <span class="keyword">from</span> <span class="string">&quot;lib/mathplusplus&quot;</span>;</span><br><span class="line">alert(<span class="string">&quot;2π = &quot;</span> + ln(e)*pi*<span class="number">2</span>);</span><br></pre></td></tr></table></figure><p>자세한 정보: <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/import">import statement</a>, <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/export">export statement</a></p><h3 id="Module-Loaders"><a href="#Module-Loaders" class="headerlink" title="Module Loaders"></a>Module Loaders</h3><p>Module Loader가 지원하는 것들:</p><ul><li>동적 로딩 (Dynamic loading)</li><li>상태 격리 (State isolation)</li><li>글로벌 네임스페이스 격리 (Global namespace isolation)</li><li>컴파일 훅 (Compilation hooks)</li><li>중첩된 가상화 (Nested virtualization)</li></ul><p>기본 모듈 로더가 구성되어 있을 수 있으며 새로운 로더가 격리 또는 제한된 실행구문 안에서 코드를 불러오고 평가할 수 있도록 구성될수 있습니다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Dynamic loading – ‘System’ is default loader</span></span><br><span class="line">System.import(<span class="string">&#x27;lib/math&#x27;</span>).then(<span class="function"><span class="keyword">function</span>(<span class="params">m</span>) </span>&#123;</span><br><span class="line">  alert(<span class="string">&quot;2π = &quot;</span> + m.sum(m.pi, m.pi));</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Create execution sandboxes – new Loaders</span></span><br><span class="line"><span class="keyword">var</span> loader = <span class="keyword">new</span> Loader(&#123;</span><br><span class="line">  <span class="built_in">global</span>: fixup(<span class="built_in">window</span>) <span class="comment">// replace ‘console.log’</span></span><br><span class="line">&#125;);</span><br><span class="line">loader.eval(<span class="string">&quot;console.log(&#x27;hello world!&#x27;);&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Directly manipulate module cache</span></span><br><span class="line">System.get(<span class="string">&#x27;jquery&#x27;</span>);</span><br><span class="line">System.set(<span class="string">&#x27;jquery&#x27;</span>, Module(&#123;<span class="attr">$</span>: $&#125;)); <span class="comment">// WARNING: not yet finalized</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="Map-Set-WeakMap-WeakSet"><a href="#Map-Set-WeakMap-WeakSet" class="headerlink" title="Map + Set + WeakMap + WeakSet"></a>Map + Set + WeakMap + WeakSet</h3><p>공통된 알고리즘을 위한 효율적인 데이터 구조이며 WeakMaps은 누수(leak)로부터 자유로운 object-key 구조의 side tables을 제공합니다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Sets</span></span><br><span class="line"><span class="keyword">var</span> s = <span class="keyword">new</span> <span class="built_in">Set</span>(); <span class="comment">// Set(0) &#123;&#125;</span></span><br><span class="line">s.add(<span class="string">&quot;hello&quot;</span>).add(<span class="string">&quot;goodbye&quot;</span>).add(<span class="string">&quot;hello&quot;</span>); <span class="comment">// Set(2) &#123;&quot;hello&quot;, &quot;goodbye&quot;&#125;</span></span><br><span class="line">s.size === <span class="number">2</span>; <span class="comment">// true</span></span><br><span class="line">s.has(<span class="string">&quot;hello&quot;</span>) === <span class="literal">true</span>; <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Maps</span></span><br><span class="line"><span class="keyword">var</span> m = <span class="keyword">new</span> <span class="built_in">Map</span>(); <span class="comment">// Map(0) &#123;&#125;</span></span><br><span class="line">m.set(<span class="string">&quot;hello&quot;</span>, <span class="number">42</span>); <span class="comment">// Map(1) &#123;&quot;hello&quot; =&gt; 42&#125;</span></span><br><span class="line">m.set(<span class="string">&quot;s&quot;</span>, <span class="number">34</span>); <span class="comment">// Map(2) &#123;&quot;hello&quot; =&gt; 42, &quot;s&quot; =&gt; 34&#125;</span></span><br><span class="line">m.get(<span class="string">&quot;s&quot;</span>) == <span class="number">34</span>; <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Weak Maps</span></span><br><span class="line"><span class="keyword">var</span> wm = <span class="keyword">new</span> <span class="built_in">WeakMap</span>(); <span class="comment">// WeakMap &#123;&#125;</span></span><br><span class="line">wm.set(&#123; <span class="attr">extra</span>: <span class="number">42</span> &#125;, <span class="number">42</span>);</span><br><span class="line"><span class="comment">// WeakMap &#123;&#123;…&#125; =&gt; 42&#125; [[Entries]]0: &#123;Object =&gt; 42&#125;__proto__: WeakMap</span></span><br><span class="line">wm.size === <span class="literal">undefined</span> <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">/ Weak Sets</span><br><span class="line"><span class="keyword">var</span> ws = <span class="keyword">new</span> <span class="built_in">WeakSet</span>(); <span class="comment">// WeakSet &#123;&#125;</span></span><br><span class="line">ws.add(&#123; <span class="attr">data</span>: <span class="number">42</span> &#125;);</span><br><span class="line"><span class="comment">// Because the added object has no other references, it will not be held in the set</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>자세한 정보: <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map">Map</a>, <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Set">Set</a>, <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/WeakMap">WeakMap</a>, <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/WeakSet">WeakSet</a></p><h3 id="Proxies"><a href="#Proxies" class="headerlink" title="Proxies"></a>Proxies</h3><p>Proxy는 호스트 객체에 사용 가능한 모든 동작 범위를 가진 객체를 생성할 수 있다. 가로채기(interception), 객체 가상화(object virtualization), 로깅/프로파일링(logging/profiling) 등에 대해 사용할 수 있습니다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Proxying a normal object</span></span><br><span class="line"><span class="keyword">var</span> target = &#123;&#125;;</span><br><span class="line"><span class="keyword">var</span> handler = &#123;</span><br><span class="line">  get: <span class="function"><span class="keyword">function</span> (<span class="params">receiver, name</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">`Hello, <span class="subst">$&#123;name&#125;</span>!`</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> <span class="built_in">Proxy</span>(target, handler);</span><br><span class="line">p.world === <span class="string">&#x27;Hello, world!&#x27;</span>; <span class="comment">// true</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Proxying a function object</span></span><br><span class="line"><span class="keyword">var</span> target = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="keyword">return</span> <span class="string">&#x27;I am the target&#x27;</span>; &#125;;</span><br><span class="line"><span class="keyword">var</span> handler = &#123;</span><br><span class="line">  apply: <span class="function"><span class="keyword">function</span> (<span class="params">receiver, ...args</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;I am the proxy&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> <span class="built_in">Proxy</span>(target, handler);</span><br><span class="line">p() === <span class="string">&#x27;I am the proxy&#x27;</span>; <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>모든 런타임 수준의 메타 작업을 사용 가능한 트랩이 있다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> handler =</span><br><span class="line">&#123;</span><br><span class="line">  get:...,</span><br><span class="line">  set:...,</span><br><span class="line">  has:...,</span><br><span class="line">  deleteProperty:...,</span><br><span class="line">  apply:...,</span><br><span class="line">  construct:...,</span><br><span class="line">  getOwnPropertyDescriptor:...,</span><br><span class="line">  defineProperty:...,</span><br><span class="line">  getPrototypeOf:...,</span><br><span class="line">  setPrototypeOf:...,</span><br><span class="line">  enumerate:...,</span><br><span class="line">  ownKeys:...,</span><br><span class="line">  preventExtensions:...,</span><br><span class="line">  isExtensible:...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>자세한 정보: <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy">MDN Proxy</a></p><h3 id="Symbols"><a href="#Symbols" class="headerlink" title="Symbols"></a>Symbols</h3><p>Symbol은 객체 상태에 접근 제어를 가능하게 하며 속성에 (ES5에서와 같이 ) <code>string</code> 또는 <code>symbol</code>로 키를 지정할 수 있습니다. Symbol은 새로운 원시(primitive) 타입입니다. 선택적으로 <code>description</code> 파라미터를 디버깅에서 사용합니다. - 속성의 일부분은 아닙니다. Symbol은 고유하지만  <code>Object.getOwnPropertySymbols</code> 와 같은 reflection 기능을 통해 노출되기 때문에 비공개가 아니다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> MyClass = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// module scoped symbol</span></span><br><span class="line">  <span class="keyword">var</span> key = <span class="built_in">Symbol</span>(<span class="string">&quot;key&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">MyClass</span>(<span class="params">privateData</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>[key] = privateData;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  MyClass.prototype = &#123;</span><br><span class="line">    doStuff: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      ... this[key] ...</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> MyClass;</span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> c = <span class="keyword">new</span> MyClass(<span class="string">&quot;hello&quot;</span>)</span><br><span class="line">c[<span class="string">&quot;key&quot;</span>] === <span class="literal">undefined</span></span><br></pre></td></tr></table></figure><p>자세한 정보: <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Symbol">MDN Symbol</a></p><h3 id="Subclassable-Built-ins"><a href="#Subclassable-Built-ins" class="headerlink" title="Subclassable Built-ins"></a>Subclassable Built-ins</h3><p>ES6에서는  <code>Array</code>, <code>Date</code> 그리고 DOM <code>Element</code> 와 같은 내장 기능(built-in)을 서브클래싱할 수 있으며 현재 <code>Ctor</code> 라는 이름의 함수에 대한 객체 구조는 두가지 측면으로 사용한다. </p><ul><li>특정 행위를 설치하기 위한 <code>Ctor[@@create]</code>를 객체에 배치하기 위해 호출한다.</li><li>새로운 인스턴스에 초기화하기 위한 constructor를 선언한다.</li></ul><p>알려진 <code>@@create</code> symbol은 <code>symbol.create</code> 를 통해 사용가능하고, 내장 기능들은 현재   암죽적으로 스스로의 <code>@@create</code>를 노출합니다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Pseudo-code of Array</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Array</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(...args) &#123; <span class="comment">/* ... */</span> &#125;</span><br><span class="line">    <span class="keyword">static</span> [<span class="built_in">Symbol</span>.create]() &#123;</span><br><span class="line">        <span class="comment">// Install special [[DefineOwnProperty]]</span></span><br><span class="line">        <span class="comment">// to magically update &#x27;length&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// User code of Array subclass</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyArray</span> <span class="keyword">extends</span> <span class="title">Array</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(...args) &#123; <span class="built_in">super</span>(...args); &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Two-phase &#x27;new&#x27;:</span></span><br><span class="line"><span class="comment">// 1) Call @@create to allocate object</span></span><br><span class="line"><span class="comment">// 2) Invoke constructor on new instance</span></span><br><span class="line"><span class="keyword">var</span> arr = <span class="keyword">new</span> MyArray();</span><br><span class="line">arr[<span class="number">1</span>] = <span class="number">12</span>;</span><br><span class="line">arr.length == <span class="number">2</span></span><br></pre></td></tr></table></figure><h3 id="Math-Number-String-Array-Object-APIs"><a href="#Math-Number-String-Array-Object-APIs" class="headerlink" title="Math + Number + String + Array + Object APIs"></a>Math + Number + String + Array + Object APIs</h3><p>핵심적인 수학 라이브러리, 배열, 변환 헬퍼, 문자열 헬퍼 그리고 복사를 위한 Object.assign를 포함해 많은 새로운 라이브러리 추가.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Number</span>.EPSILON</span><br><span class="line"><span class="built_in">Number</span>.isInteger(<span class="literal">Infinity</span>) <span class="comment">// false</span></span><br><span class="line"><span class="built_in">Number</span>.isNaN(<span class="string">&quot;NaN&quot;</span>) <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Math</span>.acosh(<span class="number">3</span>) <span class="comment">// 1.762747174039086</span></span><br><span class="line"><span class="built_in">Math</span>.hypot(<span class="number">3</span>, <span class="number">4</span>) <span class="comment">// 5</span></span><br><span class="line"><span class="built_in">Math</span>.imul(<span class="built_in">Math</span>.pow(<span class="number">2</span>, <span class="number">32</span>) - <span class="number">1</span>, <span class="built_in">Math</span>.pow(<span class="number">2</span>, <span class="number">32</span>) - <span class="number">2</span>) <span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;abcde&quot;</span>.includes(<span class="string">&quot;cd&quot;</span>) <span class="comment">// true</span></span><br><span class="line"><span class="string">&quot;abc&quot;</span>.repeat(<span class="number">3</span>) <span class="comment">// &quot;abcabcabc&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Array</span>.from(<span class="built_in">document</span>.querySelectorAll(<span class="string">&#x27;*&#x27;</span>)) <span class="comment">// Returns a real Array</span></span><br><span class="line"><span class="built_in">Array</span>.of(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>) <span class="comment">// Similar to new Array(...), but without special one-arg behavior</span></span><br><span class="line">[<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>].fill(<span class="number">7</span>, <span class="number">1</span>) <span class="comment">// [0,7,7]</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].find(<span class="function"><span class="params">x</span> =&gt;</span> x == <span class="number">3</span>) <span class="comment">// 3</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].findIndex(<span class="function"><span class="params">x</span> =&gt;</span> x == <span class="number">2</span>) <span class="comment">// 1</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>].copyWithin(<span class="number">3</span>, <span class="number">0</span>) <span class="comment">// [1, 2, 3, 1, 2]</span></span><br><span class="line">[<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>].entries() <span class="comment">// iterator [0, &quot;a&quot;], [1,&quot;b&quot;], [2,&quot;c&quot;]</span></span><br><span class="line">[<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>].keys() <span class="comment">// iterator 0, 1, 2</span></span><br><span class="line">[<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>].values() <span class="comment">// iterator &quot;a&quot;, &quot;b&quot;, &quot;c&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.assign(Point, &#123; <span class="attr">origin</span>: <span class="keyword">new</span> Point(<span class="number">0</span>,<span class="number">0</span>) &#125;)</span><br></pre></td></tr></table></figure><p>자세한 정보: <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number">Number</a>, <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math">Math</a>, <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/from">Array.from</a>, <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/of">Array.of</a>, <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/copyWithin">Array.prototype.copyWithin</a>, <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/assign">Object.assign</a></p><h3 id="Binary-and-Octal-Literals"><a href="#Binary-and-Octal-Literals" class="headerlink" title="Binary and Octal Literals"></a>Binary and Octal Literals</h3><p>binary(2진법)의  (<code>b</code>) 와 octal(8진법)의  (<code>o</code>)에 대해 두 개의 새로운 숫자 리터럴 폼이 추가되었다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0b111110111</span> === <span class="number">503</span> <span class="comment">// true</span></span><br><span class="line"><span class="number">0o767</span> === <span class="number">503</span> <span class="comment">// true</span></span><br></pre></td></tr></table></figure><h3 id="Promises"><a href="#Promises" class="headerlink" title="Promises"></a>Promises</h3><p>Promise는 비동기 프로그래밍 라이브러리이며 미래에 가능하도록 하는 일급 표현(representation)이며, 현존하는 많은 Javascript 라이브러리에서 사용되고 있다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">timeout</span>(<span class="params">duration = <span class="number">0</span></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">setTimeout</span>(resolve, duration);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> p = timeout(<span class="number">1000</span>).then(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> timeout(<span class="number">2000</span>);</span><br><span class="line">&#125;).then(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&quot;hmm&quot;</span>);</span><br><span class="line">&#125;).catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Promise</span>.all([timeout(<span class="number">100</span>), timeout(<span class="number">200</span>)]);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>자세한 정보: <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise">MDN Promise</a></p><h3 id="Reflect-API"><a href="#Reflect-API" class="headerlink" title="Reflect API"></a>Reflect API</h3><p>객체에 대한 런타임 수준의 메타 작업을 노출하는 전체 reflection API. Reflect API는 실제로 Proxy API의 반대이고, proxy 트랩으로서 같은 메타 작업에 따르는 콜들은 만들도록 해준다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> duck = &#123;</span><br><span class="line">  name: <span class="string">&#x27;Maurice&#x27;</span>,</span><br><span class="line">  color: <span class="string">&#x27;white&#x27;</span>,</span><br><span class="line">  greeting: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`Quaaaack! My name is <span class="subst">$&#123;<span class="built_in">this</span>.name&#125;</span>`</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Reflect</span>.has(duck, <span class="string">&#x27;color&#x27;</span>);</span><br><span class="line"><span class="comment">// true</span></span><br><span class="line"><span class="built_in">Reflect</span>.has(duck, <span class="string">&#x27;haircut&#x27;</span>);</span><br><span class="line"><span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Reflect</span>.ownKeys(duck);</span><br><span class="line"><span class="comment">// [ &quot;name&quot;, &quot;color&quot;, &quot;greeting&quot; ]</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Reflect</span>.set(duck, <span class="string">&#x27;eyes&#x27;</span>, <span class="string">&#x27;black&#x27;</span>);</span><br><span class="line"><span class="comment">// returns &quot;true&quot; if successful</span></span><br><span class="line"><span class="comment">// &quot;duck&quot; now contains the property &quot;eyes: &#x27;black&#x27;&quot;</span></span><br></pre></td></tr></table></figure><p>자세한 정보: <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Reflect">MDN Reflect</a></p><h3 id="Tail-Calls"><a href="#Tail-Calls" class="headerlink" title="Tail Calls"></a>Tail Calls</h3><p>tail 포지션의 콜(call)은 스택이 무제한으로 증가하지 않도록 보장합니다. 무제한 입력에 대한 재귀 알고리즘을 안전하게 만듭니다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">factorial</span>(<span class="params">n, acc = <span class="number">1</span></span>) </span>&#123;</span><br><span class="line"><span class="meta">    &#x27;use strict&#x27;</span>;</span><br><span class="line">    <span class="keyword">if</span> (n &lt;= <span class="number">1</span>) <span class="keyword">return</span> acc;</span><br><span class="line">    <span class="keyword">return</span> factorial(n - <span class="number">1</span>, n * acc);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Stack overflow in most implementations today,</span></span><br><span class="line"><span class="comment">// but safe on arbitrary inputs in ES6</span></span><br><span class="line">factorial(<span class="number">100000</span>)</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      
      <category domain="https://joontae-kim.github.io/categories/Programming/">Programming</category>
      
      <category domain="https://joontae-kim.github.io/categories/Programming/Javascript/">Javascript</category>
      
      
      <category domain="https://joontae-kim.github.io/tags/javascript/">javascript</category>
      
      <category domain="https://joontae-kim.github.io/tags/ECMAScript/">ECMAScript</category>
      
      <category domain="https://joontae-kim.github.io/tags/ECMAScript-2015/">ECMAScript 2015</category>
      
      <category domain="https://joontae-kim.github.io/tags/ES6/">ES6</category>
      
      <category domain="https://joontae-kim.github.io/tags/ECMAScript-6/">ECMAScript 6</category>
      
      <category domain="https://joontae-kim.github.io/tags/ES2015/">ES2015</category>
      
      
      <comments>https://joontae-kim.github.io/2020/10/06/ES6/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>ECMAScript와 Babel</title>
      <link>https://joontae-kim.github.io/2020/10/06/Babel/</link>
      <guid>https://joontae-kim.github.io/2020/10/06/Babel/</guid>
      <pubDate>Mon, 05 Oct 2020 16:52:32 GMT</pubDate>
      
        
        
      <description>&lt;p&gt;&lt;img src=&quot;/images/babel_javascript.jpeg&quot; alt=&quot;BABEL&quot;&gt;&lt;/p&gt;
&lt;p&gt;이전 포스트 &lt;a href=&quot;https://joontae-kim.github.io/2020/10/04/ECMAScript/&quot;&gt;ECMASc</description>
        
      
      
      
      <content:encoded><![CDATA[<p><img src="/images/babel_javascript.jpeg" alt="BABEL"></p><p>이전 포스트 <a href="https://joontae-kim.github.io/2020/10/04/ECMAScript/">ECMAScript란?</a> 까지는 Javascript의 탄생과 Javascript 표준화를 위한 ECMAScript 그리고 각 Version에 대해 알아봤습니다. 현재까지 ES10(ECMAScript 2019) 까지 발표되었으며 Javascript에서 할 수 있는 작업들이 늘어나고 있음을 느낄 수 있었다. 그러나 이를 구동시키기 위한 런타임 환경인 브라우저가 모든 버전을 해석(인터프리트) 할 수 없으며 그에 따라 개발자는 <em>브라우저가 이해하고 해석할 수 있는 버전</em> 으로 Javascript의 수준을 낮춰야만 한다. 그렇다면… 기능을 포기해야 할까? 아니라면 복잡한 기능을 직접 개발하는 우회적 방법을 써야할까? 그래서 나온것이 <strong>BABEL</strong> 이라는 <em>Javascript compiler</em> 다.</p><blockquote><p><em>본 포스트에서는 Babel에 대한 구조적 설명보다는 브라우저에서 ECMASCript 2015+ 의 코드를 실행시키기 위한 Tool로써의 의미와 ECMASCript 2015에 대해 다루도록 하겠습니다.</em></p></blockquote><h2 id="Babel-Complier-Transpiler"><a href="#Babel-Complier-Transpiler" class="headerlink" title="Babel, Complier? Transpiler?"></a>Babel, Complier? Transpiler?</h2><p>블로그를 쓰기 위해 먼저 짚고 넘어갈 부분이 생겼다. Babel은 Complier인가 Transpiler인가? 공식 사이트에 가보면 분명 <strong>Babel is Javascript Compiler</strong> 라고 써있지만… 여기저기 개발자 블로그를 들어가보면 트랜스파일러라고 하는 분들이 많았다. 왜일까….? </p><p><a href="https://advancedweb.dev/babel">Is Babel a compiler or transpiler?</a> 에 따르면, 먼저 Compiler와 Transpiler에 대해 알아보자.</p><blockquote><h4 id="Compiler-란"><a href="#Compiler-란" class="headerlink" title="Compiler 란"></a>Compiler 란</h4><p>고수준의 프로그래밍 언어로 작성된 코드를 object code, bytecode, machine code와 같은 저수준의 언어를 변환하는 도구라고 한다.</p><hr><h4 id="Transpiler-란"><a href="#Transpiler-란" class="headerlink" title="Transpiler 란"></a>Transpiler 란</h4><p>source-to-source compiler 또는 transcompiler라고도 불려지고, 고수준의 언어들 사이에서 소스코드를 변환하는 도구이며 결과 코드는 여전히 인간이 읽을 수 있다.</p></blockquote><p>위 정의만 봤을때는 Babel은 Compiler보단 <strong>Transpiler</strong>에 가깝다. 정확히는 <em>source-to-source compiler</em> 에 가깝다. <em>좀더 번역해보자.</em></p><p>바벨은 현재와 이전의 브라우저 환경에서 ECMAScript 2015 이상의 코드를 이전 버전과 호환되는 JavaScript 버전으로 변환하는데에 사용하는 주요한 JavaScript 툴체인(toolchain) 이며, 브라우저 지원을 기다리지 않고 지금 당장 새로운 문법을 사용할 수 있도록 문법 변환기(syntax transformers)를 통해 JavaScript의 최신 버전을 지원하고, JSX 문법을 변환할 수 있다.</p><p><strong>즉, Babel</strong> 은 위에서 정리했던 Compiler의 기능보다는 <strong>Transpiler</strong> 의 기능에 가까우며 최신 문법으로 작성된 Javascript 코드를 ES5 또는 그 이하의 문법으로 변환시켜주며 실행에 있어서도 문제없이 작동하도록 도와주는 역할을 한다고 정의할 수 있다.</p><h2 id="ECMAScript-2015"><a href="#ECMAScript-2015" class="headerlink" title="ECMAScript 2015+"></a>ECMAScript 2015+</h2><p>그렇다면 ECMAScript 2015 에는 무엇이 추가되었으며 ES 6, 7, 9 에는 무엇이 추가되었을까? 이 주제는 작지 않으므로 따로 포스팅하겠습니다.</p><hr><h2 id="참고"><a href="#참고" class="headerlink" title="참고"></a>참고</h2><ul><li><p><a href="https://advancedweb.dev/babel">Is Babel a compiler or transpiler?</a></p></li><li><p><a href="https://babeljs.io/docs/en/">What is Babel?</a></p></li><li><p><a href="https://babeljs.io/docs/en/learn">Learn ES2015</a></p></li><li><p><a href="https://www.daleseo.com/js-babel/">바벨(Babel 7) 기본 사용법 - daleseo.com</a></p></li><li><p><a href="https://en.wikipedia.org/wiki/Source-to-source_compiler">Source-to-source_compiler - en.wikipedia</a></p></li></ul><hr><h2 id="용어-설명"><a href="#용어-설명" class="headerlink" title="용어 설명"></a>용어 설명</h2><blockquote><h4 id="저수준-low-level-language-언어"><a href="#저수준-low-level-language-언어" class="headerlink" title="저수준(low-level language) 언어"></a>저수준(low-level language) 언어</h4><p>추상화에 대한 프로그래밍 컨셉이 거의 없거나 전혀 제공하지 않고, 실제 머신 지도에 가까운 언어이다. 예를 들어, assembly, machine code, and bytecode가 있다.</p><hr><h4 id="고수준-high-level-language-언어"><a href="#고수준-high-level-language-언어" class="headerlink" title="고수준(high-level language) 언어"></a>고수준(high-level language) 언어</h4><p>지금까지 활동중인 고 수준의 언어에는 Python, Visual Basic, Delphi, Perl, PHP, ECMAScript, Ruby, C#, Java 그리고 그 밖의 많은 언어들이 포함된다.</p></blockquote>]]></content:encoded>
      
      
      <category domain="https://joontae-kim.github.io/categories/Programming/">Programming</category>
      
      <category domain="https://joontae-kim.github.io/categories/Programming/Javascript/">Javascript</category>
      
      
      <category domain="https://joontae-kim.github.io/tags/javascript/">javascript</category>
      
      <category domain="https://joontae-kim.github.io/tags/ECMAScript/">ECMAScript</category>
      
      <category domain="https://joontae-kim.github.io/tags/Babel/">Babel</category>
      
      
      <comments>https://joontae-kim.github.io/2020/10/06/Babel/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>ECMAScript란?</title>
      <link>https://joontae-kim.github.io/2020/10/04/ECMAScript/</link>
      <guid>https://joontae-kim.github.io/2020/10/04/ECMAScript/</guid>
      <pubDate>Sun, 04 Oct 2020 09:39:51 GMT</pubDate>
      
        
        
      <description>&lt;p&gt;&lt;img src=&quot;/images/javascript.png&quot;&gt;&lt;/p&gt;
&lt;p&gt;자바스크립트를 공부하고 개발하다보면 ES5, ES6와 같은 ECMAScript에 대해 접할때가 많고, 면접을 볼때도 프로젝트를 개발할때 어떤 버전을 사용했으며 왜 사용했는</description>
        
      
      
      
      <content:encoded><![CDATA[<p><img src="/images/javascript.png"></p><p>자바스크립트를 공부하고 개발하다보면 ES5, ES6와 같은 ECMAScript에 대해 접할때가 많고, 면접을 볼때도 프로젝트를 개발할때 어떤 버전을 사용했으며 왜 사용했는지 그리고 이전 버전 그리고 다음 버전과의 차이는 무엇인지 질문 받은 경험이 있어 중간중간 공부할때가 있었는데 이참에 구체적으로 정리해볼려고 한다.</p><h4 id="브라우저-엔진과-종류"><a href="#브라우저-엔진과-종류" class="headerlink" title="브라우저 엔진과 종류"></a>브라우저 엔진과 종류</h4><p>각 브라우저는 Javascript를 구동하기 위한 엔진을 갖고 있으며 이를 ‘자바스크립트 가상 머신’이라 한다. </p><ul><li><strong>Chrom , Opera</strong> - V8</li><li><strong>Firefox</strong> - SpiderMonky</li><li><strong>IE</strong> - Trident 및 Chakar</li><li><strong>Microsoft Edge</strong> - ChakraCore</li><li><strong>Safari</strong> - Nitro 및 SquirrelFish</li></ul><h1 id="ECMAScript란"><a href="#ECMAScript란" class="headerlink" title="ECMAScript란?"></a>ECMAScript란?</h1><p>Javascript의 첫번째 포스트인 <a href="https://joontae-kim.github.io/2020/10/03/with-javascript/">자바스크립트란?</a> 의 <strong><em>표준화를 위한 작업, ECMAScript와 Javascript</em></strong> 에서 언급했듯이 ECMAScript는 각 브라우저 개발사들의 Javscript 엔진이 다르고 그에 따른 사용자들의 <strong>크로스 브라우징 이슈</strong>와 <strong>Javscript의 파편화</strong>를 방지하기 위한 Javascript 표준화에서 시작됐다.</p><h3 id="ECMAScript-정의"><a href="#ECMAScript-정의" class="headerlink" title="ECMAScript 정의"></a>ECMAScript 정의</h3><p> ECMA-262 문서에 따르면, <strong>ECMAScript (또는 ES)</strong> 는  ECMA 인터네셔널에 의해 표준화 된 범용 프로그래밍 언어로써, 서로 다른 웹 브라우저들에서 웹 페이지의 상호운용성을 보장하기 위한 Javscript 표준이다. 즉, <strong>ECMA-262</strong> 는 표준의 이름이고, <strong>ECMAScript (또는 ES)</strong> 는 ECMA-262라는 표준에서 정의된 프로그래밍 언어라는 것입니다. 쉽게 말해, 아래와 같이 비유할 수 있을거 같다.</p><ul><li>ECMA 인터네셔널 = 표준원</li><li>ECMA-262 = 표준어</li><li>ECMAScript = 표준어를 따르는 언어</li></ul><h3 id="ECMAScript와-Javascript"><a href="#ECMAScript와-Javascript" class="headerlink" title="ECMAScript와 Javascript"></a>ECMAScript와 Javascript</h3><p>Javascript는 ECMAScript 사양을 준수하는 범용 스크립트 언어라고 할 수 있으며 적절한 비유를 찾았고 공부하면서 둘의 관계를 잘 표현한 문장?이 아닐까 싶다.</p><blockquote><p><strong>ECMAScript</strong>는 스크립팅 언어를 어떻게 만들어야 하는지를 설명하는 일종의 설명서라고 생각하면 되고, <strong>JavaScript</strong>는 ECMAScript의 사양을 바탕으로 만들어진 언어인 것이다.</p><footer><strong>@Junimo</strong><cite><a href="https://sustainable-dev.tistory.com/105">ECMAScript와 Javascript의 차이점</a></cite></footer></blockquote><h3 id="Javascript-문서-Document-vs-ECMAScript-명세-Specification"><a href="#Javascript-문서-Document-vs-ECMAScript-명세-Specification" class="headerlink" title="Javascript 문서(Document) vs ECMAScript 명세(Specification)"></a>Javascript 문서(Document) vs ECMAScript 명세(Specification)</h3><blockquote><p>본 챕터는 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Introduction">mdn의 javascript 소개</a> 문서의 한 챕터로서, 다루면 좋을것 같아 추가해봅니다.</p></blockquote><p>ECMAScript 명세는 ECMAScript 구현을 위한 요구사항의 집합으로 ECMAScript 구현이나 브라우저 엔진에서 표준을 따르는 언어의 기능을 구현하려고 할때 유용합니다. ECMAScript 명세는 스크립트 프로그래머를 돕기 위한 것이 아니며 스크립트 작성을 위한 정보는 JavaScript 문서를 사용하세요.</p><p>ECMAScript 명세는 JavaScript 프로그래머에게 익숙하지 않을 수 있는 용어와 문법을 사용합니다. 언어의 기술이 ECMAScript와 다를 수 있지만, 언어 그 자체는 같습니다. 그리고 JavaScript는 ECMAScript 명세에 서술된 모든 기능을 지원합니다. JavaScript 문서는 JavaScript 프로그래머를 위한 적절한 언어의 측면을 설명합니다.</p><h1 id="ECMAScript-버전"><a href="#ECMAScript-버전" class="headerlink" title="ECMAScript 버전"></a>ECMAScript 버전</h1><p>보통 ECMAScript의 버전을 말할때는 <strong>ES</strong> + <em>(Standard Number)</em> 의 포맷으로 얘기하며 <em>Standard Number</em>는 (<em>표준화된 해의 끝자리 + 1</em>)로, 2015년에 제정된 ESCMScript 2015의 경우 <strong>ES6</strong> 라고 부른다.</p><p>ECMA-262는 현재 제 10판까지 출판되었으며 역사는 아래와 같다.</p><p><img src="/images/ECMAScript_History.png" alt="ECMAScript 출판 내역"></p><p>위 내역을 통해 알 수 있는것은 2009년 ES5는 현재 Javascript의 기본적 문법과 기능으로 추정할 수 있으며 2015년 ES6를 기준으로 본격적으로 많은 기능과 문법들이 추가되기 시작했다. </p><h3 id="ES6-이후의-추가된-기능과-문법"><a href="#ES6-이후의-추가된-기능과-문법" class="headerlink" title="ES6 이후의 추가된 기능과 문법"></a>ES6 이후의 추가된 기능과 문법</h3><ul><li><strong>ES5 (2009)</strong><ul><li>일반적으로 (구형 브라우저를 제외한) 모든 런타임에서 지원한다고 가정할 수 있는 Javascript의 기본 버전</li><li>Added <code>forEach, map, filter, reduce, some, every</code>  in Array Methods</li><li>Object getter &amp; setter</li><li>Added stricter standards to <code>strict mode</code></li><li>JSON</li></ul></li><li><strong>ES6 / ES2015</strong><ul><li>Standard Modules — <code>import</code> and <code>export</code></li><li>Standardised Promises</li><li>Classes &amp; Inheritance</li><li>Block-scoped variables — <code>let</code>and <code>const</code></li><li>Template Literals</li><li>Object destructing into variables</li><li>Generator functions</li><li>Map and Set data structures</li><li>Internationalisation for Strings, Numbers and Dates via <code>Intl</code> API</li><li>Arrow Function</li></ul></li><li><strong>ES7 / ES2016</strong><ul><li>Array.prototype.includes()</li><li>Numeric exponent (power of) operator <code>**</code></li></ul></li><li><strong>ES8 / ES2017</strong><ul><li>Async / Await Functions</li><li>Object.entries, Object.values Methods</li><li>String padding functions</li><li>Allow Trailing commas to function expression arguement</li></ul></li><li><strong>ES9 / ES2018</strong><ul><li>Object Rest/Spread <code>const obj = &#123; ...props &#125;;</code></li><li>Asynchronous Iteration <code>for await (...) &#123;</code></li><li>Promise <code>finally()</code> function</li><li>Regular expression enhancements (lookbehind, named groups)</li></ul></li><li><strong>ES10 / ES2019</strong><ul><li>Object.fromEntries</li><li>flat, flatMap</li><li>Symbol.description</li><li>optional catch</li></ul></li></ul><p><strong>ES2015/ES6</strong> 를 기준으로 수많은 편리한 메서드와 문법들이 추가되었고 개발자들은 보다 점차 높은 수준의 Javascript를 구사할 수 있게 되었으며 사용자들 또한 높은 수준의 기능들을 경험할 수 있게 되었다. </p><p>그러나 개발자들에겐 한가지 높은 장벽이 있었으니 그것은 바로 <strong>사용자의 런타임 환경인 브라우저</strong> 였다. ECMAScript가 업데이트가 되고 브라우저 개발사들이 자신들의 JS 엔진을 업그레이드 한다할지라도 그것은 사용자에게 필수적인 것이 아닐수 있으며 굳이 노력해야할 부분은 아니다. 그리하여 ECMAScript에 아무리 좋은 문법이 추가되어도 사용자 환경 때문에 사용하지 못하는 상황이 발생하며 이러한 문제점을 극복하기 위해 탄생한 것이 바로 <strong><em>Babel</em></strong> 이다. </p><hr><h2 id="참고"><a href="#참고" class="headerlink" title="참고"></a>참고</h2><ul><li><p><a href="https://en.wikipedia.org/wiki/ECMAScript">ECMA스크립트 - en.wikipedia.org</a></p></li><li><p><a href="https://developer.mozilla.org/ko/docs/Web/JavaScript/%EC%96%B8%EC%96%B4_%EB%A6%AC%EC%86%8C%EC%8A%A4">자바스크립트 언어 자료</a></p></li><li><p><a href="https://wormwlrm.github.io/2018/10/03/What-is-the-difference-between-javascript-and-ecmascript.html">JavaScript와 ECMAScript는 무슨 차이점이 있을까?</a></p></li><li><p><a href="https://medium.com/@dupski/what-major-new-features-were-in-each-javascript-version-what-version-should-i-target-25526c498687">What major new features were in each JavaScript version? What version should I target? - by Russell in medium</a></p></li><li></li></ul>]]></content:encoded>
      
      
      <category domain="https://joontae-kim.github.io/categories/Programming/">Programming</category>
      
      <category domain="https://joontae-kim.github.io/categories/Programming/Javascript/">Javascript</category>
      
      
      <category domain="https://joontae-kim.github.io/tags/javascript/">javascript</category>
      
      <category domain="https://joontae-kim.github.io/tags/ECMAScript/">ECMAScript</category>
      
      
      <comments>https://joontae-kim.github.io/2020/10/04/ECMAScript/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>자바스크립트란?</title>
      <link>https://joontae-kim.github.io/2020/10/03/with-javascript/</link>
      <guid>https://joontae-kim.github.io/2020/10/03/with-javascript/</guid>
      <pubDate>Fri, 02 Oct 2020 17:06:39 GMT</pubDate>
      
        
        
      <description>&lt;p&gt;&lt;img src=&quot;/images/javascript.png&quot;&gt;&lt;/p&gt;
&lt;p&gt;여러 프로젝트를 개발하면서 Javascript를 사용해왔고 그렇게 3년이 지나고 어느새 5년이라는 시간이 지났다. 그럼에도 불구하고 아직까지 Javascript에 대해 설</description>
        
      
      
      
      <content:encoded><![CDATA[<p><img src="/images/javascript.png"></p><p>여러 프로젝트를 개발하면서 Javascript를 사용해왔고 그렇게 3년이 지나고 어느새 5년이라는 시간이 지났다. 그럼에도 불구하고 아직까지 Javascript에 대해 설명하려면 “어렵지만, 쉬운” 언어라는 말이 먼저 나오고, 공부를 하면 할수록 “내가 알고 있는것이 맞는가?”, “얼마나 알아야 기본은 아는것일까?”라는 당혹감?에 빠져 있었다. </p><p>그래서 이참에 내가 사용해왔고 알아왔던 <strong>Javascript</strong>에 대해 더 알아보려고 한다. 그리고 친해져보려고 한다.</p><h1 id="Javascript의-탄생"><a href="#Javascript의-탄생" class="headerlink" title="Javascript의 탄생"></a>Javascript의 탄생</h1><p> Javascript의 시작은 미국의 <a href="https://ko.wikipedia.org/wiki/%EB%84%B7%EC%8A%A4%EC%BC%80%EC%9D%B4%ED%94%84">넷스케이프 커뮤니케이션스(Netscape Communications)</a>가 1994년 말 출시한 모자이크 넷스케이프가 1990년대에 주된 웹 브라우저로 자리잡기 시작하자 웹이 더 동적으로 변화할 필요을 느끼며 이를 위한 글루 언어(glue language) 개발을 위해  <a href="https://ko.wikipedia.org/wiki/%EB%B8%8C%EB%A0%8C%EB%8D%98_%EC%95%84%EC%9D%B4%ED%81%AC">브렌던 아이크</a>를 영입하고 개발한 언어가 지금의 Javascript이다.</p><p> 사실 Javascript는 개발 당시 <strong>모카</strong>(Mocha)라는 이름으로 불려졌다. 그러나 1995년 9월 넷스케이프 내비게이터 2.0 브라우저의 베타 릴리스 때는 <strong>라이브스크립트</strong>(LiveScript)로 바뀌었고 그해 12월 넷스케이프 내비게이터 2.0 베타 3 릴리스 때 우리가 알고 있는 <strong>Javascript</strong>라는 이름으로 정식 채택되었다.</p><p>개발에 대해 모르거나 시작하는 사람들이 대게 햇갈려하는 Java와 Javascript의 혼란은 넷스케이프가 당시 인기있는 웹 프로그래밍 언어로서 자바스크립트를 내밀기 위한 것으로 마케팅적인 선택으로 보여진다. 그러나 기술적으론 Javascript와 Java는 객체 모델을 갖는다는 거외에는 근본적으로 다르다.</p><h3 id="표준화를-위한-작업-ECMAScript와-Javascript"><a href="#표준화를-위한-작업-ECMAScript와-Javascript" class="headerlink" title="표준화를 위한 작업, ECMAScript와 Javascript"></a>표준화를 위한 작업, ECMAScript와 Javascript</h3><p>Javascript의 동적 웹 페이지 조작이 흥행하자 Microsoft는 자신들의 브라우저인 Internet Explerer를 지원하기 위해 <a href="https://ko.wikipedia.org/wiki/J%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8">J스크립트</a>를 개발했고 1996년 8월에 출시된 <a href="https://ko.wikipedia.org/wiki/%EC%9D%B8%ED%84%B0%EB%84%B7_%EC%9D%B5%EC%8A%A4%ED%94%8C%EB%A1%9C%EB%9F%AC">인터넷 익스플로러</a> 브라우저 3.0부터 적용하기 시작합니다. 이는 경쟁적 위치를 선점하며 자신들의 브라우저에서만 동작하는 기능들을 추가하기 시작했다는 것을 의미하며 <strong>크로스 브라우징 이슈</strong>의 말초가 된다. 즉, Javascript의 파편화가 시작된 것이다. 이러한 현상은 Javascript의 발전을 저해하며 사용자들이 공통된 경험을 누리지 못하는 불편을 야기했다.</p><p> 바로 이러한 점을 해소하기 위해 만들어진 것이 <strong>ECMAScript</strong> 그리고 <strong>ECMA-262</strong> 로, Javascript의 표준 명세서로써 프로그래밍 언어의 타입, 값, 객체와 프로퍼티, 함수, 빌트인 객체 등 <em>핵심 문법(core syntax)</em> 을 규정하며 브라우저 제조사는 이를 준수하여 <strong>브라우저 내장 자바스크립트 엔진</strong>을 구현해야 한다. (<em><strong>ECMAScript</strong>에 대한 자세한 내용은 추후 포스팅하겠습니다</em>)</p><h1 id="Javascript의-발전"><a href="#Javascript의-발전" class="headerlink" title="Javascript의 발전"></a>Javascript의 발전</h1><p>JavaScript는 XMLHttpRequest, JSON, Ajax과 같은 기술들이 개발됨에 따라 버튼의 클릭에 따른 UI 변경, Form 유효성 검증과 같은 단순한 작업에서 XMLHttpRequest의 브라우저(IE5) 도입에 따른서버와 브라우저 간의 비동기 데이터 통신을 시작으로 활용 가능성이 넓어지기 시작했다.</p><ul><li>1999년, <strong>XMLHttpRequest</strong> API가 IE5에 도입됨</li><li>2001년, 더글러스 크락포드가 자바스크립트의 기존 텍스트 형식의 데이터 저장을 ‘<strong>JSON</strong>(Javascript Object Notation)’이라는 객체 문법의 구조화된 문자기 반의 표준 포맷을 개발</li><li>2005년, <strong>Ajax</strong>를 이용해 구글이 구글Maps를 소개. 불필요한 렌더링을 줄이며 서버로부터 필요한 데이터만을 요청해 갱신이 필요한 부분만 리렌더링하는 방식을 선보임</li><li>2006년, <strong>jQuery</strong>의 등장으로 핸들링 하기 어려웠던 DOM의 한계를 극복했으며 크로스 브라우징 이슈가 해결됨</li><li>2008년, 구글이 <strong>크롬 웹브라우저</strong> 함께 <strong>V8</strong>이라는 자바스크립트 엔진 발표하면서 보다 웹 어플리케이션 또한 데스크톱 어플리케이션과 유사한 사용자 경험을 제공할 수 있게 됨</li><li>2009년, <strong>Node.js</strong> 라는 Server-side에서도 활용할 수 있는 Javascript가 개발됨에 따라 Client-side에 한정된 Javascript의 영역을 확대함</li></ul><h1 id="Javascript의-정의와-특징"><a href="#Javascript의-정의와-특징" class="headerlink" title="Javascript의 정의와 특징"></a>Javascript의 정의와 특징</h1><p>Javascript는 <strong>“웹 브라우저에서 실행되는 유일한 클라이언트 사이드 프로그래밍 언어”</strong> 로써 쉽게 배우고, 빠르게 개발할 수 있다는 강력한 장점을 제공하지만 Javascript의 성격과 패러다임 그리고 어떤 기능적 특징을 갖고 있는지 이해하는 것은 여간 어려운 것이 아니다. 왜냐하면 기본 문법은 C, Java와 유사하고 프로토타입 기반의 상속은 Self에서, 일급 함수의 개념은 Scheme에서 차용하였듯 기존의 프로그래밍 언어에서 많은 영향을 받았기 때문이다.</p><blockquote><p>프로토타입 기반, 다중 패러다임 스크립트 언어이며, 동적이고 명령어, 객체 지향, 함수 프로그래밍 스타일을 지원한다.</p><footer><strong>JavaScript란 무엇인가?</strong><cite><a href="https://developer.mozilla.org/ko/docs/Web/JavaScript/About">developer.mozilla.org/ko/docs/Web/JavaScript/About</a></cite></footer></blockquote><h3 id="Javascript의-정의"><a href="#Javascript의-정의" class="headerlink" title="Javascript의 정의"></a>Javascript의 정의</h3><p>Javascript는 가벼운 인터프리터 또는 <a href="https://ko.wikipedia.org/wiki/JIT_%EC%BB%B4%ED%8C%8C%EC%9D%BC">JIT 컴파일</a> 프로그래밍 언어로 <a href="https://ko.wikipedia.org/wiki/%ED%94%84%EB%A1%9C%ED%86%A0%ED%83%80%EC%9E%85_%EA%B8%B0%EB%B0%98_%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D">prototype 기반의 객체 지향</a> 패러다임을 바탕으로 하는 인터프리터 언어이자 기존의 웹 브라우저 뿐만이 아니라 서버사이드에서도 작동하는 크로스 플랫폼 언어이다.</p><h3 id="Javascript의-특징"><a href="#Javascript의-특징" class="headerlink" title="Javascript의 특징"></a>Javascript의 특징</h3><ol><li>일급 함수 사용<ul><li>Scheme의 일급 함수 개념을 차용했으며 이를 통해 <strong>고차 함수(high order function)</strong> 가 가능하다. </li><li>즉,  Javascript의 Array Method 중 each, filter, map과 같은 함수의 인자로 함수를 받는 형태를 말한다. </li></ul></li><li>가벼운 인터프리터 또는 <a href="https://ko.wikipedia.org/wiki/JIT_%EC%BB%B4%ED%8C%8C%EC%9D%BC">JIT 컴파일</a> 프로그래밍 언어<ul><li>Javascript는 인터프리터 언어로서 브라우저에서 동작하기 전에 다른 컴파일러를 통해 코드를 변환할 필요가 없으며 코드가 위에서 아래로 순차적으로 실행되고 결과를 즉시 반환한다.</li><li>모던 웹 브라우저에 JIT 컴파일러(Just In Time Compiler)가 내장되어 실행 시점에서 인터프리트 방식으로 기계어 코드를 생성하면서 그 코드를 캐싱하여, 같은 함수가 여러 번 불릴 때 매번 기계어 코드를 생성하는 것을 방지한다.</li></ul></li><li>프로토타입 기반의 객체 지향 언어<ul><li>클래스가 없으며 클래스 기반 언어에서 상속을 사용하는 것과 다르게 <a href="https://ko.wikipedia.org/wiki/%EA%B0%9D%EC%B2%B4_(%EC%BB%B4%ED%93%A8%ED%84%B0_%EA%B3%BC%ED%95%99)">객체</a>를 원형으로 하여 복제의 과정을 통해 객체의 동작 방식을 다시 사용할 수 있다. 이는 클래스 기반 프로그래밍 언어인 Java와도 다른 점이다.</li><li>객체 생성 시에 클래스로부터 그 내용을 상속받아서 객체를 만드는 것이 아니라, 객체로부터 그 특성을 복제하여 새로운 객체를 생성하기 때문에 런타임 중에도 객체의 속성과 값을 추가하거나 변경하고, 삭제까지 가능합니다. </li></ul></li><li><a href="https://ko.wikipedia.org/wiki/%EB%AA%85%EB%A0%B9%ED%98%95_%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D">명령형(imperative)</a>, <a href="https://ko.wikipedia.org/wiki/%ED%95%A8%EC%88%98%ED%98%95_%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D">함수형(functional)</a>을 지원하는 다중 패러다임 스크립트 언어</li><li>동적이고 명령어, 객체 지향, 함수 프로그래밍 스타일을 지원<ul><li>Javascript는 다른 언어들과 다르게 변수, 매개변수 및 함수의 반환 값의 타입을 명시적으로 지정하지 않아도 된다는 특징을 가지며 이는 프로토타입 기반 모델이 동적 상속을 제공하기 때문이다. 따라서 함수는 객체의 속성이나 타입이 느슨하게 지정된채 실행되는 메소드가 될 수 있다.</li></ul></li><li><a href="http://www.instantweb.com/~foldoc/foldoc.cgi?query=procedural&action=Search">절차지향 (procedural)</a> 언어와 <a href="http://www.instantweb.com/~foldoc/foldoc.cgi?query=object+oriented&action=Search">객체지향 (object oriented)</a> 언어 두가지 형태로 개발 가능함</li></ol><hr><h2 id="참고"><a href="#참고" class="headerlink" title="참고"></a>참고</h2><ul><li><p><a href="https://ko.wikipedia.org/wiki/%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8">자바스크립트 - wikipedia.org</a></p></li><li><p><a href="https://developer.mozilla.org/ko/docs/Web/JavaScript/Guide/%EC%86%8C%EA%B0%9C">자바스크립트 Guide 소개 - mdn</a></p></li><li><p><a href="https://ko.javascript.info/intro#ref-390">자바스크립트란? - ko.javascript.info</a></p></li><li><p><a href="https://ko.wikipedia.org/wiki/ECMA%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8">ECMA스크립트 - wikipedia.org</a></p></li><li><p><a href="https://poiemaweb.com/js-introduction">자바스크립트란? - poiemaweb</a></p></li><li><p><a href="https://kangax.github.io/compat-table/es6/">es6 compatibility table - compat-table</a></p></li><li><p><a href="https://valuefactory.tistory.com/610">Javascript 버전별 표준</a></p></li><li><p><a href="https://en.wikipedia.org/wiki/ECMAScript">ECMAScript - en.wikipedia.org</a></p></li><li><p><a href="https://en.wikipedia.org/wiki/XMLHttpRequest#History">XMLHttpRequest - en.wikipedia.org</a></p></li><li><p><a href="https://edu.goorm.io/learn/lecture/557/%ED%95%9C-%EB%88%88%EC%97%90-%EB%81%9D%EB%82%B4%EB%8A%94-node-js/lesson/174353/%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8%EC%9D%98-%EC%97%AD%EC%82%AC">자바스크립트의 역사 - edu.goorm.io</a></p></li><li><p><a href="https://ko.wikipedia.org/wiki/%ED%94%84%EB%A1%9C%ED%86%A0%ED%83%80%EC%9E%85_%EA%B8%B0%EB%B0%98_%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D">프로토타입 기반 프로그래밍 - wikipedia.org</a></p></li><li><p><a href="https://brownbears.tistory.com/407">절차지향 vs 객체지향</a></p></li><li><p><a href="https://ko.wikipedia.org/wiki/JIT_%EC%BB%B4%ED%8C%8C%EC%9D%BC">JIT 컴파일 - wikipedia.org</a></p></li></ul>]]></content:encoded>
      
      
      <category domain="https://joontae-kim.github.io/categories/Programming/">Programming</category>
      
      <category domain="https://joontae-kim.github.io/categories/Programming/Javascript/">Javascript</category>
      
      
      <category domain="https://joontae-kim.github.io/tags/javascript/">javascript</category>
      
      
      <comments>https://joontae-kim.github.io/2020/10/03/with-javascript/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>01. javascript</title>
      <link>https://joontae-kim.github.io/2020/10/01/node-all-in-one-javascript-1/</link>
      <guid>https://joontae-kim.github.io/2020/10/01/node-all-in-one-javascript-1/</guid>
      <pubDate>Thu, 01 Oct 2020 08:07:32 GMT</pubDate>
      
        
        
      <description>&lt;p&gt;&lt;img src=&quot;/images/course.png&quot;&gt;&lt;/p&gt;
&lt;h4 id=&quot;01-Javascript-란&quot;&gt;&lt;a href=&quot;#01-Javascript-란&quot; class=&quot;headerlink&quot; title=&quot;01. Javascript  란&quot;&gt;&lt;/a&gt;0</description>
        
      
      
      
      <content:encoded><![CDATA[<p><img src="/images/course.png"></p><h4 id="01-Javascript-란"><a href="#01-Javascript-란" class="headerlink" title="01. Javascript  란"></a>01. Javascript  란</h4><ul><li><p>브라우저를 제어하기 위한 넷스케이프에서 개발한 언어</p></li><li><p>사용자의 클릭, 계산기 등의 이벤트 조작에 대응하기 위한 언어</p></li><li><p>자바스크립트의 확대</p><ul><li>Ajax 활용 (구글맵)</li><li>디버깅툴의 발전<ul><li>파이어폭스의 콘솔로그</li></ul></li><li>크롬의 V8 엔진 개발</li><li>V8 엔진 기반의 서버 사이드 javascript 개발<ul><li>Node.js</li></ul></li><li>여러 플랫폼에서 js 기반의 환경 조성<ul><li>Desktop, IOT 등에서</li></ul></li></ul></li><li><p>변수형</p><ul><li><p>js는 동적언어이므로 자료형을 선언할 필요가 없음</p></li><li><p>기본 자료형과 객체(Object) 두가지로 나뉨</p><table><thead><tr><th>기본자료형</th><th>설명</th></tr></thead><tbody><tr><td>Boolean</td><td>논리적 요소 (true / false)</td></tr><tr><td>Null</td><td>객체 값이 존재하지 않는다는 의미</td></tr><tr><td>Undefined</td><td>값을 할당하지 않음</td></tr><tr><td>Number</td><td>숫자형</td></tr><tr><td>String</td><td>문자형</td></tr><tr><td>Symblo</td><td>ECMAScript 6에서 추가, 유일하고 변경 불가</td></tr></tbody></table></li></ul></li></ul><hr><h4 id="02-배열"><a href="#02-배열" class="headerlink" title="02. 배열"></a>02. 배열</h4><ul><li>배열도 기본 자료형 중에 하나</li><li>예제: <code>[&#39;안녕&#39;, &#39;Node.js&#39;, 55, &#39;Hello&#39;]</code></li><li>위와 같이, 문자형과 숫자형이 섞여있든 요소에 대한 자료형이 통일되지 않아도 되는 구조</li><li>배열에는 인덱싱이라는게 있음<ul><li>예제의 <code>&#39;안녕&#39;</code>을 기준으로 인덱싱이 <code>0</code> 이 되며 차례대로 1,2,3 ….</li></ul></li><li>배열의 인덱싱을 통해 <strong>overwrite</strong> 가능<ul><li><code>example[0] = &#39;Hi&#39;</code></li></ul></li></ul><hr><h4 id="03-반복문"><a href="#03-반복문" class="headerlink" title="03. 반복문"></a>03. 반복문</h4><ul><li><p>대표적으로 <code>for</code>, <code>while</code>, <code>do-while</code> 문이 있음</p></li><li><p>for 문</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i&lt;<span class="number">10</span>; i++) &#123;</span><br><span class="line">  <span class="comment">// .....</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>while 문</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> i = <span class="number">0</span> <span class="comment">// 초기화 조건</span></span><br><span class="line"><span class="keyword">while</span> (i &lt; <span class="number">10</span>) &#123;</span><br><span class="line">  <span class="comment">// .....</span></span><br><span class="line">  i = i+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>do .. while 문</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">  <span class="comment">// .....</span></span><br><span class="line">  i = i + <span class="number">1</span>;</span><br><span class="line">&#125; <span class="keyword">while</span> (i &lt; <span class="number">5</span>)</span><br></pre></td></tr></table></figure></li><li><p><code>while</code> 문과 <code>do ... while</code> 문의 차이는 </p><ul><li><code>while</code> 의 조건문을 언제 시작하느냐</li><li><code>do ... while</code> 의 경우 일단 <code>do &#123; ... &#125;</code> 문을 실행한 뒤 <code>while</code>  문을 실행</li></ul></li></ul><hr><h4 id="04-함수"><a href="#04-함수" class="headerlink" title="04. 함수"></a>04. 함수</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Car 라는 틀(prototype) 생성</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Car</span> (<span class="params">a, b, c</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// function의 member 선언</span></span><br><span class="line">  <span class="comment">// this는 public 변수</span></span><br><span class="line">  <span class="built_in">this</span>.name = a;</span><br><span class="line">  <span class="built_in">this</span>.color = b;</span><br><span class="line">  <span class="comment">// var 등 함수내에서 선언된 변수들은 private 변수라 함.</span></span><br><span class="line">  <span class="keyword">var</span> move = c</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 객체 생성 , 변수 a는 Car의 인스턴스</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> Car(<span class="string">&#x27;현대&#x27;</span>, <span class="string">&#x27;노랑&#x27;</span>, <span class="string">&#x27;전진&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(a.name)</span><br><span class="line"><span class="comment">// 현대</span></span><br><span class="line"><span class="built_in">console</span>.log(a.color)</span><br><span class="line"><span class="comment">// 노랑</span></span><br><span class="line"><span class="built_in">console</span>.log(a.move)</span><br><span class="line"><span class="comment">// undefined =&gt; 왜냐하면 private 변수로 선언되었기 때문</span></span><br></pre></td></tr></table></figure><hr><h4 id="05-프로토타입"><a href="#05-프로토타입" class="headerlink" title="05. 프로토타입"></a>05. 프로토타입</h4><ul><li><p>js는 프로토타입 기반 언어이다.</p></li><li><p>예제</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Car</span> (<span class="params">a, b, c</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// function의 member 선언</span></span><br><span class="line">  <span class="comment">// this는 public 변수</span></span><br><span class="line">  <span class="built_in">this</span>.name = a;</span><br><span class="line">  <span class="built_in">this</span>.color = b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 객체 생성 , 변수 a는 Car의 인스턴스</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> Car(<span class="string">&#x27;현대&#x27;</span>, <span class="string">&#x27;노랑&#x27;</span>);</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>자바스크립트는 <code>Car</code> 에 <strong>프로토타입</strong> 이라는 것이 있음</p><ul><li><p><strong>프로토타입</strong>을 기준으로 <strong>객체</strong>. 즉, <strong>인스턴스</strong>를 생성</p></li><li><p>예제</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Car.prototype.move = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// Car의 prototype에 접근해 함수를 추가</span></span><br><span class="line">   <span class="built_in">console</span>.log(<span class="built_in">this</span>.name + <span class="string">&#x27;차이고&#x27;</span>+ <span class="built_in">this</span>.name + <span class="string">&#x27;색이다&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">a.move()</span><br><span class="line"><span class="comment">// 현대차이고 노랑색입니다.</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Car.prototype.move = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// Car의 prototype에 접근해 함수를 추가</span></span><br><span class="line">   <span class="built_in">console</span>.log(<span class="built_in">this</span>.name + <span class="string">&#x27;차이고&#x27;</span>+ <span class="built_in">this</span>.name + <span class="string">&#x27;색이다&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">a.move()</span><br><span class="line"><span class="comment">// 현대차이고 노랑색입니다.</span></span><br></pre></td></tr></table></figure></li></ul></li></ul><ul><li><p>예제</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>]</span><br><span class="line"><span class="comment">// 배열의 prototype에 접근해 커스텀 함수 추가</span></span><br><span class="line"><span class="built_in">Array</span>.prototype.print = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">0</span>;i &lt; <span class="built_in">this</span>.length; i++) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>[i])</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">a.print()</span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 3</span></span><br><span class="line"><span class="comment">// 5</span></span><br><span class="line"><span class="comment">// 7</span></span><br><span class="line"><span class="comment">// 9</span></span><br></pre></td></tr></table></figure></li></ul><hr><h3 id="보충해서-볼것"><a href="#보충해서-볼것" class="headerlink" title="보충해서 볼것"></a>보충해서 볼것</h3><ul><li>변수형</li><li>프로토타입</li><li>함수 선언식과 표현식</li></ul>]]></content:encoded>
      
      
      <category domain="https://joontae-kim.github.io/categories/course/">course</category>
      
      <category domain="https://joontae-kim.github.io/categories/course/node-all-in-one/">node_all_in_one</category>
      
      
      <category domain="https://joontae-kim.github.io/tags/course-javascript/">course,javascript</category>
      
      
      <comments>https://joontae-kim.github.io/2020/10/01/node-all-in-one-javascript-1/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>Hexo로 글 작성하기</title>
      <link>https://joontae-kim.github.io/2020/09/29/hexo-writing/</link>
      <guid>https://joontae-kim.github.io/2020/09/29/hexo-writing/</guid>
      <pubDate>Tue, 29 Sep 2020 12:16:43 GMT</pubDate>
      
        
        
      <description>&lt;p&gt;&lt;img src=&quot;/images/hello_hexo.png&quot;&gt;&lt;/p&gt;
&lt;p&gt;Hexo는 간단하고 파워풀한 프레임워크로써, 마크다운 문법을 통해 포스트를 작성하면 theme와 함께 정적 웹사이트를 만들 수 있습니다. 설치와 설정 그리고 theme 등</description>
        
      
      
      
      <content:encoded><![CDATA[<p><img src="/images/hello_hexo.png"></p><p>Hexo는 간단하고 파워풀한 프레임워크로써, 마크다운 문법을 통해 포스트를 작성하면 theme와 함께 정적 웹사이트를 만들 수 있습니다. 설치와 설정 그리고 theme 등 공식문서를 잘 읽어보면 더 유용한 기능들이 많으며 이번 포스팅에서는 Hexo 명령어를 통해서 글 작성하는 법 즉, 포스트를 생성하고 배포하는 법을 다뤄보겠습니다.</p><h3 id="명령어"><a href="#명령어" class="headerlink" title="명령어"></a>명령어</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hexo <span class="keyword">new</span> [layout] &lt;title&gt;</span><br><span class="line">hexo <span class="keyword">new</span> &lt;title&gt; <span class="comment">// layout을 생략할 경우 default_layout으로 새로운 마크다운 파일이 생성됨.</span></span><br></pre></td></tr></table></figure><p>Hexo 에서 새 포스트나 페이지를 생성하기 위한 명령어로 기본 <code>layout</code> 은 <strong>post</strong> 이지만 블로그의 <code>_config.yml</code> 에서 <code>default_layout</code> 을 변경하면 기본 생성 layout 유형이 바뀝니다.</p><h3 id="Layout"><a href="#Layout" class="headerlink" title="Layout"></a>Layout</h3><p>Hexo에서는 아래와 같이 3개의 기본 레이아웃을 제공하며 생성된 파일들은 서로 다른 경로에 저장됩니다.</p><table><thead><tr><th>종류</th><th>정의</th><th>생성 경로</th></tr></thead><tbody><tr><td>post</td><td>블로그에 바로 발행 가능한 레이아웃</td><td><code>source/_posts</code></td></tr><tr><td>draft</td><td>post 처럼 바로 게시하지 않고 작성할 수 있는 초안</td><td><code>source/_drafts</code></td></tr><tr><td>page</td><td>post 처럼 하나의 게시물이 아닌 하나의 페이지를 생성</td><td><code>source</code></td></tr></tbody></table><h3 id="Scaffold-레이아웃-파일-생성"><a href="#Scaffold-레이아웃-파일-생성" class="headerlink" title="Scaffold - 레이아웃 파일 생성"></a>Scaffold - 레이아웃 파일 생성</h3><p>포스트 생성 시 Hexo는 <code>scaffolds</code> 폴더 내의 적당한 파일을 기반으로 구성하며 기본적으로 각 레이아웃 이름의 마크다운 문서 이름을 참고한다. 예를 들어 <code>hexo new post &quot;newPost&quot; </code> 라는 명령어는 <code>scaffolds/post</code> 파일의 placeholder를 사용하여 새로운 마크다운 문서를 생성할 수 있습니다.</p><p>예를 들어,  <code>scaffolds/post.md</code> 파일이 아래와 같다면,  <code>hexo new post &quot;newPost&quot; </code>  를 통해 <code>newPost.md</code> 가 생성된</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">title:</span> &#123;&#123; <span class="string">title</span> &#125;&#125;</span><br><span class="line"><span class="attr">categories:</span> &#123;&#123; <span class="string">categories</span> &#125;&#125;</span><br><span class="line"><span class="attr">tags:</span> &#123;&#123; <span class="string">tags</span> &#125;&#125;</span><br><span class="line"><span class="attr">date:</span> &#123;&#123; <span class="string">date</span> &#125;&#125;</span><br><span class="line"><span class="attr">thumbnail:</span> &#123;&#123; <span class="string">thumbnail</span> &#125;&#125;</span><br></pre></td></tr></table></figure><p>파일의 <em>placeholder</em> 는 아래와 같이 채워진다. 즉, 레이아웃에 따른 common yaml 포맷 또는 placeholder가 있다면 scaffolds의 레이아웃 폴더에 기재함으로써 편리하고 공통의 포맷을 유지할 수 있다.</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">title:</span> <span class="string">newPost</span></span><br><span class="line"><span class="attr">date:</span> <span class="number">2020-09-29 21:16:43</span></span><br><span class="line"><span class="attr">subtitle:</span> </span><br><span class="line"><span class="attr">categories:</span></span><br><span class="line"><span class="attr">tags:</span></span><br><span class="line"><span class="attr">thumbnail:</span></span><br></pre></td></tr></table></figure><h3 id="Draft에-대해서"><a href="#Draft에-대해서" class="headerlink" title="Draft에 대해서"></a>Draft에 대해서</h3><p>위에서 설명했듯이 <code>Draft</code>는 바로 게시하지 않고 작성할 수 있는 초안입니다. <code>Draft</code>를 사용하며 편리했던 점은 연속으로 게시해야 되는 포스트를 한번에 작성한 후 순차적으로 게시해야 할때 <code>hexo publish (파일 이름)</code> 명령어로 하나씩 <code>Post</code>로 발행해 배포하면 된다는 점입니다.</p><p>아래는 제가 설정했던 <code>Draft</code> 관련 설정과 명령어 입니다.</p><ul><li><p><strong><code>Draft</code>를 기본 레이아웃으로 변경하기</strong><br>_config.yml에서 <code># Writing</code>이라는 주석처리된 섹션에서 <code>default_layout</code> 필드를 초기값인 <code>post</code>에서 <code>draft</code>로 변경하면 됩니다.<br><img src="https://i.imgur.com/ziwu8zX.png" alt="스크린샷 2018-08-27 오후 7.07.45"></p></li><li><p><strong>로컬 서버에서 <code>Draft</code> 문서 띄우기</strong><br>작성 중인 Draft 문서를 확인할 수 있는데 아래와 같이 <code>--draft</code> 옵션을 주면 로컬 서버에서도 확인할 수 있습니다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo server --draft</span><br></pre></td></tr></table></figure></li></ul><h3 id="Draft-발행하기"><a href="#Draft-발행하기" class="headerlink" title="Draft 발행하기"></a>Draft 발행하기</h3><p>Draft 작성이 완료되었다면 이제 발행해야 하는데 아래의 순서와 같이 진행하면 된다.</p><ul><li><p><strong><code>Draft</code> 문서를 <code>Post</code> 레이아웃으로 변환하기</strong><br>사실 변환이라고 대단한건 아니고 그저 <code>_drafts</code> 디렉토리에서 <code>_posts</code> 디렉토리로 이동하면서 작성일시가 추가되는 것이 전부이다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo publish (Draft 이름)</span><br></pre></td></tr></table></figure></li></ul><ul><li><p><strong>배포하기</strong><br>아래 명령어를 통해 배포 가능하다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo deploy 또는 hexo g -d</span><br></pre></td></tr></table></figure></li></ul>]]></content:encoded>
      
      
      <category domain="https://joontae-kim.github.io/categories/Blog/">Blog</category>
      
      <category domain="https://joontae-kim.github.io/categories/Blog/Hexo/">Hexo</category>
      
      
      <category domain="https://joontae-kim.github.io/tags/Hexo/">Hexo</category>
      
      <category domain="https://joontae-kim.github.io/tags/Blog/">Blog</category>
      
      <category domain="https://joontae-kim.github.io/tags/draft/">draft</category>
      
      
      <comments>https://joontae-kim.github.io/2020/09/29/hexo-writing/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>Critical Rendering Path</title>
      <link>https://joontae-kim.github.io/2020/09/27/critical-rendering-path/</link>
      <guid>https://joontae-kim.github.io/2020/09/27/critical-rendering-path/</guid>
      <pubDate>Sat, 26 Sep 2020 17:50:58 GMT</pubDate>
      
        
        
      <description>&lt;p&gt;&lt;img src=&quot;/images/browser_work.png&quot;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;본 글은 &lt;a href=&quot;https://developer.mozilla.org/en-US/&quot;&gt;&lt;strong&gt;mdn web docs&lt;/strong</description>
        
      
      
      
      <content:encoded><![CDATA[<p><img src="/images/browser_work.png"></p><blockquote><p>본 글은 <a href="https://developer.mozilla.org/en-US/"><strong>mdn web docs</strong></a>의 <a href="https://developer.mozilla.org/en-US/docs/Web/Performance/Critical_rendering_path#Understanding_CRP">Critical Rendering Path</a>를 번역한 글입니다.</p></blockquote><p>현재 작성일자(2020년 9월 27일) 기준으로 아직 한글로 번역되지 않아 본 번역 포스팅을 완료하면 해당 페이지를 한국어로 옮겨놓을 예정입니다. 수정 및 보완사항이 있다면 본 포스팅 하단 댓글에 작성 부탁드립니다.</p><hr><p>브라우저 작동 원리 또는 렌더링에 관해 공부하고, 포스팅하고 싶은 마음이 있었는데 mdn에 좋은 게시물이 많이 있었고 그중 몇 가지를 연재로 번역하면서 공부해보는 시간을 가져볼려고 합니다.</p><h4 id="연재할-MDN-docs"><a href="#연재할-MDN-docs" class="headerlink" title="연재할 MDN docs"></a>연재할 MDN docs</h4><ol><li><a href="https://developer.mozilla.org/ko/docs/Web/Performance/%EB%B8%8C%EB%9D%BC%EC%9A%B0%EC%A0%80%EB%8A%94_%EC%96%B4%EB%96%BB%EA%B2%8C_%EB%8F%99%EC%9E%91%ED%95%98%EB%8A%94%EA%B0%80">Populating the page: how browsers work</a></li><li><a href="https://developer.mozilla.org/en-US/docs/Web/Performance/Critical_rendering_path#Understanding_CRP"><strong>Critical rendering path</strong></a></li></ol><hr><h1 id="중요-렌더링-경로"><a href="#중요-렌더링-경로" class="headerlink" title="중요 렌더링 경로"></a>중요 렌더링 경로</h1><p>중요 렌더링 경로 (<em>Critical Rendering Path</em>)는 브라우저가 HTML, CSS, Javascipt를 화면에 픽셀로 변화하는 일련의 단계를 말하며 이를 최적화하는 것은 렌더링 성능을 향상시킵니다. 중요 렌더링 경로는  <a href="https://developer.mozilla.org/en-US/docs/Web/API/Document_Object_Model">Document Object Model </a>(DOM), <a href="https://developer.mozilla.org/en-US/docs/Web/API/CSS_Object_Model">CSS Object Model </a>(CSSOM), 렌더 트리 그리고 레이아웃을 포함합니다.</p><p>도큐먼트 오브젝트 모델은 HTML을 분석함으로써 만들어집니다. HTML은 Javascript를 요청할 수 있으며, 이 경우 DOM 이 변경될 수 있습니다. HTML은 차례대로 CSS 오브젝트 모델을 만들기 위한 스타일에 대한 요청을 만들거나 포함합니다. 브라우저 엔진은 이 두가지를 결합하여 렌더 트리를 생성하며 레이아웃은 페이지의 모든 것에 대한 크기와 위치를 결정합니다. 일단 레이아웃이 결정되면 화면에 픽셀을 그립니다.</p><p>중요 렌더링 경로 최적화는 첫번째 렌더링의 시간을 개선시킵니다. 중요 렌더링 경로를 이해하고, 최적화 하는 것은 뛰어난 사용자 상호작용을 보장하며 버벅거림을 피할 수 있도록 하고, 1초당 60 프레임에 리플로우와 리페인트가 발생할 수 있도록 하는데 중요합니다.</p><h2 id="CRP-이해하기"><a href="#CRP-이해하기" class="headerlink" title="CRP 이해하기"></a>CRP 이해하기</h2><p>웹 성능은 서버의 요청과 응답, 로딩, 스크립팅, 렌더링, 레이아웃 그리고 화면에 픽셀 그리기를 포함합니다.</p><p>웹 페이지 또는 어플리케이션에 대한 요청은 HTML 요청으로 시작됩니다. 서버는 응답 헤더 또는 데이터로 HTML을 반환합니다. 그리고 나서 브라우저는 HTML을 분석하고 수신된 바이츠를 DOM 트리로 변환하기 시작합니다. 브라우저는 스타일시트, 스크립트 또는 포함된 이미지 참조인 외부 자원에 대한 링크를 찾을때마다 요청을 시작합니다. 불러온 에셋을 다룰 때까지 나머지 HTML을 분석하는 작업하는 일부 요청은 중단되며 차단됩니다. 브라우저는 CSS 오브젝트 모델을 구축하는 작업이 끝날때까지 요청을 만들고 DOM을 생성하는 HTML을 계속해서 분석합니다. DOM과 CSSOM이 완료되면 브라우저는 렌더 트리를 생성하고 보여지는 컨텐츠를 위해 스타일을 계산합니다. 렌더트리가 완료된 후 모든 렌더 트리 요소들에 대한 위치와 크기가 정의된 레이아웃이 만들어집니다. 일단 완료되면 레이지는 렌더링되거나 또는 화면에 ‘그려집니다(<em>painted</em>)’.</p><h3 id="Document-Object-Model"><a href="#Document-Object-Model" class="headerlink" title="Document Object Model"></a>Document Object Model</h3><p>DOM 구성은 점진적으로 증가합니다. HTML 응답은 토큰으로, 토큰은 노드로, 노드는 DOM 트리로 변환됩니다.1개의 DOM 노드는 시작태그 토큰으로 시작해서 끝태그 토큰으로 끝납니다. 노드들은 HTML 요소에 대한 모두 연관성 있는 정보를 포함하고 있습니다. 그 정보는 토큰을 통해 설명됩니다. 노드들은 토큰의 위계서열을 기반으로 DOM 트리안에 연결됩니다. 만약 또 다른 시작태그와 끝태그의 묶음이 한 세트의 시작태그와 끝태그 사이에 있다면, 여러분은 DOM 트리의 위계서열을 정의하는 방법으로 노드 안에 노드를 가지게 됩니다.</p><p>많은 수의 노드는 중요 렌더링 경로에서 다음의 이벤트를 더 오래 발생시킬 것입니다. 측정하세요! 몇 개의 추가 노드는 차이를 만들지 않지만 전염은 버벅거림을 유발할 수 있습니다.</p><h3 id="CSS-Object-Model"><a href="#CSS-Object-Model" class="headerlink" title="CSS Object Model"></a>CSS Object Model</h3><p>DOM은 페이지의 모든 컨텐츠를 포함하고, CSSOM은 DOM을 스타일링 하기 위한 페이지의 모든 스타일 정보를 포함합니다. CSSOM은 DOM과 유사하지만 다릅니다. DOM의 구조는 점진적으로 증가하는 반면에 CSSOM은 그렇지 않습니다. CSS는 렌더링을 막습니다: 브라우저는 모든 CSS를 처리하고 수신할때까지 페이지 렌더링을 막습니다. CSS는 규칙을 덮어쓸수 있기 때문에 렌더링을 막습니다. 그러므로 CSSOM이 완료될때까지 콘텐츠를 렌더링 할 수 없습니다.</p><p>CSS는 유효한 토크들은 인식하기 위해 스스로 규칙 세트를 가지고 있습니다. CSS의 C가 ‘Cascade(종속 또는 폭포)’라는 의미를 기억해두세요. CSS 규칙은 아래로 종속됩니다. 분석기는 토큰을 노드로 변환할때, 하위 노드가 스타일을 상속합니다. 연속적인 규칙들이 이전의 규칙들에 덮어쓰여질 수 있기 때문에, 증감 처리 기술은 HTML 처럼 CSS에 적용되지는 않습니다. CSS 개체 모델은 CSS를 분석할 때 빌드되지만 나중에 분석되 덮어쓸 스타일들은 화면에 렌더링 할 수 없기 때문에 완전히 분석될 때까지 렌더 트리를 생성하는데 사용할 수 없습니다. </p><p>선택자 성능 측면에서, 덜 구체적인 선택자는 더 구체적인 선택자보다 더 빠릅니다. 예를 들어, 브라우저가 <code>.foo</code> 찾을때,  <code>.foo &#123;&#125;</code> 는  <code>.bar .foo &#123;&#125;</code> 보다 빠릅니다. 왜냐하면 두번째 시나리오에서, <code>.foo</code> 가 부모 객체인 <code>.bar</code> 를 가지고 있는지 확인하기 위해 DOM을 거슬러 올라가기 때문입니다. 더 구체적인 태그는 브라우저에게 더 많은 작업을 요구하지만 이러한 패널티는 최적화 할 가치가 없습니다.</p><p>만약 CSS 분석 시간을 측정한다면, 브라우저들이 정말 빠르다는 것에 놀랄 것입니다. 규칙이 구체적일수록 DOM 트리 안에서 더 많은 노드들은 지나야 하기 때문에 더 높은 비용이 듭니다. 그러나 추가적인 비용은 일반적으로 최소입니다. 첫번째는 측정입니다. 필요할때 최적화하세요. 특정 짓는 것은 쉬운 일이 아닙니다. CSS 측면에서, 선택자 성능 최적화와 개선은 오직 microsecond 밖에 되지 않될 것입니다. 축소화와 미디어 쿼리를 사용함으로써 지연된 CSS를 논-블로킹 요청으로 분리하는 것과 같은 <a href="https://developer.mozilla.org/en-US/docs/Learn/Performance/CSS_performance">CSS 최적화</a>를 위한 다른 방법이 있습니다.</p><h3 id="렌더-트리"><a href="#렌더-트리" class="headerlink" title="렌더 트리"></a>렌더 트리</h3><p>렌터 트리는 콘텐츠와 스타일 둘다 캡쳐합니다. DOM과 CSSOM 트리는 렌더 트리에 결합됩니다. 렌더 트리를 구성하기 위해 브라우저는 DOM 트리의 root에서 시작해 모든 노드는 확인하면서 어떤 CSS 규칙들을 첨부할지 결정합니다.</p><p>렌더 트리는 오직 보여지는 콘텐츠만은 캡쳐합니다. (일반적으로) 헤드 섹션은 보여지는 정보를 포함하고 있지 않으므로 렌더트리 안에 포함되지 않습니다. 만약 요소에 <code> display: none</code> 이 적용되어 있다면, 해당 요소 또는 하위 요소는 포함되지 않습니다.</p><h3 id="레이아웃"><a href="#레이아웃" class="headerlink" title="레이아웃"></a>레이아웃</h3><p>일단 렌더 트리가 생성되고 나면, 레이아웃은 가능해지며 화면의 크기에 의존합니다. 레이아웃 단계는 요소들이 페이지에서 배치되는 위치와 방법, 각 요소의 너비와 높이 그리고 서로 관련된 위치를 결정합니다.</p><p>요소의 너비는 무엇일까요? 정의에 따르면, 블럭 수준의 요소들은 그 부모 너비의 기본 너비값의 100% 입니다. 50%의 너비를 갖는 요소는 부모 요소의  절반일 것입니다. 비록 그렇게 정의되어 있지 않더라고, <code>body</code> 는 뷰포트 너비의 100%를 의미하는 너비 입니다. 디바이스의 너비는 레이아웃에 영향을 미칩니다.</p><p>뷰포트 메타 태그는 레이아웃에 영향을 미치는 뷰포트 레이아웃의 너비로 정의합니다. 이 태그 없다면, 브라우저는 뷰포트 기본값을 사용합니다. 브라우저의 full screen 기본값은 일반적으로 960px 입니다. 기본적으로 브라우저의 full screen에서, 스마트폰의 브라우저와 같은 너비는 <code>&lt;meta name=&quot;Viewport&quot; content=&quot;width=device-witdh&quot;&gt;</code> 로 세팅함으로써 기본 뷰포트 너비 대신에 디바이스의 너비를 사용합니다. 디바이스 너비는 사용자가 디비이스를 가로(landscapre) 또는 세로(portrait) 모드 사이로 돌릴때마다 바뀝니다. 레이아웃은 디바이스가 회전하거나 브라우저의 사이즈가 조정될 때마다 발생합니다.</p><p>레이아웃 성능은 DOM의 영향을 받습니다. 노드의 수가 많을수록 레이아웃은 더 길어지며 스크롤링 또는 다른 애니메이션들이 필요하다면 레이아웃에 쟁크(jank)를 일으키는 병목현상이 발생할 수 있습니다. 로딩 또는 방향 전환에 20ms 정도 밀릴 수 있지만 애니메이션 또는 스크롤에 쟁크(jank) 유발할 수 있습니다. 노드에 박스 모델 업데이트, 콘텐츠 대체 그리고 노드 추가와 같은 수정은 언제든지 렌더 트리를 수정할 수 있으며 레이아웃을 형성합니다. 레이아웃 이벤드의 반복과 형성시간을 줄이기 위해서 일괄 업데이트 해야하고, 박스 모델 속성을 애니메이션화 하지 말아야 합니다.</p><h3 id="페인트"><a href="#페인트" class="headerlink" title="페인트"></a>페인트</h3><p>마자믹 단계는 화면에 픽셀을 그리는 것입니다. 일단 렌더 트리가 생성되고 레이아웃나 나타나기 시작하면, 화면에 픽셀을 그릴수 있습니다. 로드시, 전체 화면을 그립니다. 그 후에는 브라우저가 필요한 최소 영역만을 다시 그리도록 최적화되어 있기 때문에 영향을 받는 영역만을 화면에 다시 그립니다. 그리는 시간은 렌터 트리에 적용되는 업데이트의 종류가 무엇있냐에 따라 달라집니다. 페인팅인 매우 빠르게 진행되는 과정이기 때문에 성능 향상에 집중해야 하는 가장 큰 영향있는 부분이 아닐 수 있지만, 애니메이션 프레임 소요시간을 측정할때, 레이아웃과 리페인트 시간을 모두 고려하는 것이 중요합니다. 각 노드에 적용된 스타일은 페인트 시간을 증가시키지만 페인트 시간을 0.001ms 증가시키는 스타일을 제거하는 것은 여러분의 최적화 비용이 매우 커지는 것을 막지 못할 수 있습니다. 첫째는 측정하는 것을 기억하고, 최적화 우선순위를 정해야할지 말지를 결정해야 합니다.</p><h2 id="CRP-최적화"><a href="#CRP-최적화" class="headerlink" title="CRP 최적화"></a>CRP 최적화</h2><p>자원 로드 순서를 관리하고, 파일 사이즈를 줄이며 어떤 자원을 먼저 로드할지 정함으로써 페이지 로드 속도를 개선하세요. 성능 팁으로는 1) 자원 다운로드를 연기함으로써 중요 자원들의 수를 최소화하기 , 2) 각 요청에 대한 파일 사이즈에 따라 필수적인 요청 횟수 최적하하기, 3) 다운받을 중요 에셋의 우선순위를 정함으로써 중요 자원 불러오는 순서 최적화하고, 중요 경로 길이 최소화하기</p>]]></content:encoded>
      
      
      <category domain="https://joontae-kim.github.io/categories/Web/">Web</category>
      
      <category domain="https://joontae-kim.github.io/categories/Web/Browser/">Browser</category>
      
      
      <category domain="https://joontae-kim.github.io/tags/mdn/">mdn</category>
      
      <category domain="https://joontae-kim.github.io/tags/Browser/">Browser</category>
      
      <category domain="https://joontae-kim.github.io/tags/Rendering/">Rendering</category>
      
      <category domain="https://joontae-kim.github.io/tags/Critical-Rendering-path/">Critical Rendering path</category>
      
      
      <comments>https://joontae-kim.github.io/2020/09/27/critical-rendering-path/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>페이지 채우기: 브라우저가 작동하는 방법 - 2</title>
      <link>https://joontae-kim.github.io/2020/09/25/browser-work-2/</link>
      <guid>https://joontae-kim.github.io/2020/09/25/browser-work-2/</guid>
      <pubDate>Fri, 25 Sep 2020 10:14:46 GMT</pubDate>
      
        
        
      <description>&lt;p&gt;&lt;img src=&quot;/images/browser_work.png&quot;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;본 글은 &lt;a href=&quot;https://developer.mozilla.org/en-US/&quot;&gt;&lt;strong&gt;mdn web docs&lt;/strong</description>
        
      
      
      
      <content:encoded><![CDATA[<p><img src="/images/browser_work.png"></p><blockquote><p>본 글은 <a href="https://developer.mozilla.org/en-US/"><strong>mdn web docs</strong></a>의 <a href="https://developer.mozilla.org/en-US/docs/Web/Performance/How_browsers_work">Populating the page: how browsers work</a>를 번역한 글입니다.</p></blockquote><p>현재 작성일자(2020년 9월 25일) 기준으로 아직 한글로 번역되지 않아 본 번역 포스팅을 완료하면 해당 페이지를 한국어로 옮겨놓을 예정입니다. 수정 및 보완사항이 있다면 본 포스팅 하단 댓글에 작성 부탁드립니다.</p><hr><p>브라우저 작동 원리 또는 렌더링에 관해 공부하고, 포스팅하고 싶은 마음이 있었는데 mdn에 좋은 게시물이 많이 있었고 그중 몇 가지를 연재로 번역하면서 공부해보는 시간을 가져볼려고 합니다.</p><h4 id="연재할-MDN-docs"><a href="#연재할-MDN-docs" class="headerlink" title="연재할 MDN docs"></a>연재할 MDN docs</h4><ol><li><a href="https://developer.mozilla.org/ko/docs/Web/Performance/%EB%B8%8C%EB%9D%BC%EC%9A%B0%EC%A0%80%EB%8A%94_%EC%96%B4%EB%96%BB%EA%B2%8C_%EB%8F%99%EC%9E%91%ED%95%98%EB%8A%94%EA%B0%80"><strong>Populating the page: how browsers work</strong></a></li><li><a href="https://developer.mozilla.org/en-US/docs/Web/Performance/Critical_rendering_path#Understanding_CRP">Critical rendering path</a></li></ol><hr><h1 id="페이지-채우기-브라우저-작동원리"><a href="#페이지-채우기-브라우저-작동원리" class="headerlink" title="페이지 채우기: 브라우저 작동원리"></a>페이지 채우기: 브라우저 작동원리</h1><p>사용자들은 컨텐츠가 빠르게 로드되고 상호작용이 부드러운 웹 경험을 원합니다. 그러므로 개발자들은 이 두가지 목표를 성취하기 위해서 노력해야만 합니다.</p><p>성능과 감지된 성능을 개선하는 방법을 이해하기 위해서는 브라우저가 어떻게 동작하는지 이해하는 것이 도움을 줄 수 있습니다.</p><br><h2 id="파싱-Parsing"><a href="#파싱-Parsing" class="headerlink" title="파싱 (Parsing)"></a>파싱 (Parsing)</h2><p>일단 브라우저가 첫번째 데이터 청크를 받고나면, 받은 정보를 분석하기 시작합니다. <a href="https://developer.mozilla.org/en-US/docs/Glossary/speculative_parsing">Parsing</a> 은 네트워크를 통해 전송된 데이터를 <a href="https://developer.mozilla.org/en-US/docs/Glossary/DOM">DOM</a> 과 <a href="https://developer.mozilla.org/en-US/docs/Glossary/CSSOM">CSSOM</a> 으로 변환해야할 단계이며, 렌더러가 화면에 페이지를 그리는데 사용됩니다.</p><p>DOM은 브라우저의 마크업을 내부적으로 표현한 것입니다. 또한, 외부적으론 Javascript에서 다양한 API들을 통해 재생산될 수도 있습니다.</p><p>비록 요청된 페이지의 HTML 사이즈가 초기 14KB 패킷보다 훨씬 클지라도, 브라우저는 분석을 시작할 것이며 데이터를 기반으로 경험을 렌더링하려고 시도할 것입니다. 웹 퍼포먼스 최적화가 중요한 이유는 브라우저가 페이지 또는 적어도 페이지의 템플릿(첫 번째 렌더링에 필요한 CSS와 HTML)을 렌더링하기 위해 필요한 모든 것을 초기 14kb 안에 포함해야 하기 때문입니다. 그러나 화면에 어떠한 것이든 렌더링하기 전에 HTML, CSS 그리고 Javascript를 분석해야만 합니다.</p><h3 id="DOM-트리-구성하기-Building-the-DOM-tree"><a href="#DOM-트리-구성하기-Building-the-DOM-tree" class="headerlink" title="DOM 트리 구성하기(Building the DOM tree)"></a>DOM 트리 구성하기(Building the DOM tree)</h3><p>우리는 <a href="https://developer.mozilla.org/en-US/docs/Web/Performance/Critical_rendering_path">중요 렌더링 경로</a> 에 5 단계로 설명해놨습니다.</p><p>첫 번째 단계로 HTML 마크업을 처리하고 DOM 트리를 구성하는 것입니다. HTML 파싱은  <a href="https://developer.mozilla.org/en-US/docs/Web/API/DOMTokenList">tokenization</a> 과 트리 구조를 포함합니다. HTML 토큰은 속성(attribute) 이름과 값 뿐만 아니라 태크의 시작과 끝을 포함하고 있습니다.  만약 도큐먼트(document)가 잘 짜여져 있다면, 파싱은 간단하고 더 빠르게 될 것입니다. 분석기(Parser)는 도큐먼트 내에 도큐먼트 트리로 구성되어진 토큰 처리된 input을 분석합니다.</p><p>DOM 트리는 도큐먼트의 컨텐츠를 설명합니다. <code>&lt;html&gt;</code> 요소는 첫번째 태그이자 도큐먼트 트리의 root 노드이며  다른 태그들 사이에서 관계성과 위계구조를 반영해줍니다. 다른 태그들 사이에 중첩된 태그들은 자식 노드들입니다. DOM 노드의 수가 많을수록 DOM 트리를 구조화하는 시간은 더 소요됩니다.</p><p><img src="https://mdn.mozillademos.org/files/16759/DOM.gif"></p><p>분석기가 이미지와 같은 비차단(non-blocking) 자원을 찾으면 브라우저는 이 자원을 요청하고 계속해서 분석합니다. 파싱은 CSS file을 만났을때도 계속되지만 특히 <code> async</code> 또는 <code> defer</code> 속성이 없는  <code>&lt;script&gt;</code> 태그를 만났을 경우에는 렌더링을 멈추고 HTML 파싱을 중단합니다. 비록 브라우저의 프리로드(preload) 스캐너가 이 과정을 가속화하지만 과도한 스크립트는 여전히 심각한 병목현상이 될 수 있습니다.</p><h3 id="Preload-scanner"><a href="#Preload-scanner" class="headerlink" title="Preload scanner"></a>Preload scanner</h3><p>브라우저가 DOM 트리를 구성하는 동안, 이 프로세스는 메인 스레드에서 발생합니다. 이 현상 때문에 <em>Preload scanner</em> 는 사용 가능한 콘텐츠를 분석하고 CSS, Javascript 그리고 웹 폰트와 같은 선순위의 자원을 요청합니다. Preload scanner 덕분에 우리는 분석기가 선순위의 자원을 요청하기 위해 외부 자원에 대한 참조를 찾을때까지 대기하고 있지 않습니다. 메인 HTML 분석기가 요청된 에셋에 도달할 때에는 이미 전송중이거나 또는 이미 다운로드 되었을 수 있도록 백그라운드에서 자원을 획득할 것입니다. Preload scanner의 최적화는 차단시간을 줄여줍니다.</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">src</span>=<span class="string">&quot;styles.css&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;myscript.js&quot;</span> <span class="attr">async</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;myimage.jpg&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;image description&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;anotherscript.js&quot;</span> <span class="attr">async</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>이와 같이, 메인 스레드가 HTML, CSS를 분석하는 동안 Preload scanner는 스크립트와 이미지를 검색할 것이고 다운로드 받기 시작할 것입니다. 스크립트가 DOM 트리 구성 프로세스를 막지 않도록 보장하기 위해, 만약 Javascript 파싱 또는 실행 순서가 중요하지 않다면 <code>async</code> 또는 <code>defer</code> 속성을 추가해야 합니다.</p><p>CSS를 받기 위해 대기하는 것은 HTML 분석 또는 다운로딩은 막지 않지만 Javascript는 종종 HTML 요소에서 CSS 속성을 조회하는데 영향을 끼치기 때문에 막습니다.</p><h3 id="CSSOM-구성하기"><a href="#CSSOM-구성하기" class="headerlink" title="CSSOM 구성하기"></a>CSSOM 구성하기</h3><p>중요 렌더링 경로의 두번째 단계는 CSS를 처리하고 CSSOM 트리를 구성하는 것입니다.  DOM과 CSSOM은 둘다 트리 구조로, CSS object model은 DOM과 유사합니다. 이 둘은 독립적인 데이터 구조이며 브라우저는 CSS 규칙을 이해할 수 있고 작동할 수 있는 스타일 맵으로  변환합니다. 브라우저는 CSS의 각 규칙 세트를 거치면서 CSS 선택자를 기반으로 부모, 자식 그리고 형제 관계에 있는 노드의 트리를 만듭니다.</p><p>HTML도 마찬가지로, 브라우저는 수신된 CSS 규칙을 무언가를 작업할 수 있는 것으로 변환해야 합니다. 따라서, HTML-to-object 프로세스를 반복하지만 CSS 또한 반복합니다. </p><p>CSSOM 트리는 유저 에이전트 스타일시트의 스타일을 포함합니다. 브라우저는 노드에 적용가능한 가장 일반적인 규칙으로 시작하고 보다 구체적인 규칙을 적용함으로써 계산된 스타일을 반복적으로 재조정합니다. 다르게 말해, 속성값은 계단식을 표현됩니다.</p><p>CSSOM 구축은 매우 매우 빠르고 현재 개발자 도구에서 단일 색상으로 표시되지 않습니다. 대신 개발자 도구의 “보정된 스타일”은 CSS를 분석하고, CSSOM 트리를 구축하며 회귀적으로 처리된 스타일을 계산하기 위한 모든 시간을 보여줍니다. CSSOM을 만드는 시간이 일반적으로 한개의 DNS 조회를 위해 걸리는 시간보다 덜 걸리기 때문에 웹 퍼포먼스 최적화의 측면에서는 더 쉽다.</p><h3 id="다른-프로세스들"><a href="#다른-프로세스들" class="headerlink" title="다른 프로세스들"></a>다른 프로세스들</h3><h4 id="자바스크립트-컴파일"><a href="#자바스크립트-컴파일" class="headerlink" title="자바스크립트 컴파일"></a>자바스크립트 컴파일</h4><p>CSS가 분석되고, CSSOM이 만들어지는 동안 자바스크립 파일을 포함한 다른 에셋들을 다운로드하고 있을 것입니다.(preload scanner 덕분에). 자바스크립트는 해석되고, 변환되며 분석한 후 실행됩니다. 스크립트는 추상적인 문법 트리안에서 분석되고 몇몇의 브라우저 엔진들은 <em>Abstract Syntax Tree(추상적 문법 트리)</em> 를 가지고 있으며 이를 인터프리터 안으로 전달하여 메인 쓰레드에서 실행할 바이트 코드를 출력합니다.</p><h4 id="접근성-트리-구성하기"><a href="#접근성-트리-구성하기" class="headerlink" title="접근성 트리 구성하기"></a>접근성 트리 구성하기</h4><p>브라우저는 또한 보조 장치가 콘텐츠를 분석하고 해석하기 위해 사용되는 접근성 트리를 구성합니다. 접근성 오브젝트 모델(The accessibility object model, AOM)은 DOM의 시멘틱 버전과 같습니다. 브라우저는 DOM이 업데이트 될때 접근성 트리도 업데이트 합니다. 접근성 트리는 보조 기술 그 자체로는 수정할 수 없다. AOM이 구성될떄, 콘텐츠는 <a href="https://developer.mozilla.org/en-US/docs/Web/Accessibility/ARIA/ARIA_Screen_Reader_Implementors_Guide">screen reader</a>에서 접근할 수 없습니다.</p><br><h2 id="렌더-Render"><a href="#렌더-Render" class="headerlink" title="렌더(Render)"></a>렌더(Render)</h2><p>렌더링 단계는 스타일, 레이아웃, 그리기 그리고 경우에 따라서 합성(compositing)하는 것을 포함합니다. 파싱 단계에서 생성된 CSSOM과 DOM 트리들은 렌더 트리에서 결합되며, 렌더 크리는 표시되는 모든 요소의 레이아웃을 처리하는데 사용되며 화면을 그립니다. 몇 가지 경우에 따라서, 콘텐츠를 그들 스스로의 레이어로 승격하고 합성할 수 있으며 CPU 대신 GPU에서 화면의 일부를 그림으로써 메인 스레드를 확보하여 성능을 향상시킬 수 있습니다.</p><h3 id="스타일"><a href="#스타일" class="headerlink" title="스타일"></a>스타일</h3><p>주요 렌더링 경로의 세번째 단계는 렌더 트리 안에서 DOM과 CSSOM을 결합하는 것입니다. 계산된 스타일 트리 또는 렌더 트리 구조는 각각의 표시되는 노드를 가로지르는 DOM 트리의 root로 시작됩니다.</p><p> <code>&lt;head&gt;</code> 와 같은 보여지지 않는 태그들과 이 자식 노드들 그리고 유저 에이전트 스타일시트에서 찾아볼수 있는  <code>script &#123; display: none; &#125;</code> 와 같이 <code>display: none</code> 으로 설정되어 있는 특정 노드들은 그들은 렌더된 결과물로써 나타나지 않을것이기 때문에 렌더 트리에 포함되지 않습니다. <code>visibility: hidden</code> 가 적용된 노드들은 공간을 차지함으로써 렌더 트리안에 포함됩니다. 우리는 유저 에이전트 기본값을 덮어쓰기 위한 어떠한 지시사항도 주지 않으므로, 위의 코드 예제에서 <code>script</code> 노드는 렌더 트리에 포함되지 않을 것입니다.</p><p>각각의 표시되는 노드들은 적용되는 CSSOM 규칙을 가지고 있습니다. 렌더 트리는 계산된 스타일과 컨텐츠와 함께 표시되는 모든 노드들을 보유하고 있습니다. DOM 트리 안에서 표시되는 모든 노드에 모든 관련 스타일들을 일치시키고, <a href="https://developer.mozilla.org/en-US/docs/Web/CSS/Cascade">CSS cascade</a> 를 기반으로 계산된 스타일들을 결정합니다. </p><h3 id="레이아웃"><a href="#레이아웃" class="headerlink" title="레이아웃"></a>레이아웃</h3><p>주요 렌더링 경로의 네번째 단계는 각 노드의 위치를 계산하기 위해 렌더 트리에서 레이아웃을 작동시키는 것입니다. <em>레이아웃</em> 은 너비, 높이 그리고 렌더 트리 안에서 모든 노드들의 위치를 결정하는 과정이며 페이지 안에서 각 오브젝트의 크기와 위치에 대한 결정도 추가됩니다. <em>리플로우</em> 페이지의 특정 부분 또는 전체 도큐먼트의 어떤 연속적인 크기와 위치에 대한 결정입니다.</p><p>일단 렌터 트리가 구성되나면 레이아웃이 시작됩니다.</p><p>렌더 트리는 (심지어 보이지 않을지라도) 각 노드들의 계산된 스타일들에 따라 어떤 노드들을 배치할지 인식하지만 각 노드의 차원이나 위치는 아닙니다. 각 오브젝트의 정확한 사이즈나 위치를 결정하기 위해서 브라우저는 렌더 트리의 root에서 시작하며 순회합니다.</p><p>웹 페이지 상에서 대부분의 것들은 상자입니다. 디바이스와 데스크탑의 기본 설정이 다르면 뷰포트 크기가 무제한으로 달라질 수 있습니다. 이 단계에선 뷰포트 크기를 고려하여 브라우저가 화면에 표시되는 다양한 상자의 크기를 결정합니다. 뷰포트의 크기를 기준으로 하여 일반적으로 레이아웃은 본문에서 시작하여 각 요소의 박스 모델 속성들에 따라 본문의 모든 하위 자식의 치수를 나열하고, 이미지와 같이 치수를 알지 못하는 대체될 요소를 위해 플레이스홀더 공간을 제공합니다.</p><p>노드들의 크기와 위치가 처음으로 결정되면 <em>레이아웃 (layout)</em> 이라고 부른다. 노드 사이와 위치에 대한 연속적인 재계산을 <em>리플로우 (reflow)</em> 라고 부른다. 예를 들어, 초기 레이아웃은 이미지를 불러오기 전에 발생한다고 할 수 있다. 왜냐하면 우리는 이미지의 크기를 결정할 수 없기 때문에, 일단 이미지의 사이즈를 알았을때 리플로우 될 것입니다.</p><h3 id="페인트"><a href="#페인트" class="headerlink" title="페인트"></a>페인트</h3><p>주요 렌더링 경로의 마지막 단계로 화면에서 <a href="https://developer.mozilla.org/en-US/docs/Glossary/first_meaningful_paint">first meaningful paint</a> 라 불리는 첫번째 현상으로, 각 노드들을 그리는 것입니다. 페인팅 또는 레스터화 단계에서 브라우저는 레이아웃 단계에서 처리된 각 박스를 실제 픽셀로 변환합니다. 페인팅은 화면에서 텍스트, 색깔, 선, 그림자 그리고 버튼이나 이미지와 같은 대체되는 요소들을 포함하는 보여지는 모든 요소를 그리는 것을 포함합니다. 브라우저는 이것을 매우 빠르게 할 필요가 있습니다.</p><p>부드러운 스크롤링과 애니메이션을 보장하기 위해서 리플로우와 페인트에 따라 스타일 계산을 포함해 메인 스레드가 담당하는 모든 것이 브라우저에서 16.67ms 미만으로 처리되어야만 한다. 2048 X 1536 크기에서는, iPad는 스크린에 페인트 하기 위해서 3,145,000 이상의 픽셀을 가지고 있으며 매우 빨리 페인트 되어야 하는 많은 픽셀입니다. 리페인팅이 초기 페인트보다 훨씬 빠르게 끝내는 것을 보장하기 위해 일반적으로 스크린에 그리는 것을 몇개의 레이어로 나누고 이를 위해 컴포지팅(compositing)이 필수적입니다.</p><p>페인팅은 레이아웃 트리의 요소를 레이어로 나눌 수 있으며 콘텐츠를 CPU의 메인 스레드가 아닌 GPU의 레이어로 승격하면 페인트 및 리페인트 성능이 향상됩니다. 레이어를 인스턴스화 하는 특정 특성과 요소가 있으며 이는  <code>&lt;video&gt;</code> 와 <code>&lt;canvas&gt;</code>, 그리고  CSS 속성 중 <code>opacity</code> 또는 3D <code>transform</code>, <code>will-change</code> 그리고 몇 안되는 다른 요소들을 포함합니다. 이러한 노드는 하위 항목이 위의 이유 중 하나 (또는 그 이상)로 인해 자체 레이어를 필요로하지 않는 한 하위 항목과 함께 자체 레이어에 페인팅됩니다.</p><p>레이어들은 성능을 개선하지만 메모리 관리에 있어서는 비용이 따릅니다. 따라서, 웹 성능 최적화 전략의 한 부분으로써 과도하게 사용하지 말아야만 한다.</p><h3 id="컴포지팅"><a href="#컴포지팅" class="headerlink" title="컴포지팅"></a>컴포지팅</h3><p>도큐먼트의 섹션들이 서로 겹쳐서 서로 다른 레이어에서 그려질 때, 컴포지팅은 화면상에서 올바른 순서로 그려지고 콘텐츠가 올바르게 렌더링 되도록 보장하는 것이 필수적입니다.</p><p>페이지가 에셋들을 계속해서 불러옴으로써 리플로우가 발생될 수 있다(예제에서 늦게 도착한 이미지를 다시 호출하기 위해).  리플로우는 리페인팅과 리컴포지 하도록 합니다. 만약 우리가 이미지의 크기를 정했다면, 리플로우는 필요하지 않을 것이며 오직 리페인팅될 필요가 있는 레이어를 리페인팅할 것이며 필요할 경우 합성할 수 있습니다. 그러나 우리는 이미지 크기를 포함하고 있지 않습니다! 그 이미지가 서버에서 받았을때 렌더링 과정은 레이아웃 스텝 다시 돌아가고 다시 시작한다.</p><br><h2 id="상호운용성"><a href="#상호운용성" class="headerlink" title="상호운용성"></a>상호운용성</h2><p>일단 메인 쓰레드가 페이지 그리기를 완료하면, 여러분은 “모든 것”을 갖췄다고 생각했겠지만, 꼭 그런것만은 아닙니다. 만약 불러오기에 정확하게는 지연되고 오직 <code>onload</code> 이벤트에 후에 실행되는 자바스크립트를 포함하고 있을 경우, 메인 스레드는 바빠지고 스크롤링, 터치 그리고 다른 상호작용은 불가능해질지도 모른다.</p><p><a href="https://developer.mozilla.org/ko/docs/Glossary/Time_to_Interactive">Time to Interactive</a> (TTI)는 페이지가 상호작용할때 DNS 조회와 SSL 연결에 의한 첫번째 요청에서 <a href="https://developer.mozilla.org/ko/docs/Glossary/First_Contentful_Paint">First Contentful Paint</a> 이후로 50ms 안에 즉시 페이지가 상호작용할때 까지의 시간을 측정한 것입니다. 만약 메인 스레드가 분석, 컴파일링 그리고 자바스크립트 실행까지 담당하고 있다면 이것은 가능하지 않으며 (50ms 미만으로) 제때에 사용자 상호작용에 반응할 수 없습니다.</p><p>예를 들어, 아마 이미지가 빠르게 로드 되었다 할지라도,  <code>anotherscript.js</code> 파일은 2MB이고 사용자의 네트워크 연결은 느려졌다. 이러한 경우 사용자는 페이지를 매우 빠르게 볼수 있었겠지만 스크립트가 다운로드 될때까지 잰크(jank) 없이는 스크롤할 수 없을 것이고, 좋지 못한 사용자 경험이 됩니다. WebPageTest 예제에서 설명하듯 메인 스레드를 차지하는 것을 피해야 합니다.</p><p><img src="https://mdn.mozillademos.org/files/16760/visa_network.png"></p><p>이 예제의 DOM 콘텐츠 로드 과정은 1.5 초 이상 소요됐고 메인 스레드는 전체 시간동안 가득 찼으며 스크린 탭 또는 클릭 이벤트에 반응하지 않습니다.</p>]]></content:encoded>
      
      
      <category domain="https://joontae-kim.github.io/categories/Web/">Web</category>
      
      <category domain="https://joontae-kim.github.io/categories/Web/Browser/">Browser</category>
      
      
      <category domain="https://joontae-kim.github.io/tags/mdn/">mdn</category>
      
      <category domain="https://joontae-kim.github.io/tags/Browser/">Browser</category>
      
      
      <comments>https://joontae-kim.github.io/2020/09/25/browser-work-2/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>페이지 채우기: 브라우저가 작동하는 방법 - 1</title>
      <link>https://joontae-kim.github.io/2020/09/25/browser-work/</link>
      <guid>https://joontae-kim.github.io/2020/09/25/browser-work/</guid>
      <pubDate>Fri, 25 Sep 2020 06:54:56 GMT</pubDate>
      
        
        
      <description>&lt;p&gt;&lt;img src=&quot;/images/browser_work.png&quot;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;본 글은 &lt;a href=&quot;https://developer.mozilla.org/en-US/&quot;&gt;&lt;strong&gt;mdn web docs&lt;/strong</description>
        
      
      
      
      <content:encoded><![CDATA[<p><img src="/images/browser_work.png"></p><blockquote><p>본 글은 <a href="https://developer.mozilla.org/en-US/"><strong>mdn web docs</strong></a>의 <a href="https://developer.mozilla.org/en-US/docs/Web/Performance/How_browsers_work">Populating the page: how browsers work</a>를 번역한 글입니다.</p></blockquote><p>현재 작성일자(2020년 9월 25일) 기준으로 아직 한글로 번역되지 않아 본 번역 포스팅을 완료하면 해당 페이지를 한국어로 옮겨놓을 예정입니다. 수정 및 보완사항이 있다면 본 포스팅 하단 댓글에 작성 부탁드립니다.</p><hr><p>브라우저 작동 원리 또는 렌더링에 관해 공부하고, 포스팅하고 싶은 마음이 있었는데 mdn에 좋은 게시물이 많이 있었고 그중 몇 가지를 연재로 번역하면서 공부해보는 시간을 가져볼려고 합니다.</p><h4 id="연재할-MDN-docs"><a href="#연재할-MDN-docs" class="headerlink" title="연재할 MDN docs"></a>연재할 MDN docs</h4><ol><li><a href="https://developer.mozilla.org/ko/docs/Web/Performance/%EB%B8%8C%EB%9D%BC%EC%9A%B0%EC%A0%80%EB%8A%94_%EC%96%B4%EB%96%BB%EA%B2%8C_%EB%8F%99%EC%9E%91%ED%95%98%EB%8A%94%EA%B0%80"><strong>Populating the page: how browsers work</strong></a></li><li><a href="https://developer.mozilla.org/en-US/docs/Web/Performance/Critical_rendering_path#Understanding_CRP">Critical rendering path</a></li></ol><hr><h1 id="페이지-채우기-브라우저-작동원리"><a href="#페이지-채우기-브라우저-작동원리" class="headerlink" title="페이지 채우기: 브라우저 작동원리"></a>페이지 채우기: 브라우저 작동원리</h1><p>사용자들은 컨텐츠가 빠르게 로드되고 상호작용이 부드러운 웹 경험을 원합니다. 그러므로 개발자들은 이 두가지 목표를 성취하기 위해서 노력해야만 합니다.</p><p>성능과 감지된 성능을 개선하는 방법을 이해하기 위해서는 브라우저가 어떻게 동작하는지 이해하는 것이 도움을 줄 수 있습니다.</p><br><h2 id="개요"><a href="#개요" class="headerlink" title="개요"></a>개요</h2><p>빠른 사이트들은 더 나은 사용자 경험을 제공한다. 사용자들은 컨텐츠와 함께 빠르게 로드되고 상호작용이 부드러운 웹 경험을 예상하고 바랍니다.</p><p>웹 퍼포먼스에서 두가지 주요한 이슈로는 지연시간(latency)에서 경험하게 될 이슈와 브라우저가 단일 쓰레드로서 갖는 주요한 사실에서 갖는 이슈들입니다.</p><p>지연시간은 빠른 로드를 보장하기 위해 극복해야하는 우리의 주요한 위협입니다. 로드을 빠르게 하기 위해 개발자의 목표로는 가능하 한 빠르게 또는 적어도 보기에 매우 빠른 속도로 요청된 정보를 보내는 것을 포함함니다. 네트워크 지연은 바이트(bytes)를 무선에서 컴퓨터로 전송하는 시간을 얘기합니다. 웹 퍼포먼스는 가능한 한 빠르게 페이지 로드가 될 수 있도록 우리가 해야만 하는  가능한 빠르게 되도록 우리가 해야 하는 것입니다.</p><p>대부분은 브라우저들은 단일 쓰레드로 간주됩니다. 부드러운 상호작용을 위해 개발자들의 목표는 부드러운 스크롤링에서부터 터치에 반응하는 것까지 효율적인 사이트 상호작용을 보장하는 것입니다. 렌더링 시간의 핵심은 우리가 부여한 모든 작업을 메인 쓰레드가 완료할 수 있도록 보장하는 것과 항상 사용자 상호작용에  대처할 수 있도록 하는것입니다. 웹 퍼포먼스는 브라우저의 단일 쓰레드의 성질을 이해하고, 메인 쓰레드의 업무를 부드러운 렌더링과 상호작용에 즉시 반응할 수 있도록 보장하기 위해 가능한 그리고 적절한 범위내로 최소화함으로써 개선할 수 있습니다. </p><br><h2 id="네비게이션"><a href="#네비게이션" class="headerlink" title="네비게이션"></a>네비게이션</h2><p>네비게이션은 웹 페이지 로딩에 있어서 첫번째 단계입니다. 언제든지 사용자가 주소바에 URL을 입력함으로써 페이지를 요청할때, 링크를 클릭할때, 폼을 제출하거나 다른 행동을 취할때마다 발생합니다.</p><p>웹 퍼포먼스의 첫번째 목표는 탐색이 완료되는 시간을 최소화 하는 것입니다. 이상적인 조건에서는 이건 보통 오래 걸리지 않지만 지연시간과 인터넷 접속 속도는 지연을 야기할 수 있는 적입니다.</p><h3 id="DNS-조회"><a href="#DNS-조회" class="headerlink" title="DNS 조회"></a>DNS 조회</h3><p>웹 페이지를 탐색하는 첫번째 단계는 페이지에 배치되어 있는 자산(asset)들이 어디에 있는지 찾는 것입니다. 여러분이 <code>https://example.com</code> 를 탐색한다면, HTML 페이지는 <code>93.184.216.34</code> 라는 IP 주소에 서버를 두고 있을것입니다. 만약 여러분이 이 사이트를 절대로 방문하지 않았었다면, DNS 조회는 반드시 발생해야만 합니다.</p><p>여러분의 브라우저는 차례대로 IP 주소에 의해 반응하기 위해 최종적으로 네임서버에 지정된 DNS 조회를 요청할 것입니다. 이러한 초기 요청 이후, IP는 지속적인 요청 속도를 올리기 위해서 네임서버로 다시 접속하는 대신 캐시로부터 IP 주소를 획득함으로써 한동안 캐시될 것입니다.</p><p>DNS 조회는 보통 페이지 로드를 위해 호스트네임 당 오직 한번만 수행될 필요가 있습니다. 하지만 DNS 조회는 요청된 페이지 참조의 각각의 유일한 호스트네임을 위해 완료되야만 합니다.</p><p>만약 당신의 폰트, 이미지, 스크립트, 광고 그리고 메트릭스 등 모든 것들이 다른 호스트네임을 갖고 있다면, DNS 조회는 각각의 것들을 위해 이루어져야 합니다.</p><p><img src="https://mdn.mozillademos.org/files/16743/latency.jpg"></p><p>이러한 작업은 특히 모바일 네트워크 환경에서 성능에 있어서 문제를 유발할 수 있습니다. 사용자가 모바일 네트워크 환경에 있다면, 각각의 DNS 조회는 권한이 있는 DNS 서버에 도달하기 위해 휴대전화에서 기지국까지 가야만 합니다. 휴대전화, 기지국 그리고 네임서버 간의 거리는 막대한 지연시간을 추가합니다.</p><h3 id="TCP-핸드쉐이크-TCP-Handshake"><a href="#TCP-핸드쉐이크-TCP-Handshake" class="headerlink" title="TCP 핸드쉐이크 (TCP Handshake)"></a>TCP 핸드쉐이크 (TCP Handshake)</h3><p>일단 IP 주소를 알고 있다면, 브라우저는 <a href="https://developer.mozilla.org/en-US/docs/Glossary/TCP_handshake">TCP three-way handshake</a> 를 통해 서버 연결을 설정합니다. 이러한 메커니즘은 두개의 엔터티가 소통하기 위한 설계입니다–브라우저와 서버의 경우에– 종종 <a href="https://developer.mozilla.org/en-US/docs/Glossary/HTTPS">HTTPS</a> 를 거쳐 네트워크 TCP 소켓 연결의 매개변수(parameter)를 협상할 수 있습니다.</p><p>TCP’s three way handshaking 기술은 종종 “SYN-SYN-ACK”(또는 더 정확하게는 SYN, SYN-ACK, ACK)이라고 부릅니다. 왜냐하면 그리고 시작하기 위해 두 컴퓨터 사이에서 TCP 세션을 시작하고 협상하기 위해 TCP에 의해 전송된 세가지 메시지가 있기 때문입니다. 즉, 세가지 이상의 메시지들이 각각의 서버 사이에서 오고 간다는 것을 의미하며 해당 요청은 아직 완료되지 않았다는 것입니다.</p><h3 id="TLS-협상"><a href="#TLS-협상" class="headerlink" title="TLS 협상"></a><a href="https://developer.mozilla.org/en-US/docs/Glossary/TLS">TLS</a> 협상</h3><p>HTTPS를 통해 설정된 안전한 연결을 위해서 또 다른 “Handshake”이 필요합니다. 이 Handshake 또는 TLS Negotiation은 통신을 암호화하고, 서버를 식별하며 데이터의 전송이 실질적으로 이루어지기 전에 제때 안전한 연결(secure connection)이 설정되도록 사용할 암호(cipher)를 결정합니다. 이러한 작업들은 요청된 콘텐츠가 실제로 전송되기 전에 서버에 3회 이상의 왕복을 요구합니다.</p><p><img src="https://mdn.mozillademos.org/files/16746/ssl.jpg"></p><p>통신을 보안화하는것이 페이지 로드에 시간을 추가하는 반면에, 브라우저와 웹 서버 사이에 전송된 데이터가 서드 파티(third party)에 의해 암호 해독이 될수 없으므로 보안화된 연결(secure connection)의 시간지연 비용은 가치있다.</p><p>8번의 왕복 이후에 브라우저는 최종적으로 요청을 완료할 수 있다.</p><br><h2 id="응답"><a href="#응답" class="headerlink" title="응답"></a>응답</h2><p>일단 우리가 웹 서버와 접근을 설정하고 있다면 , 브라우저는 유저를 대신해 초기 <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Methods">HTTP <code>GET</code> request</a> 를 전송합니다. 웹사이트의 경우 HTML 파일이 대부분 입니다. 일단 웹 서버가 요청을 받으면, 관련 응답(response) 헤더와 HTML 콘텐츠를 응답할 것입니다.</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!doctype <span class="meta-keyword">HTML</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>My simple page<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">src</span>=<span class="string">&quot;styles.css&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;myscript.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h1</span> <span class="attr">class</span>=<span class="string">&quot;heading&quot;</span>&gt;</span>My Page<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>A paragraph with a <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;https://example.com/about&quot;</span>&gt;</span>link<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;myimage.jpg&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;image description&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;anotherscript.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>초기 요청에 대한 응답은 획득한 데이터의 첫번째 바이트를 포함하고 있습니다. <a href="https://developer.mozilla.org/en-US/docs/Glossary/Time_to_First_Byte">Time to First Byte</a> (TTFB)는 사용자가 요청한 시간(링크를 클릭함으로써)과 HTML의 첫번째 패킷의 수신 사이의 시간입니다. 첫번째 콘텐츠의 청크는 보통 데이터의 14kb 입니다.</p><p>위 예제에서, 요청은 확실히 14Kb 미만이지만 다음에서 언급할 분석(parsing) 중에는  브라우저가 링크를 찾을때까지 연결된 리소스는 요청되지 않습니다.</p><h3 id="TCP-Slow-Start-14kb-rule"><a href="#TCP-Slow-Start-14kb-rule" class="headerlink" title="TCP Slow Start / 14kb rule"></a>TCP Slow Start / 14kb rule</h3><p>첫번째 응답 패킷은 14kb 일것입니다. 이건 네트워크 연결 속도의 균형을 잡기위한 알고리즘인 <a href="https://developer.mozilla.org/en-US/docs/Glossary/TCP_slow_start">TCP slow start</a> 의 일부분입니다. Slow Start는 네트워크의 최대 대역폭이 결정될때까지 전송되는 데이터의 양을 점진적으로 증가시킵니다.</p><p>초기 패킷의 수신 이후에 TCP slow start 에서, 서버는 다음 패킷를 약 28kb 까지 두배로 키웁니다. 미리 지정된 스레드홀드에 도달하거나 정체가 발생할때까지 후속 패킷의 크기는 증가할 것입니다.</p><p><img src="https://mdn.mozillademos.org/files/16754/congestioncontrol.jpg"></p><p>만약 여러분이 초기 페이지 로드에 대한 14kb 규칙을 들은적이 있다면, TCP Slow Start는 초기 응답이 14kb인 이유이기도 하며 웹 퍼포먼스 최적화가 이러한 초기 14kb 응답을 염두에 두고 최적화에 초점을 맞춰야하는 이유이기도 합니다. TCP slow start는 혼잡을 피하기 위한 네트워크 수용능력을 위해 점진적으로 전송 속도를 알맞게 구성합니다.</p><h3 id="혼잡-관리"><a href="#혼잡-관리" class="headerlink" title="혼잡 관리"></a>혼잡 관리</h3><p>서버가 TCP 패킷에 데이터를 보낼때, 사용자의 클라이언트는 승인 또는 ACK를 반환하여 전달을 확인합니다. 이 연결은 하드웨어와 네트워크 조건에 따라 제한된 수용력을 가지고 있다. 만약 서버가 매우 빠르게 매우 많은 패킷을 보낸다면, 그들은 멈출것입니다. 즉, 인식하지 못할것입니다. 서버는 이것을 분실된 ACK(missing ACKs)로 등록합니다. 혼잡 관리 알고리즘(Congestion control algorithms)은  전송된 패킷과 ACK의 흐름을 사용하여 전송 속도를 결정합니다.</p><br><hr><p> mdn 원본 페이지의 콘텐츠가 너무 길다고 판단되어 DOM과 CSSSOM에 대한 내용을 다룰 <strong>Parsing</strong> 부분은 ‘페이지 채우기: 브라우저가 작동하는 방법 - 2’ 에서 다루겠습니다.</p>]]></content:encoded>
      
      
      <category domain="https://joontae-kim.github.io/categories/Web/">Web</category>
      
      <category domain="https://joontae-kim.github.io/categories/Web/Browser/">Browser</category>
      
      
      <category domain="https://joontae-kim.github.io/tags/mdn/">mdn</category>
      
      <category domain="https://joontae-kim.github.io/tags/Browser/">Browser</category>
      
      
      <comments>https://joontae-kim.github.io/2020/09/25/browser-work/#disqus_thread</comments>
      
    </item>
    
  </channel>
</rss>
