<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>dev and dev</title>
    <link>https://joontae-kim.github.io/</link>
    
    <atom:link href="https://joontae-kim.github.io/rss2.xml" rel="self" type="application/rss+xml"/>
    
    <description>내가 볼려고 만든 깃헙 블로그</description>
    <pubDate>Wed, 14 Apr 2021 11:45:50 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title>Prototype 기반의 Javascript</title>
      <link>https://joontae-kim.github.io/2021/04/07/js-oop-prototype/</link>
      <guid>https://joontae-kim.github.io/2021/04/07/js-oop-prototype/</guid>
      <pubDate>Wed, 07 Apr 2021 14:00:24 GMT</pubDate>
      
        
        
      <description>&lt;p&gt;&lt;img src=&quot;/images/js_with_prototype.png&quot; alt=&quot;Javascript&quot;&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;지난 포스트인 &lt;a href=&quot;/2020/11/02/js-oop-2/&quot;&gt;Javascript와 객체 지향 프로그래밍 - </description>
        
      
      
      
      <content:encoded><![CDATA[<p><img src="/images/js_with_prototype.png" alt="Javascript"></p><hr><p>지난 포스트인 <a href="/2020/11/02/js-oop-2/">Javascript와 객체 지향 프로그래밍 - 객체 지향 프로그래밍(OOP)</a>에서는 객체 지향 프로그래밍의 기본적인 개념, 기본 구성요소, OOP의 기법 또는 특성으로 많이 언급되는 추상화, 캔슐화, 은닉화, 상속성, 다형성 그리고 OOP의 장단점에 대해 공부해보면서 객체 지향 프로그래밍에서 중요시하는 것은 무엇이며 프로그래밍 설계 및 구현시 이반되는 장점에 대해 알 수 있었습니다.</p><p>이번 포스트에서 다를 주제는 <strong>Prototype 기반의 프로그래밍</strong>입니다.</p><h2 id="Prototype-기반의-프로그래밍"><a href="#Prototype-기반의-프로그래밍" class="headerlink" title="Prototype 기반의 프로그래밍?"></a>Prototype 기반의 프로그래밍?</h2><p>Prototype 이란 사전적 의미는 <strong>원형, 원본</strong> 이다. 그럼 Prototype 기반의 프로그래밍은 무엇일까? Javascript에서 어디에 쓰는 개념인고…?<br>일단 이전 포스트인 <a href="/2020/11/02/js-oop-2/">Javascript와 객체 지향 프로그래밍 - 객체 지향 프로그래밍(OOP)</a>에서 언급한 <strong>Class</strong>에 대해 복기해보면 객체 지향 프로그래밍을 구현하기 위해 추상화된 속성과 메서드를 Class 라는 하나의 틀(template)을 정의하고, 클래스에 의해 생성된 새로운 객체(object)를 클래스의 <strong>인스턴스</strong>라고 부르며 클래스의 속성과 메서드를 그대로 상속받아 OOP의 기법인 캡슐화와 은닉화, 추상화, 상속성과 다형성의 개념을 구현할 수 있다.</p><p>위와 같은 Class의 개념이 Javascript에서는 <strong>prototype</strong> 이다. 즉, 프로토타입 기반 프로그래밍이란 객체의 원형인 프로토타입을 이용해 새로운 객체를 만들어내는 프로그래밍 기법으로, 새롭게 생성된 객체는 자기 자신의 원형(prototype)을 가지며 원형의 속성과 메서드를 상속받거나 확장할 수 있다.</p><h2 id="객체-생성법"><a href="#객체-생성법" class="headerlink" title="객체 생성법"></a>객체 생성법</h2><p>Javascript에서 객체를 생성하는 방법은 총 3가지로 객체 리터럴, Object 생성자 함수, 생성자 함수가 있으며 Javascript에서는 <code>new</code> 연산자와 함께 생성자 함수를 사용해 인스턴스 객체를 생성할 수 있다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">var obj &#x3D; &#123;</span><br><span class="line">  name : &#39;BKJang&#39;,</span><br><span class="line">  job : &#39;Developer&#39;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Object 생성자 함수</span><br><span class="line">var obj &#x3D; new Object();</span><br><span class="line">obj.name &#x3D; &#39;BKJang&#39;;</span><br><span class="line">obj.job &#x3D; &#39;Developer&#39;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 생성자 함수</span><br><span class="line">function Person(name, job) &#123;</span><br><span class="line">  this.name &#x3D; name;</span><br><span class="line">  this.job &#x3D; job;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 인스턴스 생성</span><br><span class="line">var obj &#x3D; new Person(&#39;BKJang&#39;, &#39;Developer&#39;);</span><br></pre></td></tr></table></figure><h3 id="생성자-함수와-new-연산자"><a href="#생성자-함수와-new-연산자" class="headerlink" title="생성자 함수와 new 연산자"></a>생성자 함수와 new 연산자</h3><p>생성자 함수란 객체 인스터스를 생성하는 함수로, 선언된 일반 함수를 <code>new</code> 키워드와 함께 호출 및 실행하는 함수로, Javascript에서는 두 가지 타입의 생성자 함수가 존재합니다.</p><ul><li><code>Array</code>와 <code>Object</code> 와 같은 내장 생성자 함수: 런타임 환경의 실행 컨텍스트 환경에서 자동으로 사용 가능</li><li>커스텀 생성자 함수: 객체 타입으로 프로퍼티와 메서드 정의</li></ul><p>객체 생성을 위해 우리가 사용할 생성자 함수 타입은 두번째로, 위에서 객체 생성 방법 중 굳이 생성자 함수를 사용하는 이유는 동일한 프로퍼티와 메서드를 갖는 복수의 객체를 생성할때 객체 리터럴 방식보다 유용하기 때문이며 객체 인스턴스를 생성할때 생성자 함수의 <code>this</code> 가 반환되면서 인스턴스 각자의 실행 컨텍스트를 갖게 되어 독립적 실행환경을 유지할 수 있기 때문입니다.</p><h4 id="new-연산자"><a href="#new-연산자" class="headerlink" title="new 연산자"></a>new 연산자</h4><p>Javascript에서 <code>new</code> 연산자는 사용자 정의 객체 타입 또는 내장 객체 타입의 인스턴스를 생성할때 사용되며 아래와 같은 문법을 따릅니다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">new constructor[([arguments])]</span><br></pre></td></tr></table></figure><ul><li>constructor: 객체 인스턴스의 타입을 기술 또는 명세하는 함수</li><li>arguments: constructor와 함께 호출될 값 목록</li></ul><h4 id="생성자-함수와-함께-new-연산자를-사용하면…"><a href="#생성자-함수와-함께-new-연산자를-사용하면…" class="headerlink" title="생성자 함수와 함께 new 연산자를 사용하면…"></a>생성자 함수와 함께 <code>new</code> 연산자를 사용하면…</h4><p>생성자 함수와 함께 <code>new</code> 연산자를 사용하면 아래의 단계를 거쳐 객체 인스턴스가 생성됩니다.</p><ol><li>비어있는 객체(<code>&#123;&#125;</code>)를 만듭니다.</li><li>생성자 함수의 <code>Prototype Object</code>에 연결된 새 객체(<code>__proto__</code>)를 프로퍼티에 추가합니다.<ul><li>따라서, <code>new</code> 연산자를 사용함으로써 생성자 함수 prototype에 추가된 프로퍼티와 객체는 생성자 함수에 의해 생성된 모든 인스턴스에서 접근가능(accessible)하다.</li></ul></li><li>새롭게 생성된 객체 인스턴스를 <code>this</code> 컨텍스트로 바인딩한다.<ul><li>i.e.) 생성자 함수에서 <code>this</code>에 대한 모든 참고는 현재 첫번째 단계에서 생성된 객체를 참고한다.</li></ul></li><li>만약 함수가 객체를 반환하지 않는다면 <code>this</code>를 반환한다.</li></ol><h4 id="사용자-정의-객체를-생성하기-위해서는…"><a href="#사용자-정의-객체를-생성하기-위해서는…" class="headerlink" title="사용자 정의 객체를 생성하기 위해서는…"></a>사용자 정의 객체를 생성하기 위해서는…</h4><p>사용자 정의 객체를 생성하기 위해서는 총 2개의 과정이 필요합니다.</p><ol><li>이름과 속성을 가진 함수를 작성함으로써 객체 타입을 정의한다.</li><li><code>new</code> 연산자와 함께 객체의 인스턴스를 생성한다.</li></ol><h5 id="예제-및-실행문맥-분석-parsing"><a href="#예제-및-실행문맥-분석-parsing" class="headerlink" title="예제 및 실행문맥 분석 (parsing)"></a>예제 및 실행문맥 분석 (parsing)</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 1. 생성자 함수 정의</span><br><span class="line">function Car(make, model, year) &#123;</span><br><span class="line">  this.make &#x3D; make;</span><br><span class="line">  this.model &#x3D; model;</span><br><span class="line">  this.year &#x3D; year;</span><br><span class="line">  this.introduce &#x3D; function () &#123;</span><br><span class="line">    console.log(&#96;This Car&#39;s Model is $&#123;this.model&#125; made by $&#123;this.make&#125; in $&#123;this.year&#125;&#96;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 2. 객체 인스턴스 생성</span><br><span class="line">var myCar &#x3D; new Car(&#39;Eagle&#39;, &#39;Talon TSi&#39;, 1993);</span><br><span class="line">myCar.make</span><br><span class="line">&gt; &quot;Eagle&quot;</span><br><span class="line">myCar.introduce()</span><br><span class="line">&gt; &quot;This Car&#39;s Model is &#39;Talon TSi&#39; made by &#39;Eagle in 1993&quot;</span><br></pre></td></tr></table></figure><p><code>new Car(...)</code>를 실행하면 </p><ol><li><code>Car.prototype</code> 으로부터 상속된 새로운 객체가 생성된다.</li><li><code>make</code>, <code>model</code>, <code>year</code> 인자와 함께 생성자 함수 <code>Car</code>가 호출되며 새롭게 생성된 객체에 <code>this</code>가 바인딩 됩니다. <code>new Car</code>는 <code>new Car()</code>와 동일하고, 예를 들어 인자가 지정되지 않았다면 인자 없이 <code>Car</code>를 호출합니다.<br>3, 생성자 함수에 의해 반환된 객체는 전체 <code>new</code> 표현식의 결과입니다. 만약 생성자 함수가 객체를 반환하지 않는다면, 1 단계에서 생성된 객체가 대신 사용됩니다. (일반적으로 생성자 함수는 값(value)를 반환하지 않으나 만약 객체 생성 과정을 재정의(overide)하려는 경우 그렇게 할 수도 있습니다)</li></ol><p>위와 같이 동일한 프로퍼티 또는 멤버와 메서드를 같는 객체를 효율적으로 생성할 수 있는 방법이 <strong>생성자 함수</strong>이다. 인스턴스가 생성되면 각 인스턴스는 <code>make</code>, <code>model</code>, <code>year</code>라는 프로퍼티와 <code>introduce</code>와 같은 메서드를 동일하게 갖게 된다. 즉, 인스턴스가 생성될 때마다 동일한 프로퍼티와 메서드가 계속 생성되는 것이다. 필요한 만큼. 만약 인스턴스가 매우 많아지거나 각 사이즈가 늘어난다면 <strong><em>메모리를 낭비하게 되는 구조가 된다.</em></strong> 이를 해결하기 위해 개념이 바로 <strong>Prototype</strong> 이다. </p><p><strong><em>prototype에 대해 공부해본 후 생성자 함수 <code>Car</code>를 수정하고 확장해보자.</em></strong></p><h2 id="Javascript에서-Prototype이란"><a href="#Javascript에서-Prototype이란" class="headerlink" title="Javascript에서 Prototype이란?"></a>Javascript에서 Prototype이란?</h2><p>먼저, 프로토타입 기반 프로그래밍에 대해 다시 복기해보면, 아래와 같이 정의했었다.</p><blockquote><p>프로토타입 기반 프로그래밍이란 객체의 원형인 프로토타입을 이용해 새로운 객체를 만들어내는 프로그래밍 기법으로, 새롭게 생성된 객체는 자기 자신의 원형(prototype)을 가지며 원형의 프로퍼티와 메서드를 상속받거나 확장할 수 있다.</p></blockquote><p>그리고 <strong>생성자 함수와 new 연산자 섹션</strong>의 2번에서 우리는<br>생성자 함수와 <code>new</code> 연산자를 통해 인스턴스를 생산했을 경우, 생성자 함수의 <code>Prototype Object</code>에 연결된 새 객체(<code>__proto__</code>)를 프로퍼티에 추가한다는 것을 배웠다. 따라서, 생성자 함수에 추가된 속성과 객체는 생성자 함수에 의해 생성된 모든 인스턴스에서 접근 가능(accessible)하게 해주며 Javascript에서 OOP의 개념이 가능하게 해준다.</p><p>어떻게 이게 가능할까?</p><p>Javascript에는 아래와 같이 크게 2가지 개념의 <strong>protoype</strong> 이 존재하며 이는 Javascript의 함수와 객체에 대한 내부 구조를 더 살펴봐야 한다.</p><ul><li>함수의 <strong>prototype</strong> 프로퍼티가 가리키고 있는 <code>Prototype Object</code></li><li><strong>자기 자신을 만들어낸 인스턴스 객체의 원형</strong>을 의미하는 <code>Prototype Link</code></li></ul><h3 id="함수와-객체의-구조"><a href="#함수와-객체의-구조" class="headerlink" title="함수와 객체의 구조"></a>함수와 객체의 구조</h3><p>Javascript의 모든 객체는 생성과 동시에 정의된 프로퍼티와 메서드를 가진 <strong>프로토타입 객체(Prototype Object)</strong> 라는 새로운 객체를 복제(Cloning)하여 만드는데 함수의 경우에도 객체 타입으로써 정의 및 분석(parsing) 단계에서 함수 내부에 <code>prototype</code> 프로퍼티를 추가한 후 복제된  <strong>프로토타입 객체(Prototype Object)</strong> 를 참조하도록 한다. 또한, <strong>프로토타입 객체(Prototype Object)</strong> 는 <code>constructor</code> 프로퍼티를 갖는 구조로써, 이는 함수를 참조하는 구조를 갖는다.</p><p>단계를 나열하면 아래와 같다.</p><ol><li>생성자 함수 <code>function Car (make, model, year)</code> 정의 및 <code>prototype</code> 프로퍼티 추가</li><li>생성자 함수 <code>Car</code>의 원형인 <strong>프로토타입 객체(Prototype Object) - Car Prototype Object</strong> 생성 및 <code>constructor</code> 프로퍼티 추가</li><li>생성자 함수 <code>Car</code>의 <code>prototype</code> 프로퍼티는 <code>Car Prototype Object</code> 참조</li><li><strong>Car Prototype Object</strong>의 <code>constructor</code>는 생성자 함수 <code>Car</code> 참조</li></ol><p><img src="/images/protoype_exam_graph.png" alt="생성자 함수와 인스턴스 그리고 Prototype Object의 관계도"></p><p>즉, <strong>Car Prototype Object</strong>는 <code>new</code> 연산자와 생성자 함수에 의해 생성될 새로운 인스턴스가 참조할 <strong>원형 객체(Prototype Object)</strong> 이다. 또한 생성된 인스턴스는 아래와 같은 구조를 갖는데 예를 들어, <strong>myCar</strong> 인스턴스는 생성자 함수를 참조한 프로퍼티 이외에 <code>__proto__</code> 프로퍼티를 가지고 있는데 바로 이 프로퍼티가 <strong>myCar</strong> 라는 객체를 만들어내기 위해 사용된 <em>프로토타입 객체 (Car protototype object)에 대한 숨겨진 연결</em> 이며 이를 <code>Prototype Link</code>라고 한다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 인스턴스 &#96;myCar&#96;</span><br><span class="line">myCar &#123;</span><br><span class="line">  introduce: ƒ ()</span><br><span class="line">  make: &quot;Eagle&quot;</span><br><span class="line">  model: &quot;Talon TSi&quot;</span><br><span class="line">  year: 1993</span><br><span class="line">  __proto__: &#123;</span><br><span class="line">    constructor: ƒ Car(make, model, year)</span><br><span class="line">    __proto__: Object</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 인스턴스의 __proto__의 생성자와 생성자 함수의 prototype 프로퍼티의 생성자 비교</span><br><span class="line">myCar.__proto__.constructor &#x3D;&#x3D;&#x3D; Car.prototype.constructor</span><br><span class="line">&gt; true</span><br></pre></td></tr></table></figure><p>예시를 기반으로 생성자 함수, 인스턴스 그리고 <strong>프로토타입 객체(Prototype Object)</strong> 에 대해 정리해보면,</p><ul><li><code>constructor</code>는 생성자 함수 본인이고,</li><li><code>prototype</code>은 생성자 함수에 정의한 모든 객체가 공유할 원형으로 <strong>하위로 물려줄 연결에 대한 속성</strong></li><li><code>__proto__</code>는 생성자 함수를 new로 호출할 때, 정의해두었던 <code>prototype</code>을 참조한 객체로서 <strong>상위에서 물려받은 객체의 프로토타입에 대한 정보</strong></li><li><code>prototype</code>은 생성자 함수에 사용자가 직접 넣는 거고, <code>__proto__</code>는 new를 호출할 때 <code>prototype</code>을 참조하여 자동으로 만들어짐</li><li>생성자에는 <code>prototype</code>, 생성자로부터 만들어진 객체에는 <code>__proto__</code></li></ul><h3 id="Prototype-Chain-프로토타입-체인"><a href="#Prototype-Chain-프로토타입-체인" class="headerlink" title="Prototype Chain (프로토타입 체인)"></a>Prototype Chain (프로토타입 체인)</h3><p>우리는 <strong>프로토타입 객체(Prototype Object)</strong> 와 <strong>프로토타입 링크(Prototype Link)</strong> 에 대해 살펴봤습니다. 생성자 함수의 <code>prototype</code> 프로퍼티가 함수의 프로토타입 객체(Prototype Object)를 참고하고 있으며 <code>new</code> 연산자와 생성자 함수에 의해 생성한 인스턴스는 <code>__proto__</code> 프로퍼티를 통해서 함수 객체의 원형을 참조하고 있음을 알 수 있었다. 따라서 생성된 인스턴스들은 생성자 함수의 <strong>프로토타입 객체(Prototype Object)</strong> 을 계속 주시하고 있다는 것이며 생성자 함수의 <code>prototype</code> 프로퍼티에 프로퍼티 또는 메서드를 추가할 경우 <strong>프로토타입 링크(Prototype Link)</strong> 의 관계인 인스턴스도 이를 공유받아 추가된 속성들을 활용할 수 있습니다. 이는 그 어떠한 상위 프로토타입 객체도 마찬가지입니다. 이러한 개념이 바로 <strong>프로토타입 체인(prototype chain)</strong> 이고 다른 객체에 정의된 메소드와 속성을 한 객체에서 사용할 수 있도록 하는 원리입니다.</p><p>정확히 말하자면 상속되는 속성과 메소드들은 각 객체가 아니라 객체의 생성자의 <code>prototype</code> 이라는 속성에 정의되어 있습니다.</p><p>그리고 위와 같이 객체 인스턴스와 프로토타입 간에 연결을 <code>prototype</code>과 <code>__proto__</code>을 통해 구성하고 있으며 이 연결을 따라 <strong>프로토타입 체인(Prototype Chain)</strong> 을 타고 올라가며 속성과 메소드를 탐색합니다.</p><p>아래 코드는 프로토타입 체인을 설명하기 위한 예시입니다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; #예제 1.</span><br><span class="line">function exam1 () &#123;</span><br><span class="line">  this.x &#x3D; function () &#123;</span><br><span class="line">    console.log(&#39;hello&#39;);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br><span class="line">exam1.x&#x3D;function() &#123;</span><br><span class="line">    console.log(&#39;world&#39;);</span><br><span class="line">&#125;;</span><br><span class="line">var exam1A &#x3D; new A();</span><br><span class="line">var exam1B &#x3D; new A();</span><br><span class="line">exam1A.x();</span><br><span class="line">&gt; hello</span><br><span class="line">exam1B.x();</span><br><span class="line">&gt; hello</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; #예제 2.</span><br><span class="line">var exam2 &#x3D; function () &#123; &#125;;</span><br><span class="line">exam2.x&#x3D;function() &#123;</span><br><span class="line">  console.log(&#39;hello&#39;);</span><br><span class="line">&#125;;</span><br><span class="line">exam2.prototype.x &#x3D; function () &#123;</span><br><span class="line">  console.log(&#39;world&#39;);</span><br><span class="line">&#125;;</span><br><span class="line">var exam2A &#x3D; new exam2();</span><br><span class="line">var exam2B &#x3D; new exam2();</span><br><span class="line">exam2A.x();</span><br><span class="line">&gt; world</span><br><span class="line">exam2B.x();</span><br><span class="line">&gt; world</span><br></pre></td></tr></table></figure><p><strong>프로토타입 객체</strong>와 <strong>프로토타입 링크</strong> 에 대해 잘 이해했다면, ‘#예제1’에서 메서드 메서드 <code>x</code>의 수정이 즉시 반영되지 않는 이유를 금방 눈치챌 수 있을 것입니다. 힌트는 바로 <em>생성자 함수 객체의 메서드를 어디에서 수정했냐</em> 이다. 생성자 함수와 객체 인스턴스는 <strong>프로토타입 객체(Prototype Object)</strong> 와 연결되어 있으며 생성자 함수 내 메서드의 추가, 변경, 삭제 등의 내부 속성의 변경상태를 공유하기 위해서는 ‘#예제2’ 와 같이 생성자 함수의 <code>prototype</code> 프로퍼티를 통해 정의 및 수정해야 한다.  <strong>#예제1</strong> 의 <code>exam1.x=function () &#123; ~ &#125;</code> 와 같은 수정은 단지 생성자 함수 객체의 메서드를 변경한 것 뿐이다.</p><h3 id="잊고-있던-예제를-개선해보자"><a href="#잊고-있던-예제를-개선해보자" class="headerlink" title="잊고 있던 예제를 개선해보자."></a>잊고 있던 예제를 개선해보자.</h3><p>Javascript의 <code>prototype</code>에 대해 공부하면서 잊고 있었던 <code>Car</code> 생성자 함수의 <strong>introduce</strong> 메서드 할당을 개선해보자.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 1. 생성자 함수 정의</span><br><span class="line">function Car(make, model, year) &#123;</span><br><span class="line">  this.make &#x3D; make;</span><br><span class="line">  this.model &#x3D; model;</span><br><span class="line">  this.year &#x3D; year;</span><br><span class="line">  &#x2F;&#x2F; this.introduce &#x3D; function () &#123;</span><br><span class="line">  &#x2F;&#x2F;   console.log(&#96;This Car&#39;s Model is $&#123;this.model&#125; made by $&#123;this.make&#125; in $&#123;this.year&#125;&#96;)</span><br><span class="line">  &#x2F;&#x2F; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 2. &#96;introduce&#96; 메서드를 &#96;Car&#96; 함수의 prototype 속성에 추가</span><br><span class="line">Car.prototype.introduce &#x3D; function () &#123;</span><br><span class="line">  console.log(&#96;This Car&#39;s Model is $&#123;this.model&#125; made by $&#123;this.make&#125; in $&#123;this.year&#125;&#96;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 3. 인스턴스 생성</span><br><span class="line">var myCar &#x3D; new Car(&#39;Eagle&#39;, &#39;Talon TSi&#39;, 1993);</span><br><span class="line">myCar.make</span><br><span class="line">&gt; &quot;Eagle&quot;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 4. 인스턴스에서 &#96;introduce&#96; 메서드 호출</span><br><span class="line">myCar.introduce()</span><br><span class="line">&gt; &quot;This Car&#39;s Model is &#39;Talon TSi&#39; made by &#39;Eagle in 1993&quot;</span><br></pre></td></tr></table></figure><p>위와 같이 생성자 함수의 내부에 메서드를 할당하는 대신 <code>prototype</code> 프로퍼티에 메서드를 할당해줌으로써 <code>Car Prototype Object</code> 또한 참조 받으며 생성된 인스턴스 객체들 또한 <strong>Prototype Link</strong> 속성으로 추가된 메서드 또는 프로퍼티를 공유받아 생성 이후에 할당된 기능들도 실행시킬 수 있게 된다.</p><h2 id="마치며"><a href="#마치며" class="headerlink" title="마치며"></a>마치며</h2><p>Prototype에 대해 학습하면서 몇몇 부분에서 제대로 이해되지 않아 디테일한 부분까지 찾아보다보니 많은 블로그를 찾아보았고 많은 시간을 소모했다고 느꼈지만 끝나고나니 이제서야 왜 Javascript에서 Prototype 기반의 프로그래밍이 중요하고 OOP를 구현하기 위한 기반이라고 했는지 이해하게 되었다.</p><p>다음 포스트 주제로는 prototype의 상속에 대해 다뤄보겠습니다.</p><h2 id="참고"><a href="#참고" class="headerlink" title="참고"></a>참고</h2><ul><li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/new#object_property_that_is_itself_another_object">new Operator</a></li><li><a href="https://ko.javascript.info/constructor-new">‘new’ 연산자와 생성자 함수</a></li><li><a href="https://bamdule.tistory.com/196">[javascript] new 연산자와 생성자 함수</a></li><li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/new">new operator</a></li><li><a href="https://oneroomtable.tistory.com/entry/%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8-%EA%B0%9D%EC%B2%B4-%EC%83%9D%EC%84%B1%EC%9E%90-%ED%95%A8%EC%88%98%EB%9E%80">자바스크립트 객체 생성자 함수란?</a></li><li><a href="http://insanehong.kr/post/javascript-prototype/">Javascript 기초 - Object prototype 이해하기</a></li><li><a href="https://www.nextree.co.kr/p7323/">Javascript: 프로토타입 (prototype) 이해</a></li><li><a href="https://www.zerocho.com/category/JavaScript/post/573c2acf91575c17008ad2fc">객체 지향 프로그래밍(생성자와 프로토타입)</a></li><li><a href="https://medium.com/@bluesh55/javascript-prototype-%EC%9D%B4%ED%95%B4%ED%95%98%EA%B8%B0-f8e67c286b67">[Javascript ] 프로토타입 이해하기</a></li><li><a href="https://webclub.tistory.com/158?category=501048">자바스크립트는 프로토타입 기반의 객체지향 프로그래밍 언어이다.</a></li><li><a href="https://webclub.tistory.com/301?category=501048">함수의 프로토타입 - prototype</a></li><li><a href="https://poiemaweb.com/js-object-oriented-programming">자바스크립트 객체지향 프로그래밍</a></li><li><a href="https://developer.mozilla.org/ko/docs/Learn/JavaScript/Objects/Object_prototypes">Object prototypes</a></li><li><a href="https://developer.mozilla.org/ko/docs/Learn/JavaScript/Objects/Inheritance">Inheritance in JavaScript</a></li><li><a href="https://medium.com/javascript-scene/common-misconceptions-about-inheritance-in-javascript-d5d9bab29b0a">Common Misconceptions About Inheritance in JavaScript</a></li><li><a href="https://bkdevlog.netlify.app/posts/oop-class-of-js">[JavaScript] 8-1. 객체지향 프로그래밍(클래스 vs 프로토타입)</a></li><li><a href="https://bkdevlog.netlify.app/posts/oop-inheritance-of-js">[JavaScript] 8-2. 객체지향 프로그래밍(상속)</a></li></ul>]]></content:encoded>
      
      
      <category domain="https://joontae-kim.github.io/categories/Programming/">Programming</category>
      
      <category domain="https://joontae-kim.github.io/categories/Programming/Javascript/">Javascript</category>
      
      
      <category domain="https://joontae-kim.github.io/tags/javascript/">javascript</category>
      
      <category domain="https://joontae-kim.github.io/tags/oop/">oop</category>
      
      <category domain="https://joontae-kim.github.io/tags/prototype/">prototype</category>
      
      <category domain="https://joontae-kim.github.io/tags/object/">object</category>
      
      <category domain="https://joontae-kim.github.io/tags/js/">js</category>
      
      
      <comments>https://joontae-kim.github.io/2021/04/07/js-oop-prototype/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>알고리즘 시리즈 - 시작</title>
      <link>https://joontae-kim.github.io/2021/04/04/algorithm/</link>
      <guid>https://joontae-kim.github.io/2021/04/04/algorithm/</guid>
      <pubDate>Sun, 04 Apr 2021 09:06:15 GMT</pubDate>
      
        
        
      <description>&lt;p&gt;&lt;img src=&quot;/images/algorithm.png&quot; alt=&quot;알고리즘&quot;&gt;&lt;/p&gt;
&lt;p&gt;알고리즘을 공부하기 위해 책과 자료들을 수집해 보고 공부하기만 해서 정리하는 느낌으로 알고리즘 시리즈를 연재해보려고 합니다.&lt;/p&gt;
&lt;h2 id=&quot;알고리</description>
        
      
      
      
      <content:encoded><![CDATA[<p><img src="/images/algorithm.png" alt="알고리즘"></p><p>알고리즘을 공부하기 위해 책과 자료들을 수집해 보고 공부하기만 해서 정리하는 느낌으로 알고리즘 시리즈를 연재해보려고 합니다.</p><h2 id="알고리즘에-대한-갈증"><a href="#알고리즘에-대한-갈증" class="headerlink" title="알고리즘에 대한 갈증"></a>알고리즘에 대한 갈증</h2><p>알고리즘에 대한 필요성은 <a href="https://clippler-9d22e.web.app/">클립플러</a>를 개발하면서 강하게 느꼈다. 클립플러의 일부 기능 중 clip으로 만들 사이트의 메타태그를 긁어와 유효한 태그를 추천하는 기능을 설계하는데 가장 큰 문제에 봉착했었다. 바로 코딩. 분명 팩토리얼로 단어의 조합을 만들면 된다는 생각은 있는데 팩토리얼 알고리즘 맞는지 그리고 어떻게 구현하는지 까마득했다;;; 그러다 잠시 개발은 중단하고 알고리즘에 대한 기초중의 기초와 중간을 건너띄고 팩토리얼 알고리즘에 대해 공부했다. 기능개발은 했지만 리팩토링은 물론 성능분석도 거의 하지 못했다. 그러다 조언을 구하면 더 나은 코드 설계와 개발실력을 갖추기 위해서는 알고리즘 공부가 도움이 많이 되고, 나중에 취업을 할때에도 도움이 많이 될거라고 했는데… 그렇게 모두의 충고를 과소평가하고 드문드문 보기만 했다;;; 그러다보니 알고리즘에 대한 베이스가 약하고, 코딩 테스트를 보더라도 쉬운 문제까지가 한계였다.</p><p>그래서 이번 기회에 알고리즘에 대한 숙제를 시리즈로 연재해보려고 마음 먹었다. 다시 시작하는 마음으로 꼬박꼬박 정리해가면서 다음에 봐도 공부할만한 자료가 될때까지.</p><p>먼저 알고리즘에 대해 간략하게 다룬 후 연재를 어떤 방향으로 할지 논해보려고 한다.</p><h2 id="알고리즘이란"><a href="#알고리즘이란" class="headerlink" title="알고리즘이란?"></a>알고리즘이란?</h2><p>우리는 이미 알고리즘에 익숙해져있다. 다만, 그러한 것들을 ‘알고리즘’이라고 부르지 않을뿐. 이를테면,</p><ul><li>가장 빠른 또는 편한 출근길 또는 퇴근길 경로 탐색</li><li>오늘 치킨을 먹을것인가, 주중에 먹을것인가에 대한 기회비용 탐색</li><li>한정된 금액 안에서 장보기</li></ul><p>위와 같은 과정 모두 알고리즘이라고 할 수 있으며, <strong>특정 문제를 해결하기 위한 일련의 계산과정</strong>으로 <em>입력, 출력 그리고 계산과정</em> 이 존재한다.</p><p>프로그래밍에서 알고리즘이란 필수적인 것은 아니지만 더 효율적이고 효과적인 방법으로 어떤 결과값(출력)을 만들어낼 수 있는 과학적 접근법으로, 어떤 알고리즘으로 과정을 설계하느냐에 따라 결과가 동일하더라도 프로그램의 속도나 처리방식 등이 크게 차이나는 경우도 있다.</p><h3 id="알고리즘의-조건"><a href="#알고리즘의-조건" class="headerlink" title="알고리즘의 조건"></a>알고리즘의 조건</h3><p>알고리즘은 다음의 조건을 만족해야 한다.</p><ul><li>입력: 외부에서 제공되는 자료가 0개 이상 존재한다.</li><li>출력: 적어도 2개 이상의 서로 다른 결과를 내어야 한다.(즉 모든 입력에 하나의 출력이 나오면 안됨)</li><li>명확성: 수행 과정은 명확하고 모호하지 않은 명령어로 구성되어야 한다.</li><li>유한성(종결성): 유한 번의 명령어를 수행 후(유한 시간 내)에 종료한다.</li><li>효율성: 모든 과정은 명백하게 실행 가능(검증 가능)한 것이어야 한다.</li></ul><h3 id="좋은-알고리즘이란-분석-기준"><a href="#좋은-알고리즘이란-분석-기준" class="headerlink" title="좋은 알고리즘이란? 분석 기준."></a>좋은 알고리즘이란? 분석 기준.</h3><ul><li>정확성 : 적당한 입력에 대해서 유한 시간내에 올바른 답을 산출하는가를 판단.</li><li>작업량 : 전체 알고리즘에서 수행되는 가장 중요한 연산들만으로 작업량을 측정. 해결하고자 하는 문제의 중요 연산이 여러개인 경우에는 각각의 중요 연산들의 합으로 간주하거나 중요 연산들에 가중치를 두어 계산</li><li>최적성 :그 알고리즘보다 더 적은 연산을 수행하는 알고리즘은 없는가? 최적이란 가장 ‘잘 - 알려진’ 이 아니라 ‘가장 좋은’의 의미이다</li><li>시간 복잡도 (Big-O Notation), (<em>이 부분에 대해서는 연재물로 따로 다루겠습니다.</em>)</li><li>기억 장소 사용량 (공간 복잡도) : 수행에 필요한 저장 공간</li></ul><h2 id="알고리즘과-함께-논하는-개념들"><a href="#알고리즘과-함께-논하는-개념들" class="headerlink" title="알고리즘과 함께 논하는 개념들"></a>알고리즘과 함께 논하는 개념들</h2><ul><li>시간 복잡도</li><li>자료구조</li><li>정렬</li></ul><p>알고리즘 공부를 준비함과 동시에 취업 및 면접에 대한 자료를 찾고 읽으면서 가장 많이 언급된 것들로 시간 복잡도에 대한 정확한 이해와 각 알고리즘에 대한 시간 복잡도 특성에 대해 암기수준으로 준비를 한다면 면접에서 많은 점수를 딸수 있다고 했습니다. 그리고 자료구조와 정렬의 경우도 마찬가지이다. 알고리즘과 뗄 수 없는 관계이며 각 알고리즘에 맞는 자료구조와 <strong>어떤 특징</strong>을 가지고 있으며 <strong>왜 사용하는지</strong> 를 알고 있다면 이 또한 (많은) 점수를 얻을 수 있다고 합니다.</p><h2 id="연재-계획"><a href="#연재-계획" class="headerlink" title="연재 계획"></a>연재 계획</h2><p>앞으로 다룰 주제는 <strong><em>알고리즘과 함께 논하는 개념들</em></strong> 순서로 연재할 것이며 중간중간 문제를 풀어보며 되새김질을 빙자한 복습을 이어가려고 합니다.</p><h2 id="주워-들은-팁"><a href="#주워-들은-팁" class="headerlink" title="주워 들은 팁"></a>주워 들은 팁</h2><p>이 부분은 <a href="https://blog.yena.io/studynote/2018/11/14/Algorithm-Basic.html">yena님의 알고리즘 포스팅</a>에서 보고 나 또한 상기하는 목적에서 복붙해왔습니다.</p><blockquote><p>많은 사람들이 공통적으로 얘기하는 사실들이 있다.</p><ul><li>처음부터 어려운 걸 하려고 하지 말고, 간단한 것부터 시작하자.</li><li>선택한 언어의 문법과 클래스를 잘 파악하자.</li><li>풀고 난 후 다른 사람의 풀이 참고하자.</li><li>경험이 쌓이면 익숙해진다. 조급해하지 말자.</li></ul></blockquote><p><em>(보실지는 모르겠지만 yena님 감사합니다.)</em></p><hr><h2 id="참조"><a href="#참조" class="headerlink" title="참조"></a>참조</h2><ul><li><a href="https://blog.yena.io/studynote/2018/11/14/Algorithm-Basic.html">[Algorithm] 알고리즘 공부 시작 방법 및 순서</a></li><li><a href="https://ko.wikipedia.org/wiki/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98">알고리즘</a></li><li><a href="https://opentutorials.org/course/2471/13912">프로그래밍 입문 - 알고리즘의 정의</a></li><li><a href="https://wayhome25.github.io/cs/2017/04/17/cs-18/">강의노트 17. 알고리즘, 자료구조 개요</a></li><li><a href="https://librewiki.net/wiki/%EC%8B%9C%EB%A6%AC%EC%A6%88:%EC%88%98%ED%95%99%EC%9D%B8%EB%93%AF_%EA%B3%BC%ED%95%99%EC%95%84%EB%8B%8C_%EA%B3%B5%ED%95%99%EA%B0%99%EC%9D%80_%EC%BB%B4%ED%93%A8%ED%84%B0%EA%B3%BC%ED%95%99/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98_%EA%B8%B0%EC%B4%88">시리즈:수학인듯 과학아닌 공학같은 컴퓨터과학/알고리즘 기초</a></li></ul>]]></content:encoded>
      
      
      <category domain="https://joontae-kim.github.io/categories/Programming/">Programming</category>
      
      <category domain="https://joontae-kim.github.io/categories/Programming/Algorithm/">Algorithm</category>
      
      
      <category domain="https://joontae-kim.github.io/tags/Algorithm/">Algorithm</category>
      
      <category domain="https://joontae-kim.github.io/tags/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/">알고리즘</category>
      
      <category domain="https://joontae-kim.github.io/tags/Study/">Study</category>
      
      <category domain="https://joontae-kim.github.io/tags/%EA%B3%B5%EB%B6%80-%EC%88%9C%EC%84%9C/">공부 순서</category>
      
      
      <comments>https://joontae-kim.github.io/2021/04/04/algorithm/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>Nuxt 라이프사이클</title>
      <link>https://joontae-kim.github.io/2021/03/18/nuxt-lifecycle/</link>
      <guid>https://joontae-kim.github.io/2021/03/18/nuxt-lifecycle/</guid>
      <pubDate>Thu, 18 Mar 2021 07:35:59 GMT</pubDate>
      
        
        
      <description>&lt;p&gt;&lt;img src=&quot;/images/nuxt.png&quot; alt=&quot;Nuxt.js&quot;&gt;&lt;/p&gt;
&lt;p&gt;Vue.js를 사용해 웹 어플리케이션 개발할때 라이프사이클에 대한 공부를 제대로 시작하지 고생한 경험이 있는데 Nuxt는 그런 과정을 밟지 않기위해 라이프사</description>
        
      
      
      
      <content:encoded><![CDATA[<p><img src="/images/nuxt.png" alt="Nuxt.js"></p><p>Vue.js를 사용해 웹 어플리케이션 개발할때 라이프사이클에 대한 공부를 제대로 시작하지 고생한 경험이 있는데 Nuxt는 그런 과정을 밟지 않기위해 라이프사이클부터 차근차근 공부해보자. 일단 공식문서 번역과 아래 <strong>Nuxt Lifecycle HOOKS</strong> 이미지에 대한 내용에 대해 공부해보자.</p><h1 id="Nuxt-Lifecycle"><a href="#Nuxt-Lifecycle" class="headerlink" title="Nuxt Lifecycle"></a>Nuxt Lifecycle</h1><p><img src="https://nuxtjs.org/docs/2.x/nuxt-lifecycle.svg" alt="Nuxt Lifecycle"></p><p>여러분이 어떤 도구(tool)를 사용하든 그 도구의 서두(the hood)에 대해 잘 이해하고 있을때 더 자신있음을 느낄 것입니다. Nuxt.js도 해당됩니다. 이 챕터에서는 여러분에게 프레임워크의 실행순서와 어떻게 함께 작동하는지 서로 다른 부분에 대한 수준 높은 개요를 제공할 것입니다.</p><p>Nuxt.js 라이프사이클은 빌드 단계 이후에 무엇이 발생되는지, 여러분의 어플리케이션이 어디서 번들되고(bundled), 청크되고(chunked), 최소화(minified) 되는지 설명합니다. 이 단계 이후에 발생하는 것은 여러분이 서버사이드 렌더링(server-side rendering) 활성화 여부에 따라 다릅니다. 만약 여러분이 서버사이드 렌더링 사용한다면, 추가적으로 여러분이 선택한 서버사이드 렌더링의 유형에 따라 달라집니다.</p><p>Dynamic SSR (<code>nuxt start</code>) 또는 Static Site Generation (<code>nuxt generate</code>).</p><h2 id="Lifecycle"><a href="#Lifecycle" class="headerlink" title="Lifecycle"></a>Lifecycle</h2><h3 id="Server"><a href="#Server" class="headerlink" title="Server"></a>Server</h3><p>SSR을 위해서 아래의 단계가 여러분의 어플리케이션에서 모든 초기요청(request) 동안에 실행될 것입니다.</p><ul><li>서버 시작 <em>The server starts</em> (<code>nuxt start</code>)</li></ul><p>정적 사이트 생성모드를 사용하면, 서버 단계에서는 오직 빌드타임에만 실행되나 모든 페이지에 대해 단 한번만 실행될 것입니다.</p><ul><li>생성 프로세스 시작 (<code>nuxt generate</code>)</li><li>Nuxt hooks</li><li>serverMiddleware</li><li>Server-side Nuxt 플러그인(plugins)<ul><li>nuxt.config.js에 정의된 순서대로 <em>(in order as defined in nuxt.config.js)</em></li></ul></li><li>nuxtServerInit<ul><li><em>만약 Vuex store를 설정했다면 서버 사이드에서 요청되는 첫번째 생명주기 훅(lifecycle hook)이다</em></li><li>스토어(store)를 미리 채우기(pre-populate) 위해 서버 사이드에서 Vuex 호출한다.</li><li>첫번째 인자(argument)는 Vuex context, 두번째 인자는 Nuxt.js context 입니다.<ul><li>서버 사이드에서 연속적인 스토어 액션(action)을 위해 오직 “entry point”에서 다른 액션을 Dispatch 합니다.</li></ul></li><li>오직 <code>store/index.js</code>에 정의할 수 있습니다.</li></ul></li><li>미들웨어 (Middleware 또는 Route Middleware)<ul><li><em>페이지 컴포넌트가 렌더링되기 전에 호출됩니다.</em></li><li><em>조건을 설정하거나 체크할수도 있으며 페이지를 리다이렉트(redirect)하는데 사용할 수 있습니다.</em></li><li>전역 미들웨어(Global middleware) <em>- 모든 라우트에 영향을 끼치며, <strong>route.config.js</strong>에 정의합니다.</em></li><li>레이아웃 미들웨어(Layout middleware) <em>- 라우트 그룹에 영향을 끼치며, <strong>layout</strong>에 정의합니다.</em></li><li>페이지 미들웨어(Page middleware) <em>- 싱글 라우트에 영향을 끼치며, <strong>page component</strong>에 정의합니다.</em></li></ul></li><li><em>validate</em><ul><li><em>동적 라우트 파라미터(dynamic route parameter)를 검증하는데 유용합니다.</em></li><li><em>페이지 컴포넌트가 렌더링 되기 전에 호출됩니다.</em></li></ul></li><li>asyncData<ul><li><em>페이지 컴포넌트가 로딩되기 전에 매번 호출됩니다.</em></li><li><em>컴포넌트 <code>data</code> 프로퍼티와 병합(merge)됩니다.</em></li></ul></li><li>beforeCreate (Vue 라이크사이클 메서드)<ul><li><em>Vue 인스턴트(instance)가 초기화(initialized) 될때 호출됩니다.</em></li></ul></li><li>created (Vue 라이크사이클 메서드)</li><li>The new fetch (top to bottom, siblings = parallel)</li><li>상태의 일렬화(Serialization of state) (<code>render:routeContext</code> Nuxt.js hook)</li><li>HTML을 렌더링 할때 일어난다. (<code>render:route</code> Nuxt.js hook)</li><li><code>render:routeDone</code> 훅: HTML 파일을 브라우저로 보낼때 일어난다.</li><li><code>generate:before</code> Nuxt.js hook</li><li>HTML 파일들을 생성한다.<ul><li><strong>Full static generation</strong><ul><li>e.g. 정적 페이로드(static payloads)를 추출한다.</li></ul></li></ul></li><li><code>generate:page</code> (HTML 편집가능(editable))</li><li><code>generate:routeCreated</code> (Route가 생성된다.)</li><li><code>generate:done</code> 훅: 모든 HTML 파일들이 생성될때 일어난다.</li></ul><h3 id="Client"><a href="#Client" class="headerlink" title="Client"></a>Client</h3><p>여러분이 Nuxt.js의 어떤 모드를 선택하든, 이 부분은 라이프사이클 중에 완전히 브라우저에서 실행된다.</p><ul><li>HTML 파일을 받는다(Receives).</li><li>assets 로딩하기 (e.g. JavaScript)</li><li>Vue Hydration</li><li>미들웨어 (Middleware 또는 Route Middleware)<ul><li><em>페이지 컴포넌트가 렌더링되기 전에 호출됩니다.</em></li><li><em>조건을 설정하거나 체크할수도 있으며 페이지를 리다이렉트(redirect)하는데 사용할 수 있습니다.</em></li><li>전역 미들웨어(Global middleware) <em>- 모든 라우트에 영향을 끼치며, <strong>route.config.js</strong>에 정의합니다.</em></li><li>레이아웃 미들웨어(Layout middleware) <em>- 라우트 그룹에 영향을 끼치며, <strong>layout</strong>에 정의합니다.</em></li><li>페이지 미들웨어(Page middleware) <em>- 싱글 라우트에 영향을 끼치며, <strong>page component</strong>에 정의합니다.</em></li></ul></li><li>클라이언트 사이드(client-side) Nuxt.js 플러그인<ul><li>nuxt.config.js에 정의된 순서대로 <em>(in order as defined in nuxt.config.js)</em></li></ul></li><li>asyncData (비동기, blocking)<ul><li><em>페이지 컴포넌트가 로딩되기 전에 매번 호출됩니다.</em></li><li><em>컴포넌트 <code>data</code> 프로퍼티와 병합(merge)됩니다.</em></li></ul></li><li>beforeCreate (Vue 라이크사이클 메서드)<ul><li><em>Vue 인스턴트(instance)가 초기화(initialized) 될때 호출됩니다.</em></li></ul></li><li>created (Vue 라이크사이클 메서드)</li><li>The new fetch (top to bottom, siblings = parallel) (동기, non-blocking)</li><li>beforeMount (Vue 라이크사이클 메서드)</li><li>mounted (Vue 라이크사이클 메서드)</li></ul><h3 id="NuxtLink-컴포넌트-component-를-사용한-네비게이트-Navigate"><a href="#NuxtLink-컴포넌트-component-를-사용한-네비게이트-Navigate" class="headerlink" title="NuxtLink 컴포넌트(component)를 사용한 네비게이트(Navigate)"></a>NuxtLink 컴포넌트(component)를 사용한 네비게이트(Navigate)</h3><p>클라이언트 사이드 부분과 동일하게 브라우저에서 모든것이 발생하지만 오직 <code>&lt;NuxtLink&gt;</code>를 통해 네비게이팅 될때만 발생합니다.</p><blockquote><p><a href="https://nuxtjs.org/docs/2.x/features/nuxt-components#the-nuxtlink-component"><code>&lt;NuxtLink&gt;</code></a> 에 대한 더 자세한 정보는 컴포넌트 챕터에서 확인하세요</p></blockquote><ul><li>middleware (비동기, blocking)</li><li>전역 미들웨어(Global middleware)</li><li>레이아웃 미들웨어(Layout middleware)</li><li>라우트 미들웨어(Route middleware)</li><li>asyncData (비동기, blocking)</li><li>asyncData (비동기, blocking) [또는 완전히 정적 페이로드(static payload)가 로딩된 후]</li><li>beforeCreate &amp; created (Vue 라이크사이클 메서드)</li><li>fetch (동기, non-blocking)</li><li>beforeMount &amp; mounted</li></ul><h2 id="중간-정리"><a href="#중간-정리" class="headerlink" title="중간 정리"></a>중간 정리</h2><p>Nuxt의 라이프사이클은 전체적으로 서버와 클라이언트 사이드 부분으로 나뉘는 것을 알 수 있으며 각 부분에서 공통으로 실행되는 과정과 아닌 과정이 있음을 확인할 수 있었습니다. 또한, 정적 (Static) 어플리케이션를 만드느냐 SSR(Server-Side Rendering) 또는 유니버설(universal) 어플리케이션을 만드느냐에 따라 과정이 달라질 수 있다.</p><h2 id="추가-공부"><a href="#추가-공부" class="headerlink" title="추가 공부"></a>추가 공부</h2><p>라이프사이클에 대해 공부 및 정리하면서 봤던 내용들에 대해 정리해보자.</p><h3 id="1-활용도가-높고-중요한-몇가지-훅"><a href="#1-활용도가-높고-중요한-몇가지-훅" class="headerlink" title="1. 활용도가 높고 중요한 몇가지 훅"></a>1. 활용도가 높고 중요한 몇가지 훅</h3><ul><li>middleware(클라이언트, 서버)<ul><li>클라이언트와 서버 모두 훅들이 본격적으로 호출되기 전에, 앱을 만드는 과정에서 미리 정의해놓은 미들웨어들이 먼저 동작합니다.</li><li>만약 <code>serverMiddlware</code>을 정의했다면 서버 사이드에서만 렌더링 과정에서 일반 미들웨어가 동작하기 전에 먼저 동작합니다.</li></ul></li><li>asyncData(서버 or 클라이언트)<ul><li>서버 혹은 클라이언트 사이드에서 생명주기 통틀어 한번씩만 호출되는 훅입니다.</li><li>Vue 인스턴스의 생명주기 이전에 먼저 데이터를 가져와서 렌더링을 하고싶은 경우에 사용합니다.</li><li>컴포넌트를 로드하기 전에 항상 호출되며, 페이지 컴포넌트의 경우에만 사용할 수 있습니다.</li><li>asyncData 의 리턴값은 Vue 인스턴스의 data()와 병합됩니다.</li></ul></li><li>beforeCreated, created(클라이언트, 서버)<ul><li>서버에서 새로운 vue 인스턴스를 생성한 뒤 이를 프리랜더링 하기 때문에 Vue 인스턴스가 서버에서 만들어지는 시점에 created와 beforeCreated 훅이 호출됩니다.</li><li>또한 클라이언트에서도 인스턴스를 만들고 $mount 메소드가 호출될 때도 따라 호출됩니다.</li><li>즉 서버와 클라이언트 사이드 양쪽에서 호출되는 훅입니다.</li></ul></li><li>beforeMount 이후의 훅(클라이언트)<ul><li>클라이언트 사이드에서만, 하이드레이션 이후에 $mount 메소드가 호출될 때 나머지 Vue 생명주기 훅들이 실행됩니다.</li></ul></li></ul><p><em>출처: 참조 1</em></p><h3 id="2-Nuxt-js-비동기-데이터"><a href="#2-Nuxt-js-비동기-데이터" class="headerlink" title="2. Nuxt.js 비동기 데이터"></a>2. Nuxt.js 비동기 데이터</h3><blockquote><p>Nuxt.js에는 비동기데이터 가져 오기를 위해 설계된 3가지 후크가 있다.</p></blockquote><ul><li>nuxtServerInit : 모든 페이지에 호출되는 VueX 저장소를 미리 채우는 데 사용됩니다.</li><li>fetch : 페이지 내에서 호출 된 데이터로 VueX 저장소를 미리 채우는 데 사용됩니다.</li><li>asyncData : data 페이지의 객체와 동기 데이터를 병합하는데 사용된다. 비동기 방식으로 미들웨어를 사용할 수도 있습니다. 즉, 미들웨어를 사용하여 VueX 저장소를 채울 수 있습니다.</li></ul><p><img src="https://linked2ev.github.io/assets/img/devlog/201811/Nust-SSR-sample-s1.png" alt="Nust-SSR"></p><h4 id="asyncData-메소드"><a href="#asyncData-메소드" class="headerlink" title="asyncData 메소드"></a>asyncData 메소드</h4><p>서버사이드에서 데이터를 가져와서 렌더링하고 싶을 때, 이때 pages 컴포넌트를 로딩하기 전에 매번 호출되는 <code>asyncData</code>를 사용하면 된다.</p><ul><li>pages 컴포넌트에서만 지원됩니다.</li><li>서버사이드에서 호출되거나 페이지를 이동할 때 호출</li><li>컴포넌트가 렌더링 되기 전에 호출</li><li>context 인자 사용가능</li><li>nuxt.js가 <code>컴포넌트와 데이터를 자동으로 Merge하는 개념</code></li></ul><blockquote><p><code>!! asyncData 안에서 컴포넌트가 생성되기 전에 호출하기 때문에 this를 엑세스할 수 없다.</code></p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  data () &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      title: &#39;&#39;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  asyncData (&#123; params &#125;) &#123;</span><br><span class="line">    return axios.get(&#96;http:&#x2F;&#x2F;localhost:8080&#x2F;test&#x2F;1&#96;)</span><br><span class="line">    .then((res) &#x3D;&gt; &#123;</span><br><span class="line">      &#x2F;&#x2F; 여기서 this는 컴포넌트 생성 전이기에 &#39;undefined&#39;</span><br><span class="line">      return this.title &#x3D; res.data</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure><p><em>출처: 참조 2</em></p><h4 id="3-asyncData-와-fetch"><a href="#3-asyncData-와-fetch" class="headerlink" title="3. asyncData()와 fetch()"></a>3. asyncData()와 fetch()</h4><ul><li><p>두 개의 Hook은 매우 비슷해보이면서 목적은 다름</p><ul><li>공통점: 컴포넌트가 로딩되기 전에 매번 호출된다는 점, 첫번째 인자로 컨텍스트 오브젝트를 받음</li></ul></li><li><p>asyncData</p><ul><li>페이지가 로딩되기전에 컴포넌트 data를 미리 지정하여 컴포넌트가 생성될 때 병합하는데에 목적</li><li>즉 필요한 컴포넌트의 data를 컴포넌트가 랜더링 되기 전에 미리 지정하여 보다 빠르게 구성한다는 데에 목적을 둠</li></ul></li><li><p>fetch</p><ul><li>주로 비동기 작업을 작성하게 되면, 컴포넌트가 랜더링 되기전에 이 작업을 기다리게 됨</li><li>예를들어 유저정보가 필요한 컴포넌트라면 <code>fetch</code> 부분에 유저정보를 가져오는 API를 호출하여 활용할 수 있음</li></ul></li><li><p>요약하자면,</p><ul><li><code>asyncData</code>는 컴포넌트가 랜더링 되기전에 <em>컴포넌트 데이터를 구성하는데에 목적</em>이 있고,</li><li><code>fetch</code>는 컴포넌트가 랜더링 되기전에 <em>비동기로직을 호출하는데에 목적</em>이 있다고 생각합니다!</li></ul></li></ul><p><em>출처: 참조 4</em></p><h4 id="4-잘-정리된-Nuxt-Lifecucle-Hooks"><a href="#4-잘-정리된-Nuxt-Lifecucle-Hooks" class="headerlink" title="4. 잘 정리된 Nuxt Lifecucle Hooks"></a>4. 잘 정리된 Nuxt Lifecucle Hooks</h4><p><img src="https://miro.medium.com/max/1400/0*e4lPLcP-qGU9g8sv.jpg" alt="Nuxt Lifecucle Hooks"></p><p><em>출처: 참조 5</em></p><hr><h2 id="참조"><a href="#참조" class="headerlink" title="참조"></a>참조</h2><ul><li>(1) <a href="https://maxkim-j.github.io/posts/nuxt-ssr">🌧 Nuxt로 살펴보는 서버사이드 렌더링의 핵심</a></li><li>(2) <a href="https://linked2ev.github.io/devlog/2018/11/21/Nuxt-%EC%99%84-6.-Nuxt-SSR-sample/">[Nuxt][완] 6. Nuxt.js로 SSR 확인</a></li><li>(3) <a href="https://evan-moon.github.io/2018/09/25/vue-ssr/">Vue Server Side Rendering</a></li><li>(4) <a href="https://www.a-ha.io/questions/4050f94b442d0048b8c81562dc3d26e1">Nuxt.js 에서 asyncData() 와 fetch() 은 차이는 무엇인가요?</a></li><li>(5) <a href="https://medium.com/@imsukmin/%EB%B2%88%EC%97%AD-universal-application-code-structure-in-nuxt-js-f624f2e5e7e9">[번역] Universal application code structure in Nuxt.js</a></li></ul>]]></content:encoded>
      
      
      <category domain="https://joontae-kim.github.io/categories/Programming/">Programming</category>
      
      <category domain="https://joontae-kim.github.io/categories/Programming/nuxt/">nuxt</category>
      
      
      <category domain="https://joontae-kim.github.io/tags/vue-js/">vue.js</category>
      
      <category domain="https://joontae-kim.github.io/tags/nuxt-js/">nuxt.js</category>
      
      <category domain="https://joontae-kim.github.io/tags/vue/">vue</category>
      
      <category domain="https://joontae-kim.github.io/tags/nuxt/">nuxt</category>
      
      <category domain="https://joontae-kim.github.io/tags/lifecycle/">lifecycle</category>
      
      <category domain="https://joontae-kim.github.io/tags/nuxt-lifecycle/">nuxt lifecycle</category>
      
      
      <comments>https://joontae-kim.github.io/2021/03/18/nuxt-lifecycle/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>Nuxt 디렉토리 구조</title>
      <link>https://joontae-kim.github.io/2021/03/18/nuxt-directory-3/</link>
      <guid>https://joontae-kim.github.io/2021/03/18/nuxt-directory-3/</guid>
      <pubDate>Thu, 18 Mar 2021 07:11:39 GMT</pubDate>
      
        
        
      <description>&lt;h3 id=&quot;1-Nuxt-프로젝트-디렉토리&quot;&gt;&lt;a href=&quot;#1-Nuxt-프로젝트-디렉토리&quot; class=&quot;headerlink&quot; title=&quot;1.Nuxt 프로젝트 디렉토리&quot;&gt;&lt;/a&gt;1.Nuxt 프로젝트 디렉토리&lt;/h3&gt;&lt;p&gt;막 생성된 nuxt 프로젝</description>
        
      
      
      
      <content:encoded><![CDATA[<h3 id="1-Nuxt-프로젝트-디렉토리"><a href="#1-Nuxt-프로젝트-디렉토리" class="headerlink" title="1.Nuxt 프로젝트 디렉토리"></a>1.Nuxt 프로젝트 디렉토리</h3><p>막 생성된 nuxt 프로젝트의 디렉토리는 아래와 같다. 디렉토리에 대한 정의를 잘 몰라도 이미 Vue.js를 사용했던 개발자라면 비슷한 구조이며 스캐폴딩이 이미 되어있다는 생각이 들것이다.<br><img src="/images/nuxt-directory.png" alt="nuxt 프로젝트 디렉토리"></p><p>각 디렉토리의 역할에 대해 알아보자.</p><h4 id="static"><a href="#static" class="headerlink" title="static"></a>static</h4><p>The <code>static</code> directory is directly mapped to the server root and contains files that likely won’t be changed. All included files will be automatically served by Nuxt and are accessible through your project root URL.</p><p><code>/static/robots.txt</code> will be available at <code>http://localhost:3000/robots.txt</code></p><p><code>/static/favicon.ico</code> will be available at <code>http://localhost:3000/favicon.ico</code></p><p>This option is helpful for files like <code>robots.txt</code>, <code>sitemap.xml</code> or <code>CNAME</code> (which is important for GitHub Pages deployment).</p><blockquote><p>This directory cannot be renamed without extra configuration.</p></blockquote><h5 id="Static-Assets"><a href="#Static-Assets" class="headerlink" title="Static Assets"></a>Static Assets</h5><p>If you don’t want to use Webpack <code>assets</code> from the assets directory, you can add the images to the static directory.</p><p>In your code, you can then reference these files relative to the root (<code>/</code>):</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- Static image from static directory --&gt;</span><br><span class="line">&lt;img src&#x3D;&quot;&#x2F;my-image.png&quot; &#x2F;&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- webpacked image from assets directory --&gt;</span><br><span class="line">&lt;img src&#x3D;&quot;~&#x2F;assets&#x2F;my-image-2.png&quot; &#x2F;&gt;</span><br></pre></td></tr></table></figure><h5 id="Static-Directory-Config"><a href="#Static-Directory-Config" class="headerlink" title="Static Directory Config"></a>Static Directory Config</h5><p>Should you need to you can configure the <code>static/</code> directory behavior in the <code>nuxt.config.js</code> file.</p><h6 id="Static-asset-Prefix"><a href="#Static-asset-Prefix" class="headerlink" title="Static asset Prefix"></a>Static asset Prefix</h6><p>If you deploy Nuxt.js to a subfolder, e.g. <code>/blog/</code>, the router base will be added to the static asset path by default. If you want to disable this behavior, you can set <code>static.prefix</code> to false in the <code>nuxt.config.js</code>.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">export default &#123;</span><br><span class="line">  static: &#123;</span><br><span class="line">    prefix: false</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Default: <code>/blog/my-image.png</code><br>With <code>static.prefix</code> disabled: <code>/my-image.png</code></p><h4 id="store"><a href="#store" class="headerlink" title="store"></a>store</h4><p>The <code>store</code> directory contains your <a href="https://vuex.vuejs.org/guide/">Vuex Store</a> files. The Vuex Store comes with Nuxt.js out of the box but is disabled by default. Creating an  index.js  file in this directory enables the store.</p><blockquote><p>This directory cannot be renamed without extra configuration.</p></blockquote><h5 id="Activate-the-Store"><a href="#Activate-the-Store" class="headerlink" title="Activate the Store"></a>Activate the Store</h5><p>Nuxt.js will look for the <code>store</code> directory. If it contains a file, that isn’t a hidden file or a <code>README.md</code> file, then the store will be activated. This means that Nuxt will:</p><ol><li>Import Vuex,</li><li>Add the <code>store</code> option to the root Vue instance.</li></ol><h5 id="Modules"><a href="#Modules" class="headerlink" title="Modules"></a>Modules</h5><p>Every <code>.js</code> file inside the <code>store</code> directory is transformed as a <a href="https://vuex.vuejs.org/guide/modules.html">namespaced module</a> (<code>index</code> being the root module). Your <code>state</code> value should always be a <code>function</code> to avoid unwanted shared state on the server side.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- store&#x2F;index.js --&gt;</span><br><span class="line"></span><br><span class="line">new Vuex.Store(&#123;</span><br><span class="line">  state: () &#x3D;&gt; (&#123;</span><br><span class="line">    counter: 0</span><br><span class="line">  &#125;),</span><br><span class="line">  mutations: &#123;</span><br><span class="line">    increment(state) &#123;</span><br><span class="line">      state.counter++</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  modules: &#123;</span><br><span class="line">    todos: &#123;</span><br><span class="line">      namespaced: true,</span><br><span class="line">      state: () &#x3D;&gt; (&#123;</span><br><span class="line">        list: []</span><br><span class="line">      &#125;),</span><br><span class="line">      mutations: &#123;</span><br><span class="line">        add(state, &#123; text &#125;) &#123;</span><br><span class="line">          state.list.push(&#123;</span><br><span class="line">            text,</span><br><span class="line">            done: false</span><br><span class="line">          &#125;)</span><br><span class="line">        &#125;,</span><br><span class="line">        remove(state, &#123; todo &#125;) &#123;</span><br><span class="line">          state.list.splice(state.list.indexOf(todo), 1)</span><br><span class="line">        &#125;,</span><br><span class="line">        toggle(state, &#123; todo &#125;) &#123;</span><br><span class="line">          todo.done &#x3D; !todo.done</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>And in your pages/todos.vue, using the todos module:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- pages&#x2F;todos.vue --&gt;</span><br><span class="line"></span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;ul&gt;</span><br><span class="line">    &lt;li v-for&#x3D;&quot;todo in todos&quot; :key&#x3D;&quot;todo.text&quot;&gt;</span><br><span class="line">      &lt;input :checked&#x3D;&quot;todo.done&quot; @change&#x3D;&quot;toggle(todo)&quot; type&#x3D;&quot;checkbox&quot;&gt;</span><br><span class="line">      &lt;span :class&#x3D;&quot;&#123; done: todo.done &#125;&quot;&gt;&#123;&#123; todo.text &#125;&#125;&lt;&#x2F;span&gt;</span><br><span class="line">    &lt;&#x2F;li&gt;</span><br><span class="line">    &lt;li&gt;&lt;input @keyup.enter&#x3D;&quot;addTodo&quot; placeholder&#x3D;&quot;What needs to be done?&quot;&gt;&lt;&#x2F;li&gt;</span><br><span class="line">  &lt;&#x2F;ul&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">import &#123; mapMutations &#125; from &#39;vuex&#39;</span><br><span class="line"></span><br><span class="line">export default &#123;</span><br><span class="line">  computed: &#123;</span><br><span class="line">    todos () &#123;</span><br><span class="line">      return this.$store.state.todos.list</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    addTodo (e) &#123;</span><br><span class="line">      this.$store.commit(&#39;todos&#x2F;add&#39;, e.target.value)</span><br><span class="line">      e.target.value &#x3D; &#39;&#39;</span><br><span class="line">    &#125;,</span><br><span class="line">    ...mapMutations(&#123;</span><br><span class="line">      toggle: &#39;todos&#x2F;toggle&#39;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style&gt;</span><br><span class="line">.done &#123;</span><br><span class="line">  text-decoration: line-through;</span><br><span class="line">&#125;</span><br><span class="line">&lt;&#x2F;style&gt;</span><br></pre></td></tr></table></figure><h5 id="Example-folder-structure"><a href="#Example-folder-structure" class="headerlink" title="Example folder structure"></a>Example folder structure</h5><p>A complex store setup file/folder structure might look like this:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">store&#x2F;</span><br><span class="line">--| index.js</span><br><span class="line">--| ui.js</span><br><span class="line">--| shop&#x2F;</span><br><span class="line">----| cart&#x2F;</span><br><span class="line">------| actions.js</span><br><span class="line">------| getters.js</span><br><span class="line">------| mutations.js</span><br><span class="line">------| state.js</span><br><span class="line">----| products&#x2F;</span><br><span class="line">------| mutations.js</span><br><span class="line">------| state.js</span><br><span class="line">------| itemsGroup1&#x2F;</span><br><span class="line">--------| state.js</span><br></pre></td></tr></table></figure><h4 id="nuxt-config"><a href="#nuxt-config" class="headerlink" title="nuxt.config"></a>nuxt.config</h4><p>By default, Nuxt.js is configured to cover most use cases. This default configuration can be overwritten with the nuxt.config.js file.</p><h5 id="nuxt-config-js"><a href="#nuxt-config-js" class="headerlink" title="nuxt.config.js"></a>nuxt.config.js</h5><h6 id="alias"><a href="#alias" class="headerlink" title="alias"></a>alias</h6><p>This option lets you define aliases that will be available within your JavaScript and CSS.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">nuxt.config.js</span><br><span class="line">import &#123; resolve &#125; from &#39;path&#39;</span><br><span class="line"></span><br><span class="line">export default &#123;</span><br><span class="line">  alias: &#123;</span><br><span class="line">    &#39;style&#39;: resolve(__dirname, &#39;.&#x2F;assets&#x2F;style&#39;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="css"><a href="#css" class="headerlink" title="css"></a>css</h6><p>This option lets you define the CSS files, modules, and libraries you want to include globally (on every page).</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">export default &#123;</span><br><span class="line">  css: [&#39;~&#x2F;assets&#x2F;css&#x2F;main.css&#39;, &#39;~&#x2F;assets&#x2F;css&#x2F;animations.scss&#39;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="env"><a href="#env" class="headerlink" title="env"></a>env</h6><p>This option lets you define environment variables that are required at build time (rather than runtime) such as <code>NODE_ENV=staging</code> or <code>VERSION=1.2.3</code>. However, for runtime environment variables <code>runtimeConfig</code> is required.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">export default &#123;</span><br><span class="line">  env: &#123;</span><br><span class="line">    baseURL: process.env.BASE_URL</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="More-Configuration-property"><a href="#More-Configuration-property" class="headerlink" title="More Configuration property"></a>More Configuration property</h6><p><em>Refer <a href="https://nuxtjs.org/docs/2.x/directory-structure/nuxt-config">https://nuxtjs.org/docs/2.x/directory-structure/nuxt-config</a></em></p>]]></content:encoded>
      
      
      <category domain="https://joontae-kim.github.io/categories/Programming/">Programming</category>
      
      <category domain="https://joontae-kim.github.io/categories/Programming/nuxt/">nuxt</category>
      
      
      <category domain="https://joontae-kim.github.io/tags/vue-js/">vue.js</category>
      
      <category domain="https://joontae-kim.github.io/tags/nuxt-js/">nuxt.js</category>
      
      <category domain="https://joontae-kim.github.io/tags/vue/">vue</category>
      
      <category domain="https://joontae-kim.github.io/tags/nuxt/">nuxt</category>
      
      
      <comments>https://joontae-kim.github.io/2021/03/18/nuxt-directory-3/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>Nuxt 디렉토리 구조</title>
      <link>https://joontae-kim.github.io/2021/03/18/nuxt-directory-2/</link>
      <guid>https://joontae-kim.github.io/2021/03/18/nuxt-directory-2/</guid>
      <pubDate>Thu, 18 Mar 2021 07:05:00 GMT</pubDate>
      
        
        
      <description>&lt;h3 id=&quot;1-Nuxt-프로젝트-디렉토리&quot;&gt;&lt;a href=&quot;#1-Nuxt-프로젝트-디렉토리&quot; class=&quot;headerlink&quot; title=&quot;1.Nuxt 프로젝트 디렉토리&quot;&gt;&lt;/a&gt;1.Nuxt 프로젝트 디렉토리&lt;/h3&gt;&lt;p&gt;막 생성된 nuxt 프로젝</description>
        
      
      
      
      <content:encoded><![CDATA[<h3 id="1-Nuxt-프로젝트-디렉토리"><a href="#1-Nuxt-프로젝트-디렉토리" class="headerlink" title="1.Nuxt 프로젝트 디렉토리"></a>1.Nuxt 프로젝트 디렉토리</h3><p>막 생성된 nuxt 프로젝트의 디렉토리는 아래와 같다. 디렉토리에 대한 정의를 잘 몰라도 이미 Vue.js를 사용했던 개발자라면 비슷한 구조이며 스캐폴딩이 이미 되어있다는 생각이 들것이다.<br><img src="/images/nuxt-directory.png" alt="nuxt 프로젝트 디렉토리"></p><p>각 디렉토리의 역할에 대해 알아보자.</p><h4 id="modules"><a href="#modules" class="headerlink" title="modules"></a>modules</h4><p>Nuxt Module은 Nuxt 프레임워크의 핵심 기능을 확장하고 통합 및 추가할 수 있다. 사용자가 직접 모듈을 작성할 수 있으며 Nuxt 커뮤니티에 이미 많은 모듈이 공개되어있다.</p><p><img src="https://nuxtjs.org/docs/2.x/modules.svg" alt="Nuxt modules Cheetsheet"></p><h5 id="The-modules-Property"><a href="#The-modules-Property" class="headerlink" title="The modules Property"></a>The modules Property</h5><p>Modules are Nuxt.js extensions which can extend the framework’s core functionality and add endless integrations. Once you have installed the modules you can then add them to your nuxt.config.js file under the modules property.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- nuxt.config.js --&gt;</span><br><span class="line"></span><br><span class="line">export default &#123;</span><br><span class="line">  modules: [</span><br><span class="line">    &#x2F;&#x2F; Using package name</span><br><span class="line">    &#39;@nuxtjs&#x2F;axios&#39;,</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Relative to your project srcDir</span><br><span class="line">    &#39;~&#x2F;modules&#x2F;awesome.js&#39;,</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Providing options</span><br><span class="line">    [&#39;@nuxtjs&#x2F;google-analytics&#39;, &#123; ua: &#39;X1234567&#39; &#125;],</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Inline definition</span><br><span class="line">    function () &#123;&#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>Module developers usually provide additionally needed steps and details for usage.</p></blockquote><p>Nuxt.js tries to resolve each item in the modules array using node require path (in the node_modules) and then will resolve from the project srcDir if @ alias is used.</p><blockquote><p>Modules are executed sequentially so the order is important.</p></blockquote><p>Modules should export a function to enhance build/runtime and optionally return a promise until their job is finished. Note that they are imported at runtime so they should be already transpiled if using modern ES6 features.</p><h4 id="pages"><a href="#pages" class="headerlink" title="pages"></a>pages</h4><p>The pages directory contains your application views and routes. Nuxt.js reads all the .vue files inside this directory and automatically creates the router configuration for you.</p><blockquote><p>You can also create routes with .js files and .ts files</p></blockquote><p>Every Page component is a Vue component but Nuxt.js adds special attributes and functions to make the development of your universal application as easy as possible.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;h1 class&#x3D;&quot;red&quot;&gt;Hello &#123;&#123; name &#125;&#125;!&lt;&#x2F;h1&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">  export default &#123;</span><br><span class="line">    &#x2F;&#x2F; page properties go here</span><br><span class="line">  &#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style&gt;</span><br><span class="line">  .red &#123;</span><br><span class="line">    color: red;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;&#x2F;style&gt;</span><br></pre></td></tr></table></figure><h5 id="Dynamic-Pages"><a href="#Dynamic-Pages" class="headerlink" title="Dynamic Pages"></a>Dynamic Pages</h5><p>Dynamic pages can be created when you don’t know the name of the page due to it coming from an API or you don’t want to have to create the same page over and over again. To create a dynamic page you need to add an underscore before the .vue file name or before the the name of the directory, if you want the directory to be dynamic. You can name the file or directory anything you want but you must prefix it with an underscore.</p><p>If you’ve defined a file named <code>_slug.vue</code> in your pages folder, you can access the value using the context with params.slug</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- pages&#x2F;_slug.vue --&gt;</span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;h1&gt;&#123;&#123; this.slug &#125;&#125;&lt;&#x2F;h1&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">  export default &#123;</span><br><span class="line">    async asyncData(&#123; params &#125;) &#123;</span><br><span class="line">      const slug &#x3D; params.slug &#x2F;&#x2F; When calling &#x2F;abc the slug will be &quot;abc&quot;</span><br><span class="line">      return &#123; slug &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure><p>If you’ve defined a file named _slug.vue inside a folder called _book you can access the value using the context with params.slug and params.book</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">pages&#x2F;_book&#x2F;_slug.vue</span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;h1&gt;&#123;&#123; this.book &#125;&#125; &#x2F; &#123;&#123; this.slug &#125;&#125;&lt;&#x2F;h1&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">  export default &#123;</span><br><span class="line">    async asyncData(&#123; params &#125;) &#123;</span><br><span class="line">      const book &#x3D; params.book</span><br><span class="line">      const slug &#x3D; params.slug</span><br><span class="line">      return &#123; book, slug &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure><h5 id="Properties"><a href="#Properties" class="headerlink" title="Properties"></a>Properties</h5><h6 id="asyncData"><a href="#asyncData" class="headerlink" title="asyncData"></a>asyncData</h6><p>asyncData is called every time before loading the component. It can be asynchronous and receives the context as an argument. The returned object will be merged with your data object.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- pages&#x2F;index.vue --&gt;</span><br><span class="line"></span><br><span class="line">export default &#123;</span><br><span class="line">  asyncData(context) &#123;</span><br><span class="line">    return &#123; name: &#39;World&#39; &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="fetch"><a href="#fetch" class="headerlink" title="fetch"></a>fetch</h6><p>Every time you need to get asynchronous data you can use fetch. Fetch is called on server-side when rendering the route, and on client-side when navigating.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">  export default &#123;</span><br><span class="line">    data() &#123;</span><br><span class="line">      return &#123;</span><br><span class="line">        posts: []</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    async fetch() &#123;</span><br><span class="line">      this.posts &#x3D; await fetch(&#39;https:&#x2F;&#x2F;api.nuxtjs.dev&#x2F;posts&#39;).then(res &#x3D;&gt;</span><br><span class="line">        res.json()</span><br><span class="line">      )</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure><h6 id="head"><a href="#head" class="headerlink" title="head"></a>head</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">export default &#123;</span><br><span class="line">  head() &#123;</span><br><span class="line">    &#x2F;&#x2F; Set Meta Tags for this Page</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="layout"><a href="#layout" class="headerlink" title="layout"></a>layout</h6><p>Specify a layout defined in the layouts directory.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- pages&#x2F;index.vue --&gt;</span><br><span class="line"></span><br><span class="line">export default &#123;</span><br><span class="line">  layout: &#39;blog&#39;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="loading"><a href="#loading" class="headerlink" title="loading"></a>loading</h6><p><a href="https://nuxtjs.org/docs/2.x/directory-structure/pages#loading">https://nuxtjs.org/docs/2.x/directory-structure/pages#loading</a></p><h6 id="transition"><a href="#transition" class="headerlink" title="transition"></a>transition</h6><p><a href="https://nuxtjs.org/docs/2.x/directory-structure/pages#transition">https://nuxtjs.org/docs/2.x/directory-structure/pages#transition</a></p><h6 id="scrollToTop"><a href="#scrollToTop" class="headerlink" title="scrollToTop"></a>scrollToTop</h6><p><a href="https://nuxtjs.org/docs/2.x/directory-structure/pages#scrolltotop">https://nuxtjs.org/docs/2.x/directory-structure/pages#scrolltotop</a></p><h6 id="middleware"><a href="#middleware" class="headerlink" title="middleware"></a>middleware</h6><p><a href="https://nuxtjs.org/docs/2.x/directory-structure/pages#middleware">https://nuxtjs.org/docs/2.x/directory-structure/pages#middleware</a></p><h4 id="plugins"><a href="#plugins" class="headerlink" title="plugins"></a>plugins</h4><p><img src="https://nuxtjs.org/docs/2.x/plugins.svg" alt="Nuxt Plugins Cheetsheet"><br>The plugins directory contains JavaScript plugins that you want to run before instantiating the root Vue.js Application. This is the place to add Vue plugins and to inject functions or constants. Every time you need to use Vue.use(), you should create a file in plugins/ and add its path to plugins in nuxt.config.js.</p><h5 id="External-Packages"><a href="#External-Packages" class="headerlink" title="External Packages"></a>External Packages</h5><p>You may want to use external packages/modules in your application (one great example is axios) for making HTTP requests for both server and client.</p><h6 id="Install-Package"><a href="#Install-Package" class="headerlink" title="Install Package"></a>Install Package</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install @nuxtjs&#x2F;axios</span><br></pre></td></tr></table></figure><p>You can configure for example the axios interceptors to react on possible errors from your API calls across the application. In this example we redirect the user to a custom error page called sorry when we get a 500 status error from our API.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">plugins&#x2F;axios.js</span><br><span class="line">export default function (&#123; $axios, redirect &#125;) &#123;</span><br><span class="line">  $axios.onError(error &#x3D;&gt; &#123;</span><br><span class="line">    if (error.response.status &#x3D;&#x3D;&#x3D; 500) &#123;</span><br><span class="line">      redirect(&#39;&#x2F;sorry&#39;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Last but not least, add the module and the newly created plugin to the project configuration.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">nuxt.config.js</span><br><span class="line">module.exports &#x3D; &#123;</span><br><span class="line">  modules: [&#39;@nuxtjs&#x2F;axios&#39;],</span><br><span class="line">  plugins: [&#39;~&#x2F;plugins&#x2F;axios.js&#39;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Then we can use it directly in your page components:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;h1&gt;&#123;&#123; post.title &#125;&#125;&lt;&#x2F;h1&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">    async asyncData (&#123; $axios, params &#125;) &#123;</span><br><span class="line">      const  post  &#x3D; await $axios.$get(&#96;https:&#x2F;&#x2F;api.nuxtjs.dev&#x2F;posts&#x2F;$&#123;params.id&#125;&#96;)</span><br><span class="line">      return &#123; post &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure><p>Another way to use axios without installing the module is by importing axios direct in the <code>&lt;script&gt;</code> tag.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- pages&#x2F;index.vue --&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">import axios from &#39;axios&#39;</span><br><span class="line"></span><br><span class="line">export default &#123;</span><br><span class="line">    async asyncData (&#123; params &#125;) &#123;</span><br><span class="line">      const &#123; data: post &#125;  &#x3D; await axios.get(&#96;https:&#x2F;&#x2F;api.nuxtjs.dev&#x2F;posts&#x2F;$&#123;params.id&#125;&#96;)</span><br><span class="line">      return &#123; post &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure><blockquote><p>If you get an Cannot use import statement outside a module error, you may need to add your package to the build &gt; transpile option in nuxt.config.js for webpack loader to make your plugin available.</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">nuxt.config.js</span><br><span class="line">build: &#123;</span><br><span class="line">  &#x2F;&#x2F; You can extend webpack config here</span><br><span class="line">  transpile: [&#39;npm-package-name&#39;],</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><h6 id="Vue-Plugins"><a href="#Vue-Plugins" class="headerlink" title="Vue Plugins"></a>Vue Plugins</h6><p>If we want to use Vue plugins, like v-tooltip to display tooltips in your application, we need to setup the plugin before launching the app.</p><p>First we need to install it</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- install vue plugin --&gt;</span><br><span class="line">npm install v-tooltip</span><br><span class="line"></span><br><span class="line">&lt;!-- plugins&#x2F;vue-tooltip.js --&gt;</span><br><span class="line"></span><br><span class="line">import Vue from &#39;vue&#39;</span><br><span class="line">import VTooltip from &#39;v-tooltip&#39;</span><br><span class="line"></span><br><span class="line">Vue.use(VTooltip)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h6 id="ES6-Plugins"><a href="#ES6-Plugins" class="headerlink" title="ES6 Plugins"></a>ES6 Plugins</h6><p><a href="https://nuxtjs.org/docs/2.x/directory-structure/plugins#es6-plugins">https://nuxtjs.org/docs/2.x/directory-structure/plugins#es6-plugins</a></p><h6 id="Client-or-server-side-only"><a href="#Client-or-server-side-only" class="headerlink" title="Client or server side only"></a>Client or server side only</h6><p><a href="https://nuxtjs.org/docs/2.x/directory-structure/plugins#client-or-server-side-only">https://nuxtjs.org/docs/2.x/directory-structure/plugins#client-or-server-side-only</a></p>]]></content:encoded>
      
      
      <category domain="https://joontae-kim.github.io/categories/Programming/">Programming</category>
      
      <category domain="https://joontae-kim.github.io/categories/Programming/nuxt/">nuxt</category>
      
      
      <category domain="https://joontae-kim.github.io/tags/vue-js/">vue.js</category>
      
      <category domain="https://joontae-kim.github.io/tags/nuxt-js/">nuxt.js</category>
      
      <category domain="https://joontae-kim.github.io/tags/vue/">vue</category>
      
      <category domain="https://joontae-kim.github.io/tags/nuxt/">nuxt</category>
      
      
      <comments>https://joontae-kim.github.io/2021/03/18/nuxt-directory-2/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>Nuxt 디렉토리 구조</title>
      <link>https://joontae-kim.github.io/2021/03/18/nuxt-directory/</link>
      <guid>https://joontae-kim.github.io/2021/03/18/nuxt-directory/</guid>
      <pubDate>Thu, 18 Mar 2021 03:49:55 GMT</pubDate>
      
        
        
      <description>&lt;h3 id=&quot;1-Nuxt-프로젝트-디렉토리&quot;&gt;&lt;a href=&quot;#1-Nuxt-프로젝트-디렉토리&quot; class=&quot;headerlink&quot; title=&quot;1.Nuxt 프로젝트 디렉토리&quot;&gt;&lt;/a&gt;1.Nuxt 프로젝트 디렉토리&lt;/h3&gt;&lt;p&gt;막 생성된 nuxt 프로젝</description>
        
      
      
      
      <content:encoded><![CDATA[<h3 id="1-Nuxt-프로젝트-디렉토리"><a href="#1-Nuxt-프로젝트-디렉토리" class="headerlink" title="1.Nuxt 프로젝트 디렉토리"></a>1.Nuxt 프로젝트 디렉토리</h3><p>막 생성된 nuxt 프로젝트의 디렉토리는 아래와 같다. 디렉토리에 대한 정의를 잘 몰라도 이미 Vue.js를 사용했던 개발자라면 비슷한 구조이며 스캐폴딩이 이미 되어있다는 생각이 들것이다.<br><img src="/images/nuxt-directory.png" alt="nuxt 프로젝트 디렉토리"></p><p>각 디렉토리의 역할에 대해 알아보자.</p><h4 id="nuxt"><a href="#nuxt" class="headerlink" title=".nuxt"></a>.nuxt</h4><p>The .nuxt directory is the so-called build directory. It is dynamically generated and hidden by default. Inside the directory you can find automatically generated files when using nuxt dev or your build artifacts when using nuxt build.</p><h4 id="assets"><a href="#assets" class="headerlink" title="assets"></a>assets</h4><p>The assets directory contains your uncompiled assets such as Stylus or Sass files, images, or fonts.</p><h5 id="Images"><a href="#Images" class="headerlink" title="Images"></a>Images</h5><p>Inside your vue templates, if you need to link to your assets directory use ~/assets/your_image.png with a slash before assets.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;img src&#x3D;&quot;~&#x2F;assets&#x2F;your_image.png&quot; &#x2F;&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br></pre></td></tr></table></figure><p>Inside your css files, if you need to reference your  assets  directory, use ~assets/your_image.png(without a slash)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">background: url(&#39;~assets&#x2F;banner.svg&#39;);</span><br></pre></td></tr></table></figure><h5 id="Styles"><a href="#Styles" class="headerlink" title="Styles"></a>Styles</h5><p>Nuxt.js lets you define the CSS files/modules/libraries you want to set globally (included in every page). In the nuxt.config you can easily add your styles using the CSS Property.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">export default &#123;</span><br><span class="line">  css: [</span><br><span class="line">    &#x2F;&#x2F; Load a Node.js module directly (here it&#39;s a Sass file)</span><br><span class="line">    &#39;bulma&#39;,</span><br><span class="line">    &#x2F;&#x2F; CSS file in the project</span><br><span class="line">    &#39;~&#x2F;assets&#x2F;css&#x2F;main.css&#39;,</span><br><span class="line">    &#x2F;&#x2F; SCSS file in the project</span><br><span class="line">    &#39;~&#x2F;assets&#x2F;css&#x2F;main.scss&#39;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="Fonts"><a href="#Fonts" class="headerlink" title="Fonts"></a>Fonts</h5><p>You can use local fonts by adding them to your assets folder. Once they have been added you can then access them through your css using the @font-face.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-| assets</span><br><span class="line">----| fonts</span><br><span class="line">------| DMSans-Regular.ttf</span><br><span class="line">------| DMSans-Bold.ttf</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">@font-face &#123;</span><br><span class="line">  font-family: &#39;DM Sans&#39;;</span><br><span class="line">  font-style: normal;</span><br><span class="line">  font-weight: 400;</span><br><span class="line">  font-display: swap;</span><br><span class="line">  src: url(&#39;~assets&#x2F;fonts&#x2F;DMSans-Regular.ttf&#39;) format(&#39;truetype&#39;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@font-face &#123;</span><br><span class="line">  font-family: &#39;DM Sans&#39;;</span><br><span class="line">  font-style: normal;</span><br><span class="line">  font-weight: 700;</span><br><span class="line">  font-display: swap;</span><br><span class="line">  src: url(&#39;~assets&#x2F;fonts&#x2F;DMSans-Bold.ttf&#39;) format(&#39;truetype&#39;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="components"><a href="#components" class="headerlink" title="components"></a>components</h4><p>The components directory contains your Vue.js components. Components are what makes up the different parts of your page and can be reused and imported into your pages, layouts and even other components.</p><h5 id="Fetching-Data"><a href="#Fetching-Data" class="headerlink" title="Fetching Data"></a>Fetching Data</h5><p>To access asynchronous data from an API in your components you can use Nuxt fetch() hook.</p><p>By checking $fetchState.pending, we can show a message when data is waiting to be loaded. We can also check $fetchState.error and show an error message if there is an error fetching the data. When using fetch(), we must declare the appropriate properties in data(). The data that comes from the fetch can then be assigned to these properties.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;p v-if&#x3D;&quot;$fetchState.pending&quot;&gt;Loading....&lt;&#x2F;p&gt;</span><br><span class="line">    &lt;p v-else-if&#x3D;&quot;$fetchState.error&quot;&gt;Error while fetching mountains&lt;&#x2F;p&gt;</span><br><span class="line">    &lt;ul v-else&gt;</span><br><span class="line">      &lt;li v-for&#x3D;&quot;(mountain, index) in mountains&quot; :key&#x3D;&quot;index&quot;&gt;</span><br><span class="line">        &#123;&#123; mountain.title &#125;&#125;</span><br><span class="line">      &lt;&#x2F;li&gt;</span><br><span class="line">    &lt;&#x2F;ul&gt;</span><br><span class="line">  &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  export default &#123;</span><br><span class="line">    data() &#123;</span><br><span class="line">      return &#123;</span><br><span class="line">        mountains: []</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    async fetch() &#123;</span><br><span class="line">      this.mountains &#x3D; await fetch(</span><br><span class="line">        &#39;https:&#x2F;&#x2F;api.nuxtjs.dev&#x2F;mountains&#39;</span><br><span class="line">      ).then(res &#x3D;&gt; res.json())</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure><h4 id="content"><a href="#content" class="headerlink" title="content"></a>content</h4><p>Empower your Nuxt.js application with @nuxtjs/content module where you can write in a content/ directory and fetch your Markdown, JSON, YAML and CSV files through a MongoDB like API, acting as a Git-based Headless CMS.</p><h4 id="dist"><a href="#dist" class="headerlink" title="dist"></a>dist</h4><p>The dist folder, short for distribution folder. It is dynamically generated when using the nuxt generate command and includes the generated production ready HTML files and assets that are necessary to deploy and run your statically generated Nuxt.js application.</p><h4 id="layouts"><a href="#layouts" class="headerlink" title="layouts"></a>layouts</h4><p>Layouts are a great help when you want to change the look and feel of your Nuxt.js app. Whether you want to include a sidebar or have distinct layouts for mobile and desktop.</p><blockquote><p>This directory cannot be renamed without extra configuration.</p></blockquote><h5 id="Default-Layout"><a href="#Default-Layout" class="headerlink" title="Default Layout"></a>Default Layout</h5><p>You can extend the main layout by adding a layouts/default.vue file. It will be used for all pages that don’t have a layout specified. Make sure to add the <Nuxt> component when creating a layout to actually include the page component.</p><p>All you need in your layout is three lines of code which will render the page component.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- layouts&#x2F;default.vue --&gt;</span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;Nuxt &#x2F;&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br></pre></td></tr></table></figure><p>You can add more components here such as Navigation, Header, Footer etc.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- layouts&#x2F;default.vue --&gt;</span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;TheHeader &#x2F;&gt;</span><br><span class="line">    &lt;Nuxt &#x2F;&gt;</span><br><span class="line">    &lt;TheFooter &#x2F;&gt;</span><br><span class="line">  &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br></pre></td></tr></table></figure><blockquote><p>If you have components set to true then there is no need to add any import statements for your components.</p></blockquote><h5 id="Custom-Layout"><a href="#Custom-Layout" class="headerlink" title="Custom Layout"></a>Custom Layout</h5><p>Every file (top-level) in the layouts directory will create a custom layout accessible with the layout property in the page components.</p><p>Let’s say we want to create a blog layout and save it to layouts/blog.vue:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;div&gt;My blog navigation bar here&lt;&#x2F;div&gt;</span><br><span class="line">    &lt;Nuxt &#x2F;&gt;</span><br><span class="line">  &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br></pre></td></tr></table></figure><p>Then you have to tell the pages to use your custom layout</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  layout: &#39;blog&#39;,</span><br><span class="line">  &#x2F;&#x2F; OR</span><br><span class="line">  layout (context) &#123;</span><br><span class="line">    return &#39;blog&#39;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure><h4 id="middleware"><a href="#middleware" class="headerlink" title="middleware"></a>middleware</h4><p>The middleware directory contains your application middleware. Middleware lets you define custom functions that can be run before rendering either a page or a group of pages (layout).</p><p>Shared <code>middleware</code> should be placed in the  <code>middleware/</code>  directory. The filename will be the name of the middleware (<code>middleware/auth.js</code> will be the <code>auth</code> middleware). You can also define page-specific middleware by using a function directly, see <a href="https://nuxtjs.org/docs/2.x/components-glossary/pages-middleware#anonymous-middleware">anonymous middleware</a>.</p><p>A middleware receives <a href="https://nuxtjs.org/docs/2.x/internals-glossary/context">the context</a> as the first argument.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">export default function (context) &#123;</span><br><span class="line">  &#x2F;&#x2F; Add the userAgent property to the context</span><br><span class="line">  context.userAgent &#x3D; process.server</span><br><span class="line">    ? context.req.headers[&#39;user-agent&#39;]</span><br><span class="line">    : navigator.userAgent</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>In universal mode, middlewares will be called once on server-side (on the first request to the Nuxt app, e.g. when directly accessing the app or refreshing the page) and on the client-side when navigating to further routes. With ssr: false, middlewares will be called on the client-side in both situations.</p><p>The middleware will be executed in series in this order:</p><p>nuxt.config.js (in the order within the file)<br>Matched layouts<br>Matched pages</p><h5 id="Router-Middleware"><a href="#Router-Middleware" class="headerlink" title="Router Middleware"></a>Router Middleware</h5><p>A middleware can be asynchronous. To do this return a  Promise or use async/await.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- middleware&#x2F;stats.js --&gt;</span><br><span class="line"></span><br><span class="line">import http from &#39;http&#39;</span><br><span class="line"></span><br><span class="line">export default function (&#123; route &#125;) &#123;</span><br><span class="line">  return http.post(&#39;http:&#x2F;&#x2F;my-stats-api.com&#39;, &#123;</span><br><span class="line">    url: route.fullPath</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Then, in your nuxt.config.js, use the router.middleware key.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- nuxt.config.js --&gt;</span><br><span class="line"></span><br><span class="line">export default &#123;</span><br><span class="line">  router: &#123;</span><br><span class="line">    middleware: &#39;stats&#39;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Now the stats middleware will be called for every route change.</p><p>You can add your middleware (even multiple) to a specific layout or page as well.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- pages&#x2F;index.vue &#x2F; layouts&#x2F;default.vue --&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  middleware: [&#39;auth&#39;, &#39;stats&#39;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="Named-middleware"><a href="#Named-middleware" class="headerlink" title="Named middleware"></a>Named middleware</h5><p>You can create named middleware by creating a file inside the  middleware/ directory, the file name will be the middleware name.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- middleware&#x2F;authenticated.js --&gt;</span><br><span class="line"></span><br><span class="line">export default function (&#123; store, redirect &#125;) &#123;</span><br><span class="line">  &#x2F;&#x2F; If the user is not authenticated</span><br><span class="line">  if (!store.state.authenticated) &#123;</span><br><span class="line">    return redirect(&#39;&#x2F;login&#39;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- pages&#x2F;secret.vue --&gt;</span><br><span class="line"></span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;h1&gt;Secret page&lt;&#x2F;h1&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">  export default &#123;</span><br><span class="line">    middleware: &#39;authenticated&#39;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure><h5 id="Anonymous-middleware"><a href="#Anonymous-middleware" class="headerlink" title="Anonymous middleware"></a>Anonymous middleware</h5><p>If you need to use a middleware only for a specific page, you can directly use a function for it (or an array of functions):</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- pages&#x2F;secret.vue --&gt;</span><br><span class="line"></span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;h1&gt;Secret page&lt;&#x2F;h1&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">  export default &#123;</span><br><span class="line">    middleware(&#123; store, redirect &#125;) &#123;</span><br><span class="line">      &#x2F;&#x2F; If the user is not authenticated</span><br><span class="line">      if (!store.state.authenticated) &#123;</span><br><span class="line">        return redirect(&#39;&#x2F;login&#39;)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      
      <category domain="https://joontae-kim.github.io/categories/Programming/">Programming</category>
      
      <category domain="https://joontae-kim.github.io/categories/Programming/nuxt/">nuxt</category>
      
      
      <category domain="https://joontae-kim.github.io/tags/vue-js/">vue.js</category>
      
      <category domain="https://joontae-kim.github.io/tags/nuxt-js/">nuxt.js</category>
      
      <category domain="https://joontae-kim.github.io/tags/vue/">vue</category>
      
      <category domain="https://joontae-kim.github.io/tags/nuxt/">nuxt</category>
      
      
      <comments>https://joontae-kim.github.io/2021/03/18/nuxt-directory/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>nuxt.js - 시작하기</title>
      <link>https://joontae-kim.github.io/2021/03/18/nuxt-intro/</link>
      <guid>https://joontae-kim.github.io/2021/03/18/nuxt-intro/</guid>
      <pubDate>Wed, 17 Mar 2021 17:08:33 GMT</pubDate>
      
        
        
      <description>&lt;p&gt;&lt;img src=&quot;/images/nuxt.png&quot; alt=&quot;Nuxt.js&quot;&gt;&lt;/p&gt;
&lt;p&gt;포트폴리오용 nuxt 앱이 필요했던 참에 신규 프로젝트에서 nuxt로 어플리케이션을 제작해야해서 정리 및 공부겸 포스팅을 하기로 했다.&lt;/p&gt;
&lt;h3 id=</description>
        
      
      
      
      <content:encoded><![CDATA[<p><img src="/images/nuxt.png" alt="Nuxt.js"></p><p>포트폴리오용 nuxt 앱이 필요했던 참에 신규 프로젝트에서 nuxt로 어플리케이션을 제작해야해서 정리 및 공부겸 포스팅을 하기로 했다.</p><h3 id="1-Nuxt란"><a href="#1-Nuxt란" class="headerlink" title="1.Nuxt란?"></a>1.Nuxt란?</h3><p>Nuxt란 NuxtJS를 사용하여 신뢰 있는 Vue.js 애플리케이션을 구축하세요. 웹 개발을 간단하고 강력하게 만드는 오픈 소스 프레임워크로 서버 사이드 렌더링 (SSR)과 정적 사이트 생성을 지원해준다.</p><h4 id="1-소개"><a href="#1-소개" class="headerlink" title="1) 소개"></a>1) 소개</h4><p>Nuxt.js의 소개를 본다면 이렇게 명시하고 있다.</p><blockquote><ul><li>주요 범위는 UI Rendering이며, 클라이언트/서버 배포를 추상화한다.</li><li>Nuxt.js의 목표는 기본 프로젝트 베이스로 사용할 수 있으며 Node.js 기반의 프로젝트를 유연하게 사용할 수 있는 프레임 워크를  만드는 것이다.</li><li>Nuxt.js는 서버 사이드 렌더링 된 Vue.js 응용 프로그램의 개발을 위해 이에 필요한 모든 구성을 사전 설정한다.</li><li>Nuxt.js는 nuxt generate 라는 배포 옵션을 제공한다. nuxt gererate를 통해 vue.js를 정적인 응용 프로그램으로 빌드한다. - 우리는 이 옵션이 마이크로 서비스가 있는 웹 응용 프로그램 개발의 다음 단계일 수 있다고 생각한다.</li><li>Nuxt.js는 단일 응용 페이지(SPA)를 신속하게 만들 수 있다.</li><li>Nuxt.js는 비동기 데이터, 미들웨어, 레이아웃 등과 같이 클라이언트 측과 서버 측 사이에서 개발하는 데 도움이 되는 많은 기능을 제공한다.</li><li>Nuxt.js 설치만으로 이미 scaffolding(프로젝트 구조화)을 해주므로 딱히 프로젝트 구조에 대해서 고민할 필요가 없다.</li><li>Vue.js 하나하나 잡아줘야 할 라우팅을 Nuxt.js에서 파일을 생성하는 것만으로 라우팅을 자동으로 생성해 준다.</li><li>layout, store, middleware와 같은 요소들을 이미 구분을 지어주고 필요한 항목들을 처리해주기 때문에 순전히 개발에만 집중하면 된다.</li><li>Server-Side-Rendering에 필요한 요소가 이미 준비가 되어있다.</li><li>webpack을 통한 빌드 시스템이 이미 구현되어 있다. 그저 npm run만 해주면 된다.</li></ul></blockquote><h4 id="2-특징"><a href="#2-특징" class="headerlink" title="2) 특징"></a>2) 특징</h4><ul><li>Vue 파일 작성</li><li>코드 분할 자동화</li><li>서버사이드 렌더링</li><li>강력한 비동기 데이터 기반 라우팅 시스템</li><li>정적 파일 전송</li><li>ES6/ES7 지원</li><li>JS &amp; CSS 코드 번들링 및 압축</li><li>html의 head 태그 관리</li><li>Hot reloading의 지원</li><li>SASS, LESS, Stylus 등의 전처리기 지원</li></ul><h4 id="일단-위-소개만-보면-안-쓸-이유가-없다"><a href="#일단-위-소개만-보면-안-쓸-이유가-없다" class="headerlink" title="일단 위 소개만 보면 안 쓸 이유가 없다."></a><em>일단 위 소개만 보면 안 쓸 이유가 없다.</em></h4><h3 id="2-Nuxt-시작하기"><a href="#2-Nuxt-시작하기" class="headerlink" title="2.Nuxt 시작하기"></a>2.Nuxt 시작하기</h3><p>Nuxt 기반의 application을 생성하기 위해서는 Vue CLI가 설치되어 있어야 한다.</p><h4 id="1-프로젝트-생성"><a href="#1-프로젝트-생성" class="headerlink" title="1) 프로젝트 생성"></a>1) 프로젝트 생성</h4><p>프로젝트 생성에는 총 3가지 방법이 있습니다.</p><h5 id="vue-cli를-통한-nuxt-js-설치"><a href="#vue-cli를-통한-nuxt-js-설치" class="headerlink" title="vue-cli를 통한 nuxt.js 설치"></a>vue-cli를 통한 nuxt.js 설치</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- vue cli 설치 --&gt;</span><br><span class="line">npm i -g @vue&#x2F;cli</span><br><span class="line">npm i -g @vue&#x2F;cli-init</span><br><span class="line"></span><br><span class="line">&lt;!-- nuxt 프로젝트 생성 및 의존성 모듈 설치 --&gt;</span><br><span class="line">vue init nuxt-community&#x2F;starter-template &lt;project-name&gt;</span><br><span class="line">cd &lt;project-name&gt;</span><br><span class="line">npm i</span><br><span class="line"></span><br><span class="line">&lt;!-- 패키지 매니저를 통한 nuxt 프로젝트 생성 --&gt;</span><br><span class="line">npx create-nuxt-app &lt;project-name&gt; </span><br><span class="line">yarn create nuxt-app &lt;project-name&gt;</span><br><span class="line">npm init nuxt-app &lt;project-name&gt;</span><br></pre></td></tr></table></figure><p>저는 vue-cli가 이미 설치된 환경에서 작업하고 있으므로 npx 패키지 매니저를 통해 nuxt application을 생성해보겠습니다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npx create-nuxt-app [프로젝트명]</span><br></pre></td></tr></table></figure><h4 id="2-프로젝트-설정"><a href="#2-프로젝트-설정" class="headerlink" title="2) 프로젝트 설정"></a>2) 프로젝트 설정</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">? Project name: [프로젝트명]</span><br><span class="line">? Programming language:</span><br><span class="line">&gt; JavaScript</span><br><span class="line">  TypeScript</span><br><span class="line">? Package manager:</span><br><span class="line">  Yarn</span><br><span class="line">&gt; Npm</span><br><span class="line">? UI framework:</span><br><span class="line">&gt; None</span><br><span class="line">  Ant Design Vue</span><br><span class="line">  Bootstrap Vue</span><br><span class="line">  Buefy</span><br><span class="line">  Bulma</span><br><span class="line">  Element</span><br><span class="line">  Framevuerk</span><br><span class="line">  iView</span><br><span class="line">  Tachyons</span><br><span class="line">  Tailwind CSS</span><br><span class="line">  Vuesax</span><br><span class="line">  Vuetify.js</span><br><span class="line">? Nuxt.js modules:</span><br><span class="line">? Choose custom server framework &lt;None (Recommended)&gt;</span><br><span class="line">&gt; None (Recommended)</span><br><span class="line">  AdonisJs</span><br><span class="line">  Express</span><br><span class="line">  Fastify</span><br><span class="line">  Feathers</span><br><span class="line">  hapi</span><br><span class="line">  Koa</span><br><span class="line">  Micro</span><br><span class="line">? Linting tools:</span><br><span class="line">(*) ESLint</span><br><span class="line">( ) Prettier</span><br><span class="line">( ) Lint staged files</span><br><span class="line">( ) StyleLint</span><br><span class="line">? Testing framework:</span><br><span class="line">  None</span><br><span class="line">&gt; Jest</span><br><span class="line">  AVA</span><br><span class="line">? Rendering mode: Universal (SSR &#x2F; SSG)</span><br><span class="line">&gt; Universal (SSR)</span><br><span class="line">  Single Page App</span><br><span class="line">? Deployment target: Server (Node.js hosting)</span><br><span class="line">? Development tools: (Press &lt;space&gt; to select, &lt;a&gt; to toggle all, &lt;i&gt; to invert selection)</span><br><span class="line">? Continuous integration: None</span><br><span class="line">? Version control system:</span><br><span class="line">&gt; Git</span><br><span class="line">  None</span><br></pre></td></tr></table></figure><h4 id="3-프로젝트-실행"><a href="#3-프로젝트-실행" class="headerlink" title="3) 프로젝트 실행"></a>3) 프로젝트 실행</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Successfully created project [프로젝트명]</span><br><span class="line"></span><br><span class="line">  To get started:</span><br><span class="line">cd [디렉토리명]</span><br><span class="line">npm run dev</span><br><span class="line"></span><br><span class="line">  To build &amp; start for production:</span><br><span class="line">cd [디렉토리명]</span><br><span class="line">npm run build</span><br><span class="line">npm run start</span><br><span class="line"></span><br><span class="line">  To test:</span><br><span class="line">cd [디렉토리명]</span><br><span class="line">npm run test</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">cd [디렉토리명] &amp;&amp; npm run dev</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="4-프로젝트-생성-디렉토리"><a href="#4-프로젝트-생성-디렉토리" class="headerlink" title="4) 프로젝트 생성 디렉토리"></a>4) 프로젝트 생성 디렉토리</h4><p>막 생성된 nuxt 프로젝트의 디렉토리는 아래와 같다. 디렉토리에 대한 정의를 잘 몰라도 이미 Vue.js를 사용했던 개발자라면 비슷한 구조이며 스캐폴딩이 이미 되어있다는 생각이 들것이다.<br><img src="/images/nuxt-directory.png" alt="nuxt 프로젝트 디렉토리"></p><p>여기까지 nuxt 프로젝트의 생성과 막 생성된 디렉토리까지 살펴봤습니다. 다음 포스트에서는 프로젝트의 디렉토리에 대해 살펴보겠습니다.</p><hr><h2 id="참조"><a href="#참조" class="headerlink" title="참조"></a>참조</h2><ul><li><a href="https://nuxtjs.org/docs/2.x/get-started/installation">Installation - Official NuxtJS</a></li><li><a href="https://kdydesign.github.io/2019/04/10/nuxtjs-tutorial/">[Nuxt.js] 개념부터 설치까지 빠르게 배우기</a></li><li><a href="https://adrian0220.tistory.com/195?category=813348">12.[Nuxt.js] 프로젝트, 설정, 라우팅</a></li><li><a href="https://khwan.kr/blog/vue/2020-03-02-nuxt-spa-ssr/">Nuxt로 알아보는 SPA, SSR 그리고 Static Web</a></li><li><a href="https://medium.com/vue-mastery/free-nuxt-js-tutorial-creating-an-app-1a531bc6045">Free Nuxt.js Tutorial — Vue Mastery Course</a></li></ul>]]></content:encoded>
      
      
      <category domain="https://joontae-kim.github.io/categories/Programming/">Programming</category>
      
      <category domain="https://joontae-kim.github.io/categories/Programming/nuxt/">nuxt</category>
      
      
      <category domain="https://joontae-kim.github.io/tags/vue-js/">vue.js</category>
      
      <category domain="https://joontae-kim.github.io/tags/nuxt-js/">nuxt.js</category>
      
      <category domain="https://joontae-kim.github.io/tags/vue/">vue</category>
      
      <category domain="https://joontae-kim.github.io/tags/nuxt/">nuxt</category>
      
      
      <comments>https://joontae-kim.github.io/2021/03/18/nuxt-intro/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>서버 사이트 렌더링과 클라이언트 사이드 렌더링</title>
      <link>https://joontae-kim.github.io/2021/03/17/scrssr/</link>
      <guid>https://joontae-kim.github.io/2021/03/17/scrssr/</guid>
      <pubDate>Wed, 17 Mar 2021 13:49:29 GMT</pubDate>
      
        
        
      <description>&lt;p&gt;&lt;img src=&quot;/images/csrssr.png&quot; alt=&quot;SSR &amp;amp; CSR&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;이번 포스팅은 Vue.js &amp;amp; Nuxt.js를 하기 전에 서버사이드 렌더링과 클라이언트 사이트 렌더링에 대해 짧게나마 정리해보는</description>
        
      
      
      
      <content:encoded><![CDATA[<p><img src="/images/csrssr.png" alt="SSR &amp; CSR"></p><p><em>이번 포스팅은 Vue.js &amp; Nuxt.js를 하기 전에 서버사이드 렌더링과 클라이언트 사이트 렌더링에 대해 짧게나마 정리해보는 것이 필요하다고 생각되서 쓰게 되었다.</em></p><h3 id="1-SSR과-CSR의-MVC-패턴"><a href="#1-SSR과-CSR의-MVC-패턴" class="headerlink" title="1. SSR과 CSR의 MVC 패턴"></a>1. SSR과 CSR의 MVC 패턴</h3><p>SSR과 CSR은 HTLM 페이지 렌더링 방식으로 아래의 이미지처럼 Rendering을 어디서 하냐에 따라 Server-Side 또는 Client-Side로 구분된다. <em>(그 외에 Rehydration, Prerendering 방식이 있긴한데 여기선 생략 - <a href="https://developers.google.com/web/updates/2019/02/rendering-on-the-web?hl=ko">참고 - developers.google.com의 웹 렌더링 포스팅</a>)</em></p><p><img src="/images/CSR_SSR_MVP_Model.png" alt="SSR과 CSR의 MVC 패턴"></p><p>Server-Side MVC 패턴의 경우, Rendering 및 HTML Serving을 위한 View와 Controller가 Server에서 처리하지만 Client-side MVC 패턴의 경우에는 서버로부터 서비스 진입 초기에 HTML 파일 + JS 파일 및 리소스 파일 등을 모두 다운 받은후 Client에서 직접 Controller와 View를 담당한다.</p><h3 id="2-SSR-Server-Side-Rendering-서버-측-렌더링"><a href="#2-SSR-Server-Side-Rendering-서버-측-렌더링" class="headerlink" title="2. SSR (Server-Side Rendering, 서버 측 렌더링)"></a>2. SSR (Server-Side Rendering, 서버 측 렌더링)</h3><p><img src="/images/SSR.png" alt="Server-Side Rendering"></p><p>SSR의 위 순서를 이해해보자.</p><ol><li>사용자가 웹사이트를 요청한다.</li><li>서버가 “렌더링 하기 위한(Ready to Render)” HTML 파일(들)을 만든다.</li><li>브라우저가 HTML 파일을 빠르게 렌더링 할 수 있지만, 사이트는 아직 상호작용(interactive)할 수 없다.</li><li>브라우저가 Javascript를 다운로드한다.</li><li>사용자가 컨텐츠를 볼 수 있으며 상호작용(interactions)이 기록된다.</li><li>브라우저가 JS 프레임워크를 실행한다.</li><li>기록된 상호작용(들)이 실행될 수 있고, 페이지가 상호작용(interactive)한다.</li></ol><h3 id="3-CSR-Client-Side-Rendering-클라이언트-측-렌더링"><a href="#3-CSR-Client-Side-Rendering-클라이언트-측-렌더링" class="headerlink" title="3. CSR (Client-Side Rendering, 클라이언트 측 렌더링)"></a>3. CSR (Client-Side Rendering, 클라이언트 측 렌더링)</h3><p><img src="/images/CSR.png" alt="Client-Side Rendering"><br>CSR의 위 순서를 이해해보자.</p><ol><li>사용자가 웹사이트를 요청한다.</li><li>CDN이 빠르게 JS가 연결된 링크와 함께 HTML 파일(들)을 제공한다.</li><li>브라우저가 HTML 파일을 다운로드 한 후, JS를 다운로드 한다. 그동안, 사용자는 사이트를 볼 수 없다.</li><li>브라우저는 Javascript를 다운로드 한다.</li><li>JS가 실행되고 API가 데이터를 요청하는 동안 사용자는 placeholder를 본다.</li><li>서버가 API에 대한 응답으로 데이터를 제공한다.</li><li>API 응답으로 온 데이터는 placeholder를 채우고, 페이지가 상호작용(interactive)한다. </li></ol><h3 id="4-SSR과-CSR의-성능"><a href="#4-SSR과-CSR의-성능" class="headerlink" title="4. SSR과 CSR의 성능"></a>4. SSR과 CSR의 성능</h3><p>SSR과 CSR의 Rendering 순서에는 확연히 차이가 존재하며 이에 따라 성능에서도 차이가 존재한다. 아래 목록은 브라우저 렌더링에 있어서 어떤 장단점이 있는지 설명하는데 도움이 되며 또한 렌더링 방식에 따른 최적화를 하는데에도 도움이 되는 지표들이다.</p><ul><li><p>TTFB (<a href="https://en.wikipedia.org/wiki/Time_to_first_byte">Time to First Byte</a>): (첫 번째 바이트까지의 시간) - 링크를 클릭한 시점부터 처음으로 콘텐츠의 바이트가 들어오는 시간차</p></li><li><p>FP (<a href="https://developers.google.com/web/fundamentals/performance/user-centric-performance-metrics#first_paint_and_first_contentful_paint">First Paint</a>): 픽셀이 처음으로 사용자에게 표시되는 시점</p></li><li><p>FCP (<a href="https://developers.google.com/web/fundamentals/performance/user-centric-performance-metrics#first_paint_and_first_contentful_paint">First Contentful Paint</a>): 요청 콘텐츠(기사(article) 본문 등)가 표시되는 시점</p></li><li><p>TTI (<a href="https://developers.google.com/web/tools/lighthouse/audits/time-to-interactive">Time to Interactive</a>): 페이지가 상호작용 가능하게 될 때까지의 시간 (이벤트 발생 등).</p></li></ul><h4 id="1-SSR-Performance"><a href="#1-SSR-Performance" class="headerlink" title="1) SSR Performance"></a>1) SSR Performance</h4><p><img src="https://developers.google.com/web/updates/images/2019/02/rendering-on-the-web/server-rendering-tti.png?hl=ko" alt="SSR 퍼포먼스"></p><p>기본적으로 서버 사이드 렌더링은 브라우저에서 응답을 받기 전에 처리되므로 클라이언트에서 데이터 요청 및 템플릿 작성을 위한 추가 요청작업이 발생하지 않아 First Paint 및 First Contentful Paint가 빠르게 생성되며 서버에서 페이지 로직 및 렌더링을 실행하면 많은 JS를 클라이언트에 보내지 않아도 되므로 Time to Interactive를 빠르게 수행할 수 있다.</p><h4 id="2-CSR-Performance"><a href="#2-CSR-Performance" class="headerlink" title="2) CSR Performance"></a>2) CSR Performance</h4><p><img src="https://developers.google.com/web/updates/images/2019/02/rendering-on-the-web/client-rendering-tti.png?hl=ko" alt="CSR 퍼포먼스"></p><p>기본적으로 클라이언트 사이드 렌더링은 JS를 사용해 브라우저에서 페이지를 직접 렌더링 하는 방식으로 가장 처음에 언급한 <strong><em>CSR의 MVC 패턴</em></strong> 을 보면 렌더링 구조를 이해할 수 있다. 서버 사이드에 해당 웹사이트에 대한 자원을 요청하면, 프론트엔드에 대한 <code>bundle.js</code> 또는 <code>app.js</code>와 <code>index.html</code>을 다운받고 번들링 파일을 브라우저의 JS Parser에서 분석한 다음, controller에 해당하는 <strong>router</strong> 의 정보에 따라 html을 동적으로 생성하는 동시에 사용자에게 보여줄 데이터를 동적으로 요청 및 view 처리해줌에 따라 First Paint 및 First Contentful Paint가 SSR 렌더링 방식보다 오래 걸리며 TTI 또한 오래 걸린다는 단점이 있다.</p><h5 id="그럼-왜-CSR-렌더링-방식을-쓰지"><a href="#그럼-왜-CSR-렌더링-방식을-쓰지" class="headerlink" title="그럼 왜? CSR 렌더링 방식을 쓰지???"></a>그럼 왜? CSR 렌더링 방식을 쓰지???</h5><p>바로 웹사이트 초기 진입시의 FCP 및 TTI가 오래 걸릴뿐이지 그 다음부터는 CSR의 구조 특성상 페이지 이동에 따라 html 파일을 서버에서 reqeust 하는 것이 아닌 클라이언트 단에서 control하며 필요한 데이터면 request하면 되기 때문에 페이지 이동간의 FCP 및 TTI는 SSR보다 좋은 성능을 보인다. 그리고 lazy loading 또는 code splitting을 한다면 페이지별로 필요한 Javascript와 그 외 리소스만 불러올 수 있어서 초기 Rendering 속도를 개선해볼수 있는 가능성도 있다.</p><h4 id="5-정리"><a href="#5-정리" class="headerlink" title="5) 정리"></a>5) 정리</h4><p>정리하자면 각 장단점 또는 차이는 아래와 같으며, 두 렌더링 방식 중 각 어플리케이션의 구조 또는 서비스 페이지의 특징에 따라 적절히 사용하는 것이 중요하다.<br>대표적으로, 초기 View 로딩 속도, SEO 문제, 보안 문제가 있다.</p><table><thead><tr><th></th><th>SSR</th><th>CSR</th></tr></thead><tbody><tr><td><strong>초기 View 로딩 속도</strong></td><td>CSR에 비해 렌더링 해야하는 파일이 적어 초기 View 로딩 속도가 빠름.</td><td>브라우저에서 페이지를 직접 렌더링해야 하므로 초기에는 오래 걸림.</td></tr><tr><td><strong>SEO</strong></td><td>페이지에 대한 meta 정보가 렌더링시 이미 포함되어 있기 때문에 크롤러봇에서 데이터를 수집해가는데 용이함.</td><td>렌더링시 JS 파싱, 로딩 및 실행 순서 때문에 크롤러봇이 데이터를 수집하는데 어려움이 있음.</td></tr><tr><td><strong>보안 문제</strong></td><td>사용자에 대한 정보를 서버측에서 Session으로 관리</td><td>사용자에 대한 정보를 LocalStorage나 Cookie에서 관리해 XSS 공격에 취약함</td></tr></tbody></table><ul><li>SSR 방식의 경우, 초기 로딩속도가 빠르고, SEO 측면에서 유리하지만<ul><li>View 변경시 서버에 계속 새로운 HTML 파일을 요청해야 하므로 서버에 부담이 큼</li></ul></li><li>CSR 방식의 경우, 초기 로딩속도는 느리지만 그 다음 페이지 이동 및 처리에 있어 필요한 데이터만 요청하면 되므로 서버에 부담이 적고, 빠르게 처리할 수 있으나<ul><li>SEO 측면에서 Google 크롤러봇을 제외하곤 Javascript를 실행시키지 못해 데이터 수집하는데 어려움이 있음</li></ul></li></ul><hr><h2 id="참조"><a href="#참조" class="headerlink" title="참조"></a>참조</h2><ul><li><a href="https://developers.google.com/web/updates/2019/02/rendering-on-the-web">웹 렌더링</a></li><li><a href="https://jaroinside.tistory.com/24">11. 서버사이트 렌더링, 클라이언트 사이드 렌더링</a></li><li><a href="https://asfirstalways.tistory.com/244">서버사이트 렌더링 그리고 클라이언트 사이드 렌더링</a></li><li><a href="https://velog.io/@namezin/CSR-SSR">CSR, SSR</a></li><li><a href="https://goodgid.github.io/Server-Side-Rendering-and-Client-Side-Rendering/#ssr-vs-csr">서버 사이드 렌더링(SSR)과 클라이언트 사이드 렌더링(CSR)</a></li><li><a href="https://velog.io/@rjs1197/SSR%EA%B3%BC-CSR%EC%9D%98-%EC%B0%A8%EC%9D%B4%EB%A5%BC-%EC%95%8C%EC%95%84%EB%B3%B4%EC%9E%90">SPA에서의 SSR과 CSR</a></li></ul>]]></content:encoded>
      
      
      <category domain="https://joontae-kim.github.io/categories/Web/">Web</category>
      
      <category domain="https://joontae-kim.github.io/categories/Web/Rendering/">Rendering</category>
      
      
      <category domain="https://joontae-kim.github.io/tags/Rendering/">Rendering</category>
      
      <category domain="https://joontae-kim.github.io/tags/CSR/">CSR</category>
      
      <category domain="https://joontae-kim.github.io/tags/SSR/">SSR</category>
      
      <category domain="https://joontae-kim.github.io/tags/Client-Side-Rendering/">Client Side Rendering</category>
      
      <category domain="https://joontae-kim.github.io/tags/Server-Side-Rendering/">Server Side Rendering</category>
      
      
      <comments>https://joontae-kim.github.io/2021/03/17/scrssr/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>TIL-1</title>
      <link>https://joontae-kim.github.io/2020/12/03/til-1/</link>
      <guid>https://joontae-kim.github.io/2020/12/03/til-1/</guid>
      <pubDate>Wed, 02 Dec 2020 18:55:44 GMT</pubDate>
      
        
        
      <description>&lt;p&gt;최근 진행하고 있는 외주 프로젝트에서 이미지 및 js, css 관련 최적화 과정 진행 중 webpack의 압축 관련 설정을 살펴보던 중 참고할만한 링크들을 찾았다.&lt;/p&gt;
&lt;h3 id=&quot;공식-링크&quot;&gt;&lt;a href=&quot;#공식-링크&quot; class=&quot;he</description>
        
      
      
      
      <content:encoded><![CDATA[<p>최근 진행하고 있는 외주 프로젝트에서 이미지 및 js, css 관련 최적화 과정 진행 중 webpack의 압축 관련 설정을 살펴보던 중 참고할만한 링크들을 찾았다.</p><h3 id="공식-링크"><a href="#공식-링크" class="headerlink" title="공식 링크"></a>공식 링크</h3><ul><li><a href="https://webpack.js.org/plugins/compression-webpack-plugin/">https://webpack.js.org/plugins/compression-webpack-plugin/</a></li><li><a href="https://github.com/webpack-contrib/compression-webpack-plugin">https://github.com/webpack-contrib/compression-webpack-plugin</a></li></ul><h5 id="webpack3-버전-compressions-wepack-plugin"><a href="#webpack3-버전-compressions-wepack-plugin" class="headerlink" title="webpack3 버전 compressions-wepack-plugin"></a>webpack3 버전 compressions-wepack-plugin</h5><ul><li><a href="https://webpack-3.cdn.bcebos.com/plugins/compression-webpack-plugin/">https://webpack-3.cdn.bcebos.com/plugins/compression-webpack-plugin/</a></li></ul><h4 id="js-module-for-image-compression"><a href="#js-module-for-image-compression" class="headerlink" title="js module for image compression"></a>js module for image compression</h4><ul><li><a href="https://www.npmjs.com/package/browser-image-compression">https://www.npmjs.com/package/browser-image-compression</a></li><li>demo: <a href="https://donaldcwl.github.io/browser-image-compression/example/basic.html">https://donaldcwl.github.io/browser-image-compression/example/basic.html</a></li></ul><h4 id="webpack-plugin-for-image-compression"><a href="#webpack-plugin-for-image-compression" class="headerlink" title="webpack plugin for image compression"></a>webpack plugin for image compression</h4><ul><li><a href="https://github.com/tcoopman/image-webpack-loader#readme">https://github.com/tcoopman/image-webpack-loader#readme</a></li><li><a href="https://github.com/Klathmon/imagemin-webpack-plugin#readme">https://github.com/Klathmon/imagemin-webpack-plugin#readme</a></li><li>blog<ul><li><a href="https://web.dev/use-imagemin-to-compress-images/">https://web.dev/use-imagemin-to-compress-images/</a></li><li><a href="https://coderrocketfuel.com/article/compress-a-png-image-size-by-up-to-75-percent-with-node-js">https://coderrocketfuel.com/article/compress-a-png-image-size-by-up-to-75-percent-with-node-js</a></li></ul></li></ul><h4 id="webpack-loader-for-image-trace"><a href="#webpack-loader-for-image-trace" class="headerlink" title="webpack loader for image trace"></a>webpack loader for image trace</h4><ul><li><a href="https://github.com/EmilTholin/image-trace-loader#readme">https://github.com/EmilTholin/image-trace-loader#readme</a></li></ul>]]></content:encoded>
      
      
      <category domain="https://joontae-kim.github.io/categories/TIL/">TIL</category>
      
      <category domain="https://joontae-kim.github.io/categories/TIL/webpack/">webpack</category>
      
      
      <category domain="https://joontae-kim.github.io/tags/TIL/">TIL</category>
      
      <category domain="https://joontae-kim.github.io/tags/webpack/">webpack</category>
      
      
      <comments>https://joontae-kim.github.io/2020/12/03/til-1/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>Javascript와 객체 지향 프로그래밍</title>
      <link>https://joontae-kim.github.io/2020/11/02/js-oop-2/</link>
      <guid>https://joontae-kim.github.io/2020/11/02/js-oop-2/</guid>
      <pubDate>Mon, 02 Nov 2020 12:10:12 GMT</pubDate>
      
        
        
      <description>&lt;p&gt;&lt;img src=&quot;/images/js_with_oop.png&quot; alt=&quot;Javascript&quot;&gt;&lt;/p&gt;
&lt;!-- Javascript에 대한 이론을 검색하면 아마도 먼저 시작하는 말은 **&quot;Javascript 는 객체 지향 언어로써...&quot;** 일 것</description>
        
      
      
      
      <content:encoded><![CDATA[<p><img src="/images/js_with_oop.png" alt="Javascript"></p><!-- Javascript에 대한 이론을 검색하면 아마도 먼저 시작하는 말은 **"Javascript 는 객체 지향 언어로써..."** 일 것이다. 그만큼 객체란 Javascript에서 거의 근본적인 요소라는 것을 추측할 수 있으며 Javascript를 잘 이해하고, 잘 쓰기 위해서는 객체에 대한 속성을 이해할 필요가 있습니다.그렇다면 Javascript에서 객체란 무엇이며, 객체 지향이란 무엇인지 알아보자.객체를 설명할때 많이 사용하는 표현이 "현실 세계의 사물"이다. 예를 들어, 컴퓨터를 생각해보자. 컴퓨터의 구성요소는 모니터와 본체 그리고 키보드와 마우스가 있으며 입력으로는 전원버튼 누름에 의한 작동유무, 키보드의 타이핑과 마우스의 클릭과 드래그 등으로 분류할 수 있다. 바로 이게 우리가 앞으로 알게 될 객체의 구조이다.즉, **객체는 자신의 정보를 가지고 있는 독립적인 개체(Entity)로써 객체 자신에 대한 속성(Property)과 동작(method) 을 가질 수 있다.** 그리고 객체 자신을 통해 자식을 만들 수도 있다. 컴퓨터의 예처럼 컴퓨터의 기본 구성인 모니터, 본체 그리고 입력장치를 하나의 틀로 여기면 데스크톱 컴퓨터, 노트북 컴퓨터 등 다양한 형태의 컴퓨터가 생성(_객체의 상속_)되기도 하며, 내부적으로는 키보드와 마우스, 모니터 등이 하나의 객체가 되어 컴퓨터라는 하나의 어플리케이션을 구성하고 있는 것으로 설명할 수도 있다. --><p>지난 포스트인 <a href="/2020/10/22/javascript-oop/">Javascript와 객체 지향 프로그래밍 - 절차 지향 프로그래밍 &amp; 객체 지향 프로그래밍</a> 편에서 Javascript의 객체 지향에 대해 공부하면서 느꼈던 어려움과 절차지향과 객체지향에 대해 정리를 해보았습니다. 이번 포스트에서는 객체지향 프로그래밍이란 무엇인지 공부해보겠습니다.</p><h2 id="객체-지향-프로그래밍-이란"><a href="#객체-지향-프로그래밍-이란" class="headerlink" title="객체 지향 프로그래밍 이란"></a>객체 지향 프로그래밍 이란</h2><p>이전 포스트에서 언급했듯이 객체 지향 프로그래밍이란 <strong>“누가 어떤 일을 할 것인가”</strong> 를 중심으로 구현된 프로그래밍 패러다임으로써, <strong>객체 지향의 “객체”는 현실 세계의 사물을 나타내는데 각 객체는 자신의 정보를 가지고 있는 독립적인 개체(Entity)로써 각각의 성격을 띄고 있으며 이 객체가 유기적으로 상호작용 하여 작게는 하나의 기능, 크게는 하나의 어플리케이션을 프로그래밍 하는 방법</strong> 입니다.</p><p>그렇다면 객체 지향 프로그래밍의 “객체”의 기본 구성 요소는 무엇일까?</p><h3 id="기본-구성요소"><a href="#기본-구성요소" class="headerlink" title="기본 구성요소"></a>기본 구성요소</h3><p>위에서 언급했듯이 OOP의 객체(object)는 현실 세계의 사물을 나타낸다고 했다. 즉, 현실 세계의 사물은 각각의 동작(기능)과 상태를 가지고 있으며 여러 동작은 유기적으로 움직이며 상호간 침범하지 않도록 또는 방해되지 않도록 설계되어 있다고 설명할 수 있다. 대표적인 예로 <strong><em>사람</em></strong> 이다.</p><p>OOP의 기본 구성요소를 설명하기 전에 현실 세계의 사물을 먼저 정의한 이유는 OOP의 기본 구성요소 또한 같기 때문이다.</p><h4 id="1-클래스-class"><a href="#1-클래스-class" class="headerlink" title="1) 클래스 (class)"></a>1) 클래스 (class)</h4><p>클래스란 1개 이상의 유사 객체의 공통된 특성(속성과 메서드)을 데이터 추상화 과정을 통해 구현한 하나의 틀(template)로써, 객체지향 프로그램의 기본적인 사용자 정의 데이터형(user defined data type)이라고 할 수 있다.</p><ul><li>다른 클래스 또는 외부 요소와 독립적으로 디자인하여야 한다.</li><li>클래스에 의해 생성된 새로운 객체(object)를 클래스의 <strong>인스턴스</strong>라 하며, 클래스로부터 새로운 객체를 생성하는 것을 <strong>인스턴스화</strong> 라고 한다.</li><li>최상위 클래스 또는 메타 클래스는 상위 클래스를 갖지 않는 유일한 클래스로 클래스 계층 트리의 최상단에 위치하는 클래스이며, 슈퍼 클래스는 특정 클래스의 상위 클래스이고, 서브 클래스는 특정 클래스의 하위 클래스이다.</li></ul><h4 id="2-객체-object"><a href="#2-객체-object" class="headerlink" title="2) 객체 (object)"></a>2) 객체 (object)</h4><p>클래스의 인스턴스를 객체(object)라고 하며 필요한 속성(Attribute)과 속성을 처리하기 위한 메서드(Method)를 가진 하나의 소프트웨어 모듈이며 다른 객체들과 구별될 수 있는 이름이 있고, 실제 메모리상에 할당된 것으로 실제 프로그램에서 사용되는 데이터이다.</p><h5 id="속성-Attribute"><a href="#속성-Attribute" class="headerlink" title="속성(Attribute)"></a>속성(Attribute)</h5><ul><li>객체가 가지고 있는 정보 또는 상태를 나타내며 객체의 속성, 데이터, 변수, 상수 또는 자료구조라고도 부른다.</li></ul><h5 id="메서드-Method"><a href="#메서드-Method" class="headerlink" title="메서드(Method)"></a>메서드(Method)</h5><ul><li>객체가 가진 기능으로 객체의 속성을 처리하는 하나의 알고리즘이다.</li><li>객체가 메시지를 받아 실행해야 할 객체의 구체적인 연산을 정의한 것, 전통적 시스템의 함수(Function)나 프로시저(Procedure)에 해당하는 연산 기능을 수행한다.</li><li>메소드는 다른 객체로부터 메시지를 받았을 때 수행하게 된다.</li></ul><h4 id="3-메시지-message"><a href="#3-메시지-message" class="headerlink" title="3) 메시지 (message)"></a>3) 메시지 (message)</h4><p>메시지는 객체 간의 상호작용을 하는 데 사용되는 수단으로, 객체에게 어떤 행위를 하도록 지시하는 명령 또는 요구 사항이다.<br>클래스로부터 생성된 객체를 사용하는 방법으로서 객체에 명령을 내리는 것이 메시지라 할 수 있다.</p><ul><li>메시지의 구성 요소 : 메시지를 받는 객체의 이름, 객체가 수행할 메소드 이름, 메소드를 수행할 때 필요한 인자</li><li>메시지를 받은 수신 객체는 요구된 메소드를 수행하여 결과를 반환하게 된다.</li></ul><h2 id="OOP-기법-특성"><a href="#OOP-기법-특성" class="headerlink" title="OOP 기법 (특성)"></a>OOP 기법 (특성)</h2><p>객체 지향 프로그래밍이란 <strong>“누가 어떤 일을 할 것인가”</strong> 이며 1개 이상의 유사 객체의 공통된 특성(속성과 메서드) 가진 클래스를 통해 객체를 생성하고 상호 유기적으로 메시지를 주고 받으며 결과를 반환한다고 정리해볼 수 있으며 OOP의 기법 및 특성이 모두 담겨져 있다.</p><h3 id="1-캡슐화-Encapsulation"><a href="#1-캡슐화-Encapsulation" class="headerlink" title="1) 캡슐화 (Encapsulation)"></a>1) 캡슐화 (Encapsulation)</h3><ul><li>자료 부분과 연산(또는 함수) 부분 등 정보처리에 필요한 기능을 한 테두리로 묶는 것</li><li>연관된 데이터와 함수를 함께 묶어 외부와 경계를 만들고 필요한 인터페이스만을 밖으로 드러내는 과정</li><li>객체지향 기법의 <em>정보 은닉</em> 과 밀접한 기법</li><li>장점<ul><li>높은 재사용성</li><li>인터페이스의 단순화</li><li>변경 또는 수정이 발생할때 오류의 파급효과가 적음</li><li>응집력이 향상됨</li></ul></li></ul><h3 id="2-은닉화-Information-Hiding"><a href="#2-은닉화-Information-Hiding" class="headerlink" title="2) 은닉화 (Information Hiding)"></a>2) 은닉화 (Information Hiding)</h3><ul><li>캡슐화에서 가장 중요한 개념으로, 다른 객체에게 자신의 정보를 숨기고 자신의 연산만을 통하여 접근을 허용하는 것</li><li>정보 은닉은 고려되지 않은 영향(side effect)들을 최소화함을 목적으로 함</li><li>따라서, 외부 객체가 접근하거나 사용하지 못하므로 유지보수와 소프트웨어 확장 시 오류를 최소화 할 수 있음</li></ul><h3 id="3-추상화-Abstraction"><a href="#3-추상화-Abstraction" class="headerlink" title="3) 추상화 (Abstraction)"></a>3) 추상화 (Abstraction)</h3><ul><li>자료 추상화는 불필요한 정보는 숨기고 중요한 정보만을 표현함으로써 프로그램을 간단히 만드는 것으로, 모델화하는 것을 의미</li><li>자료 추상화를 통해 정의된 자료형을 추상 자료형이라고 함</li><li>추상 자료형은 자료형의 자료 표현과 자료형의 연산을 캡슐화한 것으로 접근 제어를 통해서 자료형의 정보를 은닉할 수 있다.</li><li>객체 지향 프로그래밍에서 일반적으로 추상 자료형을 클래스, 추상 자료형의 인스턴스를 객체, 추상 자료형에서 정의된 연산을 메소드(함수), 메소드의 호출을 생성자라고 한다.</li></ul><h3 id="4-상속성-Inheritance"><a href="#4-상속성-Inheritance" class="headerlink" title="4) 상속성 (Inheritance)"></a>4) 상속성 (Inheritance)</h3><ul><li>상속은 새로운 클래스가 기존의 클래스의 자료와 메서드를 이용할 수 있게 하는 기능</li><li>상속을 받는 새로운 클래스를 부클래스, 파생 클래스, 하위 클래스, 자식 클래스라고 하며 새로운 클래스가 상속하는 기존의 클래스를 기반 클래스, 상위 클래스, 부모 클래스라 함</li><li>상속을 통해서 기존의 클래스를 상속받은 하위 클래스를 이용해 프로그램의 요구에 맞추어 클래스를 수정할 수 있고, 클래스 간의 종속 관계를 형성함으로써 객체를 조직화할 수 있다.</li><li>다중 상속<ul><li>클래스가 2개 이상의 클래스로부터 상속받을 수 있게 하는 기능</li><li>클래스들의 기능이 동시에 필요할 때 용이하나 클래스의 상속 관계에 혼란을 줄 수 있음 (예: 다이아몬드 상속)</li><li>프로그래밍 언어에 따라 사용 가능 유무가 다르므로 주의해서 사용해야 한다. JAVA는 지원하지 않음</li></ul></li></ul><h3 id="5-다형성-Polymorphism"><a href="#5-다형성-Polymorphism" class="headerlink" title="5) 다형성 (Polymorphism)"></a>5) 다형성 (Polymorphism)</h3><ul><li>상이한 클래스들이 동일한 메서드명을 갖는 것 또는 한 메시지가 객체에 따라 다양한 방식으로 응답할 수 있는 것을 의미함</li><li>일반적으로 오버라이딩이나 오버로딩을 의미함<ul><li>오버라이딩: 같은 이름의 메소드가 여러 클래스에서 다른 기능을 하는 것 </li><li>오버로딩: 같은 이름의 메소드가 인자의 개수나 자료형에 따라서 다른 기능을 하는 것</li></ul></li><li>다형 개념을 통해서 프로그램 안의 객체 간의 관계를 조직적으로 나타낼 수 있음</li></ul><h3 id="6-연관성-Relationship"><a href="#6-연관성-Relationship" class="headerlink" title="6) 연관성 (Relationship)"></a>6) 연관성 (Relationship)</h3><table><thead><tr><th>관계성의 종류</th><th>의미</th><th>특성</th></tr></thead><tbody><tr><td>is-member-of</td><td>연관화</td><td>링크 개념과 유사</td></tr><tr><td>is-instance-of</td><td>분류화</td><td>객체 및 클래스의 인스턴스를 표현</td></tr><tr><td>is-part-of</td><td>집단화</td><td>상향식, 단일 상속, 복합 객체 (composite object) 표현에 유용</td></tr><tr><td>is-a</td><td>특수화, 일반화</td><td>하향식, 다중 상속, 복잡한 객체 표현에 유용</td></tr></tbody></table><ul><li>두 개 이상의 엔티티 형에서 데이터를 상호 참조하는 클래스간의 연관관계를 정의</li><li>객체간의 관계를 세부적으로 정의하여 구현 용이</li><li>관계성의 종류<ul><li>is-member-of (연관화, association)<ul><li>공통된 의미(semantic)를 서로 연관된 집단으로 표현하는 방법으로 링크(link)와 그 의미가 유사</li><li>객체들의 물리적, 또는 개념적 연결을 두 개 이상의 객체와 클래스로 표현</li><li>즉, 연관화는 관련되지 않은 클래스들간의 의미적 연결</li></ul></li><li>is-instance-of (분류화, classification)<ul><li>공통된 속성에 의하여 정의된 객체 및 클래스에 있어 구성원들의 인스턴스</li><li>즉, 분류화는 동일한 형의 특성을 갖는 객체들이 모여 클래스를 구성하는 것<ul><li>여기서, 클래스는 객체들의 본질에 대한 추상화</li></ul></li></ul></li><li>is-part-of (집단화, aggregation)<ul><li>서로 관련 있는 여러 개의 객체를 묶어 한 개의 상위 객체 생성</li><li>여러 개의 속성을 묶어 사용자 정의형의 엔티티를 만드는 수단으로 사용</li><li>한 객체에서 하나 이상의 객체는 사용자 표정의 형이 될 때 복합 객체(composite object)<ul><li>즉, 복합 객체의 종속 성분을 모델링하기 위해 사용되며, 이들 복합 성분 클래스 관계를 통해 복합 속성 계층(composite attribute hierarchy)을 형성</li></ul></li></ul></li><li>is-a<ul><li>일반화 (generalization)<ul><li>일반화는 객체들에 있어 공통적인 성질들을 상위 객체로 정의하고, 특수화(specialization)된 객체들을 하위의 부분형(subtype) 객체로 정의</li></ul></li><li>특수화 (specialization)<ul><li>일반화와 개념과 같으나, 클래스를 보는 시점에 있어 상위의 클래스에서 하위의 클래스를 보는 관점(특수화의 역은 일반화)</li><li>하위 개념으로 내려 갈수록 인스턴스는 특수화</li><li>클래스로 모델화되는 실세계 객체들을 겹치지 않는 서브 클래스로 나누거나 상이한 실세계 상황으로 나누기 위해 사용</li></ul></li></ul></li></ul></li></ul><h2 id="OOP-장단점"><a href="#OOP-장단점" class="headerlink" title="OOP 장단점"></a>OOP 장단점</h2><h3 id="1-장점"><a href="#1-장점" class="headerlink" title="1) 장점"></a>1) 장점</h3><ul><li>자연적인 모델링이 가능함</li><li>코드의 재사용성 증가</li><li>소프트웨어의 유지보수성 향상</li><li>대형 프로젝트 개발에 적합</li></ul><h3 id="2-단점"><a href="#2-단점" class="headerlink" title="2) 단점"></a>2) 단점</h3><ul><li>처리속도가 상대적으로 느림</li><li>다중 객체 생성에 따른 메모리 사용량 증가</li><li>객체 설계의 복잡도에 따른 설계시간 소용 시간</li></ul><h3 id="강한-응집력-Strong-Cohesion-과-약한-결합력-Weak-Coupling"><a href="#강한-응집력-Strong-Cohesion-과-약한-결합력-Weak-Coupling" class="headerlink" title="강한 응집력 (Strong Cohesion)과 약한 결합력 (Weak Coupling)"></a>강한 응집력 (Strong Cohesion)과 약한 결합력 (Weak Coupling)</h3><p>위의 장점들을 관통하는 객체 지향 프로그래밍의 중요한 특성은 <strong>강한 응집력(Strong Cohesion)과 약한 결합력(Weak Coupling)</strong> 을 지향한다는 점이다. 소프트웨어 공학에서 말하는,</p><p><strong>응집력(cohesion)</strong></p><ul><li>프로그램의 한 요소가 해당 기능을 수행하기 위해 얼마만큼의 연관된 책임과 아이디어가 뭉쳐있는지를 나타내는 정도.</li><li>프로그램의 한 요소가 특정 목적을 위해 밀접하게 연관된 기능들이 모여서 구현되어 있고, 지나치게 많은 일을 하지 않으면 그것을 응집력이 높다고 표현함.</li></ul><p><strong>결합력(coupling)</strong></p><ul><li>프로그램 코드의 한 요소가 다른 것과 얼마나 강력하게 연결되어 있는지, 얼마나 의존적인지를 나타내는 정도.</li><li>결합력이 낮다는 것은 한 요소가 다른 요소들과 관계를 크게 맺고 있지 않은 상태를 의미함.</li></ul><p>OOP의 경우 클래스에 하나의 문제 해결을 위해 데이터를 모아 놓은 객체를 활용한 프로그래밍을 지향하므로 응집력을 강화하며, 클래스 간에 독립적으로 디자인함으로써 결합력을 약하게 할 수 있다.</p><h2 id="마치며"><a href="#마치며" class="headerlink" title="마치며"></a>마치며</h2><p>사실 자바스크립트를 사용하면서 OOP에 대한 기술부채가 있었고, Javascirpt의 Prototype 기반의 객체지향 설계 및 구현과 같은 자료를 읽어도 근본이 되는 OOP에 대한 단순 암기식 지식 때문인지 이해는 되지만 시원하지 않았다. 그러나 이번 포스트를 쓰기 위해 공부하고 작성하는 동안 어플리케이션 전체를 그리고 그 내부의 세부 기능을 설계와 구현의 관점에서 OOP가 어떻게 바라보는지 이해할 수 있었다. 다음 포스팅은 <strong><em>Prototype 기반의 Javascript 객체지향</em></strong> 에 대해서 작성해보겠습니다.</p><hr><h2 id="참고"><a href="#참고" class="headerlink" title="참고"></a>참고</h2><ul><li><a href="https://webclub.tistory.com/155">객체지향 프로그래밍</a></li><li><a href="https://m.blog.naver.com/gutmsl/50118818528">객체 지향 기법의 구성 요소</a></li><li><a href="https://itwiki.kr/w/%EA%B0%9D%EC%B2%B4%EC%A7%80%ED%96%A5_%EC%97%B0%EA%B4%80%EC%84%B1">객체지향 기법</a></li><li><a href="https://itwiki.kr/w/%EA%B0%9D%EC%B2%B4%EC%A7%80%ED%96%A5_%EC%97%B0%EA%B4%80%EC%84%B1">객체지향 연관성</a></li><li><a href="https://velog.io/@cyranocoding/%EA%B0%9D%EC%B2%B4-%EC%A7%80%ED%96%A5-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8DOOP-Object-Oriented-Programming-%EA%B0%9C%EB%85%90-%EB%B0%8F-%ED%99%9C%EC%9A%A9-%EC%A0%95%EB%A6%AC-igjyooyc6c">객체 지향 프로그래밍(OOP : Object Oriented Programming) 개념 및 활용 정리</a></li><li><a href="https://ehddnjs8989.medium.com/%EC%86%8C%ED%94%84%ED%8A%B8%EC%9B%A8%EC%96%B4-%EA%B0%9C%EB%B0%9C%EC%9D%98-%EA%B8%B0%EC%B4%88-oop-c50a7701223e">소프트웨어 개발의 기초 - OOP</a></li><li><a href="https://brunch.co.kr/@kd4/4">다형성에 대해서 설명해보세요</a></li></ul>]]></content:encoded>
      
      
      <category domain="https://joontae-kim.github.io/categories/Programming/">Programming</category>
      
      <category domain="https://joontae-kim.github.io/categories/Programming/Javascript/">Javascript</category>
      
      
      <category domain="https://joontae-kim.github.io/tags/javascript/">javascript</category>
      
      <category domain="https://joontae-kim.github.io/tags/oop/">oop</category>
      
      <category domain="https://joontae-kim.github.io/tags/object/">object</category>
      
      
      <comments>https://joontae-kim.github.io/2020/11/02/js-oop-2/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>자바스크립트 알고리즘 - 시작 (a.k.a 자료 모으기)</title>
      <link>https://joontae-kim.github.io/2020/10/28/js-algorithm/</link>
      <guid>https://joontae-kim.github.io/2020/10/28/js-algorithm/</guid>
      <pubDate>Tue, 27 Oct 2020 18:26:36 GMT</pubDate>
      
        
        
      <description>&lt;p&gt;&lt;img src=&quot;/images/JS_algorithms.jpeg&quot;&gt;&lt;/p&gt;
&lt;h4 id=&quot;강좌-동영상&quot;&gt;&lt;a href=&quot;#강좌-동영상&quot; class=&quot;headerlink&quot; title=&quot;강좌 (동영상)&quot;&gt;&lt;/a&gt;강좌 (동영상)&lt;/h4&gt;&lt;ul&gt;
&lt;l</description>
        
      
      
      
      <content:encoded><![CDATA[<p><img src="/images/JS_algorithms.jpeg"></p><h4 id="강좌-동영상"><a href="#강좌-동영상" class="headerlink" title="강좌 (동영상)"></a>강좌 (동영상)</h4><ul><li><p><a href="https://www.udemy.com/course/coding-interview-bootcamp-algorithms-and-data-structure/">https://www.udemy.com/course/coding-interview-bootcamp-algorithms-and-data-structure/</a></p></li><li><p><a href="https://www.udemy.com/course/coding-interview-question-data-structures-algorithm/">https://www.udemy.com/course/coding-interview-question-data-structures-algorithm/</a></p></li><li><p>유튜브 강좌</p><ul><li><a href="https://www.youtube.com/playlist?list=PLLXdhg_r2hKA7DPDsunoDZ-Z769jWn4R8">https://www.youtube.com/playlist?list=PLLXdhg_r2hKA7DPDsunoDZ-Z769jWn4R8</a></li></ul></li></ul><h4 id="강좌-블로그"><a href="#강좌-블로그" class="headerlink" title="강좌 (블로그)"></a>강좌 (블로그)</h4><ul><li>7 JavaScript data structures you must know<ul><li><a href="https://www.educative.io/blog/javascript-data-structures#wrap-up">https://www.educative.io/blog/javascript-data-structures#wrap-up</a></li></ul></li></ul><h4 id="깃헙"><a href="#깃헙" class="headerlink" title="깃헙"></a>깃헙</h4><ul><li><a href="https://github.com/trekhleb/javascript-algorithms/blob/master/README.ko-KR.md">JavaScript 알고리즘 및 자료 구조</a></li></ul><h4 id="볼만한-알고리즘-단편-블로그"><a href="#볼만한-알고리즘-단편-블로그" class="headerlink" title="볼만한 알고리즘 단편 블로그"></a>볼만한 알고리즘 단편 블로그</h4><ul><li><a href="https://www.educative.io/blog/javascript-data-structures#what-are">7 Javascript data structure you must know</a></li><li><a href="https://ipex.tistory.com/entry/algorithms-%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EA%B0%9C%EC%9A%94-algorithms-in-JavaScript-OverView">Javascript 알고리즘 개요</a></li><li><a href="https://aidanbae.github.io/code/algorithm/bigo/">빅오 표기법(Big o notation)과 자바스크립트</a></li><li><a href="https://qkqhxla1.tistory.com/990">취업을 위한 알고리즘 공부법</a></li><li><a href="https://blog.yena.io/studynote/2018/11/14/Algorithm-Basic.html">[Algorithm] 알고리즘 공부 시작 방법 및 순서</a></li></ul><h4 id="볼만한-알고리즘-블로그-시리즈"><a href="#볼만한-알고리즘-블로그-시리즈" class="headerlink" title="볼만한 알고리즘 블로그 시리즈"></a>볼만한 알고리즘 블로그 시리즈</h4><ul><li><a href="https://soldonii.tistory.com/category/Javascript%20%EA%B3%B5%EB%B6%80/Data%20Structure%20+%20Algorithms%28-%29?page=3">Javascript 공부/Data Structure + Algorithms - soldonii.tistory.com</a></li><li><a href="https://soldonii.tistory.com/category/Javascript%20%EA%B3%B5%EB%B6%80/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98%20%ED%92%80%EC%9D%B4?page=2">Javascript 공부/알고리즘 풀이 - soldonii.tistory.com</a></li></ul>]]></content:encoded>
      
      
      <category domain="https://joontae-kim.github.io/categories/Programming/">Programming</category>
      
      <category domain="https://joontae-kim.github.io/categories/Programming/Algorithm/">Algorithm</category>
      
      
      <category domain="https://joontae-kim.github.io/tags/javascript/">javascript</category>
      
      <category domain="https://joontae-kim.github.io/tags/Algorithm/">Algorithm</category>
      
      <category domain="https://joontae-kim.github.io/tags/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/">알고리즘</category>
      
      <category domain="https://joontae-kim.github.io/tags/lecture/">lecture</category>
      
      <category domain="https://joontae-kim.github.io/tags/reference/">reference</category>
      
      <category domain="https://joontae-kim.github.io/tags/%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8/">자바스크립트</category>
      
      
      <comments>https://joontae-kim.github.io/2020/10/28/js-algorithm/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>프론트엔드 면접 질문 리스트 - FE (Browser)</title>
      <link>https://joontae-kim.github.io/2020/10/26/interview-question-fe/</link>
      <guid>https://joontae-kim.github.io/2020/10/26/interview-question-fe/</guid>
      <pubDate>Mon, 26 Oct 2020 08:19:05 GMT</pubDate>
      
        
        
      <description>&lt;p&gt;&lt;img src=&quot;/images/job_thumbnail.jpeg&quot; alt=&quot;면접!&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;프론트엔드-면접-준비를-위한-질문-리스트-정리&quot;&gt;&lt;a href=&quot;#프론트엔드-면접-준비를-위한-질문-리스트-정리&quot; class=&quot;heade</description>
        
      
      
      
      <content:encoded><![CDATA[<p><img src="/images/job_thumbnail.jpeg" alt="면접!"></p><h2 id="프론트엔드-면접-준비를-위한-질문-리스트-정리"><a href="#프론트엔드-면접-준비를-위한-질문-리스트-정리" class="headerlink" title="프론트엔드 면접 준비를 위한 질문 리스트 정리"></a>프론트엔드 면접 준비를 위한 질문 리스트 정리</h2><h3 id="Front-end"><a href="#Front-end" class="headerlink" title="Front-end"></a>Front-end</h3><p>아래질문 리스트를 기반으로 면접 질문 &amp; 답변 목록을 작성할 예정이고, 지속적으로 보충 or 보수할 계획입니다.</p><ul><li>업데이트 날짜<ul><li>2020-10-26</li></ul></li></ul><ul><li>질문 목록<ul><li>브라우저의 렌더링 과정에 대해서 상세하게 설명해달라</li><li>DOM을 건드리는 방식과 아닌 방식들의 차이</li><li>CORS(Cross-Origin Resource Sharing)는 무엇인가 왜 이러한 방법이 정의 되었으며, 본인이 코드를 작성하면서 CORS와 관련하여서 경험하였던 이슈는 무엇인가</li><li>라이브러리와 프레임워크에 대해서 설명</li><li>프로세스와 스레드의 차이</li><li>CSR과 SSR의 차이</li><li>가비지컬렉터의 역할은? 어떻게 동작하나요?</li><li>크로스 브라우징이란 무엇인가요?</li><li>우아한 퇴보와 점진적 향상은 무엇인가요</li></ul></li></ul><hr><h3 id="1-브라우저의-렌더링-과정에-대해서-상세하게-설명해달라"><a href="#1-브라우저의-렌더링-과정에-대해서-상세하게-설명해달라" class="headerlink" title="1. 브라우저의 렌더링 과정에 대해서 상세하게 설명해달라"></a>1. 브라우저의 렌더링 과정에 대해서 상세하게 설명해달라</h3><p><strong>렌더링</strong> 이란 <em>서버로부터 HTML 파일을 받아 브라우저에 뿌려주는 과정</em> 이고, <strong>중요 렌더링 경로</strong> (Critical Rendering Path)이란 <em>브라우저에서 화면이 그려지기까지의 주요한 과정으로, 브라우저가 HTML, CSS, Javascipt를 화면에 픽셀로 변화하는 일련의 단계</em> 를 말하며 이를 최적화하는 것은 렌더링 성능을 향상시킵니다. </p><p><strong><em>간략하게</em></strong></p><ol><li>HTML 마크업을 Parsing(처리)하여 DOM 트리를 빌드한다. (<strong>“무엇을”</strong> 그릴지 결정한다.) (DOM 파싱)</li><li>CSS Parsing(처리)하여 CSSOM 트리를 빌드한다. (<strong>“어떻게”</strong> 그릴지 결정한다.) (CSS 파싱)</li><li>DOM 및 CSSOM 을 결합하여 렌더링 트리를 형성한다. (<strong>“화면에 그려질 것만”</strong> 결정) (Combination)</li><li>렌더링 트리에서 레이아웃을 실행하여 각 노드의 기하학적 형태를 계산한다. (<strong>“Box-Model”</strong> 을 생성한다.) (Layout)</li><li>개별 노드를 화면에 페인트한다.(or 래스터화)  (Painting)</li><li>렌더링이 완료된 상태에서 사용자의 인터랙션에 의해 화면의 일부 영역이 변경된다면, <code>리플로우</code> 또는 <code>리페인트</code>가 발생한다.</li></ol><p><strong>개략적인 과정</strong> 은 아래와 같다.</p><ul><li><p>웹 페이지 또는 어플리케이션에 대한 요청은 HTML 요청으로 시작됩니다.</p></li><li><p>서버는 응답 헤더 또는 데이터로 HTML을 반환합니다. </p></li><li><p>브라우저는 HTML을 분석하고 수신된 bytes를 DOM 트리로 변환하기 시작합니다. </p></li><li><p>브라우저는 스타일시트, 스크립트 또는 포함된 이미지 참조인 외부 자원에 대한 링크를 찾을때마다 요청을 시작합니다.</p></li><li><p>불러온 에셋을 다룰 때까지 나머지 HTML을 분석하는 작업하는 일부 요청은 중단되며 차단됩니다.</p><ul><li><p>파싱은 CSS file을 만났을때도 계속되지만 특히 <code>async</code> 또는 <code>defer</code> 속성이 없는 <code>&lt;script&gt;</code> 태그를 만났을 경우에는 렌더링을 멈추고 HTML 파싱을 중단합니다. 비록 브라우저의 프리로드(preload) 스캐너가 이 과정을 가속화하지만 과도한 스크립트는 여전히 심각한 병목현상이 될 수 있습니다.</p></li><li><p>메인 스레드가 HTML, CSS를 분석하는 동안 Preload scanner는 스크립트와 이미지를 검색할 것이고 다운로드 받기 시작할 것입니다. 스크립트가 DOM 트리 구성 프로세스를 막지 않도록 보장하기 위해, 만약 Javascript 파싱 또는 실행 순서가 중요하지 않다면 <code>async</code> 또는 <code>defer</code> 속성을 추가해야 합니다.</p><p>CSS를 받기 위해 대기하는 것은 HTML 분석 또는 다운로딩은 막지 않지만 Javascript는 종종 HTML 요소에서 CSS 속성을 조회하는데 영향을 끼치기 때문에 막습니다.</p></li></ul></li><li><p>브라우저는 CSSOM 구축 작업이 끝날때까지 요청을 만들고 DOM을 생성하는 HTML을 계속해서 분석합니다. </p></li><li><p>DOM과 CSSOM이 완료되면 브라우저는 렌더 트리를 생성하고 보여지는 컨텐츠를 위해 스타일을 계산합니다. <em>(Layout)</em></p><ul><li><em>레이아웃</em> 은 너비, 높이 그리고 렌더 트리 안에서 모든 노드들의 위치를 결정하는 과정으로, 각 노드의 위치를 계산하기 위해 렌더 트리에서 레이아웃을 작동시키는 것입니다. </li><li>페이지 안에서 각 오브젝트의 크기와 위치에 대한 결정도 추가됩니다. <em>리플로우</em> 는 페이지의 특정 부분 또는 전체 도큐먼트의 어떤 연속적인 크기와 위치에 대한 결정입니다.</li></ul></li><li><p>렌더트리가 완료된 후 모든 렌더 트리 요소들에 대한 위치와 크기가 정의된 레이아웃이 만들어집니다. 일단 완료되면 레이지는 렌더링되거나 또는 화면에 ‘그려집니다(<em>painted</em>)’.</p></li></ul><h3 id="2-DOM을-건드리는-방식과-아닌-방식들의-차이"><a href="#2-DOM을-건드리는-방식과-아닌-방식들의-차이" class="headerlink" title="2. DOM을 건드리는 방식과 아닌 방식들의 차이"></a>2. DOM을 건드리는 방식과 아닌 방식들의 차이</h3><blockquote><h4 id="이-질문에-대한-핵심-or-예상-의도"><a href="#이-질문에-대한-핵심-or-예상-의도" class="headerlink" title="이 질문에 대한 핵심 or 예상 의도"></a>이 질문에 대한 핵심 or 예상 의도</h4><p>모던 js 프레임워크의 가상돔 (<em>Virtual Dom</em>)에 대한 질문</p></blockquote><p>직접 DOM을 건드리는 경우 DOM의 구조를 파악하고 있어야하며, 클래스명이다 태그명이 바뀌는 경우 다시 DOM을 변경해야한다. </p><p>Angular의 경우 view와 model을 연결시키는 바인딩 작업이 있고 변화 감지를 통해서 상태를 보고 있다가 업데이트 되는 방식이다. React와 Vue의 경우 가상 DOM이 있고, 가상 DOM이 실제 DOM과 비교하여 state가 변화되었는지 감지 한다.</p><h3 id="3-CORS-Cross-Origin-Resource-Sharing"><a href="#3-CORS-Cross-Origin-Resource-Sharing" class="headerlink" title="3. CORS(Cross-Origin Resource Sharing)"></a>3. CORS(Cross-Origin Resource Sharing)</h3><h4 id="1-정의"><a href="#1-정의" class="headerlink" title="1) 정의"></a>1) 정의</h4><p>교차 출처 자원 공유(Cross-Origin Resource Sharing)의 줄임말로, 여기서 말하는 오리진이란 도메인(domain)을 <code>naver.com</code> 라고 한다면 오리진(origin)은 <code>https://www.naver.com/PORT</code> 으로 차이는 프로토콜과 포트번호의 포함 여부이다.</p><p>__특정 오리진에서 작동하고 있는 웹 어플리케이션이 다른 오리진 서버로이 엑세스를 오리진 사이의 HTTP 요청에 허가를 할 수 있는 체계__를 말한다.</p><p><code>Cross-Origin Resource Sharing</code> 표준은 웹 브라우저가 사용하는 정보를 읽을 수 있도록 허가된 <strong>출처 집합</strong>을 서버에게 알려주도록 허용하는 특정 HTTP 헤더를 추가함으로써 동작한다.</p><table><thead><tr><th>HTTP Header</th><th>Description</th></tr></thead><tbody><tr><td>Access-Control-Allow-Origin</td><td>접근 가능한 <code>url</code> 설정</td></tr><tr><td>Access-Control-Allow-Credentials</td><td>접근 가능한 <code>쿠키</code> 설정</td></tr><tr><td>Access-Control-Allow-Headers</td><td>접근 가능한 <code>헤더</code> 설정</td></tr><tr><td>Access-Control-Allow-Methods</td><td>접근 가능한 <code>http method</code> 설정</td></tr></tbody></table><p><img src="https://media.vlpt.us/images/josworks27/post/4a53c23c-ca72-4f2c-a7a5-7b53b9df6e6e/CORS_principle.png" alt="CORS"></p><h4 id="2-목적"><a href="#2-목적" class="headerlink" title="2) 목적"></a>2) 목적</h4><ul><li><strong>Same-Origin Policy</strong></li><li>웹 시큐리티의 중요한 정책 중 하나로 <strong>Same-Origin Policy</strong> 가 있다.</li><li>이는 오리진 사이의 리소스 공유 제한을 둬 아래와 같은 위험을 막고자 함<ul><li>XSS (Cross Site Scripting)</li><li>CSRF (Cross-Site Request Forgeries)</li></ul></li><li>XSS<ul><li>공격자가 악성 스크립트를 신뢰할 수 있는 웹사이트에 삽입하는 방법</li><li>유저가 웹 사이트에 접속하는 것으로 정상적이지 않은 요청이 클라이언트에서 실행되는 것</li><li>Cookie 내 Session 정보를 탈취 당하는 등의 예</li><li>종류<ul><li>Stored XSS: 보호되지 않고 검수되지 않은 사용자 입력으로 인한 취약점(데이터 베이스에 직접 저장되어 다른 사용자에게 표시됨)</li><li>Reflected XSS: 웹 페이지에서 직접 사용되는 URL의 비보안에 의해 발생하는 취약점</li><li>DOM based XSS: 웹페이지에서 직접 사용되는 URL의 비보안에 의해 발생한 취약점이라는 점에서 reflected XSS와 비슷하지만 DOM based XSS는 서버측으로 이동하지 않는다.</li></ul></li></ul></li><li>CSRF<ul><li>웹 어플리케이션의 유저가 의도하지 않은 처리를 웹 어플리케이션에서 실행되는 것</li><li>악의적인 웹사이트, 전자 메일, 블로그, 인스턴트 메시지 또는 프로그램으로 인해 사용자의 웹 브라우저가 사용자가 인증 된 다른 신뢰할 수 있는 사이트에서 원치 않는 작업을 수행 할 때 발생하는 공격 유형이다.</li><li>접근 권한이 있는 사용자만이 접근할 수 있는 요청이 멋대로 실행되는 등의 예</li><li>이 취약점은 브라우저가 세션 쿠키, IP주소 또는 각 요청과 유사한 인증 리소스를 자동으로 보내는 경우에 발생 할 수 있다.</li></ul></li></ul><h4 id="3-CORS와-관련-경험-또는-이슈"><a href="#3-CORS와-관련-경험-또는-이슈" class="headerlink" title="3) CORS와 관련 경험 또는 이슈"></a>3) CORS와 관련 경험 또는 이슈</h4><p><strong>REST API 서버</strong> 와 <strong>Web 서버</strong> 의 분리로 CORS를 해결해야 했으며 REST API 서버에 <strong>Role-based</strong> 구조를 띄고 있어 리소스 서버에 접근하기 전에 권한 검증을 위해 <strong>Preflight Request</strong> 를 구현했었음</p><p><code>Preflight Request</code> 는 실제 요청 전에 인증 헤더를 전송해 서버의 접근 허용 여부를 미리 체크하는 테스트 요청으로, 서버 측에서는 브라우저가 해당 도메인에서 CORS를 허용하는지 알아보기 위해 preflight 요청을 보내는데, HTTP <code>OPTION</code> 메서드를 사용하며  <code>Access-Control-Request-*</code> 형태의 헤더로 전송한다.</p><p>이는 브라우저가 강제하며 HTTP <code>OPTION</code> 요청 메서드를 이용해 서버로부터 지원 중인 메서드들을 내려 받은 뒤, 서버에서 <code>approval(승인)</code> 시에 실제 HTTP 요청 메서드를 이용해 실제 요청을 전송하는 것이다.</p><p>개발시 참고했던 링크: <a href="https://dev.to/miguelmota/understanding-cross-origin-resource-sharing-cors-2i3e">Understanding Cross-Origin Resource Sharing</a></p><h3 id="4-프레임워크와-라이브러리에-대해서-설명"><a href="#4-프레임워크와-라이브러리에-대해서-설명" class="headerlink" title="4. 프레임워크와 라이브러리에 대해서 설명"></a>4. 프레임워크와 라이브러리에 대해서 설명</h3><p>라이브러리와 프레임워크의 차이는 자유도의 차이 인것 같다. 프레임워크는 짜여진 패턴이나 틀 기반에서 내가 코딩을 하는 것이고, 라이브러리는 내가 가져다 사용해서 자유롭게 사용하는 방식이다.</p><h4 id="1-프레임워크"><a href="#1-프레임워크" class="headerlink" title="1) 프레임워크"></a>1) 프레임워크</h4><p>뼈대나 기반구조를 뜻하고, 제어의 역전 개념이 적용된 대표적인 기술입니다</p><p>소프트웨어에서의 프레임워크는 ‘소프트웨어의 특정 문제를 해결하기 위해서 상호 협력하는 클래스와 인터페이스의 집합’ 이라 할 수 있으며, 완성된 어플리케이션이 아닌 프로그래머가 완성시키는 작업을 해야합니다. 객체 지향 개발을 하게 되면서 통합성, 일관성의 부족이 발생되는 문제를 해결할 방법중 하나라고 할 수 있습니다.</p><h4 id="2-라이브러리"><a href="#2-라이브러리" class="headerlink" title="2) 라이브러리"></a>2) 라이브러리</h4><p>라이브러리는 단순 활용가능한 도구들의 집합을 말합니다</p><p>즉, 개발자가 만든 클래스에서 호출하여 사용, 클래스들의 나열로 필요한 클래스를 불러서 사용하는 방식을 취하고 있습니다.</p><h4 id="3-차이"><a href="#3-차이" class="headerlink" title="3) 차이"></a>3) 차이</h4><p>라이브러리와 프레임워크의 차이는 <strong>제어 흐름에 대한 주도성이 누구에게/어디에 있는가</strong>에 있습니다. 즉, 어플리케이션의 <strong>Flow(흐름)를 누가 쥐고 있느냐</strong>에 달려 있습니다</p><p><strong>프레임워크</strong>는 <code>전체적인 흐름을 스스로가 쥐고 있으며 사용자는 그 안에서 필요한 코드를 짜</code> 넣으며 반면에 <strong>라이브러리</strong>는 <code>사용자가 전체적인 흐름을 만들며 라이브러리를 가져다 쓰는 것</code>이라고 할 수 있습니다. 다시 말해, 라이브러리는 라이브러리를 가져다가 사용하고 호출하는 측에 전적으로 주도성이 있으며 프레임워크는 그 틀안에 이미 제어 흐름에 대한 주도성이 내재(내포)하고 있습니다.</p><p><em>프레임워크는 가져다가 사용한다기보다는 거기에 들어가서 사용한다는 느낌/관점으로 접근할 수 있습니다.</em></p><h3 id="5-OS-프로세스와-스레드의-차이"><a href="#5-OS-프로세스와-스레드의-차이" class="headerlink" title="5. (OS) 프로세스와 스레드의 차이"></a>5. (OS) 프로세스와 스레드의 차이</h3><blockquote><h4 id="이-질문에-대한-핵심"><a href="#이-질문에-대한-핵심" class="headerlink" title="이 질문에 대한 핵심"></a>이 질문에 대한 핵심</h4><p><em>운영체제에서 작업을 실행할때 자원을 할당하는 단위를 알고 있느냐와 프로그램을 멀티 쓰레드를 구현할때 장/단점을 알고 있느냐에 대한 질문</em> 이다.</p></blockquote><h4 id="1-프로세스-Process"><a href="#1-프로세스-Process" class="headerlink" title="1) 프로세스 (Process)"></a>1) 프로세스 (Process)</h4><p>컴퓨터에서 연속적으로 실행되고 있는 프로그램</p><ul><li>프로그램 이란 실행 가능한 명령어의 집합으로, 여기서 얘기하는 프로그램이란 <em>“디스크에 저장된 실행 가능한 명령어의 집합인지의 여부”</em> 라고 말할 수 있다.</li><li>프로그램과 프로세스의 관계를 OOP (객체 지향 프로그래밍)의 클래스와 인스턴스 와 빗대어 예를 들면, 1개의 클래스에서 여러 인스턴스가 생성되듯이 1개의 프로그램에서 여러 프로세스가 생성되고 동시에 존재 가능.</li><li><strong>“메모장”</strong> 이라는 <code>프로그램</code> 은 하나이지만, <code>여러개의 메모장 (각 메모장 프로그램의 프로세스)</code> 이 실행될 수 있으며 동시에 존재 가능</li><li>커널 메모리 안에서 관리되는 PCB(Process Control Block) 정보 외에 유저가 사용하는 메모리 공간상의 프로세스 정보는 아래와 같다.<ul><li>Code: 프로그램의 실제 코드 저장</li><li>Data: 프로세스가 실행될째 정의된 전역 변수. Static 변수들을 저장</li><li>Heap: 프로세스 런타임 중 동적할당 변수들을 저장</li><li>Stack: 함수 실행 등의 서브루틴 정보 저장</li></ul></li><li><img src="/images/Process.png" alt="프로세스 정보"></li></ul><h4 id="2-쓰레드-Tread"><a href="#2-쓰레드-Tread" class="headerlink" title="2) 쓰레드 (Tread)"></a>2) 쓰레드 (Tread)</h4><p>한 프로세스 내에서 동작되는 여러 실행의 흐름</p><ul><li>프로세스가 할당 받은 자원 (주소 공간이나 자원)을 이용하는 실행의 단위</li><li>운영체제적으로는 한 프로세스 안의 스레드들은 <em>스택(Stack)을 제외한 프로세스의 나머지 공간(Code, Data, Heap)과 시스템 자원을 공유</em></li><li>한 스레드가 프로세스 자원을 변경하면, 다른 스레드도 그 변경 결과를 즉시 반영한다.</li><li><img src="/images/Tread.png" alt="스레드 정보"></li></ul><h5 id=""><a href="#" class="headerlink" title=""></a></h5><h4 id="3-프로세스와-쓰레드의-차이"><a href="#3-프로세스와-쓰레드의-차이" class="headerlink" title="3) 프로세스와 쓰레드의 차이"></a>3) 프로세스와 쓰레드의 차이</h4><blockquote><p><strong>프로세스는 운영체제로부터 독립된 시간, 공간 자원을 할당 받아 실행된다는 점이고, 스레드는 한 프로세스 내에서 많은 자원을 공유하면서 병렬적으로(Concurrently) 실행된다는 것이다.</strong> 다른 차이는 모두 이 근본적인 차이에서 비롯된다.</p></blockquote><ul><li>스레드는 프로세스 보다 독립적이다.<ul><li><strong><em>자원의 할당과 공유 측면에서,</em></strong> 스레드는 프로세스의 하위 집합으로 여러 스레드가 동일 프로세스의 자원을 공유하지만 프로세스는 보유한 자원에 대한 별개의 주소 공간을 갖고 공유해야하며 스레드는 이 주소 공간을 공유한다.</li></ul></li><li>프로세스간 통신은 스레드간 통신보다 어렵다.<ul><li><strong><em>프로그램의 안정성 측면에서는</em></strong> 스레드는 단순히 공유 변수의 수정만으로도 스레드간 통신을 구현할 수 있으며 프로세스는 OS가 제공하는 IPC 메커니즘을 통해서만 통신할 수 있으며 시스템에 의해 관리된다. 다만, 상대적으로 프로세스가 나을 수 있다.</li></ul></li><li><strong><em>Context Switch 측면에서도,</em></strong> 프로세스보다 스레드가 “일반적으로” 더 빠르고 자원소모가 적다.<ul><li>프로세스는 Switch 될때 Context를 PCB 등에 저장하는 등 오버헤드가 발생하나 스레드는 상대적으로 부하가 적다.</li><li>그러나 OS, 배포버전 그리고 프로세스의 지원 환경에 따라 이 점은 달라질 수 있다.</li></ul></li></ul><table><thead><tr><th>차이</th><th>프로세스</th><th>스레드</th></tr></thead><tbody><tr><td><strong>지원 할당 여부</strong></td><td>실행 시마다 새로운 자원 할당</td><td>동일 프로세스 내 자원을 공유</td></tr><tr><td><strong>자원 공유 여부</strong></td><td>일반적으론 자원 공유 하지 않으나 같은 프로그램의 경우 코드를 공유</td><td>동일 프로세스 내 스레드들은 스택을 제외한 자원을 공유</td></tr><tr><td><strong>독립성 여부</strong></td><td>일반적으로 독립적</td><td>프로세스 내 하위 집합</td></tr><tr><td><strong>주소 소유 여부</strong></td><td>별개의 주소 공간을 갖음</td><td>주소 공간을 공유</td></tr><tr><td><strong>통신 여부</strong></td><td>오직 시스템이 제공하는 IPC 방법으로만 통신</td><td>공유 변수 수정 등 자유롭게 동일 프로세스 내 타 스레드와 소통</td></tr><tr><td><strong>Context Switch</strong></td><td>일반적으로 프로세스 보다 스레드의 Context Switching이 더 빠를 수 있음</td><td>OS, 배포버전 또는 프로세스 내 환경에 따라 유동적임</td></tr></tbody></table><h3 id="6-CSR과-SSR의-차이"><a href="#6-CSR과-SSR의-차이" class="headerlink" title="6. CSR과 SSR의 차이"></a>6. CSR과 SSR의 차이</h3><h4 id="1-SSR-Server-Side-Rendering-서버-측-렌더링"><a href="#1-SSR-Server-Side-Rendering-서버-측-렌더링" class="headerlink" title="1) SSR (Server-Side Rendering, 서버 측 렌더링)"></a>1) SSR (Server-Side Rendering, 서버 측 렌더링)</h4><p><img src="/images/SSR.png" alt="Server-Side Rendering"></p><p>클라이언트 측 또는 유니버설 앱을 서버의 HTML로 렌더링합니다.</p><p>서버 렌더링은 탐색에 대한 응답으로 서버의 페이지에 대한 전체 HTML을 생성합니다. 이렇게 하면 브라우저에서 응답을 받기 전에 처리되므로 클라이언트에서 데이터 가져 오기 및 템플릿 작성에 대한 추가 왕복이 발생하지 않습니다.</p><h4 id="2-CSR-Client-Side-Rendering-클라이언트-측-렌더링"><a href="#2-CSR-Client-Side-Rendering-클라이언트-측-렌더링" class="headerlink" title="2) CSR (Client-Side Rendering, 클라이언트 측 렌더링)"></a>2) CSR (Client-Side Rendering, 클라이언트 측 렌더링)</h4><p><img src="/images/CSR.png" alt="Client-Side Rendering"></p><p>브라우저에서 애플리케이션을 렌더링합니다. 일반적으로 DOM을 사용합니다.</p><p>클라이언트 측 렌더링 (CSR)은 JavaScript를 사용하여 브라우저에서 페이지를 직접 렌더링하는 것을 의미합니다. 모든 로직, 데이터 가져오기, 템플릿 및 라우팅은 서버가 아닌 클라이언트에서 처리됩니다.</p><h4 id="3-CSR-SSR-장단점"><a href="#3-CSR-SSR-장단점" class="headerlink" title="3) CSR SSR 장단점"></a>3) CSR SSR 장단점</h4><p><img src="/images/CSR_SSR.png" alt="SSR과 CSR 장단점"></p><p><img src="/images/CSR_SSR_MVP_Model.png" alt="SSR과 CSR의 MVC 패턴"></p><h4 id="4-CSR과-SSR의-차이"><a href="#4-CSR과-SSR의-차이" class="headerlink" title="4) CSR과 SSR의 차이"></a>4) CSR과 SSR의 차이</h4><p>대표적으로, 초기 View 로딩 속도, SEO 문제, 보안 문제가 있다.</p><table><thead><tr><th></th><th>SSR</th><th>CSR</th></tr></thead><tbody><tr><td><strong>초기 View 로딩 속도</strong></td><td>CSR에 비해 렌더링 해야하는 파일이 적어 초기 View 로딩 속도가 빠름.</td><td>브라우저에서 페이지를 직접 렌더링해야 하므로 초기에는 오래 걸림.</td></tr><tr><td><strong>SEO</strong></td><td>페이지에 대한 meta 정보가 렌더링시 이미 포함되어 있기 때문에 크롤러봇에서 데이터를 수집해가는데 용이함.</td><td>렌더링시 JS 파싱, 로딩 및 실행 순서 때문에 크롤러봇이 데이터를 수집하는데 어려움이 있음.</td></tr><tr><td><strong>보안 문제</strong></td><td>사용자에 대한 정보를 서버측에서 Session으로 관리</td><td>사용자에 대한 정보를 LocalStorage나 Cookie에서 관리해 XSS 공격에 취약함</td></tr></tbody></table><h4 id="5-정리"><a href="#5-정리" class="headerlink" title="5) 정리"></a>5) 정리</h4><ul><li>SSR 방식의 경우, 초기 로딩속도가 빠르고, SEO 측면에서 유리하지만<ul><li>View 변경시 서버에 계속 새로운 HTML 파일을 요청해야 하므로 서버에 부담이 큼</li></ul></li><li>CSR 방식의 경우, 초기 로딩속도는 느리지만 그 다음 페이지 이동 및 처리에 있어 필요한 데이터만 요청하면 되므로 서버에 부담이 적고, 빠르게 처리할 수 있으나<ul><li>SEO 측면에서 Google 크롤러봇을 제외하곤 Javascript를 실행시키지 못해 데이터 수집하는데 어려움이 있음</li></ul></li></ul><h4 id="6-SPA-SSR"><a href="#6-SPA-SSR" class="headerlink" title="6) SPA + SSR ?"></a>6) SPA + SSR ?</h4><p>일단 서버와 클라이언트가 Node.js 라면 가능하다 (Isomorphic Javascript). 즉, 서버와 클라이언트가 동일한 코드로 동작한다는 의미로, React의 경우 Next.js와 같이 React SSR 라이브러리를 이용해서도 구현할 수 있으며 Vue.js의 경우 Nuxt.js를 이용해 구현할 수 있다.</p><h3 id="7-가비지컬렉터의-역할은-어떻게-동작하나요"><a href="#7-가비지컬렉터의-역할은-어떻게-동작하나요" class="headerlink" title="7. 가비지컬렉터의 역할은? 어떻게 동작하나요?"></a>7. 가비지컬렉터의 역할은? 어떻게 동작하나요?</h3><p>메모리 할당을 추적하고 할당된 메모리 영역이 필요하지 않은 영역일 경우를 판단해서 회수하는 것.<br>자바스크립트에서 변수는 직접적으로 참조 값(문자열, 객체, 배열 등)을 담고 있지 않고, 해당 값을 메모리 상에 저장 된다. 그래서 참조 값을 생성하고나서 더이상 참조할 것이 없거나 비어졌을 때 가비지 컬렉터가 동작해서 메모리가 반환됨.  (메모리를 다시 재사용할 수 있는 상태가 된다)</p><h3 id="8-크로스-브라우징이-무엇인가요"><a href="#8-크로스-브라우징이-무엇인가요" class="headerlink" title="8. 크로스 브라우징이 무엇인가요?"></a>8. 크로스 브라우징이 무엇인가요?</h3><p>크로스 브라우징은 웹 표준에 따라 서로 다른 OS 또는 플랫폼에 대응하는 것을 말한다. 브라우저별 렌더링 엔진이 다른 상황 등 어떠한 상황 속에서도 문제 없이 동작하게 하는 것을 목표로 한다. 프론트엔드 개발자는 여러가지 전략을 세울 수가 있는데, feature detection(기능 탐지)을 사용해서 해당 기능이 해당 브라우저에 있는지를 확인하는 방법을 사용할 수도 있다. 특히 한 쪽 환경에 최적화를 하는 것 보다, 전체적인 웹 표준을 지키는 데에 노력해야 한다.</p><h4 id="1-적용-기능의-지원-브라우저-파악-또는-Tool-사용"><a href="#1-적용-기능의-지원-브라우저-파악-또는-Tool-사용" class="headerlink" title="1) 적용 기능의 지원 브라우저 파악 또는 Tool 사용"></a>1) 적용 기능의 지원 브라우저 파악 또는 Tool 사용</h4><p>caniuse 사이트에서 스펙 조회 또는 크로스 브라우저 테스트 툴 사용 (BrowserStack, lambdaTest, Experitest)</p><h4 id="2-모든-환경에서-지원해야-한다면-라이브러리를-사용하자"><a href="#2-모든-환경에서-지원해야-한다면-라이브러리를-사용하자" class="headerlink" title="2) 모든 환경에서 지원해야 한다면 라이브러리를 사용하자"></a>2) 모든 환경에서 지원해야 한다면 라이브러리를 사용하자</h4><p>대중적인 라이브러리는 호환성 이슈를 해결하기 위한 좋은 전략이다. ( ex) jQuery, underscore.js extJS, <a href="https://github.com/Modernizr/Modernizr/wiki/HTML5-Cross-Browser-Polyfills">HTML5 polypill 라이브러리</a> )</p><h4 id="직접-구현시-‘기능-탐지’를-이용하자-feature-detection"><a href="#직접-구현시-‘기능-탐지’를-이용하자-feature-detection" class="headerlink" title="직접 구현시 ‘기능 탐지’를 이용하자 (feature detection!)"></a>직접 구현시 ‘기능 탐지’를 이용하자 (feature detection!)</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (isIE) &#123;</span><br><span class="line">  attachEvent();</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  addEventListener();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-브라우저-표준에-맞게-스타일-CSS-지원하기"><a href="#3-브라우저-표준에-맞게-스타일-CSS-지원하기" class="headerlink" title="3) 브라우저 표준에 맞게 스타일(CSS) 지원하기"></a>3) 브라우저 표준에 맞게 스타일(CSS) 지원하기</h4><p>Reset CSS 또는 Normalize.css를 사용합니다.</p><p>아직 웹 표준이 안된 CSS 기능을 지원해주기 위해 각 브라우저들의 엔진을 벤더 프리픽스(Vender Prefix) 수동으로 또는 <code>autoprefixer</code>  를 자동으로 추가하자.</p><h4 id="4-Reset-css과-Normalize-css"><a href="#4-Reset-css과-Normalize-css" class="headerlink" title="4) Reset.css과 Normalize.css"></a>4) Reset.css과 Normalize.css</h4><p><code>reset.css</code>는 기본적으로 제공되는 브라우저 스타일 전부를 <strong>제거</strong> 하기 위해 사용된다. <code>reset.css</code>가 적용되면 <code>&lt;H1&gt;~&lt;H6&gt;</code>, <code>&lt;p&gt;</code>, <code>&lt;strong&gt;</code>, <code>&lt;em&gt;</code> 등 과 같은 표준 요소는 완전히 똑같이 보이며 브라우저가 제공하는 기본적인 styling 이 전혀 없다.</p><p><code>normalize.css</code>는 브라우저 간 일관된 스타일링을 목표로 한다. <code>&lt;H1&gt;~&lt;H6&gt;</code>과 같은 요소는 브라우저간에 일관된 방식으로 굵게 표시됩니다. 추가적인 디자인에 필요한 style 만 CSS 로 작성해주면 된다.</p><p>즉, <code>normalize.css</code>는 모든 것을 “해제”하기보다는 <strong>유용한 기본값을 보존하는 것</strong>이다. 예를 들어, sup 또는 sub 와 같은 요소는 <code>normalize.css</code>가 적용된 후 바로 기대하는 스타일을 보여준다. 반면 <code>reset.css</code>를 포함하면 시각적으로 일반 텍스트와 구별 할 수 없다. 또한 normalize.css 는 reset.css 보다 넓은 범위를 가지고 있으며 HTML5 요소의 표시 설정, 양식 요소의 글꼴 상속 부족, pre-font 크기 렌더링 수정, IE9 의 SVG 오버플로 및 iOS 의 버튼 스타일링 버그 등에 대한 이슈를 해결해준다.</p><h3 id="9-우아한-퇴보와-점진적-향상은-무엇인가요"><a href="#9-우아한-퇴보와-점진적-향상은-무엇인가요" class="headerlink" title="9. 우아한 퇴보와 점진적 향상은 무엇인가요"></a>9. 우아한 퇴보와 점진적 향상은 무엇인가요</h3><p><strong>우아한 퇴보</strong> 란 최신 브라우저를 위한 어플리케이션을 구축하는 동시에 그것이 구형 브라우저에서도 계속 작동하도록 하는 구축방법이고,</p><p><strong>점진적 향상</strong> 는 기본 수준의 사용자 환경에 대한 응용 프로그램을 구축하지만 브라우저가 이를 지원할 경우 기능을 강화하는 방법입니다.</p><hr><h2 id="참조"><a href="#참조" class="headerlink" title="참조"></a>참조</h2><ul><li><p><a href="https://velog.io/@ru_bryunak/%EB%A0%8C%EB%8D%94%EB%A7%81%EC%9D%B4%EB%9E%80">HTML 기초 - 3 (렌더링이란?)</a></p></li><li><p><a href="https://velog.io/@josworks27/CORS-%EA%B8%B0%EC%B4%88-%EA%B0%9C%EB%85%90">CORS(Cross-origin Resource Sharing)</a></p></li><li><p><a href="https://velog.io/@nayeon/CORS-%EA%B0%9C%EB%85%90%EA%B3%BC-%EA%B0%84%EB%8B%A8%ED%95%9C-XSS-CSRF-%EC%86%8C%EA%B0%9C">CORS 개념과 간단한 XSS ,CSRF 소개</a></p></li><li><p><a href="https://webclub.tistory.com/458">프레임워크와 라이브러리의 차이점</a></p></li><li><p><a href="https://shoark7.github.io/programming/knowledge/difference-between-process-and-thread">Process와 Thread의 차이</a></p></li><li><p><a href="https://brunch.co.kr/@kd4/3">프로세스와 스레드의 차이</a></p></li><li><p><a href="https://gmlwjd9405.github.io/2018/09/14/process-vs-thread.html">[OS] 프로세스와 스레드의 차이</a></p></li><li><p><a href="https://www.growth-rocket.com/blog/a-closer-look-at-client-side-server-side-rendering/">A Closer Look at Client-Side &amp; Server-Side Rendering</a></p></li><li><p><a href="https://goodgid.github.io/Server-Side-Rendering-and-Client-Side-Rendering/#ssr-vs-csr">서버 사이드 렌더링(SSR)과 클라이언트 사이드 렌더링(CSR)</a></p></li><li><p><a href="https://velog.io/@rjs1197/SSR%EA%B3%BC-CSR%EC%9D%98-%EC%B0%A8%EC%9D%B4%EB%A5%BC-%EC%95%8C%EC%95%84%EB%B3%B4%EC%9E%90">SPA에서의 SSR과 CSR</a></p></li><li><p><a href="https://developers.google.com/web/updates/2019/02/rendering-on-the-web">웹 렌더링</a></p></li><li><p><a href="https://sunnykim91.tistory.com/121">프론트엔드 개발자 면접 질문(기술면접) 정리</a></p></li><li><p><a href="https://yangshun.github.io/front-end-interview-handbook/kr/css-questions#%EA%B8%B0%EB%8A%A5%EC%9D%B4-%EC%A0%9C%ED%95%9C%EB%90%9C-%EB%B8%8C%EB%9D%BC%EC%9A%B0%EC%A0%80%EC%9D%98-%ED%8E%98%EC%9D%B4%EC%A7%80%EB%8A%94-%EC%96%B4%EB%96%BB%EA%B2%8C-%EC%B2%98%EB%A6%AC%ED%95%98%EB%82%98%EC%9A%94-%EC%96%B4%EB%96%A4-%EA%B8%B0%EC%88%A0%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4%EB%A5%BC-%EC%82%AC%EC%9A%A9%ED%95%98%EB%82%98%EC%9A%94">기능이 제한된 브라우저의 페이지는 어떻게 처리하나요? 어떤 기술/프로세스를 사용하나요?</a></p></li><li><p><a href="https://yangshun.github.io/front-end-interview-handbook/kr/css-questions#%EB%B8%8C%EB%9D%BC%EC%9A%B0%EC%A0%80-%EB%B3%84%EB%A1%9C-%EC%8A%A4%ED%83%80%EC%9D%BC%EC%9D%B4-%EB%8B%A4%EB%A5%B8-%EB%AC%B8%EC%A0%9C%EB%A5%BC-%EC%96%B4%EB%96%A4-%EC%A0%91%EA%B7%BC-%EB%B0%A9%EB%B2%95%EC%9C%BC%EB%A1%9C-%ED%95%B4%EA%B2%B0%ED%95%98%EB%82%98%EC%9A%94">브라우저 별로 스타일이 다른 문제를 어떤 접근 방법으로 해결하나요?</a></p></li></ul>]]></content:encoded>
      
      
      <category domain="https://joontae-kim.github.io/categories/Blog/">Blog</category>
      
      <category domain="https://joontae-kim.github.io/categories/Blog/Job/">Job</category>
      
      
      <category domain="https://joontae-kim.github.io/tags/Front-end/">Front-end</category>
      
      <category domain="https://joontae-kim.github.io/tags/Interview/">Interview</category>
      
      <category domain="https://joontae-kim.github.io/tags/Job/">Job</category>
      
      
      <comments>https://joontae-kim.github.io/2020/10/26/interview-question-fe/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>프론트엔드 면접 질문 목록</title>
      <link>https://joontae-kim.github.io/2020/10/26/interview-question-list/</link>
      <guid>https://joontae-kim.github.io/2020/10/26/interview-question-list/</guid>
      <pubDate>Mon, 26 Oct 2020 05:38:17 GMT</pubDate>
      
        
        
      <description>&lt;p&gt;&lt;img src=&quot;/images/job_thumbnail.jpeg&quot; alt=&quot;면접!&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;Interview-Question-Summary&quot;&gt;&lt;a href=&quot;#Interview-Question-Summary&quot; class=&quot;hea</description>
        
      
      
      
      <content:encoded><![CDATA[<p><img src="/images/job_thumbnail.jpeg" alt="면접!"></p><h2 id="Interview-Question-Summary"><a href="#Interview-Question-Summary" class="headerlink" title="Interview Question Summary"></a>Interview Question Summary</h2><h4 id="프론트엔드-면접-준비를-위한-질문-리스트-정리"><a href="#프론트엔드-면접-준비를-위한-질문-리스트-정리" class="headerlink" title="프론트엔드 면접 준비를 위한 질문 리스트 정리!"></a>프론트엔드 면접 준비를 위한 질문 리스트 정리!</h4><p>아래 질문 리스트를 기반으로 면접 질문 &amp; 답변 목록을 작성할 예정이고, 지속적으로 보충 or 보수할 계획입니다.</p><p>업데이트 날짜</p><ul><li>2020-10-26</li><li>2020-10-28<ul><li>FE (Browser) 질문 목록 수정</li><li>Security 항목 추가</li></ul></li></ul><h3 id="FE-Browser"><a href="#FE-Browser" class="headerlink" title="FE (Browser)"></a>FE (Browser)</h3><ul><li>브라우저의 렌더링 과정에 대해서 상세하게 설명해달라</li><li>DOM을 건드리는 방식과 아닌 방식들의 차이</li><li>CORS(Cross-Origin Resource Sharing)는 무엇인가 왜 이러한 방법이 정의 되었으며, 본인이 코드를 작성하면서 CORS와 관련하여서 경험하였던 이슈는 무엇인가</li><li>라이브러리와 프레임워크에 대해서 설명</li><li>프로세스와 스레드의 차이</li><li>CSR과 SSR의 차이</li><li>가비지컬렉터의 역할은? 어떻게 동작하나요?</li><li>크로스 브라우징이란 무엇인가요?</li><li>우아한 퇴보와 점진적 향상은 무엇인가요</li></ul><h3 id="Security"><a href="#Security" class="headerlink" title="Security"></a>Security</h3><ul><li>보안은 서버쪽에서 많이 신경쓰고 있지만, 프론트엔드 개발에서 보안관련 이슈는 어떠한 것들이 있는가</li><li>Wireshark 에 대해 알고 있는가</li><li>HTTP 통신의 문제점에 대해서 아는대로 말해달라</li><li>CORS(Cross-Origin Resource Sharing)는 무엇인가 왜 이러한 방법이 정의 되었으며, 본인이 코드를 작성하면서 CORS와 관련하여서 경험하였던 이슈는 무엇인가</li><li>간단한 데이터를 클라이언트로만 관리 할수 있는가, 이와 관련해서 브라우저 에서 어떠한 것들을 지원하고 있는가, 예를 들면 소셜 로그인같은 것들에 대한 브라우저 종료시 발생하는 문제에 대응 경험이 있는가</li></ul><h3 id="Network"><a href="#Network" class="headerlink" title="Network"></a>Network</h3><ul><li>Http와 Https 통신 방식의 차이?</li><li>웹 프로토콜이란</li><li>CORS(Cross-Origin Resource Sharing)는 무엇인가 왜 이러한 방법이 정의 되었으며, 본인이 코드를 작성하면서 CORS와 관련하여서 경험하였던 이슈는 무엇인가</li><li>RESTful API 가 무엇인가, 아는대로 다 말해달라</li></ul><h3 id="Programming"><a href="#Programming" class="headerlink" title="Programming"></a>Programming</h3><ul><li><p>타입스크립트를 사용해본 경험이 있는가, 타입스크립트에 대한 본인의 생각과 도입시의 장점을 말해달라</p></li><li><p>메소드 체이닝이란 무엇이며, 이것의 장단점은 무엇인가?</p></li><li><p>메모라이제이션이란</p></li><li><p>배포를 해본적이 있는가?</p><ul><li>어떻게 배포를 해보았나</li></ul></li><li><p>쓰로틀링과 디바운스</p></li></ul><h3 id="JS"><a href="#JS" class="headerlink" title="JS"></a>JS</h3><ul><li><p>실행 컨텍스트(Execution Context)에 대해 설명해달라</p></li><li><p>DOM (Document Object Model)</p><ul><li>이벤트 버블링(Event Bubbling), 이벤트 캡쳐링(Event Capturing)에 대해서 설명하세요.</li><li>이벤트 위임(event delegation)에 대해 설명하세요.</li></ul></li><li><p>Javascript Scope Chaining</p></li><li><p>전역 scope를 사용했을 때 장단점에 관해 설명해주세요.</p></li><li><p>이벤트 루프와 동시성 모델에 대해서 설명</p></li><li><p>document load와 DOM Content Loaded의 차이</p><ul><li>document load : DOM을 비롯한 모든 asset이 로드된 후 발생</li><li>DOM Content Loaded : 초기 html 문서가 완전히 로드되고 나면 파싱 후 발생</li></ul></li><li><p>attribute와 property</p><ul><li>attribute : HTML 마크업에서 정의</li><li>property : DOM에서 정의</li></ul></li><li><p>호스트 객체(Host Objects)와 네이티브 객체(Native Objects)의 차이점은 무엇인가요?</p><ul><li>호스트 객체 : 빌트인 또는 네이티브 객체에 포함되지 않은 사용자에 의해 생성된 객체 ⇒ js는 빌트인 및 네이티브 객체 구성 후 호스트 객체를 해석</li><li>네이티브 객체 : 브라우저 혹은 구동 엔진에 내장되어 있는 객체 DOM이 이에 해당 ⇒ 구동앤잔 별 사용성이 달라서 크로스 브라우징 문제를 바랭시키기도 함</li></ul></li><li><p>자바스크립트의 원시 타입(Primitive Data Type)은 몇가지이며, 전부 말해달라</p><ul><li>Number, String, Boolean, Null, Undefined, (Symbol)</li></ul></li><li><p>null vs undefined</p></li><li><p>use strict 은 무엇이고, 사용했을 때 장단점에 관해서 설명해주세요.</p></li><li><p>클로져(Closure)는 무엇이며, </p></li><li><p>자바스크립트의 Number Type은 다른 언어들과 차이점이 무엇인가, 왜 하나만 존재하는가</p></li><li><p>자바스크립트의 순환참조란? 어떤게 문제이고 해결방법은?</p></li><li><p><code>function foo() &#123;&#125;</code> 와 <code>var foo = function() &#123;&#125;</code> 에서 foo 의 차이가 무엇인지 설명해보세요.</p></li><li><p>ES6에서 화살표 함수와 일반 함수의 차이는</p></li><li><p>자바스크립트의 배열(Array)이 실제 자료구조 배열이 아닌데 그 이유는?</p></li><li><p>자바스크립트의 호이스팅(Hoisting)은 어떻게 이루어져 있는가</p></li><li><p>클로저(Closure)란 무엇이며, 어떻게 사용하는지, 왜 이러한 패턴을 사용하는가</p></li><li><p>This</p><ul><li>자바스크립트에서 This는 몇가지로 추론 될수 있는가, 아는대로 말해달라</li><li>일반함수의 this와 화살표 함수의 this는 어떻게 다른가?</li><li>Call, Apply, Bind 함수에 대해 설명해달라</li><li>use strict모드에서의 this?</li></ul></li><li><p>프로토타입이란</p></li><li><p>객체 지향 프로그래밍(Object Oriented Programming)</p><ul><li>OOP에 특징에 대해 설명해달라(상속, 캡슐화 등등…)</li><li>현실에 상황을 예로 들어 OOP의 개념으로 설계과정을 설명해달라<br>ex) 축구를 게임으로 만든다거나, 기타 어떠한 상황이라도 좋다</li><li>프로토타입 상속이 이루어지는 법</li></ul></li><li><p>함수형 프로그래밍(Function Programming)</p><ul><li>함수형 프로그래밍에 대해 설명해달라</li><li>함수형 프로그래밍에 개념에서 순수함수란 무엇인가</li><li>OOP와 함수형 프로그래밍의 가장 큰 차이점은 무엇인가</li></ul></li><li><p>OOP와 함수형 프로그래밍의 차이</p></li><li><p>ES6</p><ul><li>크롬 정도의 브라우저를 제외하곤 ES6 스펙에 대한 지원이 완벽하지 않다. 해결방법은 무엇인가</li><li>Babel이란? babel은 컴파일러 인가 ? 트랜스파일러인가</li><li>ES6 에서 추가된 스펙에 대해 아는대로 다 말해달라</li><li>var 와 let, const의 차이점은 무엇인가 (function scope와 block scope의 개념에서)</li><li>Class 는 무엇이고, Prototype, fucntion의 ES5 스펙만으로 Class를 구현할수 있는가</li></ul></li><li><p>익명함수와 함수 즉시 호출</p></li><li><p>비동기 프로그래밍</p><ul><li>동기 함수와 비동기 함수</li><li>AJAX란 무엇인가</li><li>Callback 함수란</li><li>Promise 함수</li><li>Promise와 Callback의 차이점은 무엇이며 각각의 장단점에 대해 설명해달라</li><li>Promise란 무엇이며 코드가 어떻게 구성되어있는가</li><li>async, await는 무엇이며 Promise의 차이는</li></ul></li><li><p>고차함수 (High-Order Function)</p></li><li><p>JSON이 무엇이며 사용하면 어떠한 장점이 있나요?</p></li><li><p>JSONP의 동작</p><ul><li>크로스 도메인 이슈에 의해 ajax 요청이 허용 되지 않아 우회용으로 많이 쓰임 ⇒ script 태그를 통해 callback 쿼리 매게 변수를 요청함</li></ul></li><li><p>모듈 패턴과 전통적 상속, 각각의 장단점을</p></li><li><p>Call by value &amp; call by ref</p></li><li><p>디자인 패턴</p></li></ul><h3 id="CSS"><a href="#CSS" class="headerlink" title="CSS"></a>CSS</h3><ul><li>CSS cascading system</li><li>CSS 적용 우선순위</li><li>CSS selector 동작원리</li><li>선택자<ul><li>하위 선택자 : 부모요소에 포함딘 모든 하위 요소에 스타일 적용</li><li>자식 선택자 : 부모 바로 아래 자식 요소에만 적용</li></ul></li><li>float</li><li>float 속성 해제 방법</li><li>이미지 대체</li><li>컨텐츠 이미지 숨기기</li><li>inline vs inline-box</li><li>px and em</li><li>inline vs inline block</li><li>Progressive Rendering</li><li>개발사 접두어</li><li>반응형과 적응형 웹</li><li>반응형 웹의 3요소<ul><li>미디어 쿼리, 플루이드 그리드, flexible img</li></ul></li><li>@media속성</li><li>모바일 우선 전략</li><li>w3c box iebox</li><li>Position 요소</li><li>자식 중앙 정렬</li><li><em>And 나머지는 여기서</em> =&gt; <a href="https://yangshun.github.io/front-end-interview-handbook/kr/css-questions">https://yangshun.github.io/front-end-interview-handbook/kr/css-questions</a></li></ul><h3 id="HTML"><a href="#HTML" class="headerlink" title="HTML"></a>HTML</h3><ul><li><p>Doctype</p></li><li><p>표준모드와 쿼크모드</p></li><li><p>다국어 서비스 제공방법</p></li><li><p><a href="https://yangshun.github.io/front-end-interview-handbook/kr/html-questions/#html5%EB%A5%BC-%EA%B0%9C%EB%B0%A9%ED%98%95-%EC%9B%B9-%ED%94%8C%EB%9E%AB%ED%8F%BC%EC%9C%BC%EB%A1%9C-%EA%B0%84%EC%A3%BC%ED%95%A0-%EB%95%8C-html5%EC%9D%98-%EA%B5%AC%EC%84%B1-%EC%9A%94%EC%86%8C%EB%8A%94-%EB%AC%B4%EC%97%87%EC%9D%B8%EA%B0%80%EC%9A%94">HTML5를 개방형 웹 플랫폼으로 간주할 때, HTML5의 구성 요소는 무엇인가요?</a> </p></li><li><p><a href="https://yangshun.github.io/front-end-interview-handbook/kr/html-questions/#script-script-async-script-defer-%EC%82%AC%EC%9D%B4%EC%9D%98-%EC%B0%A8%EC%9D%B4%EC%A0%90%EC%9D%84-%EC%84%A4%EB%AA%85%ED%95%98%EC%84%B8%EC%9A%94"><code>&lt;script async&gt;</code>, <code>&lt;script defer&gt;</code> 사이의 차이점을 설명하세요.</a></p><ul><li>script async : 페이지 파싱과 동시에 비동기적으로 진행</li><li>script defer : html 구문 분석이 끝나면 스크립트 파일 실행</li><li>script : html 파싱 도중 정지하고 실행</li></ul></li><li><p>window 객체란 무엇입니까?</p></li><li><p>DOM</p></li><li><p>블록요소와 인라인요소</p></li><li><p>웹 스토리지</p><ul><li>쿠키, 로컬 스토리지, 세션 스토리지의 정의와 차이점</li></ul></li><li><p>FOUC</p><ul><li>브라우저로 웹 문서에 접근할 때 CSS 스타일이 미적용된 모습이 화면에 노출되며 생기는 깜빡임</li><li>CSS를 <code>&lt;head&gt;</code> 안에 import하고 <code>@import</code> 사용 자제</li><li>FOUC를 보여주는 요소를 js를 통해 숨긴 후 script가 모두 적용된 후 보여줌</li></ul></li><li><p>XML과 HTML</p><ul><li>XML은 웹 브라우저 외에도 포괄적으로 사용되는 형식으로 데이터 교환에 특화되어 있으며 이것 만으론 데이터를 가지고 있을 뿐 화면에 표시되지 않는다. HTML은 웹 브라우저에서 사용하는 문서 형식이며 XHTML은 HTML규격이 가진 문제를 극복하고 확장기능을 제공한다.</li></ul></li><li><p>CSS와 JS 문서의 위치</p><ul><li>CSS를 <head>안에 넣으면 페이지 로딩 중 스타일 적용이 안 된 DOM의 모습을 안보이게 하고 js를 <body> 앞에 놓으면 CSS로딩 직후 로딩 되어 사용자가 조금 빠르다고 느낄 수 있다.</li></ul></li><li><p>기능이 제한된 브라우저 페이지 만들기</p><ul><li>우아한 퇴보, 점진적 향상</li></ul></li><li><p>Single Page Application</p><ul><li>최초 한 번 페이지를 전체 로드한 후 데이터만 변경하여 사용 가능한 어플리케이션<ul><li>클라이언트 사이드 랜더링 : 서버는 JSON 파일만 보내주고 html을 그리는 건 자바스크립트가 담당</li><li>html 다운로드 ⇒ js 다운로드 및 해석 ⇒ Fetch Data</li><li>서버 사이드 랜더링 : html 다운로드 ⇒ 사용자가 봄</li></ul></li></ul></li></ul><h3 id="Vue"><a href="#Vue" class="headerlink" title="Vue"></a>Vue</h3><ul><li>Vue를 선택한 이유</li><li>Vue의 장점</li><li>vue에서의 라이프사이클?</li><li>vue와 React의 차이?</li><li>가상돔 (virtual DOM)</li><li>면접관을 Vue.js 비사용자라고 가정하고 Vue.js에 설명하고 장단점을 말해달라</li><li>Vue.js의 Life-cycle에 대해 아는대로 말해달라</li><li>Vue.js 에서 DOM은 어느 시점에 생성되나</li><li>Computed와 Methods의 차이점은 무엇인가</li><li>가상돔(Virtual DOM) 개념은 무엇이며, DOM과의 차이점 가상돔의 개념이 사용되게된 배경은 무엇인가</li><li>최근의 프레임워크를 사용할때 외부 라이브러리와의 결합시에 더 나은 코드 작성법을 고민해본적이 있는가</li><li>DOM을 직접 조작하는 D3.js 같은 라이브러리와의 결합시에 예상되는 문제점이 있는가</li><li>State 관리</li><li>Vuex 상태 관리 &amp; Redux</li></ul><h3 id="개발외-질문-목록"><a href="#개발외-질문-목록" class="headerlink" title="개발외 질문 목록"></a>개발외 질문 목록</h3><ul><li><p>왜 개발자가 되려고 하는가</p></li><li><p>개발자로서의 본인의 비전을 이야기 해달라</p></li><li><p>비전공자로써 갖고 있는 컴플렉스가 있는가</p></li><li><p>운영체제같은 컴퓨터공학(cs)에 대한 기초지식이 있는가</p></li><li><p>최근에 관심갖거나 공부 하고 싶은 개발 기술은 무엇인가</p></li><li><p>프로젝트 협업 과정을 경험한 적이 있는가</p></li><li><p>공부 방법</p><ul><li>개발자가 되기 위해서 어떻게 공부하였는가</li><li>학습시 주로 이용하는 웹페이지나, 동영상 강좌 페이지는 어디인가</li><li>최근의 읽은 개발 관련 서적은 무엇인가</li><li>즐겨 보는 개발 관련 유튜브가 있는가</li><li>회사 기술 스택에 맞추어 단기간 내에 언어와 프레임워크를 학습 하여야 할 때, 어떻게 공부하고 해결할 것인가</li></ul></li><li><p>포트폴리오 제작시에 비인기 라이브러리를 사용한 경험이 있는가</p></li><li><p>이러한 비인기 라이브러리에 대한 정보를 어디서 얻는가 왜 활용하였는가</p></li></ul><h3 id="FE-개발-환경"><a href="#FE-개발-환경" class="headerlink" title="FE 개발 환경"></a>FE 개발 환경</h3><ul><li>Eslint가 무엇인가요</li><li>Webpack이란</li><li>패키지매니저로 어떤거 사용? npm<ul><li>npm과 yarn은 어떤게 다른가</li></ul></li><li>AMP<ul><li>AMP의 개념은 무엇이고 기존의 것에 비해 장점은 무엇인가</li><li>최근의 프레임워크들과의 조합을 고려해 본적이 있는가 ex) vue-amp..</li></ul></li><li>package.json 파일의 역할</li><li>package.json에서 dependencies와 devDependencies의 차이는</li></ul><h3 id="git"><a href="#git" class="headerlink" title="git"></a>git</h3><ul><li>두 명의 프론트엔드 개발자가 있다 git을 관리하는 방식?</li><li>git pull request rebase 와 다른 방법</li></ul><h3 id="자료구조-Data-Structure-amp-알고리즘"><a href="#자료구조-Data-Structure-amp-알고리즘" class="headerlink" title="자료구조(Data Structure) &amp; 알고리즘"></a>자료구조(Data Structure) &amp; 알고리즘</h3><ul><li>자료구조에 대해 공부한 적이 있는가</li><li>Binary Search Tree 에 대해 알고 있는가, 설명해달라</li><li>Graph 에서 다른 노드를 참조하는 구조를 코드로 구현 할수 있는가</li><li><a href="https://daniel-park.tistory.com/category/Alogorithm?page=1">https://daniel-park.tistory.com/category/Alogorithm?page=1</a></li><li><a href="https://www.educative.io/blog/javascript-data-structures">https://www.educative.io/blog/javascript-data-structures</a></li></ul><hr><h2 id="리스트-관련-링크"><a href="#리스트-관련-링크" class="headerlink" title="리스트 관련 링크"></a>리스트 관련 링크</h2><ul><li><a href="https://velog.io/@honeysuckle/%EC%8B%A0%EC%9E%85-%ED%94%84%EB%A1%A0%ED%8A%B8%EC%97%94%EB%93%9C-%EB%A9%B4%EC%A0%91-%EC%A7%88%EB%AC%B8-%EB%AA%A8%EC%9D%8C">https://velog.io/@honeysuckle/%EC%8B%A0%EC%9E%85-%ED%94%84%EB%A1%A0%ED%8A%B8%EC%97%94%EB%93%9C-%EB%A9%B4%EC%A0%91-%EC%A7%88%EB%AC%B8-%EB%AA%A8%EC%9D%8C</a></li><li><a href="https://mber.tistory.com/2">https://mber.tistory.com/2</a></li><li><a href="https://sunnykim91.tistory.com/121">https://sunnykim91.tistory.com/121</a></li><li><a href="https://devowen.com/283">https://devowen.com/283</a></li><li><a href="https://devowen.com/276">https://devowen.com/276</a></li><li></li></ul><h2 id="인터뷰-관련-링크"><a href="#인터뷰-관련-링크" class="headerlink" title="인터뷰 관련 링크"></a>인터뷰 관련 링크</h2><ul><li>브라우저는 어떻게 동작하는가? <a href="http://d2.naver.com/helloworld/59361">http://d2.naver.com/helloworld/59361</a></li><li>최신 웹사이트와 꼼꼼한 개발자들을 위한 완벽 프론트엔드 체크리스트 <a href="https://github.com/kesuskim/Front-End-Checklist">https://github.com/kesuskim/Front-End-Checklist</a></li><li>예비 개발자들의 기술 면접 준비를 위한 자료 <a href="https://github.com/JaeYeopHan/Interview_Question_for_Beginner">https://github.com/JaeYeopHan/Interview_Question_for_Beginner</a></li><li>프론트엔드 인터뷰 핸드북 <a href="https://github.com/yangshun/front-end-interview-handbook/tree/master/Translations/Korean">https://github.com/yangshun/front-end-interview-handbook/tree/master/Translations/Korean</a></li><li>Awesome Interview Questions <a href="https://github.com/MaximAbramchuck/awesome-interview-questions">https://github.com/MaximAbramchuck/awesome-interview-questions</a></li><li>프론트엔드 면접 문제 은행 <a href="https://github.com/h5bp/Front-end-Developer-Interview-Questions/tree/master/Translations/Korean">https://github.com/h5bp/Front-end-Developer-Interview-Questions/tree/master/Translations/Korean</a></li></ul>]]></content:encoded>
      
      
      <category domain="https://joontae-kim.github.io/categories/Blog/">Blog</category>
      
      <category domain="https://joontae-kim.github.io/categories/Blog/Job/">Job</category>
      
      
      <category domain="https://joontae-kim.github.io/tags/Front-end/">Front-end</category>
      
      <category domain="https://joontae-kim.github.io/tags/Interview/">Interview</category>
      
      <category domain="https://joontae-kim.github.io/tags/Job/">Job</category>
      
      
      <comments>https://joontae-kim.github.io/2020/10/26/interview-question-list/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>Javascript와 객체 지향 프로그래밍</title>
      <link>https://joontae-kim.github.io/2020/10/22/javascript-oop/</link>
      <guid>https://joontae-kim.github.io/2020/10/22/javascript-oop/</guid>
      <pubDate>Wed, 21 Oct 2020 17:03:05 GMT</pubDate>
      
        
        
      <description>&lt;p&gt;&lt;img src=&quot;/images/js_with_oop.png&quot; alt=&quot;Javascript&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;“객체-지향-언어”와-“프로토타입-기반”의-Javascript&quot;&gt;&lt;a href=&quot;#“객체-지향-언어”와-“프로토타입-기반”의-Ja</description>
        
      
      
      
      <content:encoded><![CDATA[<p><img src="/images/js_with_oop.png" alt="Javascript"></p><h2 id="“객체-지향-언어”와-“프로토타입-기반”의-Javascript"><a href="#“객체-지향-언어”와-“프로토타입-기반”의-Javascript" class="headerlink" title="“객체 지향 언어”와 “프로토타입 기반”의 Javascript"></a>“객체 지향 언어”와 “프로토타입 기반”의 Javascript</h2><p>Javascript를 소개할때 가장 먼저 언급되는 키워드로 <strong>“Javascript는 객체 지향 언어로써…”</strong> 또는 <strong>“Javascript는 Prototype 기반 언어로써…”</strong> 라는 말일것이다. 그 어떤 입문서적 또는 온라인 입문 강좌를 둘러봐도 빠지지 않는 말이고 Javascript의 성질을 잘 이해하고 잘 쓰고 있다고 하려면 저 두 가지는 반드시 이해하고 있어야 한다고 많이들 얘기한다. 예전에도 객체 지향과 prototype에 대해 공부했었으니 이번에는 조금이라도 더 낫겠지 싶은 마음으로 다시 자료들을 찾아봤다. 이전에도 공부하면서 참고했던 블로그들을 검색하고 모아놓고, MDN에서도 설명하는 객체 지향과 프로토타입에 관한 포스팅들도 읽고 또 읽었다. 읽고 정리하다보면 차근차근 이해되고, 이해가 되지 않는 부분은 상세히 설명해주시는 개인 블로그와 해외 블로그도 많이 참고했다.</p><h2 id="그래서"><a href="#그래서" class="headerlink" title="그래서?"></a>그래서?</h2><p>읽고, 정리하고, 예제를 살펴보는 몇 번의 과정 끝에 머리속 결론은…</p><p><strong><em>“그래서?”</em></strong> 였다.</p><p>무엇을 말하는지는 이해는 됐다. 좀 더 정확하게 표현하자면, Javascript에서는 객체지향을 어떻게 구현했는지는 <em>피상적인 수준에서</em>  이해가 됐다. Javascript는 객체 지향 언어로써</p><ul><li>Java의 Class와 다르게 Prototype으로 객체 지향 언어를 구현하고 있다는 것을.</li><li>그리고 객체는 현실 세계의 사물을 나타내는데 생성자 함수를 통해 “객체 지향”의 객체를 생성할 수 있으며 생성자 함수 내에 속성(property)과 행동(method)를 지정하면 생성된 객체들은 공통된 속성과 행동을 사용할 수 있으며</li><li>필요에 따라서는 객체의 원형(prototype)에 메서드를 추가하거나 상속을 구현해 확장할 수도 있다는 것을.</li></ul><p>근데 뭔가 확 와닿지 않았다.</p><p>그냥 이해를 하고 넘어가면 될거 같았지만 한번쯤 <strong><em>“왜 객체 지향일까?”</em></strong> 에 대해 deep하게 파보고 싶었다. 일단 검색하기 전에 왜 이해가 안 가는지부터 알아내는 것이 먼저라고 생각했다. </p><h2 id="코드-되새김질과-장애물-발견"><a href="#코드-되새김질과-장애물-발견" class="headerlink" title="코드 되새김질과 장애물 발견"></a>코드 되새김질과 장애물 발견</h2><p>일단 객체 지향적 코드와 익숙한지 점검해보기 위해 이전에 짰던 코드부터 조금씩 되새겨봤다. </p><ol><li>특정 기능을 구현하기 위해서 함수를 만들고</li><li>그 안에 변수와 로직을 설계하고</li><li>로직이 너무 길어지거나 타 함수와 중복되는 로직이 있을 경우 따로 분리해 처리함수를 구현 및 호출하는 구조로 재설계 및 구현하고</li><li>마지막으로 처리된 데이터를 반환(return)</li></ol><p>특정 메소드를 구현하기 위해 위와 같은 플로우로 많이 개발했고 객체 지향 프로그래밍 관점에서 말하는 구조와 다르다는 것까지는 이해했다. 그리고 한가지 궁금한 점이 생겼다. <strong>“객체 지향에서는 그럼 특정 기능에 대한 함수 실행절차는 어떻게 구현되지???”</strong> 바로 이 질문 때문에 이해는 됐지만 겉도는 느낌이 들었던 것이었다. 더 알아보자.</p><h2 id="객체와-절차"><a href="#객체와-절차" class="headerlink" title="객체와 절차"></a>객체와 절차</h2><p><em>(원론적이고 개념적인 내용은 생략하겠습니다.)</em> 구글링을 열심히 한 결과 나와 같은 고민을 한 사람들이 있었고 여러 포스팅에서 공통적으로 언급됐던 링크가 있었고 바로 <a href="https://m.blog.naver.com/atalanta16/220249264429">스파게티코드님의 “객체지향 vs 절차지향??”</a>  였다. <strong>결론부터 말하자면, <em>객체지향적 개발 패러다임이든 절차지향적 개발 패러다임인 방법론적 차이만 있을뿐 둘다 정해진 알고리즘에 따라 순서대로 실행되는건 마찬가지라는 것</em></strong> 이다. 아래는 자판기의 간단한 기능에 대해 두 패러다임을 비교분석한 예제입니다.</p><table><thead><tr><th>기능개발 분석</th><th>알고리즘 분석</th></tr></thead><tbody><tr><td><img src="/images/pcp_oop.png"></td><td><img src="/images/pcp_oop_2.png"></td></tr></tbody></table><p>위 그림에서 볼 수 있듯이 분석과 알고리즘 구현에 있어서 실행 내용은 모두 같으나 처리하고자 하는 방식이 다를뿐이다. <em>스파게티코드님은 블로그에서는 아래와 같이 정리했다.</em></p><ul><li><p>절차지향은 프로그램을 <strong>“기능 중심”으로 구현</strong> 하고, 객체지향은 <strong>“누가 어떤 일을 할 것인가”를 중심으로 구현</strong></p></li><li><p>객제지향은 <em>절차를 ‘간소화’ 해주는 것이지</em> 결코 절차를 무시하는 것이 아니다.</p></li><li><p>객체란 기존의 방식인 변수 따로, 함수 따로의 분산적이고 통일성 없는 실행절차 과정을 <strong>추상화</strong> 과정으로 통합하여 표현대상(문제해결 대상)을 좀 더 <strong>모듈화 또는 캡슐화</strong> 하기 쉽게 도와주는 도구에 불과하며</p></li><li><p>객체지향 프로그래밍은 단지 이러한 객체(데이터)의 디자인을 먼저 한뒤 데이터플로우를 짜고 진행 시나리오를 설계해 나아가는 방식의 개발 방법론일 뿐이다.</p><ul><li>어찌보면 이 모듈성 강화의 부산물인 <strong>은닉화, 상속 및 다형성을 통한 확장성과 재사용성</strong>, 이에 기반한 <em>생산성과 유지보수의 용이성</em>이 OOP의 진정한 특징이자 정체성일지도 모른다.</li></ul></li><li><p><em>플로우차트(절차 지향)를 먼저 하느냐 데이터모델링(객체 지향)을 먼저 하느냐의 차이일뿐</em> 그 이후로는 둘다 정해진 알고리즘에 따라 순서대로 실행되는건 마찬가지.</p><ul><li>다만, OOP 방식에 충실한 프로그래밍은 모듈화가 더 체계적으로 될 수 있다는 것이다.</li></ul></li></ul><p>즉, 두 패러다임 모두 정해진 또는 설계된 알고리즘에 따라 실행되지만 절차지향은 기능을 중심으로 설계되어 알고리즘에 따라 실행되는 것이고, <strong>객체지향의 경우 문제해결 <U>대상(객체)에 초점을 맞추어</U> 각 대상이 해야하는 기능(함수)과 데이터(변수)를 정리하고(추상화와 모듈화) 각 실행 단계에 따라서 필요한 대상을 생성해(객체의 인스턴스화) 특정 행위를 위한 기능과 데이터만을 호출하는 방식</strong>으로 알고리즘에 따라 실행된다는 것이다.</p><h2 id="마치며"><a href="#마치며" class="headerlink" title="마치며"></a>마치며</h2><p>거의 3일 동안 “객체지향…. 객체지향…. 객체지향…. 왜 객체지향일까…”, “뭔 뜻인지는 알겠는데 객체는 그럼 어떻게 함수들을 실행해가는걸까…” 등 뭔가에 가로막힌 느낌을 갖고 객체지향을 공부했었는데 이젠 한결 가벼운 마음과 가까워진 개념으로 조금더 쉽게 공부하고 정리하고 사용할 수 있을거 같다.</p><p>그리고 3일 동안 중간중간 시간도 빠듯한데 괜히 공부하고 외우는 것으로 끝낼까 했는데… 신기하게도 이번 3일이라는 시간동안 봐왔던 <a href="https://m.blog.naver.com/atalanta16/220249264429">스파게티코드님의 “객체지향 vs 절차지향??”</a> 이라는 블로그와 <a href="https://jhnyang.tistory.com/m/322?category=850633">jhnyang님의 “[C/C++] 절차지향언어와 객체지향언어의 관점 차이, 절차지향 프로그래밍과 객체지향 프로그래밍은 무엇일까요 “</a>  그리고 이 외의 여러 블로그를 읽으면서 이해한 객체지향의 의도를 이해한 것이 기술적 문서만 봤을때보다 머리에 훨씬 오래 남고, 굳이 암기하려고 하지 않아도 자연스레 머리에 남는 현상을 느껴 시간은 소비했지만 암기보다 좋은 효과를 느껴 반반의 이득을 얻었다고 정리하고 싶다.</p><h2 id="참고"><a href="#참고" class="headerlink" title="참고"></a>참고</h2><ul><li><a href="https://m.blog.naver.com/atalanta16/220249264429">객체지향 vs 절차지향??</a></li><li><a href="https://jhnyang.tistory.com/m/322?category=850633">jhnyang님의 “[C/C++] 절차지향언어와 객체지향언어의 관점 차이, 절차지향 프로그래밍과 객체지향 프로그래밍은 무엇일까요 “</a></li><li><a href="https://ko.wikipedia.org/wiki/%EB%AA%85%EB%A0%B9%ED%98%95_%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D">명령형 프로그래밍</a></li><li><a href="http://blog.naver.com/hirit808/221457311265">절차지향과 객체지향 언어의 차이, 장단점, 코드 비교, 용도 총정리</a></li><li><a href="http://www.incodom.kr/%EA%B0%9D%EC%B2%B4_%EC%A7%80%ED%96%A5">객체 지향</a></li></ul>]]></content:encoded>
      
      
      <category domain="https://joontae-kim.github.io/categories/Programming/">Programming</category>
      
      <category domain="https://joontae-kim.github.io/categories/Programming/Javascript/">Javascript</category>
      
      
      <category domain="https://joontae-kim.github.io/tags/javascript/">javascript</category>
      
      <category domain="https://joontae-kim.github.io/tags/oop/">oop</category>
      
      <category domain="https://joontae-kim.github.io/tags/prototype/">prototype</category>
      
      <category domain="https://joontae-kim.github.io/tags/object-oriented-javascript/">object-oriented-javascript</category>
      
      
      <comments>https://joontae-kim.github.io/2020/10/22/javascript-oop/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>Javascript 객체(Object) - 기본</title>
      <link>https://joontae-kim.github.io/2020/10/21/js-object/</link>
      <guid>https://joontae-kim.github.io/2020/10/21/js-object/</guid>
      <pubDate>Wed, 21 Oct 2020 04:22:42 GMT</pubDate>
      
        
        
      <description>&lt;p&gt;&lt;img src=&quot;/images/javascript.png&quot; alt=&quot;Javascript&quot;&gt;&lt;/p&gt;
&lt;p&gt; Javascript의 데이터 타입(Data type)에 대해 공부할때 우리는 원시형(Primitives Type 또는 기본형)과 참조형(R</description>
        
      
      
      
      <content:encoded><![CDATA[<p><img src="/images/javascript.png" alt="Javascript"></p><p> Javascript의 데이터 타입(Data type)에 대해 공부할때 우리는 원시형(Primitives Type 또는 기본형)과 참조형(Reference Type) 데이터로 분류할 수 있으며 원시형을 제외한 모든 데이터 유형은 객체라고 정의했었습니다. </p><p>그렇다면 Javascript에서 객체란 무엇이며, Javascript에서의 객체 유형과 내부 속성인 property와 method에 대해서 알아보겠습니다.</p><h2 id="객체-Objects-에-대한-기본정의"><a href="#객체-Objects-에-대한-기본정의" class="headerlink" title="객체(Objects)에 대한 기본정의"></a>객체(Objects)에 대한 기본정의</h2><p>Javascript에서 객체란 <strong>Pass by Reference</strong> 분류되는 데이터 타입으로써 메모리상의 식별자(Indentifier)을 통해 참조된다. 또한 <code>&#123;key: value&#125;</code> 와 같은 키와 값이 매핑된 복합적 형태의 데이터 구조로 키는 문자열이고 값은 원시값 또는 다시 객체가 할당될 수도 있다.</p><h2 id="Javascript-의-객체-구성요소"><a href="#Javascript-의-객체-구성요소" class="headerlink" title="Javascript 의 객체 구성요소"></a>Javascript 의 객체 구성요소</h2><p> Javascript의 표준인 ECMAScript에서는 Object에 대해 크게 3가지로 분류하고 있습니다.</p><ol><li>Built-In Object</li><li>Native Object</li><li>Host Object</li></ol><h4 id="Built-In-Object-내장-객체"><a href="#Built-In-Object-내장-객체" class="headerlink" title="Built-In Object (내장 객체)"></a>Built-In Object (내장 객체)</h4><p><code>Built-In 객체</code> 에는 <strong>Javascript 엔진이 구동되는 시점에서 즉시 제공</strong> 되는 객체로써 <code>Global, Object, String, Number, Boolean, Date, Array, Math, RegExp, Error</code> 가 있다.</p><p>위 객체들은  전역 객체(Global Object), 래퍼 객체(Wrapper Object), 표준 객체 (Standard Object)로 구성되어 있으며 <strong>래퍼 객체(Wrapper Object)</strong> 는 원시 타입의 프로퍼티에 접근하려고 할때 생성되는 임시 객체를 말하고, <strong>표준 객체 (Standard Object)</strong> 는 다른 객체의 기초가 되는 핵심 객체로서 자주 사용되는 객체로는 <code>Number</code> , <code>Math</code> , <code>Date</code> , <code>String</code> , <code>Array</code> 가 있다.</p><h4 id="Native-Object-브라우저-내장-객체"><a href="#Native-Object-브라우저-내장-객체" class="headerlink" title="Native Object (브라우저 내장 객체)"></a>Native Object (브라우저 내장 객체)</h4><p>내장 객체와 똑같이 Javascript 엔진이 구동되는 시점에서 즉시 제공되는 객체이며 내장 객체이지만, 차이점은 <strong>브라우저마다 구성을 다르기 때문에</strong> 내장객체와 다르다고 한다. 브라우저 내장 객체로는 <code>BOM(Browser Object Model)</code> 과 <code>DOM(Document Object Model)</code> 가 있다.</p><h4 id="Host-Object-사용자-정의-객체"><a href="#Host-Object-사용자-정의-객체" class="headerlink" title="Host Object (사용자 정의 객체)"></a>Host Object (사용자 정의 객체)</h4><p><code>Host 객체</code> 는 말 그대로 <code>Host === 사용자</code> 가 생성한 객체로, <code>constructor </code>  혹은 <code>Object Literal(객체 리터럴)</code> 방식을 사용자(혹은 개발자)가 정의하고 확장한 것으로 <code>Built-In 객체</code> 와 <code>Native Object(브라우저 내장 객체)</code> 가 생성된 이후에 구성된다.</p><p>이번에 우리가 다루게 될 객체는  <strong>Built-In 객체</strong> 이자 <strong>최상위 레벨의 객체(Top-Level-Object)</strong> 인  <code>Object</code>  객체 입니다.  </p><h2 id="객체-참조-프로퍼티와-메소드"><a href="#객체-참조-프로퍼티와-메소드" class="headerlink" title="객체 참조 - 프로퍼티와 메소드"></a>객체 참조 - 프로퍼티와 메소드</h2><p>우리는 객체 리터럴 방식으로 생성한 <code>person</code> 이라는 객체 하나를 가지고 있다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">  last: <span class="string">&#x27;James&#x27;</span>,</span><br><span class="line">  first: <span class="string">&#x27;Bond&#x27;</span>,</span><br><span class="line">  getLastName () &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.last;</span><br><span class="line">  &#125;,</span><br><span class="line">  getFirstName () &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.first</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>위 <code>person</code> 객체의 <code>last</code> 프로퍼티에 접근해 값을 얻고자 한다면 우리가 사용할 수 있는 방법은 두가지이다. 아래 코드를 보자.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 점(.) 표기법</span></span><br><span class="line">person.last <span class="comment">// &#x27;James&#x27;</span></span><br><span class="line">person.getLastName() <span class="comment">// &#x27;James&#x27; (메소드 호출)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 대괄호 표기법</span></span><br><span class="line">person[<span class="string">&#x27;last&#x27;</span>] <span class="comment">// &#x27;James&#x27;</span></span><br></pre></td></tr></table></figure><p>객체 이름(person)은 <strong>네임스페이스</strong> 처럼 동작하며 객체 내에 <strong>캡슐화</strong> 된 프로퍼티에 접근하기 위해서 점 표기법과 대괄호 표기법 둘다 사용 가능하며 메서드에 접근하기 위해서는 점 표기법을 사용하면 된다.</p><p>한가지 흥미로운 점은 Javascript에서 Array 요소 접근법인 대괄호 표기법이 객체에서도 사용되는 것인데   배열의 각 요소를 인덱스 숫자로 매핑하는 것과 유사하게 객체는 각 프로터피를 <code>&#123;key: value&#125;</code> 구조로 매핑하며 따라서 객체에서도 한 프로퍼티에 접근하기 위해 대괄호 표현법에서 프로퍼티의 key를 사용할 수 있는 것입니다. 이러한 점 때문에  객체가 간혹 <strong>연관배열 (associative arrays)</strong> 이라고 불리며 배열이 숫자를 값에 연결하는 것과 같은 방법으로 스트링을 값에 매핑합니다.</p><h2 id="객체-생성자"><a href="#객체-생성자" class="headerlink" title="객체 생성자"></a>객체 생성자</h2><p>우리는 Javascript 코드로 크고 작은 기능들을 개발하면서 수 많은 객체를 생성하게 된다. 이 객체들은 <strong>Built-In 객체</strong> 인  <code>Object 객체</code> 의 <code>인스턴스(instance)</code> 입니다. 그럼 객체를 생성하는 방법으로는 위에서 사용하는 리터럴 방식 외에는 무엇이 있을까?</p><h4 id="리터럴-표기법을-통한-객체-생성"><a href="#리터럴-표기법을-통한-객체-생성" class="headerlink" title="리터럴 표기법을 통한 객체 생성"></a>리터럴 표기법을 통한 객체 생성</h4><p>Javascript에서 객체를 생성하기 위한 가장 일반적이고 쉬운 방법으로 프로퍼티와 메소드를 직관적으로 설정할 수 있다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> cat = &#123;</span><br><span class="line">  name: <span class="string">&#x27;나비&#x27;</span>,</span><br><span class="line">  age: <span class="number">3</span>,</span><br><span class="line">  family: <span class="string">&#x27;korean Short Hair&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="생성자-함수-Constructor-function-을-통한-객체-생성"><a href="#생성자-함수-Constructor-function-을-통한-객체-생성" class="headerlink" title="생성자 함수 (Constructor function)을 통한 객체 생성"></a>생성자 함수 (Constructor function)을 통한 객체 생성</h4><p>Javascript에서는 new 연산자를 사용하여 객체를 생성하고 초기화할 수 있는데 이때 사용되는 메소드를 <code>생성자(constructor)</code> 라고 하며, 이 메소드는 새롭게 생성되는 객체를 초기화하는 역할을 합니다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">// Cat에 관한 생성자 함수</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Cat</span> (<span class="params">name, age, family</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.name = name;      <span class="comment">// name에 관한 프로퍼티</span></span><br><span class="line">  <span class="built_in">this</span>.age = age;        <span class="comment">// age에 관한 프로퍼티</span></span><br><span class="line">  <span class="built_in">this</span>.family = family;  <span class="comment">// family에 관한 프로퍼티</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// cat 객체는 Cat라는 프로토타입을 갖게 된다.</span></span><br><span class="line"><span class="keyword">var</span> cat = <span class="keyword">new</span> Cat(<span class="string">&#x27;나비&#x27;</span>, <span class="number">3</span>, <span class="string">&#x27;korean Short Hair&#x27;</span>)</span><br></pre></td></tr></table></figure><h4 id="Object-Create-메소드를-통한-객체-생성"><a href="#Object-Create-메소드를-통한-객체-생성" class="headerlink" title="Object Create() 메소드를 통한 객체 생성"></a>Object Create() 메소드를 통한 객체 생성</h4><p>Object.create() 메소드는 지정된 프로토타입(prototype) 객체와 프로퍼티를 가지는 새로운 객체를 생성할 수 있으며 사용자가 프로토타입 객체를 직접 명시할 수 있다는 특징이 있다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> cat = <span class="built_in">Object</span>.create(<span class="literal">null</span>, &#123;</span><br><span class="line">  name: <span class="string">&#x27;나비&#x27;</span>,</span><br><span class="line">  age: <span class="number">3</span>,</span><br><span class="line">  family: <span class="string">&#x27;korean Short Hair&#x27;</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="프로퍼티와-메소드-그리고-this"><a href="#프로퍼티와-메소드-그리고-this" class="headerlink" title="프로퍼티와 메소드 그리고 this"></a>프로퍼티와 메소드 그리고 this</h2><p>아래의 <code>person</code> 객체를 보자. 코드를 훓어보면 대략 사람의 이름이 설정되어 있는것으로 추측할 수 있으며 그 속성을 반환(return) 하는 함수들이 있다는 정도로 추측 또는 알 수 있다. 바로 사람의 이름과 같은 속성을 <strong>프로퍼티(property)</strong> , 속성을 반환(return) 하는 함수를 <strong>메소드(method)</strong> 라고 한다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">  last: <span class="string">&#x27;James&#x27;</span>,</span><br><span class="line">  first: <span class="string">&#x27;Bond&#x27;</span>,</span><br><span class="line">  getLastName () &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.last;</span><br><span class="line">  &#125;,</span><br><span class="line">  getFirstName () &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.first</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="프로퍼티-Property"><a href="#프로퍼티-Property" class="headerlink" title="프로퍼티 (Property)"></a>프로퍼티 (Property)</h4><p>프로퍼티란 객체에 붙은 변수(Variable) 로써 프로퍼티가 객체의 속성을 규정한다고 할 수 있다. 프로퍼티와 변수는 기본적으로 똑같으며 프로퍼티의 이름은 <em>대소문자를 구별</em> 하며 객체 이름 또한 해당되며 Javascript의 문자열 또는 문자열로 변환 가능한 어떤 것도 가능하나 빈 문자열(<code>&#39;&#39;</code>)의 경우 가능은 하나 Javascript의 식별자(Indentifier)로써 적합하지 않다(<code>-</code> , <code>&#39;&#39;</code>, 숫자로 시작하는 이름도 해당).</p><h4 id="메소드-Method"><a href="#메소드-Method" class="headerlink" title="메소드 (Method)"></a>메소드 (Method)</h4><p>메소드란 객체의 프로퍼티 중 함수인 것으로 일반 함수와 같은 방식으로 정의할 수 있다. ECMAScript 6 부터 더 짧은 구문으로 메서드를 정의할 수 있게 됐다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  foo: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;,</span><br><span class="line">  bar: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  foo() &#123;&#125;,</span><br><span class="line">  bar() &#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>주의할 점</strong> 은 단축 구문은 기명(named) 함수로 정의해야한다. 왜냐하면 메모리에서 함수를 참조하기 위한 식별자(Identifier)가 생기기 때문입니다.</p><h4 id="this"><a href="#this" class="headerlink" title="this"></a>this</h4><p>Javascript에서 <code>this</code> 는 함수가 실행될 때 this가 호출되고 있는 함수 또는 객체의 스코프를 가리키는 키워드로써, 객체 메서드 내부의 <code>this </code> 는 객체를 가리킨다. 본 섹션의 <code>person</code> 객체의 메서드에서 호출하고 있는 <code>this</code> 키워드가 그 예이다.</p><h2 id="getter-와-setter-메소드"><a href="#getter-와-setter-메소드" class="headerlink" title="getter 와 setter 메소드"></a>getter 와 setter 메소드</h2><p><strong>getter 메소드</strong> 는 특정 프로퍼티의 값을 받아오기 위한 메소드이자 <em>접근자 프로퍼티</em> 이며 <strong>setter 메소드</strong> 는 특정 프로퍼티의 값을 설정하기 위한 메소드로 ECMAScript 5 에 정의되었다.</p><h4 id="getter-메소드"><a href="#getter-메소드" class="headerlink" title="getter 메소드"></a>getter 메소드</h4><p><strong><code>get</code></strong> 구문은 어떤 프로퍼티에 접근할 때마다 해당 프로퍼티의 값을 계산해 반환하거나 내부 변수의 상태를 명시적인 함수 호출없이 보여주고 싶을때 사용할 수 있다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="keyword">get</span> <span class="title">prop</span>() &#123; ... &#125; &#125;</span><br><span class="line">&#123;get [expression]() &#123; ... &#125; &#125;</span><br></pre></td></tr></table></figure><p>위 구문에서 <code>prop</code> 은 주어진 함수를 바인딩할 프로퍼티의 이름이고, <code>[expression]</code> 은 ES6부터 함수의 이름을 <em>계산(computed)</em> 하기 위한 표현식을 사용할 수 있다. <code>get</code> 구문을 이용할 떄는 다음을 유의해야 한다.</p><ul><li>숫자나 문자열로 구성된 식별자를 이용할 수 있습니다.</li><li>getter는 절대로 매개변수를 가져서는 안 됩니다. (<a href="http://whereswalden.com/2010/08/22/incompatible-es5-change-literal-getter-and-setter-functions-must-now-have-exactly-zero-or-one-arguments/">Incompatible ES5 change: literal getter and setter functions must now have exactly zero or one arguments</a> 를 참조하세요.)</li><li>하나의 객체 리터럴에 또다른 getter나 데이터 바인딩은 불가능합니다. (<code>&#123; get x() &#123; &#125;, get x() &#123; &#125; &#125;</code> 나 <code>&#123; x: ..., get x() &#123; &#125; &#125;</code> 는 사용할 수 없습니다.)</li><li>getter는 <code>delete</code> 연산자를 이용해 삭제할 수 있습니다.</li></ul><p>기본적인 사용법은 아래와 같다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  log: [<span class="string">&#x27;example&#x27;</span>,<span class="string">&#x27;test&#x27;</span>],</span><br><span class="line">  <span class="keyword">get</span> <span class="title">latest</span>() &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.log.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">undefined</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.log[<span class="built_in">this</span>.log.length - <span class="number">1</span>];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(obj.latest); <span class="comment">// &quot;test&quot;</span></span><br></pre></td></tr></table></figure><h4 id="setter-메소드"><a href="#setter-메소드" class="headerlink" title="setter 메소드"></a>setter 메소드</h4><p><code>set</code> 구문은 특정 프로퍼티의 값을 변경하기 위해 함수를 실행하기 위해 사용한다. </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="keyword">set</span> <span class="title">prop</span>(<span class="params">val</span>) &#123; . . . &#125;&#125;</span><br><span class="line">&#123;set [expression](val) &#123; . . . &#125;&#125;</span><br></pre></td></tr></table></figure><p>위 구문에서 <code>prop</code> 은 주어진 함수를 바인딩할 프로퍼티의 이름이고, <code>val</code> 은 prop에 설정될 값을 가지고 있는 변수명이다. <code>[expression]</code> 은 ES6 부터 추가된 세부 문법으로 주어진 함수에 바인딩 되는 프로퍼티의 이름을 <em>계산(computed)</em> 을 통해 얻을 수 있다.</p><p>그리고 주의할 점은 실제 값을 가지는 프로퍼티와 프로퍼티의 <code>setter</code> 를 동시에 갖는 것은 불가능하다. 왜냐하면 Setter는 유사 객체(pseudo property) 타입을 생성하는 메소드이기 때문이며 getter 또한 동일하다. <code>set</code> 문법을 사용할 때 다음을 유의한다:</p><ul><li>숫자혹은 문자로된 식별자를 가질 수 있다;</li><li>한 개의 파라메터만 가질 수 있다.(더 자세한 정보는 <a href="http://whereswalden.com/2010/08/22/incompatible-es5-change-literal-getter-and-setter-functions-must-now-have-exactly-zero-or-one-arguments/">Incompatible ES5 change: literal getter and setter functions must now have exactly zero or one arguments</a>를 본다);</li><li>오브젝트 리터럴에 동일한 property에 대한 다른 <code>set</code> 이나 데이터 항목이 올 수 없다.<br>( <code>&#123; set x(v) &#123; &#125;, set x(v) &#123; &#125; &#125;</code> 그리고 <code>&#123; x: ..., set x(v) &#123; &#125; &#125;</code> 는 허용되지 않는다.)</li><li>setter는  <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/delete"><code>delete</code></a> operator를 사용하여 제거할 수 있다.</li></ul><p>기본 사용법은 아래와 같다. </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> cat = &#123;</span><br><span class="line">  set currentSnack (snack) &#123;</span><br><span class="line">    <span class="built_in">this</span>.snacks[<span class="built_in">this</span>.snacks.length] = snack;</span><br><span class="line">  &#125;,</span><br><span class="line">  snacks: []</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">cat.currentSnack = <span class="string">&#x27;달고나&#x27;</span> <span class="comment">// 달고나</span></span><br><span class="line">cat.snacks <span class="comment">// [&#x27;달고나&#x27;]</span></span><br><span class="line">cat.currentSnack = <span class="string">&#x27;커피&#x27;</span> <span class="comment">// 커피</span></span><br><span class="line">cat.snacks <span class="comment">// [&#x27;달고나&#x27;, &#x27;커피&#x27;]</span></span><br><span class="line">cat.currentSnack <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure><p><code>cat</code> 객체의 유사 객체(pseudo property)로 <code>currentSnack</code> 이 정의되었으며 이 프로퍼티의 매개변수인 <code>snack</code> 이 설정될 때마다 <code>snacks</code> 프로퍼티의 값이 갱신된다.</p><hr><h2 id="참조"><a href="#참조" class="headerlink" title="참조"></a>참조</h2><ul><li><a href="https://developer.mozilla.org/ko/docs/Learn/JavaScript/Objects/Basics">Javascript 객체 기본 - https://developer.mozilla.org</a></li><li><a href="http://insanehong.kr/post/javascript-object/">javascript 기초 - Object 이해하기 - http://insanehong.kr</a></li><li><a href="https://developer.mozilla.org/ko/docs/Web/JavaScript/Guide/Working_with_Objects">Working with objects - https://developer.mozilla.org</a></li><li><a href="https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Functions/set">setter - https://developer.mozilla.org</a></li><li><a href="https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Functions/get">getter - https://developer.mozilla.org</a></li><li><a href="http://tcpschool.com/javascript/js_object_create">객체의 생성 - http://tcpschool.com</a></li><li><a href="http://tcpschool.com/javascript/js_object_concept">객체의 개념 - http://tcpschool.com</a></li><li><a href="https://tutorialpost.apptilus.com/code/posts/js/js30-object/">Javascript 객체(Object)</a></li></ul>]]></content:encoded>
      
      
      <category domain="https://joontae-kim.github.io/categories/Programming/">Programming</category>
      
      <category domain="https://joontae-kim.github.io/categories/Programming/Javascript/">Javascript</category>
      
      
      <category domain="https://joontae-kim.github.io/tags/javascript/">javascript</category>
      
      <category domain="https://joontae-kim.github.io/tags/Object/">Object</category>
      
      
      <comments>https://joontae-kim.github.io/2020/10/21/js-object/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>함수 (function)</title>
      <link>https://joontae-kim.github.io/2020/10/20/js-function/</link>
      <guid>https://joontae-kim.github.io/2020/10/20/js-function/</guid>
      <pubDate>Tue, 20 Oct 2020 09:21:06 GMT</pubDate>
      
        
        
      <description>&lt;p&gt;&lt;img src=&quot;/images/javascript.png&quot; alt=&quot;Javascript&quot;&gt;&lt;/p&gt;
&lt;p&gt;기본적으로 함수란 특정 기능을 구현한 집합체, 특정 문제 또는 필요로 하는 요구사항를 해결하기 위해 수행하는 코드의 묶음 또는 블록으로,  </description>
        
      
      
      
      <content:encoded><![CDATA[<p><img src="/images/javascript.png" alt="Javascript"></p><p>기본적으로 함수란 특정 기능을 구현한 집합체, 특정 문제 또는 필요로 하는 요구사항를 해결하기 위해 수행하는 코드의 묶음 또는 블록으로,  Javascript에서 함수는 한번 구현해놓으면 재호출해 코드의 재사용성을 높일 수 있으며 함수 내 특정 변수를 숨기기 위한 캡슐화와 기능을 세분화해 코드의 유지보수의 용이성과 확장성을 높힐 수 있습니다.</p><p> Javascript 함수(Function)의 구조는 아래와 같이 구성되어 있습니다. </p><ul><li><strong>함수명(function name)</strong></li><li>함수블록 내에서 처리하기 위해 전달되는 <strong>매개변수들(Parameter)과 인자(Argument)</strong></li><li>함수의 기능을 구현하기 위한 <strong>몸체(function body) 또는 구문(statement)</strong></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 함수 정의</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">name</span>(<span class="params">para, meter</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// statement</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 함수 호출</span></span><br><span class="line">name(<span class="string">&#x27;argue&#x27;</span>, <span class="string">&#x27;ment&#x27;</span>)</span><br></pre></td></tr></table></figure><p>Javascript에서 함수(Function)은 원시값과 객체 데이터 타입 중 객체(Object)에 속하는 타입으로, 특히 Javascript의 함수는 <strong>일급 객체(First-class object)</strong> 로써 동적 생성과 리터럴 방식으로 함수를 생성할 수 있으며 변수(Variable), 배열(Array) 내 요소, 객체의 프로퍼티(Property) 등에 할당 가능하다는 특징을 가지고 있습니다.</p><h2 id="함수-정의하기"><a href="#함수-정의하기" class="headerlink" title="함수 정의하기"></a>함수 정의하기</h2><p>Javascript에서 함수를 정의하기 위한 방법으로는 여러가지가 있으며 대표적으로는 함수 선언문(Declarations), 표현식(expressions) 그리고 ECMAScript 6에서 추가된 화살표 함수(Arrow function)이 있다.</p><p><strong>비고 :</strong>  <code>Function</code> 생성자(constructor)로 함수를 정의하는 것은 JS 엔진 최적화를 방해 또는 기타 다른 문제를 유발할 수 있는 이유로 권장되지 않는 방식입니다.</p><h4 id="함수-선언문-Declarations"><a href="#함수-선언문-Declarations" class="headerlink" title="함수 선언문(Declarations)"></a>함수 선언문(Declarations)</h4><p>Javascript에서 함수를 정의하기 위해 사용되는 가장 대표적인 방법으로, 서두에서 언급한 함수 구조를 띄고 있다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 함수 정의</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">decFunction</span>(<span class="params">para, meter</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> para + meter</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 함수 호출</span></span><br><span class="line">decFunction(<span class="string">&#x27;argu&#x27;</span>, <span class="string">&#x27;ment&#x27;</span>) <span class="comment">// &#x27;argument&#x27;</span></span><br></pre></td></tr></table></figure><ul><li><strong>함수명 :</strong> 함수 또는 구현된 기능을 대표하기 위한 함수의 이름으로 일반적 함수 호출, 재귀적 호출 그리고 실행 컨텍스트에서 memory 상에 함수를 올리기 위한 식별자(Identifier)의 목적으로 함수 선언문에서는 생략할 수 없는 필수요소이다.</li><li><strong>매개변수 :</strong> 함수 등에서 사용되는 전달된 값을 받는 변수로써, 함수의 기능상 외부 환경에서 데이터를 받아 가공 및 반환이 필요할 경우 함수 내부로 전달하는 역할을 하며 <code>콤마(,)</code> 로 구분하여 최대 255개까지 받을 수 있습니다.</li><li><strong>함수 구문 :</strong> 함수의 로직을 담당하는 부분으로 <code>중괄호 &#123;&#125;</code> 안에 매개변수를 받아 데이터를 처리하거나 DOM을 조작하는 등 필요에 따른 특정 기능을 담고 있는 중추적 부분입니다.</li><li>인자: 함수에 전달되는 인수의 배열집합으로써, 정확히는 유사배열 객체로 <code>arguments</code> 객체라 칭하며 매개변수를 통해 전달받은 함수 외부환경의 값, 변수 또는 참조</li><li>반환값 : 함수 내부에서 처리된 값으로 <code>return</code> 키워드를 통해 처리된 값을 반환할 수 있다. 또한 함수의 코드상 종료시점에 <code>return</code>  구문이 없다면 함수는 <code>undefined</code>  를 반환하도록 Javascript에서는 설계되어 있다.</li></ul><h4 id="함수-표현식-expressions"><a href="#함수-표현식-expressions" class="headerlink" title="함수 표현식(expressions)"></a>함수 표현식(expressions)</h4><p>함수 선언문(Declarations)과 다르게 함수를 변수에 할당한다는 점이 다른 점으로 함수의 <strong>일급 객체(First-Class Object)</strong> 의 특성을 이용한 함수식이다.</p><p>구조적 요소는 함수 표현식과 같으나 코드상 구조는 변수에 할당한다는 점이 다르다. 아래를 보자.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Anonymous function expression (익명 함수 표현)</span></span><br><span class="line"><span class="keyword">var</span> expFunction = <span class="function"><span class="keyword">function</span> (<span class="params">para, meter</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> para + meter</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Named function expression (기명 함수 표현)</span></span><br><span class="line"><span class="keyword">var</span> expNamedFunction = <span class="function"><span class="keyword">function</span> <span class="title">namedFunction</span> (<span class="params">para, meter</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> para + meter</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(expFunction(<span class="string">&#x27;argu&#x27;</span>, <span class="string">&#x27;ment&#x27;</span>)); <span class="comment">// &#x27;argument&#x27;</span></span><br><span class="line"><span class="built_in">console</span>.log(expNamedFunction(<span class="string">&#x27;argu&#x27;</span>, <span class="string">&#x27;ment&#x27;</span>)); <span class="comment">// &#x27;argument&#x27;</span></span><br><span class="line"><span class="built_in">console</span>.log(namedFunction(<span class="string">&#x27;argu&#x27;</span>, <span class="string">&#x27;ment&#x27;</span>)); <span class="comment">// Uncaught ReferenceError: expNamedFunction is not defined</span></span><br></pre></td></tr></table></figure><p>함수 표현식은 함수명을 생략하는 익명 함수 방식의 선언이 일반적이지만 기명 함수 표현으로 생성했을 경우, 스택 트레이스에 함수 이름이 포함되어 <em>오류의 원인을 쉽게 찾을 수 있다는 이점</em> 이 있습니다.</p><p>그리고 함수를 할당 받은 변수는 기명 함수라고 할지라도 함수명을 저장하는 것이 아니라 기명이든 익명이든 함수의 참조값을 저장하게 된다.</p><p><strong>위 두개의 함수 정의문은 모두 <em>함수 리터럴 방식</em> 의 함수생성법으로 결국 Function Contstructor 함수로 함수 정의 방식을 단축화한 것으로 *일종의 축약법(short-way)*이라고 할 수 있다.</strong></p><h2 id="클로저"><a href="#클로저" class="headerlink" title="클로저"></a>클로저</h2><p><em>(Javascript의 클로저 개념은 다룰게 많기때문에 여기서는 함수와 클로저의 관계와 중심적 내용만 다루고 넘어가겠습니다. 자세한 내용은 포스팅할 예정입니다.)</em></p><p>Javascript의 함수를 언급할때 빠지지 않는 것이 있다면 바로 <strong>Closure</strong> 일 것이다. <strong>Closer</strong> 란 무엇인지 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Closures">MDN에서 정의한 Closure</a> 에 대한 내용을 보자.</p><blockquote><p>A <strong>closure</strong> is the combination of a function bundled together (enclosed) with references to its surrounding state (the <strong>lexical environment</strong>). In other words, a closure gives you access to an outer function’s scope from an inner function. In JavaScript, closures are created every time a function is created, at function creation time.</p><hr><p><strong>closure</strong> 는 주변 상태에 대한 참조와 함께 번들로 묶인 (포함된) 함수의 조합입니다. (<strong>lexical environment</strong>). 다른 말로, 클로저는 내부 함수에게 외부 변수의 스코프에 접근할 수 있도록 해주는 것이다. Javascript에서 클로저는 함수가 생성될 때마다 생성된다. </p></blockquote><p>이전에 포스팅한 <a href="https://joontae-kim.github.io/2020/10/12/excution-context/">자바스크립트 실행 컨텍스트(Execution Context)</a> 에 대해 알고 있다면 대략 무슨 뜻인지 이해할 수 있다. 즉, <strong>함수와 함수의 참조 환경인 Lexical Environment의 조합으로 구성된 함수</strong>로써 자식함수가 부모함수의 Scope를 <strong>Outer Lexical Environment</strong> 로 참조(Reference)함으로써 Closer의 장점인 <strong>은닉화, 캡슐화</strong> 등의 장점을 통해 <strong>Public/Private 메서드</strong> 를 흉내낼 수 있다.</p><p>이해를 돕기 위해 예제를 보자.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isUnder30</span> (<span class="params">age</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> min = <span class="number">30</span>;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">checkAge</span> (<span class="params">age</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> age &lt; min;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> checkAge(age)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">isUnder30(<span class="number">29</span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>위 예제는 중첩 함수로써, 위에서 말한 클로저의 정의와 환경에 충족하고 있다. 실행 환경을 분석해보자.</p><ol><li>실행 컨텍스트 스택에 전역 실행 컨텍스트 push</li><li><strong>isUnder30</strong> 가 호출 및 실행되면서 isUnder30 함수의 실행 컨텍스트가 push<ol><li>Lexical Environment에 변수 min, 내부함수 checkAge 그리고 Outer Lexical Environment로써 전역 실행 컨텍스트가 정의 및 참조되고</li><li>외부함수로 정의 가능한 isUnder30 함수가 checkAge 함수를 return 하면서 </li><li>checkAge 함수를 호출하고 isUnder30 함수의 함수 실행 컨텍스트는 종료된다.</li></ol></li><li>그리고 내부함수인 <strong>checkAge</strong> 가 호출 및 실행되면서 checkAge 함수의 함수 실행 컨텍스트가 push<ol><li>Lexical Environment에 변수 min, 인자 age 그리고 Outer Lexical Environment로써 isUnder30 함수 실행 컨텍스트가 정의 및 참조되고</li><li>실행되는 동안 min 변수 값을 내부 스코프에서 검색하지 못함으로써 Outer Lexical Environment에서 검색해서 값을 가지고 와서</li><li><code>return age &lt; min;</code> 결과값을 반환(return) 하면서</li><li>checkAge 함수의 실행 컨텍스트 또한 종료된다.</li></ol></li></ol><p>위 순서를 보면 checkAge 가 isUnder30 보다 오래 유지되었고, checkAge가 실행되는 동안 isUnder30의 지역 스코프을 참조해 값을 반환하고 종료되었다. 이처럼 내부함수가 외부함수보다 오래 유지되었고, 내부함수가 외부함수의 지역 스코프(=Outer Lexical Environment)를 참조 및 접근할 수 있는 함수를 **클로저(Closure)**라고 한다.</p><h2 id="함수-호이스팅"><a href="#함수-호이스팅" class="headerlink" title="함수 호이스팅"></a>함수 호이스팅</h2><p>호이스팅이란 변수와 함수 선언을 코드가 실행되기 이전에 그들의 스코프의 최상위로 옮기는 Javascript 메커니즘으로 함수와 변수가 전역이든 지역 스코프든 그들의 스코프에 상관없이 최상위로 옮겨집니다. 그렇다면 함수는 호이스팅에 어떤 영향을 받으며 함수의 정의 방법에 따른 호이스팅의 차이는 어떻게 될까?</p><h4 id="함수-선언문"><a href="#함수-선언문" class="headerlink" title="함수 선언문"></a>함수 선언문</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">firstDecFn</span>(<span class="params">para, meter</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> para + meter</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">firstDecFn(<span class="string">&#x27;argu&#x27;</span>, <span class="string">&#x27;ment&#x27;</span>) <span class="comment">// &#x27;argument&#x27;</span></span><br><span class="line">secondDecFn(<span class="string">&#x27;argu&#x27;</span>, <span class="string">&#x27;ment&#x27;</span>) <span class="comment">// &#x27;argument&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">secondDecFn</span>(<span class="params">para, meter</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> para + meter</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>기본적으로 함수 선언문은 Javascript 호이스팅의 기본 타겟 중 하나로 위 예제에서  <code>firstDecFn</code> 함수처럼 먼저 선언하고 후에 호출하든 <code>secondDecFn</code> 함수처럼 먼저 호출하고 나중에 선언하든 함수 선언문은 Javascipt의 호이스팅으로 모두 최상위로 끌어올려져 정상작동합니다.</p><h4 id="함수-표현문"><a href="#함수-표현문" class="headerlink" title="함수 표현문"></a>함수 표현문</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> firstDecFn = <span class="function"><span class="keyword">function</span> (<span class="params">para, meter</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> para + meter</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">firstDecFn(<span class="string">&#x27;argu&#x27;</span>, <span class="string">&#x27;ment&#x27;</span>) <span class="comment">// &#x27;argument&#x27;</span></span><br><span class="line">secondDecFn(<span class="string">&#x27;argu&#x27;</span>, <span class="string">&#x27;ment&#x27;</span>) <span class="comment">// Uncaught TypeError: secondDecFn is not a function</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> secondDecFn = <span class="function"><span class="keyword">function</span> (<span class="params">para, meter</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> para + meter</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>결론부터 말하면 함수 표현문은 <em>hoisting(끌어올림)</em> 되지 않는다. 왜냐하면 Javascript Engine의 Parser 부분을 이해하면 쉬운데 Parser는 스크립트 내 변수를 분석할때 변수의 선언과 할당이 분리해 실행한다. 설명을 위해 간단한 변수 호이스팅을 예를 들어보자.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 우리가 작성한 코드</span></span><br><span class="line"><span class="built_in">console</span>.log(x);</span><br><span class="line"><span class="keyword">var</span> x = <span class="number">100</span>;</span><br><span class="line">-----------------------------------------------------------------------------------</span><br><span class="line"><span class="comment">// JavaScript Parser가 해석한 코드</span></span><br><span class="line"><span class="keyword">var</span> x;</span><br><span class="line"><span class="built_in">console</span>.log(x);</span><br><span class="line">x = <span class="number">100</span>;</span><br></pre></td></tr></table></figure><p>위 예제에서 <strong>“우리가 작성한 코드”</strong> 부분을 보면 <code>console.log(x)</code> 에서 변수 x를 호출하고, 다음줄에 <code>var x = 100</code>  이라고 선언했다. 그러나 <strong>“JavaScript Parser가 해석한 코드”</strong> 를 보면 <em>선언과 할당</em> 이 분리되어 있음을 볼 수 있다. 이러한 원리가 바로 Hoisting이고 함수 표현식으로 작성된 함수 또한 이 원리를 따르며 함수표현식의 예제를 Javascript가 해석한 코드로 변환하면 아래와 같다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> firstDecFn;</span><br><span class="line"><span class="keyword">var</span> secondDecFn;</span><br><span class="line">firstDecFn = <span class="function"><span class="keyword">function</span> (<span class="params">para, meter</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> para + meter</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">firstDecFn(<span class="string">&#x27;argu&#x27;</span>, <span class="string">&#x27;ment&#x27;</span>) <span class="comment">// &#x27;argument&#x27;</span></span><br><span class="line">secondDecFn(<span class="string">&#x27;argu&#x27;</span>, <span class="string">&#x27;ment&#x27;</span>) <span class="comment">// Uncaught TypeError: secondDecFn is not a function</span></span><br><span class="line"></span><br><span class="line">secondDecFn = <span class="function"><span class="keyword">function</span> (<span class="params">para, meter</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> para + meter</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>그렇다면 함수 표현식은 hoisting에 적용받지 못해 TypeError도 나는데 쓰지 말아야할까? 그것은 아니다. 함수 표현식이 가지고 있는 장점 또한 있다. </p><ul><li>클로저 사용</li><li>콜백 함수 (함수의 인자로서 함수표현식으로 선언된 함수를 전달)</li><li>즉시 실행 함수 (IIFE)</li></ul><h2 id="매개변수-Parameter-와-인자-Argument"><a href="#매개변수-Parameter-와-인자-Argument" class="headerlink" title="매개변수(Parameter)와 인자(Argument)"></a>매개변수(Parameter)와 인자(Argument)</h2><p>설명을 위해 예제 함수를 만들어보자.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">example</span>(<span class="params">pa,ra,me,ter</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> pa + ra + me + ter</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">example(<span class="string">&#x27;ar&#x27;</span>, <span class="string">&#x27;gu&#x27;</span>, <span class="string">&#x27;me&#x27;</span>, <span class="string">&#x27;nt&#x27;</span>)</span><br></pre></td></tr></table></figure><p>위 예제를 보면 <code>example</code> 함수는 <code>pa,ra,me,ter</code> 라는 데이터를 받아 반환(return)하고, <code>example</code> 함수가 호출될때 <code>&#39;ar&#39;, &#39;gu&#39;, &#39;me&#39;, &#39;nt&#39;</code> 이라는 데이터를 넘겨줬다.</p><p>쉽게 정의하자면, <strong>함수내에서 활용하느냐</strong>와 <strong>함수안으로 넘겨주느냐</strong> 의 차이이다. 편의상 이렇게 정의 가능하며 정확한 정의는 <strong>함수 정의하기</strong> 섹션의 <strong>함수 선언문</strong> 에서 정의한 내용이다. </p><ul><li>매개변수 : 함수 등에서 사용되는 전달된 값을 받는 변수로써, 함수의 기능상 외부 환경에서 데이터를 받아 가공 및 반환이 필요할 경우 함수 내부로 전달하는 역할을 하며 <code>콤마(,)</code> 로 구분하여 최대 255개까지 받을 수 있습니다.</li><li>인자: 함수에 전달되는 인수의 배열집합으로써, 정확히는 유사배열 객체로 <code>arguments</code> 객체라 칭하며 매개변수를 통해 전달받은 함수 외부환경의 값, 변수 또는 참조이다.</li></ul><h4 id="매개변수-Parameter"><a href="#매개변수-Parameter" class="headerlink" title="매개변수 (Parameter)"></a>매개변수 (Parameter)</h4><p>매개변수란 <strong>‘함수 등에서 사용되는 전달된 값을 받는 변수’</strong> 로, 함수에서 정의한 매개변수가 충분히 오지 않으면 <code>undefined</code> 로 정의되며 <strong>ECMAScript 6</strong> 부터는 <em>Default Parameter</em> 와 <em>Rest Parameter</em> 가 추가 되었다.</p><h5 id="매개변수-기본-처리방식"><a href="#매개변수-기본-처리방식" class="headerlink" title="매개변수 기본 처리방식"></a>매개변수 기본 처리방식</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">example</span>(<span class="params">pa,ra,me,ter</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`me =&gt; <span class="subst">$&#123;me&#125;</span>, ter =&gt; <span class="subst">$&#123;ter&#125;</span>`</span>) <span class="comment">// me =&gt; undefined, ter =&gt; undefined</span></span><br><span class="line">  <span class="keyword">return</span> pa + ra + me + ter</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">example(<span class="string">&#x27;argu&#x27;</span>, <span class="string">&#x27;ment&#x27;</span>) <span class="comment">// argumentundefinedundefined</span></span><br></pre></td></tr></table></figure><h5 id="Default-Parameter-기본-매개변수"><a href="#Default-Parameter-기본-매개변수" class="headerlink" title="Default Parameter (기본 매개변수)"></a>Default Parameter (기본 매개변수)</h5><p>전달값이 없거나 <code>undefined</code> 인 경우 파라미터에 기본값으로 초기화 될 값을 할당</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">example</span>(<span class="params">pa,ra,me = <span class="string">&#x27;me&#x27;</span>,ter = <span class="string">&#x27;nt&#x27;</span></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`me =&gt; <span class="subst">$&#123;me&#125;</span>, ter =&gt; <span class="subst">$&#123;ter&#125;</span>`</span>) <span class="comment">// me =&gt; me, ter =&gt; nt</span></span><br><span class="line">  <span class="keyword">return</span> pa + ra + me + ter</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">example(<span class="string">&#x27;ar&#x27;</span>, <span class="string">&#x27;gu&#x27;</span>) <span class="comment">// argument</span></span><br></pre></td></tr></table></figure><h5 id="Rest-Parameter-나머지-매개변수"><a href="#Rest-Parameter-나머지-매개변수" class="headerlink" title="Rest Parameter (나머지 매개변수)"></a>Rest Parameter (나머지 매개변수)</h5><p>파라미터의 갯수가 불확실해 <code>Array (배열)</code> 로 인수를 넘길때 사용할 수 있다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">double</span>(<span class="params">...theArgs</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> theArgs.map(<span class="function"><span class="params">x</span> =&gt;</span> x + x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">double(<span class="number">2</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>); <span class="comment">// [4, 2, 4, 6]</span></span><br><span class="line">double(<span class="number">2</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">9</span>, <span class="number">5</span>);  <span class="comment">// [4, 2, 4, 6, 18, 10]</span></span><br></pre></td></tr></table></figure><h4 id="인자-Argument"><a href="#인자-Argument" class="headerlink" title="인자 (Argument)"></a>인자 (Argument)</h4><p>인자(Argument)는 <strong>함수에 전달되는 인수의 배열집합</strong> 또는 <strong>모든 함수 내에서 이용 가능한 지역변수</strong> 로서 함수 호출시 전달되는 값을 할당 또는 참조해 함수 내에서 사용할 수 있습니다. </p><p>함수 내에서는 <code>arguments</code> 로 호출할 수 있으며 정확시는 <strong>유사객체 배열(array-like object)</strong> 에 속한다. 따라서 Javascript의 built-in function 중 Array 관련 메서드를 사용할 수 없으며 <code>length</code> 속성은 사용 가능합니다.</p><p><code>argument</code> 객체는 배열과 같이 인덱스로 접근가능합니다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">arg</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">arguments</span>.length)</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>; i&lt;<span class="built_in">arguments</span>.length; i++) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">arguments</span>[i])</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">arg(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="comment">// 3</span></span><br></pre></td></tr></table></figure><h5 id="arguments-를-Array-로-변환하기"><a href="#arguments-를-Array-로-변환하기" class="headerlink" title="arguments 를 Array 로 변환하기"></a><code>arguments</code> 를 <code>Array</code> 로 변환하기</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> args = <span class="built_in">Array</span>.from(<span class="built_in">arguments</span>);</span><br><span class="line"><span class="keyword">var</span> args = [...arguments];</span><br></pre></td></tr></table></figure><h2 id="Function-프로토타입-객체와-프로퍼티"><a href="#Function-프로토타입-객체와-프로퍼티" class="headerlink" title="Function 프로토타입 객체와 프로퍼티"></a>Function 프로토타입 객체와 프로퍼티</h2><p>JavaScript에 함수는 Data Type에서 객체(Object)에 속하며, 모든 JavaScript 함수는 사실 <code>Function</code> 객체입니다. </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 함수 정의</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">square</span>(<span class="params">number</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> number * number;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 함수 프로퍼티 추가 Case</span></span><br><span class="line">square.x = <span class="number">10</span>;</span><br><span class="line">square.y = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(square.x, square.y); <span class="comment">// 10, 20</span></span><br></pre></td></tr></table></figure><p>아래의 함수 생성법들은 모두 <code>true</code>  를 반환하며 전역 <code>Function</code> 객체는 자신만의 메서드 또는 속성이 없으나 그 자체로 함수이기에 <a href="https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Function/prototype"><code>Function.prototype</code></a>에서 프로토타입 체인을 통해 일부 메서드 및 속성을 상속 받습니다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 즉시 실행 함수 (IIFE)</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;).constructor === <span class="built_in">Function</span> <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 함수 선언식</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">deFn</span> (<span class="params"></span>) </span>&#123; <span class="keyword">return</span> <span class="string">&#x27;body&#x27;</span> &#125;</span><br><span class="line">deFn.constructor === <span class="built_in">Function</span> <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 함수 표현식</span></span><br><span class="line"><span class="keyword">var</span> exFn = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="keyword">return</span> <span class="string">&#x27;body&#x27;</span> &#125;</span><br><span class="line">exFn.constructor === <span class="built_in">Function</span> <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>또한, 함수는 일반 객체와 다른 함수만의 프로퍼티와 메서드를 갖습니다.</p><h5 id="Function-프로토타입-객체"><a href="#Function-프로토타입-객체" class="headerlink" title="Function 프로토타입 객체"></a><code>Function</code> 프로토타입 객체</h5><ul><li><a href="https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Function/length"><code>Function.length</code></a> : 함수에 의해 기대되는 인수의 수 지정</li><li><a href="https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Function/name"><code>Function.name</code></a> : 함수명</li><li><code>Function.prototype.constructor</code> : 객체의 프로토타입을 만드는 함수 지정</li><li><a href="https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Function/arguments"><code>Function.arguments</code></a> <em>(deprecated)</em></li></ul><h5 id="메서드"><a href="#메서드" class="headerlink" title="메서드"></a>메서드</h5><ul><li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/apply"><code>Function.prototype.apply(this, [arg1, arg2, ... argn])</code></a> : 함수를 호출하고 함수의 <code>this</code> 객체에 제공된 <code>thisArg</code> 를 설정합니다. 인자는 <code>Arrat</code> 객체로 전달할 수 있습니다.</li><li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/bind"><code>Function.prototype.bind(this, binding object)</code></a> :  호출될때, 함수의 <code>this</code> 가 제공된 <code>thisArg</code> 로 설정된 새로운 함수가 생성된다. 선택적으로, 주어진 일련의 인자(arguments)는 새로 바인딩 된 함수가 호출되는 경우 인수보다 우선적으로 추가됩니다.</li><li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/call"><code>Function.prototype.call(this, arg1, arg2, ... argN)</code></a> : 주어진 <code>this</code> 값과 개별적으로 제공되는 인수를 사용하여 함수를 호출한다.</li></ul><h2 id="화살표-함수-Arrow-Function"><a href="#화살표-함수-Arrow-Function" class="headerlink" title="화살표 함수 (Arrow Function)"></a>화살표 함수 (Arrow Function)</h2><p><strong>ES6</strong> 부터 함수를 생성하는 방법으로 함수 표현식보다 단순하고 간결한 화살표 함수 <code>=&gt;</code> 가 추가되었다.</p><h4 id="특징"><a href="#특징" class="headerlink" title="특징"></a>특징</h4><ul><li>함수 표현식보다 구문이 짧고,</li><li>자신의  <a href="https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Operators/this">this</a>, <a href="https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Functions/arguments">arguments</a>, <a href="https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Operators/super">super</a> 또는 <a href="https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Operators/new.target">new.target</a>을 바인딩 하지 않는다</li><li>항상 익명 함수이다.</li><li>메소드 함수가 아닌 곳에 즉, 인자로서 부모 함수가 넘겨줄 callback 함수에 적합하다.</li><li>함수 생성자 (function constructor)로서 사용할 수 없다.</li><li>반환해야 할 값이 있을때 <code>return</code>  과 <code>&#123;&#125;</code> 를 생략할 수 있다.</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">double</span> (<span class="params">n</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> n * <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> double = <span class="function"><span class="params">n</span> =&gt;</span> n * <span class="number">2</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> numbers = [<span class="number">0</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>];</span><br><span class="line"><span class="keyword">let</span> double = <span class="function"><span class="params">n</span> =&gt;</span> n * <span class="number">2</span></span><br><span class="line"><span class="built_in">console</span>.log(numbers.map(double));</span><br><span class="line"><span class="built_in">console</span>.log(numbers.map(<span class="function"><span class="params">number</span> =&gt;</span> number * <span class="number">2</span>));</span><br><span class="line"><span class="comment">// expected output: Array [0, 4, 8, 12, 16]</span></span><br></pre></td></tr></table></figure><h4 id="기본-구문"><a href="#기본-구문" class="headerlink" title="기본 구문"></a>기본 구문</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">(param1, param2, …, paramN) =&gt; &#123; statements &#125;</span><br><span class="line">(param1, param2, …, paramN) =&gt; expression</span><br><span class="line"><span class="comment">// 다음과 동일함:  =&gt; &#123; return expression; &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 매개변수가 하나뿐인 경우 괄호는 선택사항:</span></span><br><span class="line">(singleParam) =&gt; &#123; statements &#125;</span><br><span class="line">singleParam =&gt; &#123; statements &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 매개변수가 없는 함수는 괄호가 필요:</span></span><br><span class="line">() =&gt; &#123; statements &#125;</span><br></pre></td></tr></table></figure><h4 id="고급-구문"><a href="#고급-구문" class="headerlink" title="고급 구문"></a>고급 구문</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 객체 리터럴 표현을 반환하기 위해서는 함수 본문(body)을 괄호 속에 넣음:</span></span><br><span class="line">params =&gt; (&#123;<span class="attr">foo</span>: bar&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 나머지 매개변수 및 기본 매개변수를 지원함</span></span><br><span class="line">(param1, param2, ...rest) =&gt; &#123; statements &#125;</span><br><span class="line">(param1 = defaultValue1, param2, …, paramN = defaultValueN) =&gt; &#123; statements &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 매개변수 목록 내 구조분해할당도 지원됨</span></span><br><span class="line"><span class="keyword">var</span> f = <span class="function">(<span class="params">[a, b] = [<span class="number">1</span>, <span class="number">2</span>], &#123;x: c&#125; = &#123;x: a + b&#125;</span>) =&gt;</span> a + b + c;</span><br><span class="line">f();  <span class="comment">// 6</span></span><br></pre></td></tr></table></figure><p><em>(화살표 함수의 자세한 내용에 대해서는 추후 포스팅할 예정입니다.)</em></p><hr><h2 id="참조"><a href="#참조" class="headerlink" title="참조"></a>참조</h2><ul><li><a href="https://ko.javascript.info/function-basics">https://ko.javascript.info/function-basics</a></li><li><a href="https://developer.mozilla.org/ko/docs/Web/JavaScript/Guide">https://developer.mozilla.org/ko/docs/Web/JavaScript/Guide</a></li><li><a href="https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Functions">https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Functions</a></li><li><a href="https://poiemaweb.com/js-function">https://poiemaweb.com/js-function</a></li><li><a href="https://joshua1988.github.io/web-development/javascript/function-expressions-vs-declarations/">https://joshua1988.github.io/web-development/javascript/function-expressions-vs-declarations/</a></li><li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Closures">https://developer.mozilla.org/en-US/docs/Web/JavaScript/Closures</a></li><li><a href="https://ko.javascript.info/arrow-functions-basics">https://ko.javascript.info/arrow-functions-basics</a></li></ul>]]></content:encoded>
      
      
      <category domain="https://joontae-kim.github.io/categories/Programming/">Programming</category>
      
      <category domain="https://joontae-kim.github.io/categories/Programming/Javascript/">Javascript</category>
      
      
      <category domain="https://joontae-kim.github.io/tags/javascript/">javascript</category>
      
      <category domain="https://joontae-kim.github.io/tags/function/">function</category>
      
      <category domain="https://joontae-kim.github.io/tags/arrow-function/">arrow function</category>
      
      
      <comments>https://joontae-kim.github.io/2020/10/20/js-function/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>프론트엔드 취준 관련 링크 모음</title>
      <link>https://joontae-kim.github.io/2020/10/20/front-end-interview-link-collection/</link>
      <guid>https://joontae-kim.github.io/2020/10/20/front-end-interview-link-collection/</guid>
      <pubDate>Tue, 20 Oct 2020 04:40:20 GMT</pubDate>
      
        
        
      <description>&lt;p&gt;&lt;img src=&quot;/images/job_thumbnail.jpeg&quot; alt=&quot;면접!&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;프론트엔드-지원-관련-링크-모음&quot;&gt;&lt;a href=&quot;#프론트엔드-지원-관련-링크-모음&quot; class=&quot;headerlink&quot; title=&quot;프론</description>
        
      
      
      
      <content:encoded><![CDATA[<p><img src="/images/job_thumbnail.jpeg" alt="면접!"></p><h2 id="프론트엔드-지원-관련-링크-모음"><a href="#프론트엔드-지원-관련-링크-모음" class="headerlink" title="프론트엔드 지원 관련 링크 모음"></a>프론트엔드 지원 관련 링크 모음</h2><h3 id="개발자분들-블로그"><a href="#개발자분들-블로그" class="headerlink" title="개발자분들 블로그"></a>개발자분들 블로그</h3><ul><li>박성범 개발자님 깃허브 블로그 - <a href="https://parksb.github.io/articles.html">https://parksb.github.io/articles.html</a></li><li>캡틴 판교님 깃허브 블로그 - <a href="https://joshua1988.github.io/tech/">https://joshua1988.github.io/tech/</a></li><li>roy-jung님 깃허브 블로그 - <a href="https://roy-jung.github.io/">https://roy-jung.github.io/</a></li></ul><h3 id="ALL"><a href="#ALL" class="headerlink" title="ALL"></a>ALL</h3><ul><li>[IT 개발자와 일할 때 필요한 모든 개발지식] A to Z 자료 모음집 By 그랩 - <a href="https://www.grabbing.me/IT-A-to-Z-By-1e1fbc981b7c4c03ac44943085ac8304">https://www.grabbing.me/IT-A-to-Z-By-1e1fbc981b7c4c03ac44943085ac8304</a></li><li>📋 프론트엔드 개발자를 위한 토막상식 - <a href="https://parksb.github.io/article/0.html">https://parksb.github.io/article/0.html</a></li></ul><h3 id="구직-관련-블로그-link"><a href="#구직-관련-블로그-link" class="headerlink" title="구직 관련 블로그 link"></a>구직 관련 블로그 link</h3><ul><li>DevOwen의 구직 이야기 Ch1. 마음가짐 :: DevOwen - <a href="https://devowen.com/287">https://devowen.com/287</a></li><li>이직을 준비하면서 - Today I Learned - <a href="https://vallista.kr/2019/07/03/%EC%9D%B4%EC%A7%81%EC%9D%84-%EC%A4%80%EB%B9%84%ED%95%98%EB%A9%B4%EC%84%9C/">https://vallista.kr/2019/07/03/%EC%9D%B4%EC%A7%81%EC%9D%84-%EC%A4%80%EB%B9%84%ED%95%98%EB%A9%B4%EC%84%9C/</a></li><li>28세 요우의 개발자 이직 대탐험 - <a href="https://luckyyowu.tistory.com/382">https://luckyyowu.tistory.com/382</a></li><li>2018 종합선물세트 for 취준생 - <a href="https://www.slideshare.net/LuckyYoWu/2018-for">https://www.slideshare.net/LuckyYoWu/2018-for</a></li></ul><h3 id="인터뷰-관련-블로그-link"><a href="#인터뷰-관련-블로그-link" class="headerlink" title="인터뷰 관련 블로그 link"></a>인터뷰 관련 블로그 link</h3><ul><li>[Interview] 인터뷰 경험 - 프론트 (야놀자) - <a href="https://daniel-park.tistory.com/42">https://daniel-park.tistory.com/42</a></li><li>이직초보 어느 개발자의 이력서 만들기 - <a href="https://woowabros.github.io/experience/2017/07/17/resume.html">https://woowabros.github.io/experience/2017/07/17/resume.html</a></li></ul><h3 id="이력서-및-경력기술서-관련-link"><a href="#이력서-및-경력기술서-관련-link" class="headerlink" title="이력서 및 경력기술서 관련 link"></a>이력서 및 경력기술서 관련 link</h3><ul><li>주니어 개발자 경력기술서 작성하기 :: GoGo - <a href="https://gogomalibu.tistory.com/119">https://gogomalibu.tistory.com/119</a></li><li>[youtube], [인터뷰] 면접관이 좋아하는 이력서 쓰기 - <a href="https://www.youtube.com/watch?v=JM-Tz6dGH1U">https://www.youtube.com/watch?v=JM-Tz6dGH1U</a></li><li>[youtube], 개발자 고민 상담, “이력서는 매력이 있어야지” - <a href="https://www.youtube.com/watch?v=zVDxL99tQiA">https://www.youtube.com/watch?v=zVDxL99tQiA</a></li></ul><h3 id="포트폴리오-관련-link"><a href="#포트폴리오-관련-link" class="headerlink" title="포트폴리오 관련 link"></a>포트폴리오 관련 link</h3><ul><li>[youtube], 초보개발자 포트폴리오 준비 이것으로 끝 / 프로그래머 되는법 / 프로그래머 공부 / 프로그래머 취업<br><a href="https://www.youtube.com/watch?v=_h3mGruXUSk">https://www.youtube.com/watch?v=_h3mGruXUSk</a></li></ul><h3 id="면접-질문-리스트-link"><a href="#면접-질문-리스트-link" class="headerlink" title="면접 질문 리스트 link"></a>면접 질문 리스트 link</h3><ul><li><a href="https://devowen.com/271">&lt;FE 면접질문&gt; #1. 웹 브라우저 &amp; HTML</a></li><li><a href="https://devowen.com/276">&lt;FE 면접질문&gt; #3. Javascript</a></li><li>프론트엔드 개발자 면접 질문(기술면접) 정리 - <a href="https://sunnykim91.tistory.com/121">https://sunnykim91.tistory.com/121</a></li><li>프론트엔드 개발자 면접 질문 모음 - <a href="https://mber.tistory.com/2">https://mber.tistory.com/2</a></li><li>프론트엔드 면접 질문 모음 - <a href="https://velog.io/@honeysuckle/%EC%8B%A0%EC%9E%85-%ED%94%84%EB%A1%A0%ED%8A%B8%EC%97%94%EB%93%9C-%EB%A9%B4%EC%A0%91-%EC%A7%88%EB%AC%B8-%EB%AA%A8%EC%9D%8C">https://velog.io/@honeysuckle/%EC%8B%A0%EC%9E%85-%ED%94%84%EB%A1%A0%ED%8A%B8%EC%97%94%EB%93%9C-%EB%A9%B4%EC%A0%91-%EC%A7%88%EB%AC%B8-%EB%AA%A8%EC%9D%8C</a></li><li>이번 기술 면접 중 기억나는 질문과 답변들 (프론트엔드). 이번에 이직하게 된 회사 기술 면접에서 주고 받았던 질문과 답변들 중… | by Jim Kim | Medium - <a href="https://medium.com/@jimkimau/%EC%9D%B4%EB%B2%88-%EA%B8%B0%EC%88%A0-%EB%A9%B4%EC%A0%91-%EC%A4%91-%EA%B8%B0%EC%96%B5%EB%82%98%EB%8A%94-%EC%A7%88%EB%AC%B8%EA%B3%BC-%EB%8B%B5%EB%B3%80%EB%93%A4-712daa9a2dc">https://medium.com/@jimkimau/%EC%9D%B4%EB%B2%88-%EA%B8%B0%EC%88%A0-%EB%A9%B4%EC%A0%91-%EC%A4%91-%EA%B8%B0%EC%96%B5%EB%82%98%EB%8A%94-%EC%A7%88%EB%AC%B8%EA%B3%BC-%EB%8B%B5%EB%B3%80%EB%93%A4-712daa9a2dc</a></li><li>스타트업 면접 전에 점검해야 하는 10가지 | ㅍㅍㅅㅅ - <a href="https://ppss.kr/archives/227105">https://ppss.kr/archives/227105</a></li></ul><h3 id="프론트엔드-관련-질문-관련-link"><a href="#프론트엔드-관련-질문-관련-link" class="headerlink" title="프론트엔드 관련 질문 관련 link"></a>프론트엔드 관련 질문 관련 link</h3><ul><li>프론트엔드 개발자를 위한 토막상식 - <a href="https://parksb.github.io/article/0.html">https://parksb.github.io/article/0.html</a></li><li>이직하려는 친구에게 보내는 프런트엔드 개발 면접 질문 - <a href="https://joshua1988.github.io/web-development/interview/frontend-questions/">https://joshua1988.github.io/web-development/interview/frontend-questions/</a></li></ul><h3 id="면접-질문-Javascript-link"><a href="#면접-질문-Javascript-link" class="headerlink" title="면접 질문 Javascript link"></a>면접 질문 Javascript link</h3><ul><li>JavaScript 질문 | Front End Interview Handbook - <a href="https://yangshun.github.io/front-end-interview-handbook/kr/javascript-questions">https://yangshun.github.io/front-end-interview-handbook/kr/javascript-questions</a></li></ul><h3 id="알고리즘-및-코딩테스트-관련-link"><a href="#알고리즘-및-코딩테스트-관련-link" class="headerlink" title="알고리즘 및 코딩테스트 관련 link"></a>알고리즘 및 코딩테스트 관련 link</h3><ul><li>‘Alogorithm’ 카테고리의 글 목록 - <a href="https://daniel-park.tistory.com/">https://daniel-park.tistory.com/</a></li><li>[youtube], IT개발자가 추천하는 코딩테스트 공부법, 포트폴리오 준비방법 | 5년차 웹개발 현직자는 이렇게 취준했다 - <a href="https://www.youtube.com/watch?v=rqNaabU2FmY&amp;t=209s">https://www.youtube.com/watch?v=rqNaabU2FmY&amp;t=209s</a></li></ul>]]></content:encoded>
      
      
      <category domain="https://joontae-kim.github.io/categories/Blog/">Blog</category>
      
      <category domain="https://joontae-kim.github.io/categories/Blog/Job/">Job</category>
      
      
      <category domain="https://joontae-kim.github.io/tags/Front-end/">Front-end</category>
      
      <category domain="https://joontae-kim.github.io/tags/Interview/">Interview</category>
      
      <category domain="https://joontae-kim.github.io/tags/Job/">Job</category>
      
      
      <comments>https://joontae-kim.github.io/2020/10/20/front-end-interview-link-collection/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>자바스크립트 실행 컨텍스트(Execution Context) 3 - 실행 컨텍스트의 생성과 실행</title>
      <link>https://joontae-kim.github.io/2020/10/18/execution-context-example/</link>
      <guid>https://joontae-kim.github.io/2020/10/18/execution-context-example/</guid>
      <pubDate>Sun, 18 Oct 2020 11:33:00 GMT</pubDate>
      
        
        
      <description>&lt;p&gt;실행 컨텍스트 관련 첫번째 포스트인 &lt;a href=&quot;https://joontae-kim.github.io/2020/10/12/excution-context/&quot;&gt;자바스크립트 실행 컨텍스트(Execution Context)&lt;/a&gt; 에서는 실행 컨텍스</description>
        
      
      
      
      <content:encoded><![CDATA[<p>실행 컨텍스트 관련 첫번째 포스트인 <a href="https://joontae-kim.github.io/2020/10/12/excution-context/">자바스크립트 실행 컨텍스트(Execution Context)</a> 에서는 실행 컨텍스트란 무엇인지 그리고 유형은 어떠한 것들이 있으며  Javascript 엔진이 실행 컨텍스트를 어떻게 관리하는지 알아보았습니다.</p><p>실행 컨텍스트 관련 두번째 포스트인 <a href="/2020/10/15/excution-context-2/">자바스크립트 실행 컨텍스트(Execution Context) 2 - 정의와 구조</a> 에서는 실행 컨텍스트의 정의와 ES5 이후의 Scope Chain의 변화 그리고 실행 컨텍스트의 세부구조에 대해 다뤄봤습니다.</p><p>그리고 마지막 포스트로는 <strong>실행 컨텍스트의 생성과 실행 과정</strong>에 대해 참고중이던 영문 포스트의 일부분을 번역하면서 구조와 각 세부 프로퍼티에 대해 정리해보고, <strong>Creation Phase</strong> 와 <strong>Execution Phase</strong> 에 대해서 알아보며 끝마치도록 하겠습니다.</p><p>참고 영문 포스트: <a href="https://blog.bitsrc.io/understanding-execution-context-and-execution-stack-in-javascript-1c9ea8642dd0">Understanding Execution Context and Execution Stack in Javascript</a></p><p>번역 포스트의 <strong>“How is the Execution Context created?”</strong> 부분만 발췌하여 번역하였음을 알려드립니다.</p><hr><h1 id="Javascript-실행-컨텍스트와-실행-스택-이해하기"><a href="#Javascript-실행-컨텍스트와-실행-스택-이해하기" class="headerlink" title="Javascript 실행 컨텍스트와 실행 스택 이해하기"></a>Javascript 실행 컨텍스트와 실행 스택 이해하기</h1><h5 id="Javascript-프로그램이-내부적으로-실행되는-방법-학습하기"><a href="#Javascript-프로그램이-내부적으로-실행되는-방법-학습하기" class="headerlink" title="Javascript 프로그램이 내부적으로 실행되는 방법 학습하기"></a>Javascript 프로그램이 내부적으로 실행되는 방법 학습하기</h5><h1 id="How-is-the-Execution-Context-created"><a href="#How-is-the-Execution-Context-created" class="headerlink" title="How is the Execution Context created?"></a>How is the Execution Context created?</h1><p>지금까지, 우리는 Javascript 엔진이 실행 컨텍스트를 어떻게 관리하는지 살펴봤습니다. 그럼 지금부터는 Javascript 엔진이 실행 컨텍스트를 생성하는 방법에 대해 이해해보록 하겠습니다.</p><p>실행 컨텍스트는 두 단계로 나뉘어 생성됩니다: <strong>1) 생성 단계 (Creation Phase)</strong> 그리고 <strong>2) 실행 단계 (Execution Phase)</strong></p><h1 id="생성-단계"><a href="#생성-단계" class="headerlink" title="생성 단계"></a>생성 단계</h1><p>실행 컨텍스트는 생성 단계 동안 생성되며 아래의 컨포넌트가 발생합니다:</p><ol><li><strong>LexicalEnvironment</strong> 컴포넌트가 생성된다.</li><li><strong>VariableEnvironment</strong> 컴포넌트가 생성된다.</li></ol><p>그럼 실행 컨텍스트는 개념적으론 아래와 같이 나타낼 수 있다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ExecutionContext &#x3D; &#123;</span><br><span class="line">  LexicalEnvironment &#x3D; &lt;ref. to LexicalEnvironment in memory&gt;,</span><br><span class="line">  VariableEnvironment &#x3D; &lt;ref. to VariableEnvironment in  memory&gt;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Lexical-Environment"><a href="#Lexical-Environment" class="headerlink" title="Lexical Environment"></a>Lexical Environment</h2><p>The <a href="http://ecma-international.org/ecma-262/6.0/">official ES6</a> 문서에 정의된 Lexical Environment 는</p><blockquote><p><em>Lexical Environment는 ECMAScript 코드의 lexical 중첩 구조 상에서 특정 변수와 함수에 대한 인식자(Identifier)들을 정의하는데 사용되는 명세 유형입니다. Lexical Environment는 Environment Record와 outer Lexical Environment에 대한 가능한한 null 참조로 구성되어 있다.</em></p></blockquote><p>간단하게 말해, <em>lexical environment</em> 는 <strong>인식자(identifier)-변수(variable) 매핑(mapping)</strong> 을 유지하고 있는 구조입니다. (여기서 <strong>identifier</strong> 란 변수/함수들의 이름을 참고하는 것이고, <strong>variable</strong> 은 [함수 객체와 배열 객체를 포함하는] 실질적 객체 또는 기본값에 대한 참조값이다.)</p><p>예를 들어, 아래의 코드 조각을 생각해보자.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">20</span>;</span><br><span class="line"><span class="keyword">var</span> b = <span class="number">40</span>;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;bar&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>위 코드 조각의 lexical environment는 아래와 같이 나타낼 수 있다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">lexicalEnvironment = &#123;</span><br><span class="line">a: <span class="number">20</span>,</span><br><span class="line">b: <span class="number">40</span>,</span><br><span class="line">foo: <span class="xml"><span class="tag">&lt;<span class="name">ref.</span> <span class="attr">to</span> <span class="attr">foo</span> <span class="attr">function</span>&gt;</span></span></span><br><span class="line"><span class="xml">&#125;</span></span><br></pre></td></tr></table></figure><p>각 Lexical Environment는 세가지 컴포넌트를 가지고 있다.</p><ol><li>Environment Record</li><li>Reference to the outer environment</li><li>This binding</li></ol><h2 id="Environment-Record"><a href="#Environment-Record" class="headerlink" title="Environment Record"></a><strong>Environment Record</strong></h2><p>Environment Record는 lexical environment 안에 저장된 변수와 함수의 선언이 있는 곳이다.</p><p>또한, <em>environment record</em> 는 두가지 타입이 있습니다.</p><ul><li><strong>Declarative environment record —</strong> 이름에서 알 수 있듯이 변수와 함수의 선언에 대한 것으로 추측할 수 있다. 함수 코드에 대한 lexical environment는 declarative environment record를 포함하고 있다.</li><li><strong>Object environment record —</strong> 전역(global) 코드의 lexical environment는 objective environment record를 포함하고 있다. 변수와 함수에 대한 선언과 구분지어, object environment record는 또한 전역 바인딩 객체(global binding object) (browser의 경우 window 객체)를 저장한다. 그리고 바인딩된 객체에 대한 각각의 속성(브라우저의 경우, window 객체에 browser에 의해 제공되는 속성과 메서드들이 포함된다)에 대해 새로운 엔트리가 레코드 안에 생성된다.</li></ul><p><strong>Note —</strong> <strong>함수 코드</strong> 를 위해서, <em>Environment Record</em> 는 또한 인덱스와 함수에 전달된 인자 사이의 관계에 대한 매핑과 함수로 전달된 인자들에 대한 <em>길이(숫자, number)</em> 에 대한 정보를 담고있는 <code>인자(arguments)</code> 객체를 포함한다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> c = a + b;</span><br><span class="line">&#125;</span><br><span class="line">foo(<span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line"><span class="comment">// argument object</span></span><br><span class="line">Arguments: &#123;<span class="number">0</span>: <span class="number">2</span>, <span class="number">1</span>: <span class="number">3</span>, <span class="attr">length</span>: <span class="number">2</span>&#125;,</span><br></pre></td></tr></table></figure><h2 id="Reference-to-the-Outer-Environment"><a href="#Reference-to-the-Outer-Environment" class="headerlink" title="Reference to the Outer Environment"></a>Reference to the Outer Environment</h2><p><strong>reference to the outer environment</strong> 는 현재 실행 컨텍스트의 외부(outer) lexical environment에 대해 접근하는 것을 의미합니다. 이것은 JavaScript engine이 현재 lexical environment에서 변수를 찾지 못한다면 외부 환경(outer environment)에서 찾을 수 있음을 의미합니다.</p><h2 id="This-Binding"><a href="#This-Binding" class="headerlink" title="This Binding"></a>This Binding</h2><p>이 컴포넌트에서는 <code>this</code> 의 값을 결정하거나 설정합니다.</p><p>전역(global) 실행 컨텍스트에서 <code>this</code> 는 전역 객체를 참조합니다. (브라우저에서 <code>this</code> 는 Window 객체를 참조한다.)</p><p>함수 실행 컨텍스트에서 <code>this</code> 는 함수가 호출되는 방식에 따라 달라진다. 만약 객체 참조 방식에 따라 함수가 호출될 경우,  <code>this</code> 값은 해당 객체로 설정되고 그렇지 않으면 <code>this</code>  는 전역 객체 또는 (strict mode 에서는) <code>undefined</code> 로 설정된다. 예를 들어,</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> person = &#123;</span><br><span class="line">  name: <span class="string">&#x27;peter&#x27;</span>,</span><br><span class="line">  birthYear: <span class="number">1994</span>,</span><br><span class="line">  calcAge: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">2018</span> - <span class="built_in">this</span>.birthYear);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">person.calcAge(); </span><br><span class="line"><span class="comment">// &#x27;calcAge&#x27;가 &#x27;person&#x27; 객체 참조로 호출됐기 때문에 &#x27;this&#x27;는 &#x27;person&#x27;를 참조한다.</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> calculateAge = person.calcAge;</span><br><span class="line">calculateAge();</span><br><span class="line"><span class="comment">// 어떠한 객체 참조도 주어지지 않았기 때문에 &#x27;this&#x27;는 전역 window 객체를 참조한다. </span></span><br></pre></td></tr></table></figure><p>추상적으로, lexical environment는 아래와 같은 가상의 코드로 나타낼 수 있다:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">GlobalExectionContext &#x3D; &#123;</span><br><span class="line">  LexicalEnvironment: &#123;</span><br><span class="line">    EnvironmentRecord: &#123;</span><br><span class="line">      Type: &quot;Object&quot;,</span><br><span class="line">      &#x2F;&#x2F; 인식자(Identifier) binding은 여기로 이동한다.</span><br><span class="line">    &#125;</span><br><span class="line">    outer: &lt;null&gt;,</span><br><span class="line">    this: &lt;global object&gt;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">FunctionExectionContext &#x3D; &#123;</span><br><span class="line">  LexicalEnvironment: &#123;</span><br><span class="line">    EnvironmentRecord: &#123;</span><br><span class="line">      Type: &quot;Declarative&quot;,</span><br><span class="line">      &#x2F;&#x2F; 인식자(Identifier) binding은 여기로 이동한다.</span><br><span class="line">    &#125;</span><br><span class="line">    outer: &lt;Global or outer function environment reference&gt;,</span><br><span class="line">    this: &lt;depends on how function is called&gt;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Variable-Environment"><a href="#Variable-Environment" class="headerlink" title="Variable Environment:"></a>Variable Environment:</h2><p>또한 Environment Record는 실행 컨텍스트에서 <em>VariableStatements</em> 에 의해 생성된 binding을 보관하는 Lexical Environment 이다.</p><p>즉, Variable Environment 또한 Lexical Environment이며 위에서 정의한 것처럼 Lexical Environment의 모든 속성과 컴포넌트들을 가지고 있다.</p><p>ES6에서 <strong>LexicalEnvironment</strong> 컴포넌트 and the <strong>VariableEnvironment</strong> 컴포넌트의 한가지 차이점은 <strong>LexicalEnvironment</strong> 는 함수 선언과 변수 (<code>let</code> 과 <code>const</code>) 바인딩을 저장하는데 사용되고, <strong>VariableEnvironment</strong> 는 오직 변수 (<code>var</code>) 바인딩을 저장하는데 사용된다.</p><h1 id="실행-단계"><a href="#실행-단계" class="headerlink" title="실행 단계"></a>실행 단계</h1><p>이 단계에서는, 모든 변수에 대한 할당이 끝났으며 마침내 코드가 실행된다.</p><h1 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h1><p>이상의 개념을 이해하기 위해 몇 가지 예를 보자.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="number">20</span>;</span><br><span class="line"><span class="keyword">const</span> b = <span class="number">30</span>;</span><br><span class="line"><span class="keyword">var</span> c;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">multiply</span>(<span class="params">e, f</span>) </span>&#123;</span><br><span class="line"> <span class="keyword">var</span> g = <span class="number">20</span>;</span><br><span class="line"> <span class="keyword">return</span> e * f * g;</span><br><span class="line">&#125;</span><br><span class="line">c = multiply(<span class="number">20</span>, <span class="number">30</span>);</span><br></pre></td></tr></table></figure><p> 이 코드를 실행시키면, Javascript 엔진은 전역(global) 코드를 실행하기 위한 전역 실행 컨텍스트를 생성한다. 그럼 생성 단계에서 전역 실행 컨텍스트는 아래와 같은 가상의 코드처럼 될 것이다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">GlobalExectionContext = &#123;</span><br><span class="line">  LexicalEnvironment: &#123;</span><br><span class="line">    EnvironmentRecord: &#123;</span><br><span class="line">      Type: <span class="string">&quot;Object&quot;</span>,</span><br><span class="line">      <span class="comment">// 인식자(Identifier) binding은 여기로 이동한다.</span></span><br><span class="line">      a: &lt; uninitialized &gt;,</span><br><span class="line">      b: &lt; uninitialized &gt;,</span><br><span class="line">      multiply: &lt; func &gt;</span><br><span class="line">    &#125;</span><br><span class="line">    outer: <span class="xml"><span class="tag">&lt;<span class="name">null</span>&gt;</span>,</span></span><br><span class="line">    ThisBinding: &lt;Global Object&gt;</span><br><span class="line">  &#125;,</span><br><span class="line">  VariableEnvironment: &#123;</span><br><span class="line">    EnvironmentRecord: &#123;</span><br><span class="line">      Type: &quot;Object&quot;,</span><br><span class="line">      // 인식자(Identifier) binding은 여기로 이동한다.</span><br><span class="line">      c: undefined,</span><br><span class="line">    &#125;</span><br><span class="line">    outer: &lt;null&gt;,</span><br><span class="line">    ThisBinding: &lt;Global Object&gt;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>실행 단계 동안에는, 변수 할당이 끝났으며 전역 실행 컨텍스트는 아래와 같은 가상의 코드처럼 될 것입니다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">GlobalExectionContext = &#123;</span><br><span class="line">  LexicalEnvironment: &#123;</span><br><span class="line">    EnvironmentRecord: &#123;</span><br><span class="line">      Type: <span class="string">&quot;Object&quot;</span>,</span><br><span class="line">      <span class="comment">// 인식자(Identifier) binding은 여기로 이동한다.</span></span><br><span class="line">      a: <span class="number">20</span>,</span><br><span class="line">      b: <span class="number">30</span>,</span><br><span class="line">      multiply: &lt; func &gt;</span><br><span class="line">    &#125;</span><br><span class="line">    outer: <span class="xml"><span class="tag">&lt;<span class="name">null</span>&gt;</span>,</span></span><br><span class="line">    ThisBinding: &lt;Global Object&gt;</span><br><span class="line">  &#125;,</span><br><span class="line">  VariableEnvironment: &#123;</span><br><span class="line">    EnvironmentRecord: &#123;</span><br><span class="line">      Type: &quot;Object&quot;,</span><br><span class="line">      // 인식자(Identifier) binding은 여기로 이동한다.</span><br><span class="line">      c: undefined,</span><br><span class="line">    &#125;</span><br><span class="line">    outer: &lt;null&gt;,</span><br><span class="line">    ThisBinding: &lt;Global Object&gt;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>multiply(20, 30)</code> 함수에 대한 호출이 발생했을때, 새로운 함수(function) 실행 컨텍스트가 함수 코드를 실행하기 위해 생성된다. 그리고 함수 실행 컨텍스트는 생성 단계동안 아래와 같은 가상의 코드처럼 될 것입니다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">FunctionExectionContext = &#123;</span><br><span class="line">  LexicalEnvironment: &#123;</span><br><span class="line">    EnvironmentRecord: &#123;</span><br><span class="line">      Type: <span class="string">&quot;Declarative&quot;</span>,</span><br><span class="line">      <span class="comment">// 인식자(Identifier) binding은 여기로 이동한다.</span></span><br><span class="line">      Arguments: &#123;<span class="number">0</span>: <span class="number">20</span>, <span class="number">1</span>: <span class="number">30</span>, <span class="attr">length</span>: <span class="number">2</span>&#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">    outer: <span class="xml"><span class="tag">&lt;<span class="name">GlobalLexicalEnvironment</span>&gt;</span>,</span></span><br><span class="line">    ThisBinding: &lt;Global Object or undefined&gt;,</span><br><span class="line">  &#125;,</span><br><span class="line">  VariableEnvironment: &#123;</span><br><span class="line">    EnvironmentRecord: &#123;</span><br><span class="line">      Type: &quot;Declarative&quot;,</span><br><span class="line">      // 인식자(Identifier) binding은 여기로 이동한다.</span><br><span class="line">      g: undefined</span><br><span class="line">    &#125;,</span><br><span class="line">    outer: &lt;GlobalLexicalEnvironment&gt;,</span><br><span class="line">    ThisBinding: &lt;Global Object or undefined&gt;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>이후, 실행 컨텍스트는 함수(function) 내에서 변수 할당이 끝났다는 의미로 실행 단계를 거치고 함수 실행 컨텍스트는 실행 단계동안 아래와 같은 가상의 코드처럼 될 것입니다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">FunctionExectionContext = &#123;</span><br><span class="line">  LexicalEnvironment: &#123;</span><br><span class="line">    EnvironmentRecord: &#123;</span><br><span class="line">      Type: <span class="string">&quot;Declarative&quot;</span>,</span><br><span class="line">      <span class="comment">// 인식자(Identifier) binding은 여기로 이동한다.</span></span><br><span class="line">      Arguments: &#123;<span class="number">0</span>: <span class="number">20</span>, <span class="number">1</span>: <span class="number">30</span>, <span class="attr">length</span>: <span class="number">2</span>&#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">    outer: <span class="xml"><span class="tag">&lt;<span class="name">GlobalLexicalEnvironment</span>&gt;</span>,</span></span><br><span class="line">    ThisBinding: &lt;Global Object or undefined&gt;,</span><br><span class="line">  &#125;,</span><br><span class="line">  VariableEnvironment: &#123;</span><br><span class="line">    EnvironmentRecord: &#123;</span><br><span class="line">      Type: &quot;Declarative&quot;,</span><br><span class="line">      // 인식자(Identifier) binding은 여기로 이동한다.</span><br><span class="line">      g: 20</span><br><span class="line">    &#125;,</span><br><span class="line">    outer: &lt;GlobalLexicalEnvironment&gt;,</span><br><span class="line">    ThisBinding: &lt;Global Object or undefined&gt;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>함수가 완료된 후에, 반환된 값은 <code>c</code> 에 저장되고, 전역(global) lexical environment가 업데이트 됩니다. 그 후, 전역 코크는 완료되고, 프로그램은 끝난다.</p><p><strong>Note —</strong> 여러분은 <code>let</code> 과 <code>const</code> 로 정의된 변수는 생성 단계 동안에 그 어떠한 값(value)도 연결되지 않으며 <code>var</code>  로 정의된 변수는 <code>undefined</code> 로 설정된다는 것을 주의해야 합니다.</p><p>이것은 생성 단계에서 코드에서 변수와 함수 선언에 대해 스캔하고, 함수 선언이 환경에 함수 전체적으로 저장되는 동안, 변수는 처음에 (<code>var</code> 의 경우) <code>undefined</code>  로 설정되거나 (<code>let</code> 과 <code>const</code> 의 경우) 비초기화(uninitialized) 상태로 유지되기 때문입니다.</p><p>이게 여러분이 <code>let</code> 과 <code>const</code> 변수가 선언되기 전에 접근하려고 할때 참조 에러(reference error)가 발생하는 것과 달리 <code>var</code> 로 선언된 변수는 (<code>undefined</code> 로) 선언되기 전에 접근할 수 있는 이유입니다. </p><p>이것이 바로, 우리가 호이스팅(hoisting) 이라고 부르는 것입니다.</p><p><strong>Note —</strong> 실행단계 동안에, Javascript 엔진이 소스 코드(source code) 상에서 선언한 실제 위치에서 <code> let</code>  변수에 대한 값을 찾지 못한다면 이 변수에는  <code>undefined</code>  값이 할당될 것입니다.</p><h1 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h1><p>우리는 Javascript 프로그램들이 내부적으로 어떻게 실행되는지 살펴봤습니다. 여려분이 멋진 Javascript 개발자가 되기 위해 이러한 모든 개념들을 배울 필요는 없지만, 위와 같은 개념에 대한 왠만한 이해력은 Hoisting, Scope, and Closure 와 같은 다른 개념들도 더 쉽고 더 깊게 이해할 수 있도록 도울 것입니다. </p>]]></content:encoded>
      
      
      <category domain="https://joontae-kim.github.io/categories/Programming/">Programming</category>
      
      <category domain="https://joontae-kim.github.io/categories/Programming/Javascript/">Javascript</category>
      
      
      <category domain="https://joontae-kim.github.io/tags/javascript/">javascript</category>
      
      <category domain="https://joontae-kim.github.io/tags/javascript-engine/">javascript engine</category>
      
      <category domain="https://joontae-kim.github.io/tags/execution-context/">execution context</category>
      
      <category domain="https://joontae-kim.github.io/tags/execution/">execution</category>
      
      <category domain="https://joontae-kim.github.io/tags/context/">context</category>
      
      
      <comments>https://joontae-kim.github.io/2020/10/18/execution-context-example/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>자바스크립트 실행 컨텍스트(Execution Context) 2 - 정의와 구조</title>
      <link>https://joontae-kim.github.io/2020/10/15/excution-context-2/</link>
      <guid>https://joontae-kim.github.io/2020/10/15/excution-context-2/</guid>
      <pubDate>Wed, 14 Oct 2020 16:40:35 GMT</pubDate>
      
        
        
      <description>&lt;p&gt;실행 컨텍스트 관련 첫번째 포스트인 &lt;a href=&quot;https://joontae-kim.github.io/2020/10/12/excution-context/&quot;&gt;자바스크립트 실행 컨텍스트(Execution Context)&lt;/a&gt; 에서는 실행 컨텍스</description>
        
      
      
      
      <content:encoded><![CDATA[<p>실행 컨텍스트 관련 첫번째 포스트인 <a href="https://joontae-kim.github.io/2020/10/12/excution-context/">자바스크립트 실행 컨텍스트(Execution Context)</a> 에서는 실행 컨텍스트란 무엇인지 그리고 유형은 어떠한 것들이 있으며  Javascript 엔진이 실행 컨텍스트를 어떻게 관리하는지 알아보았습니다. 이번 포스트에서는 Javascript 엔진이 실행 컨텍스트를 어떻게 생성하며 실행 컨텍스트는 어떠한 구조로 이루어져 있는지 알아보겠습니다.</p><p>실행 컨텍스트의 물리적 구조를 설명하기에 앞서 일부 블로그의 내용이 ECMAScript의 ES5 이전의 개념으로 작성되어 있었습니다. 그래서 ES5 이전의 내용과 ES5 이후의 구조를 비교하기 위해 많은 블로그와 ECMAScript 의 공식 문서(ecma-262)의 <a href="http://ecma-international.org/ecma-262/6.0/#sec-executable-code-and-execution-contexts">Executable Code and Execution Contexts</a> 내용을 참고하였고 용어 및 구조에 있어서 변경사항이 있었습니다.</p><h2 id="ES5-이전과-이후"><a href="#ES5-이전과-이후" class="headerlink" title="ES5 이전과 이후"></a>ES5 이전과 이후</h2><p>ES5 이전과 이후의 차이가 크진 않습니다. 그러나 최신 스펙으로 공부하고 알고 있는것이 맞다고 생각되었고 짧게나마 제가 공부하면서 알게된 변경사항에 대해 정리해보았습니다.</p><h4 id="실행-컨텍스트를-실행하기-위해-보유하는-프로퍼티"><a href="#실행-컨텍스트를-실행하기-위해-보유하는-프로퍼티" class="headerlink" title="실행 컨텍스트를 실행하기 위해 보유하는 프로퍼티"></a>실행 컨텍스트를 실행하기 위해 보유하는 프로퍼티</h4><ul><li>ES5 이전:<ul><li>변수 객체 (Variable Object)</li><li>Scope Chain</li><li>this (Context Object)</li></ul></li><li>ES5 이후<ul><li>Lexical Environment</li><li>Variable Environment</li></ul></li><li>Variable Object, Activation Object, Scope Chain 등의 개념이 Lexical Environment로 변경됨</li></ul><h3 id="실행-컨텍스트에서-“this”를-관리하는-주체"><a href="#실행-컨텍스트에서-“this”를-관리하는-주체" class="headerlink" title="실행 컨텍스트에서 “this”를 관리하는 주체"></a>실행 컨텍스트에서 “this”를 관리하는 주체</h3><ul><li>ES5 이전:<ul><li>실행 컨텍스트 객체가 직접</li></ul></li><li>ES5 이후<ul><li>Lexical Environment</li></ul></li></ul><h4 id="“Scope-Chain”의-변화"><a href="#“Scope-Chain”의-변화" class="headerlink" title="“Scope Chain”의 변화"></a>“Scope Chain”의 변화</h4><ul><li>Javascript는 <strong>Lexical Scope</strong>를 갖는 언어로써, <strong>식별자 탐색을 위한 참조</strong>가 ES5 이후 아래와 같이 변경되었다.</li><li>ES5 이전:<ul><li>Scope Chain</li></ul></li><li>ES5 이후<ul><li>Lexical nesting structure</li><li>Logical nesting of Lexical Environment values</li></ul></li><li><strong>Chain(사슬)</strong> 의 구조보다는 <strong>nesting(중첩)</strong> 의 의미를 강조에 의미를 둠</li></ul><h2 id="실행-컨텍스트와-그-구조"><a href="#실행-컨텍스트와-그-구조" class="headerlink" title="실행 컨텍스트와 그 구조"></a>실행 컨텍스트와 그 구조</h2><p>실행 컨텍스트 1편인 <a href="https://joontae-kim.github.io/2020/10/12/excution-context/">자바스크립트 실행 컨텍스트(Execution Context)</a> 에서 정의했듯이 “실행 가능한 코드를 <strong>형상화</strong> 하고 <strong>구분</strong> 하는 추상적인 개념으로 코드가 실행되고 있는 <strong>구역 또는 범위</strong>“ 로써 각 실행 컨텍스트는 아래와 같은 모양을 갖으며 이는 ES5 이전의 구조인 실행 컨텍스트 안에 3개의 프로퍼티(변수객체(Variable Object), Scope Chain, this Object)를 갖는 구조와 다르다.</p><p><img src="/images/Execution_context_construction.png" alt="Execution context 구조"></p><h4 id="1-실행-컨텍스트"><a href="#1-실행-컨텍스트" class="headerlink" title="1. 실행 컨텍스트"></a>1. 실행 컨텍스트</h4><p>그림의 가장 좌측에 그리고 최상위 개념인 <strong>실행 컨텍스트</strong> 는 “코드가 실행되고 있는 <strong>구역</strong> 또는 <strong>범위</strong>“ 라는 정의에 맞게 아래와 같이 어느 영역에서 호출 및 실행되고 있느냐에 따라 구분할 수 있으며 각 컨텍스트에 따라서 하위 개념 및 구조 또한 달라진다.</p><ul><li><strong>전역(Global) 영역</strong> 에서 실행되고 있으면 <strong>전역 실행 컨텍스트</strong> </li><li>전역 컨텍스트에서 호출 및 실행된 <strong>함수(Function)의 영역</strong> 에서 실행되고 있으면 <strong>함수 실행 컨텍스트</strong>  </li></ul><p>그리고 모든 실행 컨텍스트는 아래와 같은 공통된 구조를 갖으며, 짧게 정의하자면, <strong>변수의 참조를 기록하는 환경</strong>이라 할 수 있겠다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ExecutionContext = &#123;</span><br><span class="line">  LexicalEnvironment = <span class="xml"><span class="tag">&lt;<span class="name">ref.</span> <span class="attr">to</span> <span class="attr">LexicalEnvironment</span> <span class="attr">in</span> <span class="attr">memory</span>&gt;</span>,</span></span><br><span class="line">  VariableEnvironment = &lt;ref. to VariableEnvironment in  memory&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>위 두개의 프로퍼티는 초기화 시에는 같은 객체를 바라보고 있으며 실행 컨텍스트가 호출 및 실행 영역에 따라 구분되는 것과 마찬가지로 각 바라보는 또는 Linked Object가 달라진다.</p><ul><li><strong>전역(Global) 실행 컨텍스트</strong> 의 프로퍼티라면<ul><li>Global Lexical Environment / Global Variable Environment</li></ul></li><li>일반 <strong>함수(Function) 실행 컨텍스트</strong> 의 프로퍼티라면<ul><li>Lexical Environment / Variable Environment</li></ul></li></ul><h4 id="2-Lexical-Environment"><a href="#2-Lexical-Environment" class="headerlink" title="2. Lexical Environment"></a>2. Lexical Environment</h4><p>한글로 “어휘적 환경” 또는 “정적 환경”라고 할 수 있으며 <strong>Javascirpt 코드에서 변수 또는 함수 식별자를 맵핑(identifier-variable mapping)하는데 사용되는 객체</strong>로 아래와 같은 환경으로 구성되어 있다. (여기서 <strong>식별자(identifier)</strong> 란 참조 대상 식별자로써 변수나 함수의 이름을 참조하며 <strong>변수</strong> 는 함수 객체와 배열 객체를 포함한 실제 객체 또는 원시값에 대한 참조이다.)</p><ul><li><strong>Lexical Environment</strong><ul><li>Outer Environment Reference 또는 Reference to the outer environment</li><li>Environment Record</li></ul></li></ul><h5 id="2-1-Outer-Environment-Reference"><a href="#2-1-Outer-Environment-Reference" class="headerlink" title="2.1 Outer Environment Reference"></a>2.1 Outer Environment Reference</h5><p><strong>식별자(identifier) 검색을 위해 외부 Lexical Environment를 참조하는 포인터</strong>로 중첩된 Javascript 코드에서 스코프 탐색을 위해 사용된다.</p><ul><li><strong>Global Lexical Environment</strong> 의 Outer Environment Reference 값은 <code>null</code> </li><li><strong>일반 Function 환경에서의 Lexical Environment</strong> 의 Outer Environment Reference 값은 해당 실행환경(Execution Context)의 <code>상위 실행환경의 Lexical Environment</code>를 참조</li></ul><h5 id="2-2-Environment-Record"><a href="#2-2-Environment-Record" class="headerlink" title="2.2 Environment Record"></a>2.2 Environment Record</h5><p>현재 유효범위 내의 값에 식별자들의 바인딩을 기록하는 객체로 모든 지역 변수(변수, 함수 등)를 프로퍼티로 저장하며  <code>this</code> 와 같은 기타 정보도 여기에 저장된다. </p><p>현재 레코드 타입가 포함된 실행 컨텍스트(Execution Context)에 따라 <strong>Global Environment Record</strong> 와 <strong>일반 Function 환경에서의 Environment Record</strong> 으로 구분할 수 있으며 담고 있는 데이터에 대한 속성 또한 달라진다.</p><p>해당 Record 타입의 구조는 실행 컨텍스트의 영역을 불문하고 아래의 레코드 타입을 갖는다:</p><ul><li><p><strong>Environment Record</strong></p><ul><li>Object Environment Record</li><li>Declarative Environment Record</li></ul></li></ul><h5 id="2-2-1-Object-Environment-Record"><a href="#2-2-1-Object-Environment-Record" class="headerlink" title="2.2.1 Object Environment Record"></a>2.2.1 Object Environment Record</h5><p>with 문과 같이 식별자(Identifier)를 특정 객체의 속성으로 취급할때 사용되며, 이를 위해 binding Object라는 속성으로 특정 객체를 가리킨다. 현재 레코드는 Environment Record를 상속한 서브 클래스이다.</p><p><strong>전역(Global) 실행 컨텍스트의 Object Environment Record (in Environment Record)</strong> 는 브라우저 환경의 경우 전역 객체로서 <code>window</code> 객체를 저장한다. 따라서 일반적인 함수(Function) 실행 컨텍스트와 다르게 Object, Array, Function과 같은 built-in global 객체와 전역 코드에서의 함수/변수 선언에 의해 생성된 모든 식별자 정보를 저장하며 찾을 수 있다. (이는 함수 실행 컨텍스트의 Environment Record와 다른 점이다.)</p><h5 id="2-2-2-Declarative-Environment-Record"><a href="#2-2-2-Declarative-Environment-Record" class="headerlink" title="2.2.2 Declarative Environment Record"></a>2.2.2 Declarative Environment Record</h5><p>이름에서 알 수 있듯이 <strong>변수 선언, 함수 선언, catch 절과 같은 문법요소의 효과</strong> 와 같은 정보를 정의하기 위해 사용된다. 즉, 식별자(Indentifier) 정보를 해당 레코드 타입에서 찾을 수 있다는 말이다. <strong>함수 코드에 대한 lexical environment</strong>는 해당 레코드 타입을 포함하며 하위 레코드 타입으로는 아래와 같다.</p><ul><li>Declarative Environment Record<ul><li>Function Environment Record</li><li>Module Environment Record</li></ul></li></ul><p><strong>전역(Global) 실행 컨텍스트의 Declarative Environment Record (in Environment Record)</strong> 는 함수(Function) 실행 컨텍스트의 Declarative Environment Record와 다르게 전역 코드에서 object Environment Record에 포함되지 않은 식별자 정보만 보유한다. 왜냐하면 하단 전역 환경에서의 object Environment Record가 해당 레코드의 역할을 가져가 버렸기 때문이다. </p><h4 id="3-Variable-Environment"><a href="#3-Variable-Environment" class="headerlink" title="3. Variable Environment"></a>3. Variable Environment</h4><p>LexicalEnvironment 와 funtion, 변수 식별자가 binding 되는 점을 포함해 동일하다. VariableEnvironment 또한 Lexical Environment이다. 그러나 만들어진 변수 선언 및 함수 선언에 대해 바인딩을 유지한다.</p><ul><li>LexicalEnvironment는 코드 실행 중에 실행 컨텍스트 내에서 변경될 수 있지만 VariableEnvironment는 항상 값을 유지한다.<ul><li>LexicalEnvironment는 일시적으로 LexicalEnvironment 하위에 새로운 환경을 가리킵니다.</li><li>이 새로운 환경은 임시 바인딩을 보유합니다.</li><li>그리고 임시 범위를 벗어나면 VariableEnvironment가 참조하고 있는 값으로 LexicalEnvironment를 복구합니다.</li></ul></li></ul><p>ES6 에서 LexicalEnvironment와 VariableEnvironment 둘의 차이점은 전자가 함수 선언과 변수 (<code>let</code>과 <code>const</code>)의 바인딩을 저장하고 후자는 변수 <code>var</code> 만 저장한다.</p><h4 id="4-정리-실행-컨텍스트의-구조"><a href="#4-정리-실행-컨텍스트의-구조" class="headerlink" title="4. 정리 - 실행 컨텍스트의 구조"></a>4. 정리 - 실행 컨텍스트의 구조</h4><h5 id="실행-컨텍스트-하위-구조"><a href="#실행-컨텍스트-하위-구조" class="headerlink" title="실행 컨텍스트 하위 구조"></a>실행 컨텍스트 하위 구조</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ExecutionContext &#x3D; &#123;</span><br><span class="line">  LexicalEnvironment &#x3D; &lt;ref. to LexicalEnvironment in memory&gt;,</span><br><span class="line">  VariableEnvironment &#x3D; &lt;ref. to VariableEnvironment in  memory&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="Lexical-Environment-구조"><a href="#Lexical-Environment-구조" class="headerlink" title="Lexical Environment 구조"></a>Lexical Environment 구조</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Lexical Environment &#x3D; &#123;</span><br><span class="line">  Outer Environment Reference,</span><br><span class="line">  Environment Record: &#123;</span><br><span class="line">    Object Environment Record,</span><br><span class="line">    Declarative Environment Record: &#123;</span><br><span class="line">      Function Environment Record,</span><br><span class="line">      Module Environment Record</span><br><span class="line">    &#125;,</span><br><span class="line">    This Binding</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="Variable-Environment-구조"><a href="#Variable-Environment-구조" class="headerlink" title="Variable Environment 구조"></a>Variable Environment 구조</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">EnvironmentRecord: &#123;</span><br><span class="line">  Outer Environment Reference,</span><br><span class="line">  Environment Record: &#123;</span><br><span class="line">    Object Environment Record,</span><br><span class="line">    Declarative Environment Record,</span><br><span class="line">    This Binding</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>여기까지 ES5 이전과 이후의 실행 컨텍스트(Execution Context)의 변화와 구조에 대해 알아봤습니다. 다음 포스트에서는 실제 예제를 가지고 위의 실행 컨텍스트 구조가 어떻게 형성되고 실행되는지 알아보겠습니다.</p><hr><h2 id="참조"><a href="#참조" class="headerlink" title="참조"></a>참조</h2><ul><li><a href="https://blog.bitsrc.io/understanding-execution-context-and-execution-stack-in-javascript-1c9ea8642dd0">Understanding Execution Context and Execution Stack in Javascript</a></li><li><a href="http://ecma-international.org/ecma-262/6.0/#sec-executable-code-and-execution-contexts">Executable Code and Execution Contexts - ecma-262 from ECMAScript</a></li><li><a href="https://iamsjy17.github.io/javascript/2019/06/10/js33_execution_context.html">[Javascript] Execution Context와 Lexical Environment - https://iamsjy17.github.io</a></li><li><a href="https://velog.io/@imacoolgirlyo/JS-%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8%EC%9D%98-Hoisting-The-Execution-Context-%ED%98%B8%EC%9D%B4%EC%8A%A4%ED%8C%85-%EC%8B%A4%ED%96%89-%EC%BB%A8%ED%85%8D%EC%8A%A4%ED%8A%B8-6bjsmmlmgy">[JS] 자바스크립트의 The Execution Context (실행 컨텍스트) 와 Hoisting (호이스팅) - https://velog.io/@imacoolgirlyo</a></li><li><a href="https://meetup.toast.com/posts/129">자바스크립트 함수 (3) - Lexical Environment - meetup.toast.com</a></li><li><a href="https://meetup.toast.com/posts/86">자바스크립트의 스코프와 클로저 - meetup.toast.com</a></li><li><a href="https://ko.javascript.info/closure#ref-2405">변수의 유효범위와 클로저 - https://ko.javascript.info</a></li></ul>]]></content:encoded>
      
      
      <category domain="https://joontae-kim.github.io/categories/Programming/">Programming</category>
      
      <category domain="https://joontae-kim.github.io/categories/Programming/Javascript/">Javascript</category>
      
      
      <category domain="https://joontae-kim.github.io/tags/javascript/">javascript</category>
      
      <category domain="https://joontae-kim.github.io/tags/javascript-engine/">javascript engine</category>
      
      <category domain="https://joontae-kim.github.io/tags/execution-context/">execution context</category>
      
      <category domain="https://joontae-kim.github.io/tags/execution/">execution</category>
      
      <category domain="https://joontae-kim.github.io/tags/context/">context</category>
      
      
      <comments>https://joontae-kim.github.io/2020/10/15/excution-context-2/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>Dev To Read</title>
      <link>https://joontae-kim.github.io/2020/10/14/Blog-to-read/</link>
      <guid>https://joontae-kim.github.io/2020/10/14/Blog-to-read/</guid>
      <pubDate>Tue, 13 Oct 2020 17:40:15 GMT</pubDate>
      
        
        
      <description>&lt;h3 id=&quot;Blog-To-Read-In-Dev&quot;&gt;&lt;a href=&quot;#Blog-To-Read-In-Dev&quot; class=&quot;headerlink&quot; title=&quot;Blog To Read In Dev&quot;&gt;&lt;/a&gt;Blog To Read In Dev&lt;/h3&gt;&lt;ul&gt;
</description>
        
      
      
      
      <content:encoded><![CDATA[<h3 id="Blog-To-Read-In-Dev"><a href="#Blog-To-Read-In-Dev" class="headerlink" title="Blog To Read In Dev"></a>Blog To Read In Dev</h3><ul><li>Blocking-NonBlocking-Synchronous-Asynchronous<ul><li><a href="https://homoefficio.github.io/2017/02/19/Blocking-NonBlocking-Synchronous-Asynchronous/">https://homoefficio.github.io/2017/02/19/Blocking-NonBlocking-Synchronous-Asynchronous/</a></li></ul></li><li>GET이냐 POST냐 그것이 문제로다<ul><li><a href="https://homoefficio.github.io/2019/12/25/GET%EC%9D%B4%EB%83%90-POST%EB%83%90-%EA%B7%B8%EA%B2%83%EC%9D%B4-%EB%AC%B8%EC%A0%9C%EB%A1%9C%EB%8B%A4/">https://homoefficio.github.io/2019/12/25/GET%EC%9D%B4%EB%83%90-POST%EB%83%90-%EA%B7%B8%EA%B2%83%EC%9D%B4-%EB%AC%B8%EC%A0%9C%EB%A1%9C%EB%8B%A4/</a></li></ul></li><li>객체 지향 프로그래밍과 메시징<ul><li><a href="https://homoefficio.github.io/2019/07/04/%EA%B0%9D%EC%B2%B4-%EC%A7%80%ED%96%A5-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D%EA%B3%BC-%EB%A9%94%EC%8B%9C%EC%A7%95/">https://homoefficio.github.io/2019/07/04/%EA%B0%9D%EC%B2%B4-%EC%A7%80%ED%96%A5-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D%EA%B3%BC-%EB%A9%94%EC%8B%9C%EC%A7%95/</a></li></ul></li><li>Back to the Essence - Concurrency vs Parallelism<ul><li><a href="https://homoefficio.github.io/2019/02/02/Back-to-the-Essence-Concurrency-vs-Parallelism/">https://homoefficio.github.io/2019/02/02/Back-to-the-Essence-Concurrency-vs-Parallelism/</a></li></ul></li><li>Client-Side Rendering (CSR)<ul><li><a href="https://advancedweb.dev/client-side-rendering">https://advancedweb.dev/client-side-rendering</a></li></ul></li><li>Cracking The Frontend interview, Part 4: Javascript<ul><li><a href="https://advancedweb.dev/frontend-interview-part-4-javascript">https://advancedweb.dev/frontend-interview-part-4-javascript</a></li></ul></li><li>Intro to ES6<ul><li><a href="https://andrew.hedges.name/es6/">https://andrew.hedges.name/es6/</a></li></ul></li><li>Introducing the new features that ECMAScript 2016 (ES7) adds to JavaScript<ul><li><a href="https://www.freecodecamp.org/news/ecmascript-2016-es7-features-86903c5cab70/">https://www.freecodecamp.org/news/ecmascript-2016-es7-features-86903c5cab70/</a></li></ul></li><li>2020년 상반기 회고<ul><li><a href="https://medium.com/@pks2974/2020%EB%85%84-%EC%83%81%EB%B0%98%EA%B8%B0-%ED%9A%8C%EA%B3%A0-6db69bd77bfe">https://medium.com/@pks2974/2020%EB%85%84-%EC%83%81%EB%B0%98%EA%B8%B0-%ED%9A%8C%EA%B3%A0-6db69bd77bfe</a></li></ul></li><li>동기식 처리 모델 vs 비동기식 처리 모델<ul><li><a href="https://poiemaweb.com/js-async">https://poiemaweb.com/js-async</a></li></ul></li><li>[Web] Web Server와 WAS의 차이와 웹 서비스 구조<ul><li><a href="https://gmlwjd9405.github.io/2018/10/27/webserver-vs-was.html">https://gmlwjd9405.github.io/2018/10/27/webserver-vs-was.html</a></li></ul></li><li>What are Node, NPM, NVM, Yarn, Babel, Webpack and Loader<ul><li><a href="https://medium.com/@imsabitaneupane/what-are-node-npm-nvm-yarn-babel-webpack-and-loader-347f10a9a5cf">https://medium.com/@imsabitaneupane/what-are-node-npm-nvm-yarn-babel-webpack-and-loader-347f10a9a5cf</a></li></ul></li></ul>]]></content:encoded>
      
      
      <category domain="https://joontae-kim.github.io/categories/Blog/">Blog</category>
      
      <category domain="https://joontae-kim.github.io/categories/Blog/Blog-To-Read/">Blog To Read</category>
      
      
      
      <comments>https://joontae-kim.github.io/2020/10/14/Blog-to-read/#disqus_thread</comments>
      
    </item>
    
  </channel>
</rss>
