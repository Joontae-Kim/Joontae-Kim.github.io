<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8" />

    

    
    <title>프론트엔드 면접 질문 리스트 - JS | dev and dev</title>
    
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    
    <meta name="keywords" content="Front-end,Interview,Job,Javascript" />
    
    <meta name="description" content="프론트엔드 면접 준비를 위한 질문 리스트 정리Javascript아래질문 리스트를 기반으로 면접 질문 &amp; 답변 목록을 작성할 예정이고, 지속적으로 보충 or 보수할 계획입니다. 업데이트 날짜  2020-10-26 2021-07-02 Javascript 질문 목록 수정   2021-07-23 2021-07-24 2021-07-25 Javascript">
<meta property="og:type" content="article">
<meta property="og:title" content="프론트엔드 면접 질문 리스트 - JS">
<meta property="og:url" content="https://joontae-kim.github.io/2020/10/26/interview-question-js-1/index.html">
<meta property="og:site_name" content="dev and dev">
<meta property="og:description" content="프론트엔드 면접 준비를 위한 질문 리스트 정리Javascript아래질문 리스트를 기반으로 면접 질문 &amp; 답변 목록을 작성할 예정이고, 지속적으로 보충 or 보수할 계획입니다. 업데이트 날짜  2020-10-26 2021-07-02 Javascript 질문 목록 수정   2021-07-23 2021-07-24 2021-07-25 Javascript">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://joontae-kim.github.io/images/job_thumbnail.jpeg">
<meta property="article:published_time" content="2020-10-26T08:19:17.000Z">
<meta property="article:modified_time" content="2021-08-12T10:15:37.279Z">
<meta property="article:author" content="Joontae Kim">
<meta property="article:tag" content="Front-end">
<meta property="article:tag" content="Interview">
<meta property="article:tag" content="Job">
<meta property="article:tag" content="Javascript">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://joontae-kim.github.io/images/job_thumbnail.jpeg">
    
    <link rel="canonical" href="https://joontae-kim.github.io/2020/10/26/interview-question-js-1/"/>

    
        <link rel="alternate" href="/" title="dev and dev" type="application/atom+xml" />
    

    
        <link rel="icon" href="/favicon.png" />
    

    
<link rel="stylesheet" href="/libs/font-awesome/css/font-awesome.min.css">

    <!-- 
<link rel="stylesheet" href="/libs/titillium-web/styles.css">
 -->
    <!-- 
<link rel="stylesheet" href="/libs/NanumSquareRound/styles.css">
 -->
    
<link rel="stylesheet" href="/libs/NotoSans/styles.css">

    
<link rel="stylesheet" href="/libs/source-code-pro/styles.css">


    
<link rel="stylesheet" href="/css/style.css">


    
<script src="/libs/jquery/3.5.0/jquery.min.js"></script>

    
    
        
<link rel="stylesheet" href="/libs/lightgallery/css/lightgallery.min.css">

    
    
        
<link rel="stylesheet" href="/libs/justified-gallery/justifiedGallery.min.css">

    
    
        <script type="text/javascript">
(function(i,s,o,g,r,a,m) {i['GoogleAnalyticsObject']=r;i[r]=i[r]||function() {
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','//www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-178685368-1', 'auto');
ga('send', 'pageview');

</script>

    
    
    


<meta name="generator" content="Hexo 5.2.0"></head>

<body>
    <div id="wrap">
        <header id="header">
    <div id="header-outer" class="outer">
        <div class="container">
            <div class="container-inner">
                <div id="header-title">
                    <h1 class="logo-wrap">
                        <a href="/" class="logo"></a>
                    </h1>
                    
                </div>
                <div id="header-inner" class="nav-container">
                    <a id="main-nav-toggle" class="nav-icon fa fa-bars"></a>
                    <div class="nav-container-inner">
                        <ul id="main-nav">
                            
                                <li class="main-nav-list-item" >
                                    <a class="main-nav-list-link" href="/">Home</a>
                                </li>
                            
                                <li class="main-nav-list-item" >
                                    <a class="main-nav-list-link" href="/about/index.html">About</a>
                                </li>
                            
                                    <ul class="main-nav-list"><li class="main-nav-list-item"><a class="main-nav-list-link" href="/categories/Blog/">Blog</a><ul class="main-nav-list-child"><li class="main-nav-list-item"><a class="main-nav-list-link" href="/categories/Blog/Blog-To-Read/">Blog To Read</a></li><li class="main-nav-list-item"><a class="main-nav-list-link" href="/categories/Blog/Hexo/">Hexo</a></li><li class="main-nav-list-item"><a class="main-nav-list-link" href="/categories/Blog/Job/">Job</a></li></ul></li><li class="main-nav-list-item"><a class="main-nav-list-link" href="/categories/Programming/">Programming</a><ul class="main-nav-list-child"><li class="main-nav-list-item"><a class="main-nav-list-link" href="/categories/Programming/Algorithm/">Algorithm</a></li><li class="main-nav-list-item"><a class="main-nav-list-link" href="/categories/Programming/Basic/">Basic</a></li><li class="main-nav-list-item"><a class="main-nav-list-link" href="/categories/Programming/Javascript/">Javascript</a></li><li class="main-nav-list-item"><a class="main-nav-list-link" href="/categories/Programming/nuxt/">nuxt</a></li></ul></li><li class="main-nav-list-item"><a class="main-nav-list-link" href="/categories/Study/">Study</a><ul class="main-nav-list-child"><li class="main-nav-list-item"><a class="main-nav-list-link" href="/categories/Study/Browser/">Browser</a></li><li class="main-nav-list-item"><a class="main-nav-list-link" href="/categories/Study/Git/">Git</a></li><li class="main-nav-list-item"><a class="main-nav-list-link" href="/categories/Study/Rendering/">Rendering</a></li><li class="main-nav-list-item"><a class="main-nav-list-link" href="/categories/Study/Webpack/">Webpack</a></li></ul></li><li class="main-nav-list-item"><a class="main-nav-list-link" href="/categories/assignment/">assignment</a></li><li class="main-nav-list-item"><a class="main-nav-list-link" href="/categories/course/">course</a><ul class="main-nav-list-child"><li class="main-nav-list-item"><a class="main-nav-list-link" href="/categories/course/node-all-in-one/">node_all_in_one</a></li></ul></li></ul>
                                
                        </ul>
                        <nav id="sub-nav">
                            <div id="search-form-wrap">

    <form class="search-form">
        <input type="text" class="ins-search-input search-form-input" placeholder="Search" />
        <button type="submit" class="search-form-submit"></button>
    </form>
    <div class="ins-search">
    <div class="ins-search-mask"></div>
    <div class="ins-search-container">
        <div class="ins-input-wrapper">
            <input type="text" class="ins-search-input" placeholder="Type something..." />
            <span class="ins-close ins-selectable"><i class="fa fa-times-circle"></i></span>
        </div>
        <div class="ins-section-wrapper">
            <div class="ins-section-container"></div>
        </div>
    </div>
</div>
<script>
(function (window) {
    var INSIGHT_CONFIG = {
        TRANSLATION: {
            POSTS: 'Posts',
            PAGES: 'Pages',
            CATEGORIES: 'Categories',
            TAGS: 'Tags',
            UNTITLED: '(Untitled)',
        },
        ROOT_URL: '/',
        CONTENT_URL: '/content.json',
    };
    window.INSIGHT_CONFIG = INSIGHT_CONFIG;
})(window);
</script>

<script src="/js/insight.js"></script>


</div>
                        </nav>
                    </div>
                </div>
            </div>
        </div>
    </div>
</header>

        <div class="container">
            <div class="main-body container-inner">
                <div class="main-body-inner">
                    <section id="main">
                        <div class="main-body-header">
    <h1 class="header">
    
    <a class="page-title-link" href="/categories/Blog/">Blog</a><i class="icon fa fa-angle-right"></i><a class="page-title-link" href="/categories/Blog/Job/">Job</a>
    </h1>
</div>

                        <div class="main-body-content">
                            <article id="post-interview-question-js-1" class="article article-single article-type-post" itemscope itemprop="blogPost">
    <div class="article-inner">
        
            <header class="article-header">
                
    
        <h1 class="article-title" itemprop="name">
        프론트엔드 면접 질문 리스트 - JS
        </h1>
    
    <h2 class="article-subtitle">
        Javascript 인터뷰 질문 리스트 1
    </h2>


            </header>
        
        
            <div class="article-meta">
                
  <div class="article-date">
    <i class="fa fa-calendar"></i>
    <a href="/2020/10/26/interview-question-js-1/" class="article-date">
       <time datetime="2020-10-26T08:19:17.000Z" itemprop="datePublished">2020-10-26</time>
    </a>
  </div>


<div class="article-date">
  <i class="fa fa-calendar-plus-o"></i>
  <a href="/2020/10/26/interview-question-js-1/" class="article-date">
     <time datetime="2021-08-12T10:15:37.279Z" itemprop="dateModified">2021-08-12</time>
  </a>
</div>


                

                
    <div class="article-tag">
        <i class="fa fa-tag"></i>
        <a class="tag-link-link" href="/tags/Front-end/" rel="tag">Front-end</a>, <a class="tag-link-link" href="/tags/Interview/" rel="tag">Interview</a>, <a class="tag-link-link" href="/tags/Javascript/" rel="tag">Javascript</a>, <a class="tag-link-link" href="/tags/Job/" rel="tag">Job</a>
    </div>

                

                

            </div>
        
        
        <div class="article-entry" itemprop="articleBody">
            

            

            

            <p><img src="/images/job_thumbnail.jpeg" alt="면접!"></p>
<h2 id="프론트엔드-면접-준비를-위한-질문-리스트-정리"><a href="#프론트엔드-면접-준비를-위한-질문-리스트-정리" class="headerlink" title="프론트엔드 면접 준비를 위한 질문 리스트 정리"></a>프론트엔드 면접 준비를 위한 질문 리스트 정리</h2><h3 id="Javascript"><a href="#Javascript" class="headerlink" title="Javascript"></a>Javascript</h3><p>아래질문 리스트를 기반으로 면접 질문 &amp; 답변 목록을 작성할 예정이고, 지속적으로 보충 or 보수할 계획입니다.</p>
<p>업데이트 날짜</p>
<ul>
<li>2020-10-26</li>
<li>2021-07-02<ul>
<li>Javascript 질문 목록 수정</li>
</ul>
</li>
<li>2021-07-23</li>
<li>2021-07-24</li>
<li>2021-07-25<ul>
<li>Javascript 질문 추가 및 수정</li>
<li>답변 추가 및 수정</li>
</ul>
</li>
</ul>
<h3 id="질문-목록"><a href="#질문-목록" class="headerlink" title="질문 목록"></a>질문 목록</h3><ul>
<li><p>질문 목록</p>
<ol>
<li><p>자바스크립트의 원시 타입(Primitive Data Type)은 몇가지이며, 전부 말해달라</p>
<ul>
<li>Number, String, Boolean, Null, Undefined, Symbol</li>
<li>Null vs Undefined</li>
</ul>
</li>
<li><p>Pass by Value &amp; Pass by Reference</p>
</li>
<li><p><code>function foo() &#123;&#125;</code> 와 <code>var foo = function() &#123;&#125;</code> 에서 foo 의 차이가 무엇인지 설명해보세요.</p>
<ul>
<li>함수 선언식과 함수 표현식의 차이</li>
</ul>
</li>
<li><p>이벤트 루프와 동시성 모델에 대해서 설명해달라</p>
</li>
<li><p>실행 컨텍스트(Execution Context)에 대해 설명해달라</p>
</li>
<li><p>Javascript Scope Chaining이란 무엇인가</p>
</li>
<li><p>scope란 무엇이며 <code>var</code>, <code>let</code>, <code>const</code>에 대해 설명해달라</p>
</li>
<li><p>전역 scope를 사용했을 때 장단점에 관해 설명해달라</p>
</li>
<li><p>자바스크립트의 호이스팅(Hoisting)은 어떻게 이루어져 있는가</p>
</li>
<li><p>클로저(Closure)란 무엇이며, 어떻게 사용하는지, 왜 이러한 패턴을 사용하는가</p>
</li>
<li><p>This</p>
<ul>
<li>자바스크립트에서 This는 몇가지로 추론 될수 있는가, 아는대로 말해달라</li>
<li>일반함수의 this와 화살표 함수의 this는 어떻게 다른가?</li>
<li>use strict모드에서의 this?</li>
</ul>
</li>
<li><p>Call, Apply, Bind 함수에 대해 설명해달라</p>
</li>
<li><p>객체 지향 프로그래밍(Object Oriented Programming)과 프로토타입이란 무엇인가</p>
<ul>
<li>OOP에 특징에 대해 설명해달라(상속, 캡슐화 등등…)<ul>
<li>현실에 상황을 예로 들어 OOP의 개념으로 설계과정을 설명해달라</li>
<li>ex) 축구를 게임으로 만든다거나, 기타 어떠한 상황이라도 좋다</li>
</ul>
</li>
<li>프로토타입 상속이 이루어지는 법</li>
</ul>
</li>
<li><p>OOP와 함수형 프로그래밍의 차이</p>
<ul>
<li><p>함수형 프로그래밍에 대해 설명해달라</p>
</li>
<li><p>함수형 프로그래밍에 개념에서 순수함수란 무엇인가</p>
</li>
<li><p>OOP와 함수형 프로그래밍의 가장 큰 차이점은 무엇인가</p>
</li>
</ul>
</li>
<li><p>즉시 실행 함수(IIFE)란 무엇이며 언제 사용하는 것인가</p>
</li>
<li><p>비동기 프로그래밍</p>
<ul>
<li>동기 함수와 비동기 함수란 무엇인가<ul>
<li>Callback, Promise 란 무엇이며 각각의 장단점에 대해 설명해달라</li>
</ul>
</li>
<li>Promise 코드가 어떻게 구성되어있는가</li>
<li>Async, Await는 무엇이며 Promise의 차이는</li>
</ul>
</li>
</ol>
</li>
</ul>
<hr>
<h3 id="1-자바스크립트의-원시-타입-Primitive-Data-Type-은-몇가지이며-전부-말해달라"><a href="#1-자바스크립트의-원시-타입-Primitive-Data-Type-은-몇가지이며-전부-말해달라" class="headerlink" title="1. 자바스크립트의 원시 타입(Primitive Data Type)은 몇가지이며, 전부 말해달라"></a>1. 자바스크립트의 원시 타입(Primitive Data Type)은 몇가지이며, 전부 말해달라</h3><p>프로그래밍 언어에서 자료형(types) 또는 데이터 타입(data type) 이란 숫자형(정수형, 실수형), 논리값(Boolean), 문자(String) 등의 데이터를 식별하는 분류 (indentifier) 로써, Javascript에서는 다음과 같이 Boolean, Null, Undefined, Number, String, Object 데이터 유형이 있으며 Symbol은 ECMAScript 6에 신규 추가되었습니다. 이 데이터 유형은 원시형(Primitives)과 참조형(Reference)으로 구분할 수 있으며 <strong>원시형 데이터 타입 (Primitives)</strong> 으로는</p>
<ul>
<li>Boolean</li>
<li>Null</li>
<li>Undefined</li>
<li>Number</li>
<li>String</li>
<li>Symbol</li>
</ul>
<p>이 있습니다.</p>
<p>원시형(Primitives) 데이터 타입의 <strong>특징</strong>은 아래와 같습니다.</p>
<ul>
<li><strong>단 하나의 값만</strong> 가질 수 있음</li>
<li>변수에 할당될 때 <strong>스택 메모리</strong> 상에 <strong>고정된 크기</strong>로 저장</li>
<li>모든 원시 값은 <strong>불변 (immutable</strong>)의 성질로 변형 불가<ul>
<li>즉, 원시값을 교체할 수는 있지만, 직접 변형할 수는 없음<ul>
<li>객체가 아니면서 메서드도 가지지 않는 데이터</li>
<li>Null의 경우, 겉보기엔 원시 값처럼 보이는  있지만, 사실 <strong>Object</strong> 이며, 모든 구조화된 자료형은 <code>prototype chain</code> 에 따라 Null의 자손이다.</li>
<li>대부분의 경우, 원시 값은 언어 구현체의 가장 저수준(low level) 에서 나타남.</li>
<li>원시 값 자체와, 원시값을 할당한 변수를 혼동하지 않는 것이 중요!</li>
</ul>
</li>
<li>변수: 새로운 값을 다시 할당 가능</li>
<li>원시값: 객체, 배열, 함수와 달리 변형 불가능<ul>
<li><strong>값에 의한 전달 (pass-by-value) 방식</strong>으로 전달</li>
<li>Number, String, Boolean, Null, Undefined, (Symbol)</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="부록-Reference-Type-참조형"><a href="#부록-Reference-Type-참조형" class="headerlink" title="부록 - Reference Type (참조형)"></a>부록 - Reference Type (참조형)</h3><ul>
<li><strong>객체는</strong> 데이터와 그 데이터에 관련한 동작(절차, 방법, 기능)을 모두 포함할 수 있는 개념적 존재<ul>
<li>즉, <strong>Property</strong>와 <strong>Method</strong>를 포함할 수 있는 독립적 주체이자 <strong>복합적 구조의 데이터</strong></li>
</ul>
</li>
<li>데이터가 동적 바인딩 되므로 실행중에도 그 값이 변동될 수 있으며, 선언될때 크기가 정해져 있지 않음</li>
<li>JavaScript는 객체 기반의 스크립트 언어로써 JavaScript를 이루고 있는 거의 모든 것이 객체이다.<ul>
<li>원시 타입을 제외한 <strong>나머지 값들(배열, 함수, 정규표현식 등)은 모두 객체</strong>이다.</li>
</ul>
</li>
<li>참조 타입은 변수의 값이 저장된 메모리 블럭의 주소를 가지고 있고 자바스크립트 엔진이 <strong>변수가 가지고 있는 메모리 주소를 이용해서 변수의 값에 접근</strong>한다.<ul>
<li>변수에 할당이 될 때 <strong>값이 직접 해당 변수에 저장될 수 없으며 변수에는 데이터에 대한 참조만 저장</strong></li>
<li>변수의 값이 저장된 <strong>힙 메모리의 주소값을 저장</strong></li>
</ul>
</li>
<li><strong>객체</strong>와 <strong>함수</strong> 는 언어의 다른 기본 요소임.<ul>
<li>객체 <code>=&gt;</code> 값을 위한 컨테이너</li>
<li>함수 <code>=&gt;</code> 어플리케이션이 수행할 수 있는 절차 (procedure)</li>
</ul>
</li>
</ul>
<h4 id="Null-vs-Undefined"><a href="#Null-vs-Undefined" class="headerlink" title="Null vs Undefined"></a>Null vs Undefined</h4><p><code>Undefined</code>는 변수를 선언하고 값을 할당하지 않은 상태, <code>Null</code>은 변수를 선언하고 빈 값을 할당한 상태(빈 객체)이다. 즉, <code>Undefined</code>는 자료형이 없는 상태이다.<br>따라서 <strong>typeof</strong> 를 통해 자료형을 확인해보면 <code>null</code>은 <code>object</code>로, <code>undefined</code>는 <code>undefined</code>가 출력되는 것을 확인할 수 있다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typeof</span> <span class="literal">null</span> <span class="comment">// &#x27;object&#x27;</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="literal">undefined</span> <span class="comment">// &#x27;undefined&#x27;</span></span><br><span class="line"><span class="literal">null</span> === <span class="literal">undefined</span> <span class="comment">// false</span></span><br><span class="line"><span class="literal">null</span> == <span class="literal">undefined</span> <span class="comment">// true</span></span><br><span class="line"><span class="literal">null</span> === <span class="literal">null</span> <span class="comment">// true</span></span><br><span class="line"><span class="literal">null</span> == <span class="literal">null</span> <span class="comment">// true</span></span><br><span class="line">!<span class="literal">null</span> <span class="comment">// true</span></span><br><span class="line"><span class="built_in">isNaN</span>(<span class="number">1</span> + <span class="literal">null</span>) <span class="comment">// false</span></span><br><span class="line"><span class="built_in">isNaN</span>(<span class="number">1</span> + <span class="literal">undefined</span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<ul>
<li><code>Null</code> <ul>
<li><code>null</code>은 <strong>원시값(Primitive Type) 중 하나</strong> 로, <em>어떤 값이 의도적으로 비어있음을 표현</em> 한다. </li>
<li>undefined는 값이 지정되지 않은 경우를 의미하지만, <code>null</code>의 경우에는 해당 변수가 어떤 객체도 가리키고 있지 않다는 것을 의미한다.</li>
<li><code>null</code>은 <code>undefined</code> 처럼 전역 객체의 속성 중 하나가 아니라 <strong>리터럴 값</strong> 이다.</li>
</ul>
</li>
<li><code>Undefined</code><ul>
<li><code>undefined</code>는 <strong>원시값(Primitive Type)</strong> 으로, 선언한 후에 값을 할당하지 않은 변수나 값이 주어지지 않은 인수에 자동으로 할당된다. 이 값은 <em>전역 객체의 속성 중 하나</em> 로, 전역 스코프에서의 변수이기도 하다.</li>
<li>따라서 undefined 변수의 초기 값은 undefined 원시 값이다.</li>
<li>아래의 경우에 변수가 undefined를 반환한다.<ul>
<li>값을 할당하지 않은 변수</li>
<li>메서드와 선언에서 변수가 할당받지 않은 경우</li>
<li>함수가 값을 return 하지 않았을 때</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="2-Pass-by-Value-amp-Pass-by-Reference"><a href="#2-Pass-by-Value-amp-Pass-by-Reference" class="headerlink" title="2. Pass by Value &amp; Pass by Reference"></a>2. Pass by Value &amp; Pass by Reference</h3><p><strong>Pass by Value, Pass by Reference</strong> 는 인수(Arguements)를 함수에 전달할때 데이터 유형에 따라 어떻게 넘겨줄지 결정하는 것으로, <strong>Call by ~</strong> 는 함수의 입장에서, <strong>Pass by  ~</strong> 는 인수의 입장에서 설명되는 차이가 있다.</p>
<h4 id="Pass-by-Value-값의-복사에-의한-전달"><a href="#Pass-by-Value-값의-복사에-의한-전달" class="headerlink" title="Pass by Value (값의 복사에 의한 전달)"></a>Pass by Value (값의 복사에 의한 전달)</h4><p>Pass by Value는 인자로 넘기는 <strong>값을 그대로 복사해서</strong> 함수에 전달하는 방식입니다. 주로 Javascript 데이터 유형 중 원시값의 데이터 유형이 Pass by Value가 일어납니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">callByValue</span>(<span class="params">varOne, varTwo</span>) </span>&#123; </span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;Inside Call by Value Method&quot;</span>); </span><br><span class="line">  varOne = <span class="number">100</span>; </span><br><span class="line">  varTwo = <span class="number">200</span>; </span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;varOne =&quot;</span> + varOne +<span class="string">&quot;varTwo =&quot;</span> +varTwo); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> varOne = <span class="number">10</span>; </span><br><span class="line"><span class="keyword">let</span> varTwo = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;Before Call by Value Method&quot;</span>); </span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;varOne =&quot;</span> + varOne +<span class="string">&quot;varTwo =&quot;</span> +varTwo); </span><br><span class="line"></span><br><span class="line">callByValue(varOne, varTwo) </span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;After Call by Value Method&quot;</span>); </span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;varOne =&quot;</span> + varOne +<span class="string">&quot;varTwo =&quot;</span> +varTwo); </span><br><span class="line"></span><br><span class="line">output will be : </span><br><span class="line">--------------- </span><br><span class="line">Before Call by Value Method </span><br><span class="line">varOne = <span class="number">10</span> varTwo = <span class="number">20</span> </span><br><span class="line">Inside Call by Value Method </span><br><span class="line">varOne = <span class="number">100</span> varTwo = <span class="number">200</span> </span><br><span class="line">After Call by Value Method </span><br><span class="line">varOne = <span class="number">10</span> varTwo = <span class="number">20</span></span><br></pre></td></tr></table></figure>



<h4 id="Pass-by-Reference-참조에-의한-전달"><a href="#Pass-by-Reference-참조에-의한-전달" class="headerlink" title="Pass by Reference (참조에 의한 전달)"></a>Pass by Reference (참조에 의한 전달)</h4><p>Pass by Reference는 인자로 넘기는 <strong>값의 메모리상의 주소</strong> 를 복사해 함수에 전달하는 방식입니다. 주로 Javascript 데이터 유형 중 객체 유형의 데이터가 Pass by Reference가 일어납니다.  만약 우리가 메서드에 인자로써 객체 또는 배열을 전달한다면 객체의 값을 변경할 수 있는 가능성이 생깁니다.</p>
<h3 id="3-function-foo-와-var-foo-function-에서-foo-의-차이가-무엇인지-설명해보세요"><a href="#3-function-foo-와-var-foo-function-에서-foo-의-차이가-무엇인지-설명해보세요" class="headerlink" title="3. function foo() {} 와 var foo = function() {} 에서 foo 의 차이가 무엇인지 설명해보세요."></a>3. <code>function foo() &#123;&#125;</code> 와 <code>var foo = function() &#123;&#125;</code> 에서 foo 의 차이가 무엇인지 설명해보세요.</h3><blockquote>
<p>함수 선언식(Function Declarations)과 함수 표현식(Function Expressions)의 차이</p>
</blockquote>
<h4 id="함수-선언식-Function-Declarations"><a href="#함수-선언식-Function-Declarations" class="headerlink" title="함수 선언식(Function Declarations)"></a>함수 선언식(Function Declarations)</h4><p>일반적 함수 선언과 비슷한 형태</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 예시</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">funcDeclarations</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&#x27;A function declaration&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">funcDeclarations(); <span class="comment">// &#x27;A function declaration&#x27;</span></span><br></pre></td></tr></table></figure>

<h4 id="함수-표현식-Function-Expressions"><a href="#함수-표현식-Function-Expressions" class="headerlink" title="함수 표현식(Function Expressions)"></a>함수 표현식(Function Expressions)</h4><p>유연한 자바스크립트 언어의 특징을 활용한 선언 방식</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 예시</span></span><br><span class="line"><span class="keyword">var</span> funcExpression = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;A function expression&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line">funcExpression(); <span class="comment">// &#x27;A function expression&#x27;</span></span><br></pre></td></tr></table></figure>

<h4 id="함수-선언식-Function-Declarations-과-함수-표현식-Function-Expressions-의-차이"><a href="#함수-선언식-Function-Declarations-과-함수-표현식-Function-Expressions-의-차이" class="headerlink" title="함수 선언식(Function Declarations)과 함수 표현식(Function Expressions)의 차이"></a>함수 선언식(Function Declarations)과 함수 표현식(Function Expressions)의 차이</h4><ul>
<li><strong><em>함수 선언식은 호이스팅에 영향을 받지만, 함수 표현식은 호이스팅에 영향을 받지 않는다.</em></strong></li>
</ul>
<p>함수 선언식은 코드를 구현한 위치와 관계없이 자바스크립트의 특징인 호이스팅에 따라 브라우저가 자바스크립트를 해석할 때 맨 위로 끌어 올려진다.</p>
<p>예를 들어, 아래의 코드를 실행할 때</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 실행 전</span></span><br><span class="line">funcDeclarations();</span><br><span class="line">funcExpression();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">funcDeclarations</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&#x27;worked&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> funcExpression = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">10</span> + <span class="number">20</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>Javascript 해석기에 의해 분석된 코드는 호이스팅이 적용되 아래와 같습니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 실행 시</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">funcDeclarations</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&#x27;It/&#x27;</span>s func Declarations<span class="string">&#x27;;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">var funcExpression;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">funcDeclarations(); // &#x27;</span>It/<span class="string">&#x27;s func Declarations&#x27;</span></span><br><span class="line">funcExpression(); <span class="comment">// Uncaught TypeError: funcExpression is not a function</span></span><br><span class="line"></span><br><span class="line">funcExpression = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&#x27;It/&#x27;</span>s func Expression<span class="string">&#x27;;</span></span><br><span class="line"><span class="string">&#125;;</span></span><br></pre></td></tr></table></figure>

<p><code>funcExpression</code> 에 할당될 function 로직은 호출된 이후에 선언되므로, funcExpression 는 함수로 인식하지 않고 변수로 인식한다. 즉, <strong><em>선언은 위에서 됐지만 할당이 아래에서 이루어집니다.</em></strong></p>
<h4 id="함수-표현식-Function-Expressions-의-장점"><a href="#함수-표현식-Function-Expressions-의-장점" class="headerlink" title="함수 표현식(Function Expressions)의 장점"></a>함수 표현식(Function Expressions)의 장점</h4><ul>
<li>함수 표현식이 호이스팅에 영향을 받지 않는다</li>
<li><code>Closure</code> 로 사용 (With Scope)</li>
<li><code>Callback</code> 으로 사용 (다른 함수의 인자로 넘길 수 있음)</li>
</ul>
<h5 id="함수-표현식을-사용한-Closure-생성"><a href="#함수-표현식을-사용한-Closure-생성" class="headerlink" title="함수 표현식을 사용한 Closure 생성"></a>함수 표현식을 사용한 Closure 생성</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">tabsHandler</span>(<span class="params">index</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">tabClickEvent</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">        <span class="comment">// 바깥 함수인 tabsHandler() 의 index 인자를 여기서 접근할 수 있다.</span></span><br><span class="line">        <span class="built_in">console</span>.log(index); <span class="comment">// 탭을 클릭할 때 마다 해당 탭의 index 값을 표시</span></span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> tabs = <span class="built_in">document</span>.querySelectorAll(<span class="string">&#x27;.tab&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> i;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; tabs.length; i += <span class="number">1</span>) &#123;</span><br><span class="line">    tabs[i].onclick = tabsHandler(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>위 코드는 <code>.tab</code> class를 가진 DOM 요소에 <code>tabsHandler</code> 함수를 onClick 이벤트로 바인드하는 예제로 각 탭을 클릭했을때 <code>tabsHandler</code>의 인자로 전달된 <code>i</code> 를 반환하도록 설계되어 있다.<br>여기서 주목할 점은 탭을 클릭했을때 <code>tabsHandler</code>의 내부 <code>tabClickEvent</code>에서 <code>console.log(index)</code> 하기 위해 클로저 속성을 이용해 <code>tabsHandler</code> 함수가 가지고 있는 <code>index</code> 변수에 접근하며 각 탭을 클릭할때마다 서로 다른 클로저로써 서로 다른 변수 <code>i</code>를 참조 및 할당하고 있습니다.</p>
<p>그러나 만약 아래와 같이 각 탭을 클릭했을때 <code>console.log(i)</code> 하는 코드를 실행한다면 스코프틑 <code>for loop</code>문의 스코프에 존재하는 변수 <code>i</code>를 참조할 것이며 이에 따라 loop 문의 최종 <code>i</code> 값인 3을 반환할 것입니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> tabs = <span class="built_in">document</span>.querySelectorAll(<span class="string">&#x27;.tab&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> i;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; tabs.length; i += <span class="number">1</span>) &#123;</span><br><span class="line">    tabs[i].onclick = <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(i); <span class="comment">// 어느 탭을 클릭해도 항상 tabs.length (i 의 최종 값) 이 출력</span></span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="함수-표현식을-사용한-Callback-사용"><a href="#함수-표현식을-사용한-Callback-사용" class="headerlink" title="함수 표현식을 사용한 Callback 사용"></a>함수 표현식을 사용한 Callback 사용</h5><p>일반적으로 함수 표현식은 특정 변수에 할당해 사용하지만 그렇지 않은 경우 아래와 같이 콜배감함수로 사용할 수 있습니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>];</span><br><span class="line">arr.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">ele</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(ele)</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> digits = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">var</span> sum = arr.reduce(<span class="function"><span class="keyword">function</span> (<span class="params">sum, ele</span>) </span>&#123;</span><br><span class="line">  sum += ele</span><br><span class="line">  <span class="keyword">return</span> sum</span><br><span class="line">&#125;, <span class="number">0</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="4-이벤트-루프와-동시성-모델에-대해서-설명해달라"><a href="#4-이벤트-루프와-동시성-모델에-대해서-설명해달라" class="headerlink" title="4. 이벤트 루프와 동시성 모델에 대해서 설명해달라"></a>4. 이벤트 루프와 동시성 모델에 대해서 설명해달라</h3><p><strong>이벤트 루프는 Javascript의 동시성(Concurrency)을 지원하기 위한 개념</strong> 으로, 웹 브라우저에서는 애니메이션 효과를 보여주면서 마우스 이벤트를 입력 받아서 처리하고, Node.js기반의 웹서버에서는 동시에 여러 개의 HTTP 요청을 처리하기도 하는데 이는 Javascript가 이벤트 루프를 이용해서 비동기 함수 로직에 대한 동시성을 지원하기 때문이다.</p>
<p>이벤트 루프를 설명하기 위해서는 Javascript Engine이나 런타임 환경을 먼저 설명해야 합니다. Javascript의 대표적인 엔진으로 V8을 예로 들면, V8 엔진의 Memory Heap과 Call Stack으로 구성되어 있으며</p>
<p><img src="https://image.toast.com/aaaadh/real/2018/techblog/b1493856379d11e69c16a9a4cf841567.png" alt="브라우저의 Javascript 구동 환경"></p>
<p>Memory Heap은 메모리 할당이 일어나는 곳으로 구조화 되지 않은 넓은 개념의 메모리 영역을 지칭하고, Call Stack은 코드 실행 순서에 따라 호출 스택이 쌓이는 곳으로 하나의 작업을 완료하기 위해 제공되는 환경입니다. 그리고 Web APIs는 DOM Event, AJAX, Timer Event와 같은 사용자 인터렉션 또는 비동기 처리를 담당하며 Task Queue는 비동기 함수들이 완료된 후 실행될 콜백들이 대기하는 부분으로 FIFO의 큐 형태의 배열입니다.</p>
<p>이러한 구조적 메커니즘에서 Event Loop의 역할을 설명하면 만약 Timer 또는 AJAX 비동기 로직이 실행됐을 경우, 비동기 함수가 실행되고 콜백함수가 Task Queue로 이동 및 대기하는데, 비동기 함수의 작업이 완료된 후 Call Stack이 비었을 경우, Event Loop가 이를 감지해 Task Queue에서 비동기 로직 이후 실행될 콜백함수를 불러와 Call Stack에 삽입하는 역할을 합니다.</p>
<p>즉, Event Loop는 Javascript Engine, Web APIs 그리고 Task Queue를 지속적으로 관찰하며 동시성(Concurrency)을 지원하는 핵심개념입니다.</p>
<p>이런 식으로 <strong>이벤트 루프</strong> 는 <em>‘현재 실행중인 태스크가 없는지’와 ‘태스크 큐에 태스크가 남아있는지’</em> 를 반복적으로 확인합니다. 정리하면,</p>
<ul>
<li>Event Loop: (함수)호출 스택이 비워질 때마다 큐에서 콜백 함수를 꺼내와서 실행하는 역할을 함<ul>
<li>‘현재 실행중인 태스크가 없을 때’(주로 호출 스택이 비워졌을 때) 태스크 큐의 첫 번째 태스크를 꺼내와 실행한다.</li>
<li>언제나 그렇듯이, 함수를 호출하면 그 함수의 사용을 위한 새로운 스택 프레임이 생성된다.</li>
</ul>
</li>
</ul>
<p>자세한 내용은 아래 링크 참조</p>
<ul>
<li>javascript 작동원리: <a href="https://joontae-kim.github.io/2020/10/09/javascript-operation/">https://joontae-kim.github.io/2020/10/09/javascript-operation/</a></li>
<li>자바스크립트와 이벤트 루프: <a target="_blank" rel="noopener" href="https://meetup.toast.com/posts/89">https://meetup.toast.com/posts/89</a><ul>
<li>프라미스(Promise)와 이벤트 루프 내용도 추가 참고</li>
</ul>
</li>
<li>HTML 이벤트루프 스펙 정의: <a target="_blank" rel="noopener" href="https://html.spec.whatwg.org/multipage/webappapis.html#event-loops">https://html.spec.whatwg.org/multipage/webappapis.html#event-loops</a></li>
</ul>
<h3 id="5-실행-컨텍스트-Execution-Context-에-대해-설명해달라"><a href="#5-실행-컨텍스트-Execution-Context-에-대해-설명해달라" class="headerlink" title="5. 실행 컨텍스트(Execution Context)에 대해 설명해달라"></a>5. 실행 컨텍스트(Execution Context)에 대해 설명해달라</h3><p><strong>실행 컨텍스트</strong> 란 <em>“실행 가능한 코드를 형상화 하고 구분하는 추상적인 개념으로 코드가 실행되고 있는 구역 또는 범위”</em> 로 정의할 수 있습니다. Javascript 엔진은 코드를 실행하기 위해서는 변수, 인자 객체, 스코프 그리고 This에 대한 정보를 알고 있어야 하는데 이와 같은 정보는 실행 컨텍스트에 따라 달라지며 실행 컨텍스트 또한 실행 구역 또는 범위에 따라 <strong>전역 실행 컨텍스트</strong>와 <strong>함수 실행 컨텍스트</strong>로 구분됩니다. <strong>전역 실행 컨텍스트</strong>는 <em>전역 환경에서 실행되고 있는 코드의 환경</em> 이고, <strong>함수 실행 컨텍스트</strong> 는 <em>전역 컨텍스트에서 호출 및 실행된 함수의 영역에서 실행되고 있거나 함수가 실행될때마다 생성되는 코드의 환경</em> 입니다.</p>
<p>모든 실행 컨텍스트는 공통된 구조로 <strong>Lexical Environment</strong> (렉시컬 환경)과 <strong>Variable Environment</strong> (변수 환경)를 갖으며 이 둘은 <strong>변수의 참조를 기록하는 환경</strong> 이라고 할 수 있습니다.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ExecutionContext &#x3D; &#123;</span><br><span class="line">  LexicalEnvironment &#x3D; &lt;ref. to LexicalEnvironment in memory&gt;,</span><br><span class="line">  VariableEnvironment &#x3D; &lt;ref. to VariableEnvironment in  memory&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>Lexical Environment</strong> 는 Javascript 코드에서 변수 또는 함수 식별자를 맵핑하기 위해 사용되는 객체로, 식별자란 참조 대상에 대한 식별자로써 변수나 함수의 이름을 참조하며 변수는 함수 객체, 배열 객체를 포함한 실제 객체 또는 원시값에 대한 참조 입니다. Lexical Environment의 내부는 <strong>Outer Environment Reference</strong> 와 <strong>Environment Record</strong> 로 구성되어 있습니다. <strong>Outer Environment Reference</strong> 는 식별자 검색을 위해 외부 Lexical Environment를 참조하는 포인터로 중첩된 Javascript 코드에서 스코프 탐색을 위해 사용됩니다. <strong>Environment Record</strong> 는 현재 유효범위 내의 값에 식별자들의 바인딩을 기록하는 객체로 모든 지역변수를 프로퍼티로 저장하며 <code>this</code> 와 같은 기타 정보도 여기에 저장됩니다.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Lexical Environment &#x3D; &#123;</span><br><span class="line">  Outer Environment Reference,</span><br><span class="line">  Environment Record: &#123;</span><br><span class="line">    Object Environment Record,</span><br><span class="line">    Declarative Environment Record: &#123;</span><br><span class="line">      Function Environment Record,</span><br><span class="line">      Module Environment Record</span><br><span class="line">    &#125;,</span><br><span class="line">    This Binding</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>Variable Environment</strong> 은 Lexical Environment와 같이 function, 변수 식별자가 바인딩된다는 점이 동일하지만 만들어진 변수 선언 및 함수 선언에 대한 바인딩을 유지합니다. 또한, Lexical Environment는 코드 실행중에 실행 컨텍스트 내에서 변경될 수 있지만 Variable Environment는 항상 그 값을 초기화 및 선언 상태로 유지하며 일시적으로 Lexical Environment 하위에 새로운 환경을 가리키며 임시 바인딩을 보유합니다.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">EnvironmentRecord: &#123;</span><br><span class="line">  Outer Environment Reference,</span><br><span class="line">  Environment Record: &#123;</span><br><span class="line">    Object Environment Record,</span><br><span class="line">    Declarative Environment Record,</span><br><span class="line">    This Binding</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>Lexical Environment</strong> 와 <strong>Variable Environment</strong> 의 또다른 차이점으로는 <strong>Lexical Environment</strong> 은 <code>let</code> 과 <code>const</code>  키워드에 의한 함수 및 변수 선언의 바인딩을 저장하고, <strong>Variable Environment</strong> 은 <code>var</code> 키워드로 선언된 바인딩을 저장합니다.</p>
<p>자세한 내용은, 아래 링크 참조.</p>
<ul>
<li>자바스크립트 실행 컨텍스트(Execution Context) 2 - 정의와 구조<ul>
<li><a href="https://joontae-kim.github.io/2020/10/15/excution-context-2/">https://joontae-kim.github.io/2020/10/15/excution-context-2/</a></li>
</ul>
</li>
<li>자바스크립트 실행 컨텍스트(Execution Context) 3 - 실행 컨텍스트의 생성과 실행<ul>
<li><a href="https://joontae-kim.github.io/2020/10/18/execution-context-example/">https://joontae-kim.github.io/2020/10/18/execution-context-example/</a></li>
</ul>
</li>
</ul>
<h3 id="6-Javascript-Scope-Chaining이란-무엇인가"><a href="#6-Javascript-Scope-Chaining이란-무엇인가" class="headerlink" title="6. Javascript Scope Chaining이란 무엇인가"></a>6. Javascript Scope Chaining이란 무엇인가</h3><p>Javascript의 스코프 체인이란 현재 렉시컬 스코프에서 선언된 변수 또는 함수의 식별자를 검색할때, 식별자가 없는 경우 상위 렉시컬 스코프로 식별자를 연쇄적으로 찾아가는 식별자 조회 방식을 말합니다. 상위 렉시컬 스코프를 참조하기 위해 Javascript에서는 실행 컨텍스트에서 <strong>Lexical Environment</strong> 를 활용하는데 <strong>실행 컨텍스트</strong> 란 <em>“실행 가능한 코드를 형상화 하고 구분하는 추상적인 개념으로 코드가 실행되고 있는 구역 또는 범위”</em> 로써, 실행 컨텍스트는 새로운 실행문이 생성될때 마다 공통된 구조로 <strong>Lexical Environment</strong> (렉시컬 환경)과 <strong>Variable Environment</strong> (변수 환경)를 생성합니다.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ExecutionContext &#x3D; &#123;</span><br><span class="line">  LexicalEnvironment &#x3D; &lt;ref. to LexicalEnvironment in memory&gt;,</span><br><span class="line">  VariableEnvironment &#x3D; &lt;ref. to VariableEnvironment in  memory&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>여기서 <strong>Lexical Environment</strong> 란 Javascript 코드에서 변수 또는 함수 식별자를 맴핑하기 위해 사용되는 객체로 식별자란 참조 대상에 대한 식별자로써 변수나 함수의 이름을 참조하며 원시값과 함수 객체, 배열 객체를 포함한 실제 객체에 대한 참조로써, 내부에는 <strong>Outer Environment Reference</strong> 와 <strong>Environment Record</strong> 가 있습니다. 바로 이 <strong>Outer Environment Reference</strong> 가 식별자 검색을 위해 외부 Lexical Environment를 참조하는 포인터로써 중첩된 Javascript 코드에서 스코프 탐색을 위해 사용됩니다.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Lexical Environment &#x3D; &#123;</span><br><span class="line">  **Outer Environment Reference**,</span><br><span class="line">  Environment Record</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="7-scope란-무엇이며-var-let-const에-대해-설명해달라"><a href="#7-scope란-무엇이며-var-let-const에-대해-설명해달라" class="headerlink" title="7. scope란 무엇이며 var, let, const에 대해 설명해달라"></a>7. scope란 무엇이며 <code>var</code>, <code>let</code>, <code>const</code>에 대해 설명해달라</h3><p>Scope란 Javascript에서 <strong>‘변수에 접근할 수 있는 범위’</strong> 로, 자바스크립트 엔진이 참조의 대상이 되는 식별자 (Identifier)를 검색할때 사용하는 규칙의 집합입니다. 선언되는 환경에 따라 <strong>전역 스코프</strong>와 <strong>지역 스코프</strong>로 구분할 수 있으며 <strong>전역 스코프</strong>는 말 그래도 전역환경에 선언되어 어느 곳에서든지 해당 변수에 접근할 수 있는 범위이고, <strong>지역 스코프</strong> 는 해당 범위에서만 접근할 수 있으며 범위를 벗어난 곳에서는 접근할 수 없다는 의미입니다.</p>
<p>지역 스코프의 경우 함수 스코프가 있으며 <strong>ES6(ES2015)</strong> 에서 <code>let</code> 과 <code>const</code> 키워드가 추가되면서 블록 스코프가 추가됐습니다. Javascript는 대부분의 프로그래밍 언어가 블록 레벨 스코프(Block-level Scope)를 따르는 것과 다르게 함수 레벨 스코프(Function-level Scope) 를 따르는데</p>
<ul>
<li><strong>함수 레벨 스코프(Function-level Scope)</strong><br>함수를 선언할 때마다 새로운 스코프를 생성하며 함수 내에서 선언된 변수는 함수 내에서만 유효하고 함수 외부에서는 참조할 수 없음을 의미합니다. 즉, 함수 내부에서 선언한 변수는 지역 변수라는 뜻입니다.</li>
<li><strong>블록 레벨 스코프(Block-level Scope)</strong><br>모든 코드 블록(함수, if 문, while 문 등) 내에서 선언된 변수는 코드 블록 내에서만 유효하며 코드 블록 외부에서는 참조할 수 없습니다. 즉, 코드 블록 내부에서 선언한 변수는 지역 변수라는 뜻입니다.</li>
</ul>
<p>함수 레벨 스코프와 블록 레벨 스코프의 차이는 변수를 선언하는 <code>var</code>, <code>let</code>, <code>const</code> 키워드의 호이스팅 방식에 있는데, <code>var</code> 키워드의 경우, 선언 단계와 초기화 단계가 한번에 이루어지기 때문에 해당 함수 스코프의 영역에서 선언되기 전에 접근할 수 있지만 <code>undefined</code> 를 반환하고, <code>let</code> 이나 <code>const</code> 키워드의 경우, 호이스팅의 선언 단계와 초기화 단계가 분리되어 진행되며 해당 선언문에 도달했을때 이루어지기 때문에 <strong>TDZ(일시적 사각지대)</strong> 로 인해 해당 스코프의 최상위로 끌어올려지지(hoisting) 않아 해당 블록 스코프에서만 접근할 수 있습니다.</p>
<p>또한, Javascript의 실행 컨텍스트를 언급할때 등장하는 스코프로 <strong>렉시컬 스코프</strong> 가 있는데, <strong>렉시컬 스코프</strong> 란 <em>함수를 어디에 선언했는지에 따라서 상위 스코프가 결정된다는 뜻</em> 으로 함수의 <strong>Outer Lexical Scope</strong> 가 함수의 호출이 아니라 함수의 선언에 따라 결정된다는 것입니다. </p>
<p>예를 들자면, 전역변수 <code>var x = 1</code> 이 있고, 전역 함수 <code>function first()</code> , <code>function second()</code> 가 있습니다. <code>first</code> 함수 내부에서는 <code>var x = 10</code> 전역변수  x의 값을 재할당하며  <code>second()</code>  함수가 호출되면 <code>console.log(x)</code> 가 실행되며 호출은 <code>first</code> 함수 에서 호출된다고 할때 <code>second()</code>  함수에서 실행될 <code>console.log(x)</code>  의 <code>x</code> 는 선언 당시의 전역변수 <code>x</code> 의 값인 1 입니다. 왜냐하면 <code>second</code> 함수에서 <strong>렉시컬 스코프</strong>에 따라서 함수를 선언한 시점의 상위 스코프인 전역 환경을 참조하기 때문입니다.</p>
<h4 id="var-let-and-const-차이점"><a href="#var-let-and-const-차이점" class="headerlink" title="var, let, and const 차이점"></a><code>var</code>, <code>let</code>, and <code>const</code> 차이점</h4><p>JavaScript는 변수를 선언하기 위해 언어의 복잡성을 더하는 세개의 다른 키워드가 있습니다.  3개의 키워드 차이점은 스코프(scope), 호이스팅(hoisting) 그리고 재할당(reassignment)에 바탕을 두고 있습니다.</p>
<table>
<thead>
<tr>
<th>Keyword</th>
<th>Scope</th>
<th>Hoisting</th>
<th>Can Be Reassigned</th>
<th>Can Be Redeclared</th>
</tr>
</thead>
<tbody><tr>
<td><a target="_blank" rel="noopener" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/var"><code>var</code></a></td>
<td>Function scope</td>
<td>Yes</td>
<td>Yes</td>
<td>Yes</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/let"><code>let</code></a></td>
<td>Block scope</td>
<td>No</td>
<td>Yes</td>
<td>No</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/const"><code>const</code></a></td>
<td>Block scope</td>
<td>No</td>
<td>No</td>
<td>No</td>
</tr>
</tbody></table>
<h3 id="8-전역-scope를-사용했을-때-장단점에-관해-설명해달라"><a href="#8-전역-scope를-사용했을-때-장단점에-관해-설명해달라" class="headerlink" title="8. 전역 scope를 사용했을 때 장단점에 관해 설명해달라"></a>8. 전역 scope를 사용했을 때 장단점에 관해 설명해달라</h3><p>전역 scope를 사용했을시의 <strong>장점</strong> 으로는 어플리케이션 수준에서 장점이 있을수 있는데,</p>
<p><strong>절대 불변의 고정값을 가진 변수를 전역 환경에서 <code>const</code> 로 선언했을 경우,</strong> 모듈 또는 함수에서 일일이 선언해주지 않아도 Javascript 엔진이 Scope Chain에 따라서 변수값을 자동으로 참조할 수 있습니다.</p>
<p><strong>기본값을 가지는 변수를 전역 환경에서 <code>const</code> 로 또는 <code>let</code> 으로 선언했을 경우,</strong> 기본값을 참조하는 함수의 경우 전역환경에서 자동으로 참조할 것이며 이를 만약 수정해줄경우 전역변수의 값만 수정하면 자동으로 다른 함수에서도 변수의 값을 참조하기 위해 전역변수의 값을 추적해 참고할 것입니다. </p>
<p><strong>단점</strong> 으로는 전역 변수를 선언할 경우 다른 개발자와의 협업에서 우연히 같은 변수 이름을 사용해서 이전의 변수를 덮어쓴다는 불상사가 발생할 수 있으며 변수 값에 대한 불필요한 메모리를 소모할 가능성이 크다는 것입니다.</p>
<h3 id="9-자바스크립트의-호이스팅-Hoisting-은-어떻게-이루어져-있는가"><a href="#9-자바스크립트의-호이스팅-Hoisting-은-어떻게-이루어져-있는가" class="headerlink" title="9. 자바스크립트의 호이스팅(Hoisting)은 어떻게 이루어져 있는가"></a>9. 자바스크립트의 호이스팅(Hoisting)은 어떻게 이루어져 있는가</h3><p>호이스팅이란 인터프리터가 자바스크립트 코드를 해석함에 있어서, 전역(Global) 스코프 또는 함수 스코프 안에서 <code>var</code> 로 선언한 변수나 함수 선언식 등을 해당 스코프의 최상위로 옮기는 동작을 말합니다. 호이스팅은 3단계에 걸쳐 생성되는데,</p>
<ul>
<li><strong>선언 단계(Declaration phase)</strong><br>변수를 실행 컨텍스트의 변수 객체(Variable Object)에 등록한다. 이 변수 객체는 스코프가 참조하는 대상이 된다.</li>
<li><strong>초기화 단계(Initialization phase)</strong><br>변수 객체(Variable Object)에 등록된 변수를 위한 메모리 공간을 확보한다. 이 단계에서 변수는 undefined로 초기화된다.</li>
<li><strong>할당 단계(Assignment phase)</strong><br>undefined로 초기화된 변수에 실제 값을 할당한다.</li>
</ul>
<blockquote>
<p> <strong>var 키워드로 선언된 변수는 선언 단계와 초기화 단계가 한번에 이루어진다.</strong> </p>
</blockquote>
<ol>
<li><em>(선언 및 초기화 단계)</em> 즉, 스코프에 변수를 등록(선언 단계)하고 메모리에 변수를 위한 공간을 확보한 후, undefined로 초기화(초기화 단계)한다. </li>
<li>따라서 변수 선언문 이전에 변수에 접근하여도 스코프에 변수가 존재하기 때문에 에러가 발생하지 않는다. 다만 undefined를 반환한다.</li>
<li><em>(할당 단계)</em> 이후 변수 할당문에 도달하면 비로소 값이 할당된다.</li>
</ol>
<p>이러한 현상을 <strong>변수 호이스팅(Variable Hoisting)</strong> 이라 한다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 스코프의 선두에서 선언 단계와 초기화 단계가 실행된다.</span></span><br><span class="line"><span class="comment">// 따라서 변수 선언문 이전에 변수를 참조할 수 있다.</span></span><br><span class="line"><span class="built_in">console</span>.log(foo); <span class="comment">// undefined</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> foo;</span><br><span class="line"><span class="built_in">console</span>.log(foo); <span class="comment">// undefined</span></span><br><span class="line"></span><br><span class="line">foo = <span class="number">1</span>; <span class="comment">// 할당문에서 할당 단계가 실행된다.</span></span><br><span class="line"><span class="built_in">console</span>.log(foo); <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>



<blockquote>
<p><strong>let 키워드로 선언된 변수는 선언 단계와 초기화 단계가 분리되어 진행된다.</strong> 즉, 스코프에 변수를 등록(선언단계)하지만 초기화 단계는 변수 선언문에 도달했을 때 이루어진다.</p>
</blockquote>
<ol>
<li>초기화 이전에 변수에 접근하려고 하면 참조 에러(ReferenceError)가 발생한다. 즉, 변수를 위한 메모리 공간이 아직 확보되지 않았기 때문이다. 따라서 스코프의 시작 지점부터 초기화 시작 지점까지는 변수를 참조할 수 없다. </li>
<li>스코프의 시작 지점부터 초기화 시작 지점까지의 구간을 <strong>‘일시적 사각지대(Temporal Dead Zone; TDZ)’</strong> 라고 부른다.</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> foo = <span class="number">1</span>; <span class="comment">// 전역 변수</span></span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(foo); <span class="comment">// Uncaught ReferenceError: Cannot access &#x27;foo&#x27; before initialization</span></span><br><span class="line">  <span class="keyword">let</span> foo = <span class="number">2</span>; <span class="comment">// 지역 변수</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>위 예제의 경우, 전역 변수 foo의 값이 출력될 것처럼 보이지만 ES6의 선언문도 여전히 호이스팅이 발생하기 때문에 <em>참조 에러(ReferenceError)</em> 가 발생한다.</p>
<p>ES6의 <code>let</code>으로 선언된 변수는 블록 레벨 스코프를 가지므로 코드 블록 내에서 선언된 변수 foo는 지역 변수이다. 따라서 지역 변수 foo도 해당 스코프에서 호이스팅되고 코드 블록의 선두부터 초기화가 이루어지는 지점까지 일시적 사각지대(TDZ)에 빠진다. 따라서 전역 변수 foo의 값이 출력되지 않고 <em>참조 에러(ReferenceError)</em> 가 발생한다.</p>
<h3 id="10-클로저-Closure-란-무엇이며-어떻게-사용하는지-왜-이러한-패턴을-사용하는가"><a href="#10-클로저-Closure-란-무엇이며-어떻게-사용하는지-왜-이러한-패턴을-사용하는가" class="headerlink" title="10. 클로저(Closure)란 무엇이며, 어떻게 사용하는지, 왜 이러한 패턴을 사용하는가"></a>10. 클로저(Closure)란 무엇이며, 어떻게 사용하는지, 왜 이러한 패턴을 사용하는가</h3><p><strong>클로저(Closure)</strong> 는 주변 상태에 대한 참조와 함께 번들로 묶인 또는 포함된 함수와 변수의 조합인 렉시컬 환경(lexical environment)입니다. 다른 말로, 클로저는 내부 함수에게 외부 변수의 스코프에 접근할 수 있도록 해주는 것이다. Javascript에서 클로저는 함수가 생성될 때마다 생성된다.</p>
<p> 자바스크립트 실행 컨텍스트(Execution Context) 에 대해 알고 있다면 대략 무슨 뜻인지 이해할 수 있다. 즉, <strong>함수와 함수의 참조 환경인 Lexical Environment의 조합으로 구성된 함수</strong> 로써 자식함수가 부모함수의 Scope를 <strong>Outer Lexical Environment</strong> 로 참조(Reference)함으로써 Closer의 장점인 <strong>은닉화, 캡슐화</strong> 등의 장점을 통해 <strong>Public/Private 메서드를 흉내</strong> 낼 수 있다.</p>
<h3 id="11-This-자바스크립트에서-This란-무엇인가"><a href="#11-This-자바스크립트에서-This란-무엇인가" class="headerlink" title="11. This; 자바스크립트에서 This란 무엇인가?"></a>11. This; 자바스크립트에서 This란 무엇인가?</h3><p>this의 값은 <strong><em>함수가 호출되는 방식에 따라</em></strong> 달라집니다.</p>
<ol>
<li><strong>함수를 호출할 때 new 키워드를 사용하는 경우,</strong><br>함수 내부에 있는 this는 완전히 새로운 객체입니다.</li>
<li><strong>apply, call, bind가 함수의 호출/생성에 사용되는 경우,</strong><br>함수 내의 this는 인수로 전달된 객체입니다.</li>
<li><strong>obj.method()와 같이 함수를 메서드로 호출하는 경우,</strong><br>this는 함수가 프로퍼티인 객체입니다.</li>
<li><strong>함수가 전역 스코프에서 익명함수로 호출되는 경우,</strong><br>위의 조건 없이 호출되는 경우 this는 전역 객체입니다. 브라우저에서는 window 객체입니다. 엄격 모드(‘use strict’) 일 경우, this는 전역 객체 대신 <code>undefined</code> 가 됩니다.</li>
</ol>
<p>위의 규칙 중 다수가 적용되면 더 상위 규칙이 승리하고 this 값을 설정합니다.</p>
<h4 id="일반함수의-this와-화살표-함수의-this는-어떻게-다른가"><a href="#일반함수의-this와-화살표-함수의-this는-어떻게-다른가" class="headerlink" title="일반함수의 this와 화살표 함수의 this는 어떻게 다른가?"></a>일반함수의 this와 화살표 함수의 this는 어떻게 다른가?</h4><p><strong>함수가 ES2015 화살표 함수인 경우,</strong> 위의 모든 규칙을 무시하고 생성된 시점에서 주변 스코프의 this 값을 받습니다.</p>
<p>화살표 함수와 일반 함수는 this가 다른 곳을 가리키는데,</p>
<ul>
<li>화살표 함수의 this는 바로 <strong>상위 스코프의 this</strong>를 가리킨다.</li>
<li>일반 함수는 this가 <strong>동적으로 바인딩</strong> 됩니다.<br>일반 함수의 this는 <em>내부 함수, 콜백 함수: 전역 객체, 객체의 메소드, 생성자 함수</em> 입니다.</li>
</ul>
<h4 id="use-strict-모드에서의-this"><a href="#use-strict-모드에서의-this" class="headerlink" title="use strict 모드에서의 this?"></a>use strict 모드에서의 this?</h4><p><strong>엄격 모드(‘use strict’) 일 경우,</strong> this는 전역 객체 대신 <code>undefined</code> 가 됩니다.</p>
<h3 id="12-Call-Apply-Bind-함수에-대해-설명해달라"><a href="#12-Call-Apply-Bind-함수에-대해-설명해달라" class="headerlink" title="12. Call, Apply, Bind 함수에 대해 설명해달라"></a>12. Call, Apply, Bind 함수에 대해 설명해달라</h3><p>(구분해서 알고있자)</p>
<ul>
<li>Call과 Apply</li>
<li>Bind</li>
</ul>
<h4 id="Call-Apply-함수"><a href="#Call-Apply-함수" class="headerlink" title="Call, Apply 함수"></a>Call, Apply 함수</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(add.call(<span class="literal">null</span>, <span class="number">1</span>, <span class="number">2</span>)); <span class="comment">// 3</span></span><br><span class="line"><span class="built_in">console</span>.log(add.apply(<span class="literal">null</span>, [<span class="number">1</span>, <span class="number">2</span>])); <span class="comment">// 3</span></span><br></pre></td></tr></table></figure>

<p>Call과 Apply는 <strong>함수를 호출하는데 사용하며</strong> , 첫 번째 매개변수는 함수 내에서 this의 값으로 사용됩니다. 그러나 이 둘의 차이점은</p>
<ul>
<li><p><code>.Call</code>은 쉼표로 구분된 인수를 두 번째 인수로 취하고</p>
</li>
<li><p><code>.Apply</code>는 인수의 배열을 두 번째 인수로 취합니다.</p>
</li>
<li><p><code>Call</code>은 <strong>C: Comma</strong> 로 구분되며, <code>Apply</code>는 <strong>인수 배열인 A: arguments</strong> 라고 기억하면 쉽습니다.</p>
<p>그냥 실행하는 것이 아닌 첫 번째  this로 setting 하고싶은 객체를 넘겨주어 this를 바꾸고 나서 실행한다. call과 apply의 차이점은 첫 번째 인자(this를 대체할 값)를 제외하고, 실제 함수 호출에 필요한 파라미터를 넣어야 한다. call 과 다르게 apply 함수는 두 번째 인자부터 모두 배열에 넣어야 한다.</p>
</li>
</ul>
<h4 id="Bind-함수"><a href="#Bind-함수" class="headerlink" title="Bind 함수"></a>Bind 함수</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="built_in">module</span> = &#123;</span><br><span class="line">  x: <span class="number">42</span>,</span><br><span class="line">  getX: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.x;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> unboundGetX = <span class="built_in">module</span>.getX;</span><br><span class="line"><span class="built_in">console</span>.log(unboundGetX()); <span class="comment">// The function gets invoked at the global scope</span></span><br><span class="line"><span class="comment">// expected output: undefined</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> boundGetX = unboundGetX.bind(<span class="built_in">module</span>);</span><br><span class="line"><span class="built_in">console</span>.log(boundGetX());</span><br><span class="line"><span class="comment">// expected output: 42</span></span><br></pre></td></tr></table></figure>

<p>Bind 함수가 call과 apply와 다른 점은 <strong>함수를 실행하지 않으며 새로운 바인딩한 함수를 만듭니다</strong> . 바인딩한 함수는 원본 함수 객체를 감싸는 함수로, ECMAScript 2015에서 말하는 <em>특이 함수 객체(exotic function object)</em> 입니다. 바인딩한 함수를 호출하면 일반적으로 래핑된 함수가 호출 됩니다.</p>
<h3 id="13-객체-지향-프로그래밍-Object-Oriented-Programming-과-프로토타입이란-무엇인가"><a href="#13-객체-지향-프로그래밍-Object-Oriented-Programming-과-프로토타입이란-무엇인가" class="headerlink" title="13. 객체 지향 프로그래밍(Object Oriented Programming)과 프로토타입이란 무엇인가"></a>13. 객체 지향 프로그래밍(Object Oriented Programming)과 프로토타입이란 무엇인가</h3><h4 id="객체-지향-프로그래밍-Object-Oriented-Programming-이하-OOP-이란"><a href="#객체-지향-프로그래밍-Object-Oriented-Programming-이하-OOP-이란" class="headerlink" title="객체 지향 프로그래밍(Object Oriented Programming, 이하 OOP) 이란?"></a>객체 지향 프로그래밍(Object Oriented Programming, 이하 OOP) 이란?</h4><p>객체 지향 프로그래밍이란 <strong>“누가 어떤 일을 할 것인가”</strong> 를 중심으로 구현된 프로그래밍 패러다임으로써, <strong>객체 지향의 “객체”는 현실 세계의 사물을 나타내는데 각 객체는 자신의 정보를 가지고 있는 독립적인 개체(Entity)로써 각각의 성격을 띄고 있으며 이 객체가 유기적으로 상호작용 하여 작게는 하나의 기능, 크게는 하나의 어플리케이션을 프로그래밍 하는 방법</strong> 입니다.</p>
<h4 id="OOP의-기본-요소"><a href="#OOP의-기본-요소" class="headerlink" title="OOP의 기본 요소"></a>OOP의 기본 요소</h4><ol>
<li><p><strong>클래스 (class)</strong><br>클래스란 <strong>1개 이상의 유사 객체의 공통된 특성(속성과 메서드)을 데이터 추상화 과정을 통해 구현한 하나의 틀(template)</strong> 로써, 객체지향 프로그램의 기본적인 사용자 정의 데이터 타입(user defined data type)이라고 할 수 있다.</p>
<ul>
<li>다른 클래스 또는 외부 요소와 독립적으로 디자인하여야 한다.</li>
<li>클래스에 의해 생성된 새로운 객체(object)를 클래스의 <strong>인스턴스</strong>라 하며, 클래스로부터 새로운 객체를 생성하는 것을 <strong>인스턴스화</strong> 라고 한다.</li>
</ul>
</li>
<li><p><strong>객체 (object)</strong></p>
<ul>
<li>클래스의 인스턴스를 객체(object)라고 하며</li>
<li>필요한 속성(Attribute)과 속성을 처리하기 위한 메서드(Method)를 가진 하나의 소프트웨어 모듈이며 </li>
<li>다른 객체들과 구별될 수 있는 이름이 있고, </li>
<li>실제 메모리상에 할당된 것으로 실제 프로그램에서 사용되는 데이터이다.</li>
<li><strong>속성(Attribute)</strong><ul>
<li>객체가 가지고 있는 정보 또는 상태를 나타내며 객체의 속성, 데이터, 변수, 상수 또는 자료구조</li>
</ul>
</li>
<li><strong>메서드(Method)</strong> <ul>
<li>객체가 가진 기능으로 객체의 속성을 처리하는 하나의 알고리즘이다.</li>
<li>객체가 메시지를 받아 실행해야 할 객체의 구체적인 연산을 정의한 것, 전통적 시스템의 함수(Function)나 프로시저(Procedure)에 해당하는 연산 기능을 수행한다.</li>
<li>메소드는 다른 객체로부터 메시지를 받았을 때 수행하게 된다.</li>
</ul>
</li>
</ul>
</li>
</ol>
<ol start="3">
<li><strong>메시지 (message)</strong><ul>
<li>메시지는 객체 간의 상호작용을 하는 데 사용되는 수단으로, </li>
<li>객체에게 어떤 행위를 하도록 지시하는 명령 또는 요구 사항이다.</li>
<li>클래스로부터 생성된 객체를 사용하는 방법으로서 객체에 명령을 내리는 것이 메시지라 할 수 있다.</li>
<li><strong>메시지의 구성 요소</strong> : <ul>
<li>메시지를 받는 객체의 이름, 객체가 수행할 메소드 이름, 메소드를 수행할 때 필요한 인자</li>
<li>메시지를 받은 수신 객체는 요구된 메소드를 수행하여 결과를 반환하게 된다.</li>
</ul>
</li>
</ul>
</li>
</ol>
<h4 id="OOP의-장-단점"><a href="#OOP의-장-단점" class="headerlink" title="OOP의 장/단점"></a>OOP의 장/단점</h4><ol>
<li><p><strong>장점</strong></p>
<ul>
<li>자연적인 모델링이 가능함</li>
<li>코드의 재사용성 증가</li>
<li>소프트웨어의 유지보수성 향상</li>
<li>대형 프로젝트 개발에 적합</li>
</ul>
</li>
<li><p><strong>단점</strong></p>
<ul>
<li>처리속도가 상대적으로 느림</li>
<li>다중 객체 생성에 따른 메모리 사용량 증가</li>
<li>객체 설계의 복잡도에 따른 설계시간 소용 시간</li>
</ul>
</li>
</ol>
<h4 id="OOP에-특징에-대해-설명해달라-상속-캡슐화-등등…"><a href="#OOP에-특징에-대해-설명해달라-상속-캡슐화-등등…" class="headerlink" title="OOP에 특징에 대해 설명해달라(상속, 캡슐화 등등…)"></a>OOP에 특징에 대해 설명해달라(상속, 캡슐화 등등…)</h4><p><em>( 실제 예제는 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/ko/docs/Learn/JavaScript/Objects/Object-oriented_JS">https://developer.mozilla.org/ko/docs/Learn/JavaScript/Objects/Object-oriented_JS</a> 를 참고하자 )</em></p>
<p>객체 지향 프로그래밍이란 <strong>“누가 어떤 일을 할 것인가”</strong> 이며 1개 이상의 유사 객체의 공통된 특성(속성과 메서드) 가진 클래스를 통해 객체를 생성하고 상호 유기적으로 메시지를 주고 받으며 결과를 반환한다고 정리해볼 수 있으며 총 6가지 있습니다.</p>
<ul>
<li>캡슐화 (Encapsulation)</li>
<li>은닉화 (Information Hiding)</li>
<li>추상화 (Abstraction)</li>
<li>상속성 (Inheritance)</li>
<li>다형성 (Polymorphism)</li>
<li>연관성 (Relationship)</li>
</ul>
<ol>
<li><p><strong>캡슐화 (Encapsulation)</strong></p>
<ul>
<li>자료 부분과 연산(또는 함수) 부분 등 정보처리에 필요한 기능을 한 테두리로 묶는 것</li>
<li>연관된 데이터와 함수를 함께 묶어 외부와 경계를 만들고 필요한 인터페이스만을 밖으로 드러내는 과정</li>
<li>객체지향 기법의 <em>정보 은닉</em> 과 밀접한 기법</li>
<li>장점<ul>
<li>높은 재사용성</li>
<li>인터페이스의 단순화</li>
<li>변경 또는 수정이 발생할때 오류의 파급효과가 적음</li>
<li>응집력이 향상됨</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>은닉화 (Information Hiding)</strong></p>
<ul>
<li>캡슐화에서 가장 중요한 개념으로, 다른 객체에게 자신의 정보를 숨기고 자신의 연산만을 통하여 접근을 허용하는 것</li>
<li>정보 은닉은 고려되지 않은 영향(side effect)들을 최소화함을 목적으로 함</li>
<li>따라서, 외부 객체가 접근하거나 사용하지 못하므로 유지보수와 소프트웨어 확장 시 오류를 최소화 할 수 있음</li>
</ul>
</li>
<li><p><strong>추상화 (Abstraction)</strong></p>
<ul>
<li>자료 추상화는 불필요한 정보는 숨기고 중요한 정보만을 표현함으로써 프로그램을 간단히 만드는 것으로, 모델화하는 것을 의미</li>
<li>자료 추상화를 통해 정의된 자료형을 추상 자료형이라고 함</li>
<li>추상 자료형은 자료형의 자료 표현과 자료형의 연산을 캡슐화한 것으로 접근 제어를 통해서 자료형의 정보를 은닉할 수 있다.</li>
<li>객체 지향 프로그래밍에서 일반적으로 추상 자료형을 클래스, 추상 자료형의 인스턴스를 객체, 추상 자료형에서 정의된 연산을 메소드(함수), 메소드의 호출을 생성자라고 한다.</li>
</ul>
</li>
<li><p><strong>상속성 (Inheritance)</strong></p>
<ul>
<li>상속은 새로운 클래스가 기존의 클래스의 자료와 메서드를 이용할 수 있게 하는 기능</li>
<li>상속을 받는 새로운 클래스를 부클래스, 파생 클래스, 하위 클래스, 자식 클래스라고 하며 새로운 클래스가 상속하는 기존의 클래스를 기반 클래스, 상위 클래스, 부모 클래스라 함</li>
<li>상속을 통해서 기존의 클래스를 상속받은 하위 클래스를 이용해 프로그램의 요구에 맞추어 클래스를 수정할 수 있고, 클래스 간의 종속 관계를 형성함으로써 객체를 조직화할 수 있다.</li>
<li>다중 상속<ul>
<li>클래스가 2개 이상의 클래스로부터 상속받을 수 있게 하는 기능</li>
<li>클래스들의 기능이 동시에 필요할 때 용이하나 클래스의 상속 관계에 혼란을 줄 수 있음 (예: 다이아몬드 상속)</li>
<li>프로그래밍 언어에 따라 사용 가능 유무가 다르므로 주의해서 사용해야 한다. JAVA는 지원하지 않음</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>다형성 (Polymorphism)</strong></p>
<ul>
<li>상이한 클래스들이 동일한 메서드명을 갖는 것 또는 한 메시지가 객체에 따라 다양한 방식으로 응답할 수 있는 것을 의미함</li>
<li>일반적으로 오버라이딩이나 오버로딩을 의미함<ul>
<li>오버라이딩: 같은 이름의 메소드가 여러 클래스에서 다른 기능을 하는 것 </li>
<li>오버로딩: 같은 이름의 메소드가 인자의 개수나 자료형에 따라서 다른 기능을 하는 것</li>
</ul>
</li>
<li>다형 개념을 통해서 프로그램 안의 객체 간의 관계를 조직적으로 나타낼 수 있음</li>
</ul>
</li>
<li><p><strong>연관성 (Relationship)</strong></p>
<ul>
<li>두 개 이상의 엔티티 형에서 데이터를 상호 참조하는 클래스간의 연관관계를 정의</li>
<li>객체간의 관계를 세부적으로 정의하여 구현 용이</li>
<li>관계성의 종류</li>
<li><table>
<thead>
<tr>
<th>관계성의 종류</th>
<th>의미</th>
<th>특성</th>
</tr>
</thead>
<tbody><tr>
<td>is-member-of</td>
<td>연관화</td>
<td>링크 개념과 유사</td>
</tr>
<tr>
<td>is-instance-of</td>
<td>분류화</td>
<td>객체 및 클래스의 인스턴스를 표현</td>
</tr>
<tr>
<td>is-part-of</td>
<td>집단화</td>
<td>상향식, 단일 상속, 복합 객체 (composite object) 표현에 유용</td>
</tr>
<tr>
<td>is-a</td>
<td>특수화, 일반화</td>
<td>하향식, 다중 상속, 복잡한 객체 표현에 유용</td>
</tr>
</tbody></table>
</li>
</ul>
</li>
</ol>
<h4 id="프로토타입-상속이-이루어지는-법"><a href="#프로토타입-상속이-이루어지는-법" class="headerlink" title="프로토타입 상속이 이루어지는 법"></a>프로토타입 상속이 이루어지는 법</h4><p><strong>상속</strong> 이란 부모 생성자의 기능을 물려받으면서 새로운 기능도 추가하는 것을 의미합니다. 그렇다면 Prototype 기반의 Javascript는 어떻게 상속을 지원할까요? 정확히 얘기하자면, Prototype 기반의 Javascript는 상속 보다는 위임에 가깝습니다.</p>
<p>JavaScript는 흔히 **프로토타입 기반 언어(prototype-based language)**라 불립니다. 모든 객체들이 메소드와 속성들을 상속 받기 위한 템플릿으로써 **프로토타입 객체(prototype object)**를 가진다는 의미입니다. 프로토타입 객체도 또 다시 상위 프로토타입 객체로부터 메소드와 속성을 상속 받을 수도 있고 그 상위 프로토타입 객체도 마찬가지입니다. 이를 **프로토타입 체인(prototype chain)**이라 부르며 다른 객체에 정의된 메소드와 속성을 한 객체에서 사용할 수 있도록 하는 근간입니다.</p>
<p>정확히 말하자면 상속되는 속성과 메소드들은 각 객체가 아니라 객체의 생성자의 <code>prototype</code>이라는 속성에 정의되어 있습니다.</p>
<p>JavaScript에서는 객체 인스턴스와 프로토타입 간에 연결(많은 브라우저들이 생성자의 <code>prototype</code> 속성에서 파생된 <code>__proto__</code> 속성으로 객체 인스턴스에 구현하고 있습니다.)이 구성되며 이 연결을 따라 프로토타입 체인을 타고 올라가며 속성과 메소드를 탐색합니다. </p>
<p>객체의 프로퍼티에 접근할 때, 해당 객체에 해당 프로퍼티가 없으면 JavaScript 엔진은 객체의 <code>__proto__</code>과 <code>__proto__</code>의 <code>__proto__</code> 등을 보고 프로퍼티 정의가 있을 때까지 찾고, 만약 객체의 프로퍼티에 접근할 때 해당 객체에 해당 프로퍼티가 없으면 프로토타입 체인 중 하나에 있거나 프로토타입 체인의 끝에 도달할 때까지 찾습니다. 이 동작은 고전적인 상속을 흉내내지만, 실제로 상속보다 위임에 더 가깝습니다.</p>
<p>자바스크립트에서 상속을 진행할 때는 프로토타입끼리 연결을 하는데, 부모 프로토타입을 <code>Object.create()</code>나 <code>setPropertyOf()</code> 메서드를 사용하여 자식 프로토타입과 연결할 수 있습니다.</p>
<p>이런 이유로 직접적인 상속을 구현 할수는 없지만 프로토타입 확장을 이용한 상속과 같은 의미를 구현할 수 있다고 말하곤 합니다.</p>
<h3 id="14-OOP와-함수형-프로그래밍의-차이"><a href="#14-OOP와-함수형-프로그래밍의-차이" class="headerlink" title="14. OOP와 함수형 프로그래밍의 차이"></a>14. OOP와 함수형 프로그래밍의 차이</h3><h4 id="함수형-프로그래밍에-대해-설명해-주세요"><a href="#함수형-프로그래밍에-대해-설명해-주세요" class="headerlink" title="함수형 프로그래밍에 대해 설명해 주세요."></a>함수형 프로그래밍에 대해 설명해 주세요.</h4><p>순수함수와 보조함수의 조합을 통해 로직내에 존재하는 조건문과 반복문을 제거하여, 복잡성을 해결하고 변수의 사용을 억제하여 상태 변경을 피하려는 프로그래밍 패러다임이다.</p>
<ul>
<li>함수형 프로그래밍에 개념에서 <strong>순수함수</strong> 란<br>순수함수는 같은 입력이 주어지면 같은 출력을 반환해야하고, side effect(부작용)이 없어야한다. 결국, 함수형 프로그래밍은 순수함수를 통해 side effect를 최대한 억제하여 오류를 피하고 프로그램의 안전성을 높이려는 노력의 한 방법이다.</li>
</ul>
<h4 id="OOP와-함수형-프로그래밍의-차이"><a href="#OOP와-함수형-프로그래밍의-차이" class="headerlink" title="OOP와 함수형 프로그래밍의 차이"></a>OOP와 함수형 프로그래밍의 차이</h4><p>객체지향과 함수형의 차이는 <strong>상태를 관리하는 점</strong> 입니다.</p>
<blockquote>
<p>객체지향은 동작하는 부분을 캡슐화해서 이해할 수 있게 하고, 함수형 프로그래밍은 동작하는 부분을 최소화해서 코드 이해를 돕는다.    마이클 페더스 - ‘레거시 코드 활용 전략’ 저자</p>
</blockquote>
<ul>
<li>객체 지향: 상태를 저장하는 필드와 필드를 이용해 기능을 제공하는 메소드를 붙여서 클래스를 만든다. 즉, 항상 새로운 자료구조를 사용하게 되는 셈입니다.</li>
<li>함수형 프로그래밍: 몇몇 자료구조(list, set, map)를 이용해 최적화된 동작을 만들어냅니다.</li>
</ul>
<h3 id="15-즉시-실행-함수-IIFE-란-무엇이며-언제-사용하는-것인가"><a href="#15-즉시-실행-함수-IIFE-란-무엇이며-언제-사용하는-것인가" class="headerlink" title="15. 즉시 실행 함수(IIFE)란 무엇이며 언제 사용하는 것인가"></a>15. 즉시 실행 함수(IIFE)란 무엇이며 언제 사용하는 것인가</h3><p>즉시 실행 함수(IIFE)란 정의되자마자 즉각적으로 실행되는 자바스크립트 함수(Function) 중 하나로, 종류는 <strong>기명 즉시 실행 함수 (함수의 이름이 있는 즉시 실행 함수)</strong> 와 <strong>익명 즉시 실행 함수 (함수의 이름이 없는 즉시 실행 함수)</strong> 가 있다.</p>
<h4 id="형태"><a href="#형태" class="headerlink" title="형태"></a>형태</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 익명 즉시 실행 함수</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params">arg</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// statements</span></span><br><span class="line">&#125;)(params);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 기명 즉시 실행 함수</span></span><br><span class="line"><span class="keyword">var</span> print = (<span class="function"><span class="keyword">function</span> (<span class="params">arg</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// statements</span></span><br><span class="line">&#125;)(params); </span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(print);</span><br></pre></td></tr></table></figure>

<h4 id="언제-사용하나"><a href="#언제-사용하나" class="headerlink" title="언제 사용하나"></a>언제 사용하나</h4><ol>
<li><strong>불필요한 충돌을 최소화하고 단 한번만 실행하는 초기화 코드에 많이 사용한다.</strong><br> 변수를 전역 스코프에서 변수를 선언하지 않기 때문에 전역 내 또는 내부 함수 또는 블록 스코프와 충돌 없이 구현할 수 있다.</li>
<li><strong>특정 스코프를 만들 때 사용한다</strong><br> 익명 함수로써 레퍼런스 없이 즉각적으로 실행되기 때문에 특정 스코프를 만들 때 유용하게 사용할 수 있다.</li>
</ol>
<h3 id="15-비동기-프로그래밍"><a href="#15-비동기-프로그래밍" class="headerlink" title="15. 비동기 프로그래밍"></a>15. 비동기 프로그래밍</h3><h4 id="동기-함수-Synchronous-와-비동기-함수-Asynchronous-이란"><a href="#동기-함수-Synchronous-와-비동기-함수-Asynchronous-이란" class="headerlink" title="동기 함수(Synchronous)와 비동기 함수(Asynchronous)이란"></a>동기 함수(Synchronous)와 비동기 함수(Asynchronous)이란</h4><ul>
<li><strong>동기 함수</strong> 는 <em>블로킹</em> 인 반면, <strong>비동기 함수</strong> 는 <em>논블로킹</em> 처리이다. </li>
<li><strong>동기 함수</strong> 에서는 다음 명령문이 실행되기 전에 앞 명령문이 완료됩니다. 이 경우, 프로그램은 명령문의 순서대로 정확하게 평가되고 명령문 중 하나가 매우 오랜 시간이 걸리면 프로그램 실행이 일시중지 될 가능성이 있습니다.</li>
<li><strong>비동기 함수</strong> 는 일반적으로 파라미터를 통해서 콜백을 받고, 비동기 함수가 호출된 후 즉시 다음 줄 실행이 계속됩니다. 콜백은 비동기 작업이 완료되고 호출 스택이 비어 있을 때만 호출됩니다. 웹 서버에서 데이터를 로드하거나 데이터베이스를 쿼리하는 등의 무거운 작업을 비동기식으로 수행하여, 메인 스레드가 긴 작업을 완료할 때까지 블로킹하지 않고 다른 작업을 계속할 수 있습니다(브라우저의 경우 UI가 중지됨).</li>
</ul>
<h4 id="Callback-Promise-란-무엇이며-각각의-장단점에-대해-설명해달라"><a href="#Callback-Promise-란-무엇이며-각각의-장단점에-대해-설명해달라" class="headerlink" title="Callback, Promise 란 무엇이며 각각의 장단점에 대해 설명해달라"></a>Callback, Promise 란 무엇이며 각각의 장단점에 대해 설명해달라</h4><h5 id="정의"><a href="#정의" class="headerlink" title="정의"></a>정의</h5><ul>
<li><strong>Callback Function</strong><br>자바스크립트의 비동기성을 표현하는 가장 일반적인 기법으로, 호출된 함수를 알려줘서 다른 프로그램이나 다른 모듈에서 함수를 호출하게 하는 방법입니다.<br>특정 함수에 매개변수로 전달되는 함수를 의미하며 함수를 전달받은 함수 안에서 호출됩니다.<br>단점으로는 콜백지옥에 빠지면 로직이 어려워지고 가독성이 떨어지며 error 처리가 어려워질 수 있습니다.</li>
<li><strong>Promise</strong><br>Promise는 비동기 처리 로직을 추상화한 객체와 그것을 조작하는 방식으로, Callback 함수의 단점인 콜백지옥을 해결하며 동기 처리 시점을 명확하게 표현할 수 있도록 도와줘 비동기 메서드에서 마치 동기 메서드처럼 값을 반환할 수 있습니다.</li>
</ul>
<h5 id="Callback-대신에-Promise를-사용할-때의-장점과-단점은-무엇인가요"><a href="#Callback-대신에-Promise를-사용할-때의-장점과-단점은-무엇인가요" class="headerlink" title="Callback 대신에 Promise를 사용할 때의 장점과 단점은 무엇인가요"></a>Callback 대신에 Promise를 사용할 때의 장점과 단점은 무엇인가요</h5><ul>
<li><p><strong>장점</strong><br>가독성이 떨어질 수 있는 콜백 지옥을 피할 수 있습니다.<br>.then()을 이용하여 가독성 좋은 연속적인 비동기 코드를 쉽게 작성할 수 있습니다.<br>Promise.all()을 사용하여 병렬 비동기 코드를 쉽게 작성할 수 있습니다.</p>
</li>
<li><p><strong>단점</strong><br>약간 더 복잡한 소스코드(논쟁의 여지가 있음).<br><code>ES2015</code>를 지원하지 않는 이전 브라우저에서 이를 사용하기 위해서는 polyfill을 로드해야 합니다.</p>
</li>
</ul>
<h4 id="Promise-코드가-어떻게-구성되어있는가"><a href="#Promise-코드가-어떻게-구성되어있는가" class="headerlink" title="Promise 코드가 어떻게 구성되어있는가"></a>Promise 코드가 어떻게 구성되어있는가</h4><p><code>Promise</code> 는 비동기 연산이 종료된 이후의 결과값이나 실패 이유를 처리하기 위한 처리기를 연결할 수 있도록 하며 프로미스를 사용하면 비동기 메서드에서 마치 동기 메서드처럼 값을 반환할 수 있습니다. 다만 최종 결과를 반환하지는 않고, 대신 프로미스를 반환해서 미래의 어떤 시점에 결과를 제공합니다.</p>
<p><code>Promise</code> 의 작동방식을 이해하기 위해서는 Promise의 가장 뛰어난 장점 중의 하나인 <strong>chaining</strong> 에 대해 이해할 필요가 있습니다. <code>Promise</code> 는 비동기 작업의 최종 완료 또는 실패를 나타내는 객체로써, 기본적으로 promise는 함수에 콜백을 전달하는 대신에, 콜백을 첨부하는 방식의 객체입니다.</p>
<p>promise가 성공했을때는 <code>.then(successCallback)</code> 와 같이 <code>.then()</code> 메서드를 통해 비동기 처리가 성공했을때 반환된 결과값을 처리할 콜백함수를 전달하면 되고, 실패했을시에는 <code>.catch(failureCallback)</code> 와 같이 <code>.catch()</code> 메서드를 통해 실패햇을때 에러 핸들링할 콜백함수를 전달해주면 된다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Case: 콜백 함수로 처리</span></span><br><span class="line">doSomething(<span class="function"><span class="keyword">function</span>(<span class="params">result</span>) </span>&#123;</span><br><span class="line">  doSomethingElse(result, <span class="function"><span class="keyword">function</span>(<span class="params">newResult</span>) </span>&#123;</span><br><span class="line">    doThirdThing(newResult, <span class="function"><span class="keyword">function</span>(<span class="params">finalResult</span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&#x27;Got the final result: &#x27;</span> + finalResult);</span><br><span class="line">    &#125;, failureCallback);</span><br><span class="line">  &#125;, failureCallback);</span><br><span class="line">&#125;, failureCallback);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Case: Promise로 처리</span></span><br><span class="line">doSomething().then(<span class="function"><span class="keyword">function</span>(<span class="params">result</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> doSomethingElse(result);</span><br><span class="line">&#125;)</span><br><span class="line">.then(<span class="function"><span class="keyword">function</span>(<span class="params">newResult</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> doThirdThing(newResult);</span><br><span class="line">&#125;)</span><br><span class="line">.then(<span class="function"><span class="keyword">function</span>(<span class="params">finalResult</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;Got the final result: &#x27;</span> + finalResult);</span><br><span class="line">&#125;)</span><br><span class="line">.catch(failureCallback);</span><br></pre></td></tr></table></figure>

<h4 id="Async-amp-Await는-무엇이며-Promise의-차이는-무엇인가"><a href="#Async-amp-Await는-무엇이며-Promise의-차이는-무엇인가" class="headerlink" title="Async &amp; Await는 무엇이며 Promise의 차이는 무엇인가"></a>Async &amp; Await는 무엇이며 Promise의 차이는 무엇인가</h4><p><strong>Async &amp; Await</strong> 는 비동기 코드를 동기식으로 표현하는 더 나은 방법으로 <strong>ES8(ES2017)</strong> 에 등장했습니다. <code>async</code> 함수는 <code>async</code> 키워드로 선언된 함수이며 그 안에 <code>await</code> 키워드가 허용됩니다. <code>async</code> 및 <code>await</code> 키워드를 사용하면 프로미스 체인을 명시적으로 구성할 필요 없이 비동기식 프라미스 기반 동작을 보다 깔끔한 스타일로 작성할 수 있습니다. <code>await</code> 키워드는 <code>Promise</code> 객체를 받아 처리하고, 만약 비동기 함수가 아닌 동기적 함수라면 리턴 값을 그대로 받는다. <code>Async</code> 함수는 <code>Promise</code> 객체를 통해 비동기적으로 처리된 내용을 동기적인 코드 진행 순서로 보여주는 역할을 합니다.</p>
<p><strong>Async &amp; Await</strong> 구문의 반환값은 비동기 함수에 의해 반환된 값으로 해결되거나 비동기 함수 안에서 다뤄지지 않은 또는 예외처리로 거부된 <code>Promise</code> 입니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Case: Promise로 처리</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getProcessedData</span>(<span class="params">url</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> downloadData(url) <span class="comment">// returns a promise</span></span><br><span class="line">    .catch(<span class="function"><span class="params">e</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> downloadFallbackData(url)  <span class="comment">// returns a promise</span></span><br><span class="line">    &#125;)</span><br><span class="line">    .then(<span class="function"><span class="params">v</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> processDataInWorker(v)  <span class="comment">// returns a promise</span></span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Case: Async &amp; Await 처리</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">getProcessedData</span>(<span class="params">url</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> v = <span class="keyword">await</span> downloadData(url)</span><br><span class="line">    <span class="keyword">return</span> processDataInWorker(v)</span><br><span class="line">  &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    <span class="keyword">throw</span> (e) <span class="comment">// error handling</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<hr>
<h2 id="참고"><a href="#참고" class="headerlink" title="참고"></a>참고</h2><ul>
<li><a target="_blank" rel="noopener" href="https://frontendinterviewhandbook.com/">Front End Interview Handbook</a></li>
<li><a target="_blank" rel="noopener" href="https://velog.io/@cyongchoi/series/Javascript-TIL">Javascript 모음 - @cyongchoi님 블로그</a></li>
<li><a target="_blank" rel="noopener" href="https://taepcsiandwe.tistory.com/entry/frontend-%EA%B0%9C%EB%B0%9C%EC%9E%90-%EC%9D%B8%ED%84%B0%EB%B7%B0-%EB%AC%B8%EC%A0%9C-javascript-%EC%98%81%EC%97%AD">front-end 개발자 인터뷰 문제 - javascript 영역 - taepcsiandwe님 블로그</a></li>
<li><a target="_blank" rel="noopener" href="https://devowen.com/276">&lt;FE면접질문&gt; #3. JavaScript (Part 1)</a></li>
<li><a target="_blank" rel="noopener" href="https://devowen.com/283">&lt;FE면접질문&gt; #4. JavaScript (Part 2)</a></li>
<li><a target="_blank" rel="noopener" href="https://bigstar-vlog.tistory.com/60?category=1137367">프론트엔드 개발자 면접 질문 #1</a></li>
<li><a target="_blank" rel="noopener" href="https://developer.mozilla.org/ko/docs/Web/JavaScript/Inheritance_and_the_prototype_chain">MDN 상속과 프로토타입</a></li>
<li><a target="_blank" rel="noopener" href="https://developer.mozilla.org/ko/docs/Learn/JavaScript/Objects/Object_prototypes">MDN Object prototypes</a></li>
<li><a target="_blank" rel="noopener" href="https://developer.mozilla.org/ko/docs/Web/JavaScript/Guide/Using_promises">MDN promise 사용하기</a></li>
<li><a target="_blank" rel="noopener" href="https://shlee1353.github.io/2019/11/07/js-bubbling-capturing/">자바스크립트 이벤트 버블링 캡쳐링 완벽정리</a></li>
<li><a target="_blank" rel="noopener" href="https://shlee1353.github.io/2019/11/08/js-promise-async/">자바스크립트 비동기 프로그래밍 (promise, async, await) 정리</a></li>
<li><a target="_blank" rel="noopener" href="https://jihyehwang09.github.io/2019/03/30/js-immediately-invoked-function-expression/">즉시 실행 함수(Immediately-invoked function expression) - jihyehwang09님 블로그</a></li>
<li><a target="_blank" rel="noopener" href="https://parksb.github.io/article/0.html#fouc(flash-of-unstyled-content)">프론트엔드 개발자를 위한 토막상식 - parksb님 블로그</a></li>
</ul>

        </div>
        <footer class="article-footer">
            


    <div class="a2a_kit a2a_default_style">
    <a class="a2a_dd" target="_blank" rel="noopener" href="https://www.addtoany.com/share">Share</a>
    <span class="a2a_divider"></span>
    <a class="a2a_button_facebook"></a>
    <a class="a2a_button_twitter"></a>
    <a class="a2a_button_google_plus"></a>
    <a class="a2a_button_pinterest"></a>
    <a class="a2a_button_tumblr"></a>
</div>
<script type="text/javascript" src="//static.addtoany.com/menu/page.js"></script>
<style>
    .a2a_menu {
        border-radius: 4px;
    }
    .a2a_menu a {
        margin: 2px 0;
        font-size: 14px;
        line-height: 16px;
        border-radius: 4px;
        color: inherit !important;
        font-family: 'Microsoft Yahei';
    }
    #a2apage_dropdown {
        margin: 10px 0;
    }
    .a2a_mini_services {
        padding: 10px;
    }
    a.a2a_i,
    i.a2a_i {
        width: 122px;
        line-height: 16px;
    }
    a.a2a_i .a2a_svg,
    a.a2a_more .a2a_svg {
        width: 16px;
        height: 16px;
        line-height: 16px;
        vertical-align: top;
        background-size: 16px;
    }
    a.a2a_i {
        border: none !important;
    }
    a.a2a_menu_show_more_less {
        margin: 0;
        padding: 10px 0;
        line-height: 16px;
    }
    .a2a_mini_services:after{content:".";display:block;height:0;clear:both;visibility:hidden}
    .a2a_mini_services{*+height:1%;}
</style>


        </footer>
    </div>
    <script type="application/ld+json">
    {
        "@context": "https://schema.org",
        "@type": "BlogPosting",
        "author": {
            "@type": "Person",
            "name": "Joontae Kim"
        },
        "headline": "프론트엔드 면접 질문 리스트 - JS",
        "image": "https://joontae-kim.github.io/images/job_thumbnail.jpeg",
        "keywords": "Front-end Interview Job Javascript",
        "genre": "Blog Job",
        "datePublished": "2020-10-26",
        "dateCreated": "2020-10-26",
        "dateModified": "2021-08-12",
        "url": "https://joontae-kim.github.io/2020/10/26/interview-question-js-1/",
        "description": "
프론트엔드 면접 준비를 위한 질문 리스트 정리Javascript아래질문 리스트를 기반으로 면접 질문 &amp; 답변 목록을 작성할 예정이고, 지속적으로 보충 or 보수할 계획입니다.
업데이트 날짜

2020-10-26
2021-07-02
Javascript 질문 목록 수정


2021-07-23
2021-07-24
2021-07-25
Javascript ",
        "wordCount": 6273
    }
</script>

</article>

    <section id="comments">
    
        
    <div id="disqus_thread">
        <noscript>Please enable JavaScript to view the <a target="_blank" rel="noopener" href="//disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
    </div>


    
    </section>



                        </div>
                    </section>
                    <aside id="sidebar">
    <a class="sidebar-toggle" title="Expand Sidebar"><i class="toggle icon"></i></a>
    <div class="sidebar-top">
        <p>follow:</p>
        <ul class="social-links">
            
                
                <li>
                    <a class="social-tooltip" title="github" href="https://github.com/Joontae-Kim" target="_blank" rel="noopener">
                        <i class="icon fa fa-github"></i>
                    </a>
                </li>
                
            
                
                <li>
                    <a class="social-tooltip" title="rss" href="/" target="_blank" rel="noopener">
                        <i class="icon fa fa-rss"></i>
                    </a>
                </li>
                
            
        </ul>
    </div>
    
        
<nav id="article-nav">
    
        <a href="/2020/10/26/interview-question-network/" id="article-nav-newer" class="article-nav-link-wrap">
        <strong class="article-nav-caption">newer</strong>
        <p class="article-nav-title">
        
            프론트엔드 면접 질문 리스트 - Network
        
        </p>
        <i class="icon fa fa-chevron-right" id="icon-chevron-right"></i>
    </a>
    
    
        <a href="/2020/10/26/interview-question-fe/" id="article-nav-older" class="article-nav-link-wrap">
        <strong class="article-nav-caption">older</strong>
        <p class="article-nav-title">프론트엔드 면접 질문 리스트 - FE (Browser)</p>
        <i class="icon fa fa-chevron-left" id="icon-chevron-left"></i>
        </a>
    
</nav>

    
    <div class="widgets-container">
        
            
                

            
                
    <div class="widget-wrap">
        <h3 class="widget-title">recents</h3>
        <div class="widget">
            <ul id="recent-post" class="">
                
                    <li>
                        
                        <div class="item-thumbnail">
                            <a href="/2021/10/02/opentutorial-git2/" class="thumbnail">
    
    
        <span style="background-image:url(/images/git_with_opentutorial.png)" alt="Study to Git - 2" class="thumbnail-image"></span>
    
    
</a>

                        </div>
                        
                        <div class="item-inner">
                            <p class="item-category"><a class="article-category-link" href="/categories/Study/">Study</a><i class="icon fa fa-angle-right"></i><a class="article-category-link" href="/categories/Study/Git/">Git</a></p>
                            <p class="item-title"><a href="/2021/10/02/opentutorial-git2/" class="title">Study to Git - 2</a></p>
                            <p class="item-date"><time datetime="2021-10-01T16:25:29.000Z" itemprop="datePublished">2021-10-02</time></p>
                        </div>
                    </li>
                
                    <li>
                        
                        <div class="item-thumbnail">
                            <a href="/2021/10/02/openturorial-git1/" class="thumbnail">
    
    
        <span style="background-image:url(/images/git_with_opentutorial.png)" alt="Study to Git - 1" class="thumbnail-image"></span>
    
    
</a>

                        </div>
                        
                        <div class="item-inner">
                            <p class="item-category"><a class="article-category-link" href="/categories/Study/">Study</a><i class="icon fa fa-angle-right"></i><a class="article-category-link" href="/categories/Study/Git/">Git</a></p>
                            <p class="item-title"><a href="/2021/10/02/openturorial-git1/" class="title">Study to Git - 1</a></p>
                            <p class="item-date"><time datetime="2021-10-01T16:21:41.000Z" itemprop="datePublished">2021-10-02</time></p>
                        </div>
                    </li>
                
                    <li>
                        
                        <div class="item-thumbnail">
                            <a href="/2021/07/22/interview-question-js-2/" class="thumbnail">
    
    
        <span style="background-image:url(/images/job_thumbnail.jpeg)" alt="프론트엔드 면접 질문 리스트 - JS" class="thumbnail-image"></span>
    
    
</a>

                        </div>
                        
                        <div class="item-inner">
                            <p class="item-category"><a class="article-category-link" href="/categories/Blog/">Blog</a><i class="icon fa fa-angle-right"></i><a class="article-category-link" href="/categories/Blog/Job/">Job</a></p>
                            <p class="item-title"><a href="/2021/07/22/interview-question-js-2/" class="title">프론트엔드 면접 질문 리스트 - JS</a></p>
                            <p class="item-date"><time datetime="2021-07-22T07:17:30.000Z" itemprop="datePublished">2021-07-22</time></p>
                        </div>
                    </li>
                
                    <li>
                        
                        <div class="item-thumbnail">
                            <a href="/2021/05/10/nuxt-data-fetching/" class="thumbnail">
    
    
        <span style="background-image:url(/images/nuxt.png)" alt="Nuxt의 Data Fetching" class="thumbnail-image"></span>
    
    
</a>

                        </div>
                        
                        <div class="item-inner">
                            <p class="item-category"><a class="article-category-link" href="/categories/Programming/">Programming</a><i class="icon fa fa-angle-right"></i><a class="article-category-link" href="/categories/Programming/nuxt/">nuxt</a></p>
                            <p class="item-title"><a href="/2021/05/10/nuxt-data-fetching/" class="title">Nuxt의 Data Fetching</a></p>
                            <p class="item-date"><time datetime="2021-05-09T15:54:26.000Z" itemprop="datePublished">2021-05-10</time></p>
                        </div>
                    </li>
                
                    <li>
                        
                        <div class="item-thumbnail">
                            <a href="/2021/05/05/nuxt-bootstrap-dashboard-layout/" class="thumbnail">
    
    
        <span style="background-image:url(/images/nuxt.png)" alt="Nuxt와 Bootstrap4 기반의 Dashboard 만들기" class="thumbnail-image"></span>
    
    
</a>

                        </div>
                        
                        <div class="item-inner">
                            <p class="item-category"><a class="article-category-link" href="/categories/Programming/">Programming</a><i class="icon fa fa-angle-right"></i><a class="article-category-link" href="/categories/Programming/nuxt/">nuxt</a></p>
                            <p class="item-title"><a href="/2021/05/05/nuxt-bootstrap-dashboard-layout/" class="title">Nuxt와 Bootstrap4 기반의 Dashboard 만들기</a></p>
                            <p class="item-date"><time datetime="2021-05-05T14:53:27.000Z" itemprop="datePublished">2021-05-05</time></p>
                        </div>
                    </li>
                
            </ul>
        </div>
    </div>

            
                
    <div class="widget-wrap widget-list">
        <h3 class="widget-title">archives</h3>
        <div class="widget">
            <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/10/">October 2021</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/07/">July 2021</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/05/">May 2021</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/04/">April 2021</a><span class="archive-list-count">11</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/03/">March 2021</a><span class="archive-list-count">6</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/12/">December 2020</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/11/">November 2020</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/10/">October 2020</a><span class="archive-list-count">22</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/09/">September 2020</a><span class="archive-list-count">9</span></li></ul>
        </div>
    </div>


            
                
    <div class="widget-wrap widget-float">
        <h3 class="widget-title">tag cloud</h3>
        <div class="widget tagcloud">
            <a href="/tags/Algorithm/" style="font-size: 15px;">Algorithm</a> <a href="/tags/Babel/" style="font-size: 10px;">Babel</a> <a href="/tags/Blog/" style="font-size: 11.25px;">Blog</a> <a href="/tags/Browser/" style="font-size: 12.5px;">Browser</a> <a href="/tags/CSR/" style="font-size: 10px;">CSR</a> <a href="/tags/Client-Side-Rendering/" style="font-size: 10px;">Client Side Rendering</a> <a href="/tags/CompressionWebpackPlugin/" style="font-size: 10px;">CompressionWebpackPlugin</a> <a href="/tags/Critical-Rendering-path/" style="font-size: 10px;">Critical Rendering path</a> <a href="/tags/ECMAScript/" style="font-size: 12.5px;">ECMAScript</a> <a href="/tags/ECMAScript-2015/" style="font-size: 10px;">ECMAScript 2015</a> <a href="/tags/ECMAScript-6/" style="font-size: 10px;">ECMAScript 6</a> <a href="/tags/ES2015/" style="font-size: 10px;">ES2015</a> <a href="/tags/ES6/" style="font-size: 10px;">ES6</a> <a href="/tags/Front-end/" style="font-size: 15px;">Front-end</a> <a href="/tags/Hello-World/" style="font-size: 10px;">Hello World</a> <a href="/tags/Hexo/" style="font-size: 13.75px;">Hexo</a> <a href="/tags/Hoisting/" style="font-size: 10px;">Hoisting</a> <a href="/tags/Interview/" style="font-size: 15px;">Interview</a> <a href="/tags/Javascript/" style="font-size: 11.25px;">Javascript</a> <a href="/tags/Job/" style="font-size: 15px;">Job</a> <a href="/tags/Network/" style="font-size: 10px;">Network</a> <a href="/tags/Object/" style="font-size: 10px;">Object</a> <a href="/tags/Queue/" style="font-size: 10px;">Queue</a> <a href="/tags/Rendering/" style="font-size: 11.25px;">Rendering</a> <a href="/tags/Renewal/" style="font-size: 10px;">Renewal</a> <a href="/tags/SEO/" style="font-size: 10px;">SEO</a> <a href="/tags/SSR/" style="font-size: 10px;">SSR</a> <a href="/tags/Scope/" style="font-size: 10px;">Scope</a> <a href="/tags/Server-Side-Rendering/" style="font-size: 10px;">Server Side Rendering</a> <a href="/tags/Theme/" style="font-size: 11.25px;">Theme</a> <a href="/tags/Variable/" style="font-size: 10px;">Variable</a> <a href="/tags/arrow-function/" style="font-size: 10px;">arrow function</a> <a href="/tags/asset/" style="font-size: 10px;">asset</a> <a href="/tags/assignment/" style="font-size: 10px;">assignment</a> <a href="/tags/big-O/" style="font-size: 10px;">big-O</a> <a href="/tags/bootstrap/" style="font-size: 11.25px;">bootstrap</a> <a href="/tags/bootstrap-vue/" style="font-size: 11.25px;">bootstrap-vue</a> <a href="/tags/compression/" style="font-size: 10px;">compression</a> <a href="/tags/context/" style="font-size: 12.5px;">context</a> <a href="/tags/contructor/" style="font-size: 10px;">contructor</a> <a href="/tags/course-javascript/" style="font-size: 10px;">course,javascript</a> <a href="/tags/data/" style="font-size: 12.5px;">data</a> <a href="/tags/data-fetching/" style="font-size: 10px;">data fetching</a> <a href="/tags/data-structure/" style="font-size: 12.5px;">data structure</a> <a href="/tags/draft/" style="font-size: 10px;">draft</a> <a href="/tags/execution/" style="font-size: 12.5px;">execution</a> <a href="/tags/execution-context/" style="font-size: 12.5px;">execution context</a> <a href="/tags/function/" style="font-size: 10px;">function</a> <a href="/tags/git/" style="font-size: 11.25px;">git</a> <a href="/tags/github/" style="font-size: 11.25px;">github</a> <a href="/tags/image/" style="font-size: 10px;">image</a> <a href="/tags/javascript/" style="font-size: 20px;">javascript</a> <a href="/tags/javascript-engine/" style="font-size: 13.75px;">javascript engine</a> <a href="/tags/layout/" style="font-size: 10px;">layout</a> <a href="/tags/lecture/" style="font-size: 10px;">lecture</a> <a href="/tags/lifecycle/" style="font-size: 10px;">lifecycle</a> <a href="/tags/linked-list/" style="font-size: 10px;">linked list</a> <a href="/tags/mdn/" style="font-size: 12.5px;">mdn</a> <a href="/tags/new/" style="font-size: 10px;">new</a> <a href="/tags/new-%EC%83%9D%EC%84%B1%EC%9E%90/" style="font-size: 10px;">new 생성자</a> <a href="/tags/nuxt/" style="font-size: 18.75px;">nuxt</a> <a href="/tags/nuxt-lifecycle/" style="font-size: 10px;">nuxt lifecycle</a> <a href="/tags/nuxt-js/" style="font-size: 18.75px;">nuxt.js</a> <a href="/tags/object/" style="font-size: 11.25px;">object</a> <a href="/tags/object-oriented-javascript/" style="font-size: 10px;">object-oriented-javascript</a> <a href="/tags/oop/" style="font-size: 12.5px;">oop</a> <a href="/tags/portfolio/" style="font-size: 16.25px;">portfolio</a> <a href="/tags/project/" style="font-size: 16.25px;">project</a> <a href="/tags/prototype/" style="font-size: 11.25px;">prototype</a> <a href="/tags/reference/" style="font-size: 10px;">reference</a> <a href="/tags/structure/" style="font-size: 12.5px;">structure</a> <a href="/tags/time-complexity/" style="font-size: 10px;">time complexity</a> <a href="/tags/type/" style="font-size: 11.25px;">type</a> <a href="/tags/types/" style="font-size: 11.25px;">types</a> <a href="/tags/vue/" style="font-size: 17.5px;">vue</a> <a href="/tags/vue-js/" style="font-size: 18.75px;">vue.js</a> <a href="/tags/webpack/" style="font-size: 10px;">webpack</a> <a href="/tags/%EB%A7%81%ED%81%AC%EB%93%9C-%EB%A6%AC%EC%8A%A4%ED%8A%B8/" style="font-size: 10px;">링크드 리스트</a> <a href="/tags/%EB%B9%85%EC%98%A4/" style="font-size: 10px;">빅오</a> <a href="/tags/%EC%8B%9C%EA%B0%84-%EB%B3%B5%EC%9E%A1%EB%8F%84/" style="font-size: 10px;">시간 복잡도</a> <a href="/tags/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/" style="font-size: 13.75px;">알고리즘</a> <a href="/tags/%EC%9E%90%EB%A3%8C-%EA%B5%AC%EC%A1%B0/" style="font-size: 12.5px;">자료 구조</a> <a href="/tags/%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8/" style="font-size: 10px;">자바스크립트</a> <a href="/tags/%ED%81%90/" style="font-size: 10px;">큐</a> <a href="/tags/%ED%94%84%EB%A1%9C%ED%86%A0%ED%83%80%EC%9E%85/" style="font-size: 10px;">프로토타입</a>
        </div>
    </div>


            
        
    </div>
</aside>

                </div>
            </div>
        </div>
        <footer id="footer">
    <div class="container">
        <div class="container-inner">
            <a id="back-to-top" href="javascript:;"><i class="icon fa fa-angle-up"></i></a>
            <div class="credit">
                <h1 class="logo-wrap">
                    <a href="/" class="logo"></a>
                </h1>
                <p>&copy; 2021 Joontae Kim</p>
                
                <p>Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>. Theme by <a href="https://github.com/ppoffice" target="_blank">PPOffice</a></p>
                
            </div>
            <div class="footer-plugins">
              
    


            </div>
        </div>
    </div>
</footer>

    </div>
    
    
    <script>
    var disqus_shortname = 'joontae-kim';
    
    
    var disqus_url = 'https://joontae-kim.github.io/2020/10/26/interview-question-js-1/';
    
    (function() {
    var dsq = document.createElement('script');
    dsq.type = 'text/javascript';
    dsq.async = true;
    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
    </script>





    
        
<script src="/libs/lightgallery/js/lightgallery.min.js"></script>

        
<script src="/libs/lightgallery/js/lg-thumbnail.min.js"></script>

        
<script src="/libs/lightgallery/js/lg-pager.min.js"></script>

        
<script src="/libs/lightgallery/js/lg-autoplay.min.js"></script>

        
<script src="/libs/lightgallery/js/lg-fullscreen.min.js"></script>

        
<script src="/libs/lightgallery/js/lg-zoom.min.js"></script>

        
<script src="/libs/lightgallery/js/lg-hash.min.js"></script>

        
<script src="/libs/lightgallery/js/lg-share.min.js"></script>

        
<script src="/libs/lightgallery/js/lg-video.min.js"></script>

    
    
        
<script src="/libs/justified-gallery/jquery.justifiedGallery.min.js"></script>

    
    

    
    
    



<!-- Custom Scripts -->

<script src="/js/main.js"></script>


</body>
</html>
