{"meta":{"title":"dev and dev","subtitle":"내가 볼려고 만든 깃헙 블로그","description":"내가 볼려고 만든 깃헙 블로그","author":"Joontae Kim","url":"https://joontae-kim.github.io","root":"/"},"pages":[{"title":"about","date":"2020-09-23T06:16:16.000Z","updated":"2020-09-23T06:16:16.397Z","comments":true,"path":"about/index.html","permalink":"https://joontae-kim.github.io/about/index.html","excerpt":"","text":""}],"posts":[{"title":"프론트엔드 면접 질문 리스트 - JS","slug":"interview-question-js-2","date":"2021-07-22T07:17:30.000Z","updated":"2021-08-11T09:20:59.321Z","comments":true,"path":"2021/07/22/interview-question-js-2/","link":"","permalink":"https://joontae-kim.github.io/2021/07/22/interview-question-js-2/","excerpt":"","text":"프론트엔드 면접 준비를 위한 질문 리스트 정리Javascript아래질문 리스트를 기반으로 면접 질문 &amp; 답변 목록을 작성할 예정이고, 지속적으로 보충 or 보수할 계획입니다. 업데이트 날짜 2020-10-26 2021-07-02 질문 목록 수정 2021-07-22 2021-07-26 2021-07-27 질문 목록 및 답변 수정 질문 목록 ES6 ES6 이상의 버전을 브라우저에서 인식하지 못한다면 어떻게 해결해야 하는지? ES6 에서 추가된 스펙에 대해 아는대로 다 말해달라 Babel이란? babel은 컴파일러 인가 ? 트랜스파일러인가 Class 는 무엇이고, Prototype, fucntion의 ES5 스펙만으로 Class를 구현할수 있는가 ES6에서 화살표 함수와 일반 함수의 차이는 무엇인가 구조 분해 할당(destructuring) 이란 무엇인가 spread 문법과 장점과 rest 문법은 무엇이며 차이점은 무엇인가 Javascript의 디자인 패턴에 대해 아는대로 설명해주세요. 모듈 패턴과 전통적 상속, 각각의 장단점을 설명해보시오. 호스트 객체(Host Objects)와 네이티브 객체(Native Objects)의 차이점은 무엇인가요? 이벤트 버블링, 이벤트 위임(delegation)에 대해서 설명해달라 DOM (Document Object Model) 이벤트에 대한 질문 ``document.write()` 는 언제 사용하나요 ? 왜 load 이벤트와 같은 것을 사용하나요? 이 이벤트에는 단점이 있나요? 다른 대안을 알고 있나요? 알고 있다면 왜 그것을 사용할 건가요? document load event와 DOMContentLoaded event의 차이 attribute와 property use strict 은 무엇이고, 사용했을 때 장단점에 관해서 설명해주세요. Functional Programming 이란 무엇인지 설명해주세요 고차함수 (High-Order Function)란 무엇인지 설명해주세요. 자바스크립트의 배열(Array)이 실제 자료구조 배열이 아닌데 그 이유는? 자바스크립트의 순환참조란? 어떤게 문제이고 해결방법은? 자바스크립트와 관련한 same-origin 정책에 대해 설명 동일 출처 원칙을 회피하기 위한 방법으로는 무엇인 있으며 구체적으로 설정해달라. 1. ES6ES6 이상의 버전을 브라우저에서 인식하지 못한다면 어떻게 해결해야 하는지? 최신 자바스크립트의 호환성 문제를 해결하는 방법에 대한 질문 브라우저 별로 구동원리 또는 JS엔진 등의 차이가 있기 때문에 브라우저 호환성 이슈가 발생하는데, 이러한 차이를 최소화해 런타임 환경에 맞게 최적화 하는 작업을 크로스 브라우징이라고 하는데, Javascript의 호환성에 따른 충돌이나 부작용을 줄이기 위한 방법으로는 Babel이라는 도구를 사용하면 됩니다. 바벨은 주로 ES5 이상 버전의 코드를 현재 및 과거의 브라우저와 같은 환경에서 호환되는 버전으로 변환하는데 사용되는 도구로, IE나 다른 브라우저에서 동일한 기능을 제공하고 side-effect를 최소한으로 줄일수 있습니다. 바벨 공식 웹사이트에서는 바벨을 다음과 같이 정의한다. Babel is a toolchain that is mainly used to convert ECMAScript 2015+ code into a backwards compatible version of JavaScript in current and older browsers or environments. 바벨은 주로 ECMAScript 2015+ 코드를 현재 및 과거의 브라우저와 같은 환경에서 호환되는 버전으로 변환하는데 주로 사용되는 도구입니다. babel은 컴파일러 인가 ? 트랜스파일러인가Babel은 빌드 단계에서 Javascript를 다른 언어로 변환하는 것이 아닌 어플리케이션에서 설정된 환경에 맞게 또는 현재 사용하고 있는 대중적인 브라우저 스펙 또는 호환성에 맞는 하위 버전의 Javascript로 변환한다는 의미에서 Babel은 트랜스파일러라고 할 수 있습니다. 컴파일러와 트랜스파일러에 대해 설명하자면, 컴파일러 의 경우에는 한 언어도 작성된 코드를 다른 언어로 변환하는 것으로 C 코드로 개발된 코드를 Assembly 코드로 변환하는 것과 같고 트랜스파일러 란 한 언어로 작성된 소스 코드를 비슷한 수준의 추상화를 가진 언어로 변환하는 것을 의미합니다. 바벨의 빌드 단계를 설명하자면, 파싱, 변환, 출력의 단계로 코드를 변환하는데, 파싱: 코드를 읽고, 추상 구문 트리(AST)로 변환하는 단계 변환: 추상 구문 트리(AST)를 변경 출력: 변경된 결과물을 출력 위와 같은 빌드 단계를 통해 Babel은 Javascript의 호환성 이슈를 해결합니다. 그렇다면 바벨에서 코드를 변환하기 위한 규칙은 어떻게 설정하나바벨을 사용한다고 코드를 변환할 수 있다고 할수는 없으며 변환하기 위한 규칙이나 브라우저 버전을 설정해야 하는데 이 작업은 바벨 플러그인 이 담당합니다. 바벨 플러그인 이란, 바벨이 변환할 코드에 대한 규칙으로 custom으로 Javascript의 기능에 따라 각각 설정하기에는 까다롭고 매우 많기 때문에, preset 이라는 플러그인을 사용해 손쉽게 변환규칙을 설정해줄 수 있습니다. preset 이란 필요한 플러그인들을 목적에 따라 세트로 묶여 있는 플러그인으로 대표적인 프리셋 플러그인으로 preset-env 이 있으며 프로젝트가 지원하고자 하는 환경에 기반해 빌드 타임에 동적으로 결정하는 프리셋으로 ES6 이상의 코드를 변환합니다. 크로스 브라우징 이슈를 해결하기 위해 플러그인을 설정해 호환가능한 버전으로 변환하지만 빌트인 메서드나 JS 기능이 없는 경우에는 어떻게 해결할 수 있는가?빌드 과정에서 Babel을 통해 트랜스파일링 과정을 거쳤더라도 Promise와 같은 빌트인 또는 Array.prototype.includes 등의 인스턴스 메소드가 코드에 남아있을 수 있다. 해당 빌트인 또는 메서드를 지원하지 않는 환경에서는 에러를 유발하거나 어플리케이션이 멈추는 이슈가 발생하는데, 이를 해결하기 위한 기술이 폴리필 (Polyfill) 입니다. Babel 설정에서 폴리필을 설정하면, 최신 ECMAScript 환경을 만들기 위해 코드가 실행되는 환경에 존재하지 않는 빌트인 메서드 등을 추가해줍니다. 폴리필 전체를 빌드에 포함하면 번들 사이즈가 너무 커질수 있기 때문에, preset-env 의 useBuiltIns 옵션을 사용하면 빌드 타임에 babel-polyfill import를 꼭 필요한 폴리필 import로 대체해 번들의 사이즈를 줄일 수 있습니다. ES6 에서 추가된 스펙에 대해 아는대로 다 말해달라 ES5 (2009) 일반적으로 (구형 브라우저를 제외한) 모든 런타임에서 지원한다고 가정할 수 있는 Javascript의 기본 버전 Added forEach, map, filter, reduce, some, every in Array Methods Object getter &amp; setter Added stricter standards to strict mode JSON ES6 / ES2015 Standard Modules — import and export Standardised Promises Classes &amp; Inheritance Block-scoped variables — letand const Template Literals Object destructing into variables Generator functions Map and Set data structures Internationalisation for Strings, Numbers and Dates via Intl API Arrow Function ES7 / ES2016 Array.prototype.includes() Numeric exponent (power of) operator ** ES8 / ES2017 Async / Await Functions Object.entries, Object.values Methods String padding functions Allow Trailing commas to function expression arguement ES9 / ES2018 Object Rest/Spread const obj = &#123; ...props &#125;; Asynchronous Iteration for await (...) &#123; Promise finally() function Regular expression enhancements (lookbehind, named groups) ES10 / ES2019 Object.fromEntries flat, flatMap Symbol.description optional catch ES2015/ES6 를 기준으로 수많은 편리한 메서드와 문법들이 추가되었고 개발자들은 보다 점차 높은 수준의 Javascript를 구사할 수 있게 되었으며 사용자들 또한 높은 수준의 기능들을 경험할 수 있게 되었다. Class 는 무엇이고, Prototype, fucntion의 ES5 스펙만으로 Class를 구현할수 있는가둘 다 생성자 역할을 하지만 상속을 구현하는 방법에서 큰 차이가 있다. 1234567891011// ES5 Function Constructorfunction Person(name) &#123; this.name = name;&#125;// ES6 Classclass Person &#123; constructor(name) &#123; this.name = name; &#125;&#125; 아래는 상속을 구현한 코드. ES5 문법이 훨씬 더 길고 복잡하며 클래스 문법을 사용하면 간단하다. ES5에서는 생성자 함수를 상속받기 위해서 prototype에 새 객체를 복사하는 등 여러가지 작업이 필요하지만 클래스는 그런 과정이 필요없다. extends 키워드로 상속받을 함수를 명시하고, constructor 메소드에서 super(this) 만 추가하면 된다. 12345678910111213141516171819// ES5 Function Constructorfunction Student(name, studentId) &#123; // Call constructor of superclass to initialize superclass-derived members. Person.call(this, name); // Initialize subclass&#x27;s own members. this.studentId = studentId;&#125;Student.prototype = Object.create(Person.prototype);Student.prototype.constructor = Student;// ES6 Classclass Student extends Person &#123; constructor(name, studentId) &#123; super(name); this.studentId = studentId; &#125;&#125; 2. ES6에서 화살표 함수와 일반 함수의 차이는 무엇인가 일반 함수 는 함수를 선언할 때 this 에 바인딩할 객체가 정적으로 결정되는 것이 아니고, 함수를 호출할 때 함수가 어떻게 호출되었는지에 따라 this 에 바인딩할 객체가 동적으로 결정된다. 화살표 함수 는 함수를 선언할 때 this 에 바인딩할 객체가 정적으로 결정된다. 화살표 함수 안에서의 this 는 화살표 함수를 포함한 스코프의 this를 가리킨다. 3. 구조 분해 할당(destructuring) 이란 무엇인가ES6에서 도입된 객체, 배열의 값을 추출해서 변수에 바로 할당할 수 있는 편리한 문법입니다 디스트럭처링(destructuring) 할당이란 무엇인가요?디스트럭처링을 이용하면 배열의 요소나 객체의 속성을 배열 리터럴(literal)이나 객체 리터럴과 비슷한 문법을 이용해서 변수에 할당할 수 있습니다. 아주 간결한 문법입니다. 그러면서도 훨씬 더 명확합니다. 배열 Destructuring1234567// 배열 내 요소의 직접 접근 변수 할당var first = someArray[0];var second = someArray[1];var third = someArray[2];// 디스트럭처링을 이용한 변수 할당var [first, second, third] = someArray; 위와 같이 배열의 각 요소를 외부 변수에 할당할 수 있으며 배열과 이터러블(iterable) 을 이용해 디스트럭처링을 하면 특정 멤버 이외의 멤버들은 하나의 변수에 할당할 수도 있으며 또는 마지막 멤버만을 외부 변수에 할당할 수도 있습니다. 1234567let [ first, second, ...others ] = [1, 2, 3, 4, 5];// first: 1// second: 2// others: 3, 4, 5var [,,third] = [&quot;foo&quot;, &quot;bar&quot;, &quot;baz&quot;];console.log(third);// &quot;baz&quot; 객체 Destructuring객체를 디스트럭처링하면 변수에 객체의 속성값을 할당할 수 있습니다. 할당할 속성을 지정하고 그 속성값을 할당할 변수를 지정합니다. 12345678910111213141516171819202122// 기본 객체 디스트럭처링var robotA = &#123; name: &quot;Bender&quot; &#125;;var robotB = &#123; name: &quot;Flexo&quot; &#125;;var &#123; name: nameA &#125; = robotA;var &#123; name: nameB &#125; = robotB;console.log(nameA, nameB);// &quot;Bender&quot;, &quot;Flexo&quot;// 중첩 객체 디스트럭처링var complicatedObj = &#123; arrayProp: [ &quot;Zapp&quot;, &#123; second: &quot;Brannigan&quot; &#125; ]&#125;;var &#123; arrayProp: [first, &#123; second &#125;] &#125; = complicatedObj;console.log(first, second);// &quot;Zapp&quot;, &quot;Brannigan&quot; 한가지 주의할 것은 객체를 디스트럭처링해서 선언되지 않은 변수에 할당하는 경우입니다 (let, const, 또는 var를 함께 쓰지 않는 경우입니다). 12&#123; blowUp &#125; = &#123; blowUp: 10 &#125;;// Syntax error 이 구문이 에러를 일으키는 이유는 JavaScript 문법에 따라 엔진이 &#123;로 시작하는 모든 구문을 블록(block) 구문으로 해석하기 때문입니다. (예를 들어, &#123; console &#125; 은 유효한 블록 구문입니다). 구문 에러를 해결하는 방법은 문장 전체를 괄호로 감싸는 것입니다. 12(&#123; safe &#125; = &#123;&#125;);// No errors 사용사례 함수의 인자 정의 설정 객체의 파라메터 다중 결과값을 반환하기 함수의 인자 정의 개발자로서 API를 만들 때, 여러개의 속성을 가진 객체를 파라메터로 전달 받는 것이 좀 더 나은 접근입니다. 디스트럭처링을 이용하면 API 함수 안에서 파라메터 속성을 참조할 때마다 파라메터 객체를 반복해서 사용하는 것을 피할 수 있습니다. 123function removeBreakpoint(&#123; url, line, column &#125;) &#123; // ...&#125; 설정 객체의 파라메터 디스트럭처링하려는 객체의 속성에 디폴트 값을 줄 수도 있습니다. 이것은 설정값을 관리하는 객체가 있고, 각 설정값에 적절한 디폴트 값이 존재할 때 특히 도움이 됩니다. 다중 결과값을 반환하기 비록 여러개의 값을 리턴하는 기능이 랭귀지에 추가되지는 않았지만, 배열을 리턴하고 그 결과를 디스트럭처링할 수 있기 때문에 여러개의 값을 리턴하는 기능을 대신할 수 있습니다. 1234567891011121314function returnMultipleValues() &#123; return [1, 2];&#125;var [foo, bar] = returnMultipleValues();// foo: 1, bar: 2function returnMultipleValues() &#123; return &#123; foo: 3, bar: 4 &#125;;&#125;var &#123; foo, bar &#125; = returnMultipleValues();// foo: 3, bar: 4 4. spread 문법과 장점과 rest 문법은 무엇이며 차이점은 무엇인가spread ⇒ 데이터를 풀어놓는다, rest ⇒ 전달받은 데이터를 배열, 객체 안에 채워넣는다 ES6의 전개(spread) 문법은 함수형 패러다임으로 코드를 작성할 때 매우 유용하다. 배열이나 객체의 복제본을 Object.create 나 Array.prototype.slice , 또는 라이브러리 함수를 사용하지 않고도 간단하게 만들 수 있기 때문이다. 이 문법은 Redux나 RxJS 를 사용하는 프로젝트에서 자주 사용된다. 1234567891011121314function putDookieInAnyArray(arr) &#123; return [...arr, &quot;dookie&quot;];&#125;const result = putDookieInAnyArray([&quot;I&quot;, &quot;really&quot;, &quot;don&#x27;t&quot;, &quot;like&quot;]);// [&quot;I&quot;, &quot;really&quot;, &quot;don&#x27;t&quot;, &quot;like&quot;, &quot;dookie&quot;]const person = &#123; name: &quot;Todd&quot;, age: 29,&#125;;const copyOfTodd = &#123; ...person &#125;;// &#123;name: &quot;Todd&quot;, age: 29&#125; ES6의 rest 문법은 함수에 전달된 파라미터를 배열로 만들 수 있는 간단한 문법이다. 이것은 마치 spread 문법을 반대로 해놓은 것 같다. spread가 배열 안에 있는 데이터를 펼쳐놓는다면, rest 문법은 데이터를 받아서 배열에 채워넣기 때문이다. 이 문법은 함수 파라미터, 배열와 객체 destructuring에도 사용할 수 있다. destructuring에서 배열 데이터는 새로운 배열로, 객체 데이터는 새로운 객체로 만들어진다. 5. Javascript의 디자인 패턴에 대해 아는대로 설명해주세요.디자인 패턴디자인 패턴이란 무엇일까? 소프트웨어 개발을 하면서 발생하는 다양한 이슈들을 해결하는데 도움을 주는 일종의 증명된 기술들이다. 이미 많은 개발자들이 자바스크립트를 개발하면서 겪은 다양한 경험들을 바탕으로 만들어진 것들이다. 즉, 이런 상황에서는 이런 패턴을 사용하면 좋을거라는 일종의 방향성을 제시해준다. 패턴들은 정확한 해결책을 제공해주는 것이 아니다. 프레임워크나 라이브러리, 패턴 등은 그저 우리가 자바스크립트로 개발하는데 있어서 도움을 주는 도구일 뿐이고 이 패턴들을 어떻게 활용해서 어떤 식으로 개발한 것인지는 순전히 개발자의 역량에 달려있는 것이다. 디자인 패턴 종류모듈 패턴, 싱글톤 패턴, 팩토리 패턴, Iterator 패턴, Decorator 패턴 6. 모듈 패턴과 전통적 상속, 각각의 장단점을 설명해보시오.모듈 패턴모듈 패턴(Module pattern)은 Javascript 디자인 패턴 중 하나로, 클로저 개념을 이용해 구현할 수 있으며 객체를 public/private 개념으로 나누는 캡슐화 및 은닉화가 핵심 이다. 매우 기본적인 방법으로는 모든 코드를 익명함수로 감싸 내부 스코프를 생성하고, private method는 코드 접근을 제한할 수 있을뿐만 아니라 추가적인 자바스크립트가 다른 스크립트와 이름이 충돌하는 것을 막을 수 있다. 하지만 이렇게 하면 코드를 재사용하기 불편해지기 때문에 별도의 네임스페이스(namespace) 를 적용해야 한다. 이는 global 영역에 객체 고유의 영역을 지정하고 변수와 함수 할당에 해당 네임스페이스(namespace)의 하위에 둬 중복된 name으로 인한 오류를 피할 수 있다. 모듈 패턴을 작성함에 있어서 return 구문을 이용하여 공개/비공개 영역과 내부적으로 처리할 영역을 구분하여 공개여부를 선택할 수 있습니다. 1234567891011121314151617181920212223242526272829303132333435363738394041// namespace 패턴var myApp = myApp || &#123;&#125;; // 네임 스페이스 선언myApp.insanehong = function() &#123; return &#x27;insanehong&#x27;;&#125;;myApp.helloworld = function() &#123; return &#x27;hello world&#x27;;&#125;// 모듈 페턴var Messages = &#123;h : &#x27;hello&#x27;, w : &#x27;world&#x27;, insane:&#x27;insanehong&#x27;&#125;;var myApp = (function(msg) &#123; var helloworld = msg.h+&#x27; &#x27;+msg.w; var helloinsanehong = msg.h+&#x27; &#x27;+msg.insane; var printInsane = function () &#123; return helloinsanehong; &#125;; var printhello = function() &#123; return helloworld; &#125;; return &#123; foo1 : printInsane, foo2 : printhello &#125;;&#125;)(Messages);console.log(myApp.foo1());&gt; hello insanehongconsole.log(myApp.helloworld);&gt; undefined 모듈 패턴은 전역 영역에서 특정 변수영역을 보호하기 위해 단일 객체 안의 public/private의 변수를 포함할 수 있는 각 클래스 형식의 개념을 구현하는데 사용된다. 이 패턴으로 추가적인 자바스크립트 객체가 다른 스크립트의 객체와 충돌하는 것을 줄여줄 수 있다. Before module pattern 모듈 패턴을 사용하지 않으면 해당 객체가 모두 전역에서 인스턴스화 되어 다른 코드와 충돌 가능성이 높아진다. 객체 간의 연관성을 알기 어려워 코드관리가 어려우며 가용성이 떨어진다. 123456789const count = 3const publicMethod = function () &#123; console.log(&#x27;Public Method : &#x27;, count);&#125;const publicMethod2 = function () &#123; console.log(&#x27;Public Method2 : &#x27;, count);&#125;publicMethod();publicMethod2(); After module pattern 은닉화, 다형성, 상속을 통해 객체지향적으로 코드를 구성할 수 있다. 12345678910111213141516class Module &#123; private count: number = 3 private privateMethod() &#123; console.log(&#x27;Private Method : &#x27;, this.count); &#125; publicMethod() &#123; console.log(&#x27;Public Method : &#x27;, this.count); &#125; public publicMethod2() &#123; console.log(&#x27;Public Method2 : &#x27;, this.count); &#125;&#125;const mod = new Module();// mod.privateMethod(); // coudn&#x27;t accessmod.publicMethod();mod.publicMethod2(); 7. 네이티브 객체(Native Objects), 호스트 객체(Host Objects), Built-in 객체의 차이점은 무엇인가요? 네이티브 객체 는 ECMAScript 명세에 정의된 브라우저 혹은 구동 엔진에 내장되어 있는 자바스크립트의 모든 엔진에 구현된 표준객체이다. 네이티브 객체는 built-in 객체와 달리 자바스크립트 엔진이 구성하고 있는 기본객체라고 하기보단 브라우저 혹은 사용되는 자바스크립트 엔진에 영향을 많이 받게 된다. BOM 이라는 브라우저 객체 모델과 DOM 이라는 문서 객체 모델이 네이티브 객체에 포함되는데 이 객체의 사용성이 이를 구현한 구동엔진에 따라 각기 다르게 존재하는 경우가 있기 때문에 크로스 브라우징에 문제를 발생시키기도 한다. 호스트 객체 는 빌트인 객체와 네이티브객체에 포함되지 않은 사용자에 의해 생성된 객체를 의미한다. 자바스크립트 엔진은 빌트인 객체와 네이티브 객체를 구성한 이후 호스트객체를 해석하게 된다. Built-in 객체는 자바스크립트 엔진을 구성하는 기본 객체들을 포함한다. Number, String, Array, Date 등의 내장객체들이 있다 요약 네이티브 객체 : 브라우저 혹은 구동 엔진에 내장되어 있는 객체 DOM이 이에 해당 ⇒ 구동앤잔 별 사용성이 달라서 크로스 브라우징 문제를 바랭시키기도 함 호스트 객체 : 빌트인 또는 네이티브 객체에 포함되지 않은 사용자에 의해 생성된 객체 ⇒ js는 빌트인 및 네이티브 객체 구성 후 호스트 객체를 해석 8. 이벤트 버블링, 이벤트 캡쳐링, 이벤트 위임(delegation, 딜리게이션)에 대해서 설명해달라 이벤트 버블링은 특정 화면 요소에서 이벤트가 발생했을 때 더 상위 요소들로 전달되어 가는 특성을 의미합니다. 이벤트 캡처링은 이벤트 버블링과 반대로 상위 요소에서 하위 요소로 탐색하며 이벤트를 전파하는 방식입니다. 이벤트 위임은 이벤트 리스너를 하위 요소에 추가하는 대신 상위 요소에 추가하는 기법입니다. 리스너는 DOM의 event bubbling으로 인해 하위 요소에서 이벤트가 발생될 때마다 실행됩니다. 이 기술의 이점은 다음과 같습니다. 이 방법은 동적인 요소들에 대한 처리가 수월하며 이벤트 핸들러를 더 적게 등록해 주기 때문에 메모리도 절약할 수 있다. 각 하위 항목에 이벤트 핸들러를 연결하지 않고, 상위 요소에 하나의 단일 핸들러만 필요하기 때문에 제거된 요소에서 핸들러를 해제하고 새 요소에 대해 이벤트를 바인딩할 필요가 없습니다. 이벤트 전파 방식 이벤트 발생(사용자 이벤트 혹은 강제 이벤트 할당:trigger) 이벤트 발생 객체를 찾기 위하여 하위 탐색(캡쳐) 이벤트 발생 객체 도달 하위 탐색의 역순으로 복귀(버블링) IE의 경우 위와 같은 탐색에서 캡션단계를 지원하지 않음으로 이벤트 핸들링은 버블링을 기준으로 작성되어야 한다. 어찌 되었건 이벤트가 발생한 타겟에서 시작하여 상위로 해당 이벤트가 계속 해서 전파되어 버린다. 이를 버블링이라하며 이와 같은 버블링으로 인한 오작동을 방지 하기 위해서는 stopPropagation() 을 이용하여 이벤트 전파를 차단해 주어야 한다. 이벤트 흐름(Event flow)HTML 요소가 다른 요소의 내부에 중첩되어 있을 때 자식 요소를 클릭하면 부모 요소를 클릭한 셈이 된다. 이처럼 이벤트는 흐름을 가지고 있으며, 이것을 이벤트 흐름이라고 부른다. 이벤트 흐름에는 두 가지 방식이 있다. 먼저 이벤트 버블링(Event bubbling)은 이벤트가 직접적으로 발생한 노드로부터 시작해 바깥 노드로 이벤트가 퍼져 나가는 방식을 말한다. 대부분의 브라우저가 기본적으로 이 방식을 지원한다. 반대로 이벤트 캡쳐링(Event capturing)은 바깥 노드부터 시작해서 안쪽으로 퍼지는 방식이다. IE8 혹은 그 이전 버전에서는 지원되지 않는다. 이벤트 위임 CaseIE까지 고려한 코드다. 하나의 이벤트 리스너로 요소 3개를 제어하고 있다다. jQuery는 보다 편하게 이벤트를 바인딩할 수 있도록 .delegate() 메소드를 제공하고 있다. 12345&lt;ul id=&quot;todoList&quot;&gt; &lt;li&gt;TODO: A&lt;/li&gt; &lt;li&gt;TODO: B&lt;/li&gt; &lt;li&gt;TODO: C&lt;/li&gt;&lt;/ul&gt; 1234567891011121314151617181920212223242526272829function getTarget(e) &#123; if(!e) &#123; // event 객체가 존재하지 않으면 e = window.event; // IE의 event 객체를 사용 &#125; return e.target || e.srcElement; // 이벤트가 발생한 요소를 가져옴&#125;function itemDone(e) &#123; var elTarget, elParent; elTarget = getTarget(e); // 이벤트가 발생한 요소 가져옴 (li) elParent = target.parentNode; // 해당 요소의 부모 요소를 가져옴 (ul) elParent.removeChild(elTarget); // 이벤트가 발생한 요소를 제거함 (li)&#125;(function()&#123; var el = document.getElementById(&#x27;todoList&#x27;); if(el.addEventListener) &#123; // 이벤트 리스너가 지원되면 el.addEventListener(&#x27;click&#x27;, function(e) &#123; // 클릭 이벤트에 리스너를 지정 itemDone(e); &#125;, false); // 이벤트 버블링을 사용 &#125; else &#123; // 이벤트 리스너가 지원되지 않으면 el.attachEvent(&#x27;onclick&#x27;, function(e) &#123; // IE의 onclick 이벤트를 사용 itemDone(e); &#125; &#125;);&#125;)(); 9. document.write() 는 언제 사용하나요 ?document.write()는 document.open()에 의해 열린 문서 스트림에 텍스트 문자열을 씁니다. 페이지가 로드된 후에 document.write()가 실행되면 document.open을 호출하여 문서 전체를 지우고 (&lt;head&gt;와 &lt;body&gt;를 지웁니다!). 문자열로 주어진 매개 변수 값으로 대체합니다. 그러므로 일반적으로 위험하고 오용되기 쉽습니다. document.write()가 코드분석이나 JavaScript가 활성화된 경우에만 작동하는 스타일을 포함하고 싶을 때 사용되는 경우를 설명하는 온라인 답변이 몇 가지 있습니다. 심지어 HTML5 보일러 플레이트에서 스크립트를 병렬로 로드하고 실행 순서를 보존할 때도 사용됩니다! 그러나, 저는 그 이유가 시대에 뒤떨어진 것으로 생각하고 있으며, 현재는 document.write()를 사용하지 않고도 할 수 있습니다. 10. 왜 load 이벤트와 같은 것을 사용하나요? 이 이벤트에는 단점이 있나요? 다른 대안을 알고 있나요? 알고 있다면 왜 그것을 사용할 건가요? document load event와 DOMContentLoaded event에 대한 질문 두 Event 모두 DOM 을 다루기 위한 이벤트 이다. 하지만 두 이벤트에는 큰 차이가 있다. DOM을 제어하는 스크립트는 마크업의 모든 요소에 대한 처리가 끝난 뒤에 로드되어야 한다. 그래서 보통 &lt;body&gt; 태그 최하단에서 스크립트를 불러오도록한다. 또 다른 방법은 이벤트를 이용하는 것이다. document load event 페이지의 모든 리소스가 로드된 이후에 실행된다. 이 시점에서 문서의 모든 객체가 DOM에 있고, 모든 이미지, 스크립트, 링크 및 하위 프레임로딩이 완료됩니다. 때문에 구동이 지연되어 사용자 경험을 저하할 수 있다. DOMContentLoaded event 스크립트 로드를 마치고 실행이 가능한 시점에 바로 실행된다. DOM 이벤트 DOMContentLoaded는 페이지의 DOM이 생성된 후에 발생하지만 다른 리소스가 로딩되기를 기다리지 않습니다. 이것은 초기화되기 전에 전체 페이지가 로드될 필요가 없는 경우에 선호됩니다. 11. attribute와 property attribute : HTML 마크업에서 정의 property : DOM에서 정의 AttributesHTML 요소의 추가적인 정보를 전달하고 이름=“값” 이렇게 쌍으로 온다. 예를 들어 &lt;div class=&quot;my-class&quot;&gt;&lt;/div&gt; 를 보면 div 태그가 class 라는 값이 ‘my-class’인 attribute를 가지고 있다. Propertyattribute에 대한 HTML DOM 트리안에서의 표현이다. 그래서 위 예시에서 attribute는 값이 ‘my-class’이며 이름이 ‘className’인 property를 가진다. attribute 와 property의 차이는 무엇인가?Attributes는 HTML 텍스트 문서에 있는 것이고 properties는 HTML DOM 트리에 있는 것이다. 이것은 attribute는 변하지 않고 초기 (default)값을 전달한다는 것은 의미한다. 반면에 HTML properties는 변할 수 있다. 예를 들어 사용자가 체크박스를 체크했거나 input 박스에 텍스트를 넣었거나 JavaScript로 값을 변경하면 property의 값은 변한다. Input 박스에 value를 타이핑한다는 시나리오를 예로 들면, property는 DOM안에 존재하고 동적이기 때문에 property의 값만 변경되었다. 그러나 attribute는 HTML 문서안에 존재하고 결코 변하지 않는다. 12. use strict 은 무엇이고, 사용했을 때 장단점에 관해서 설명해주세요.‘use strict’는 전체 스크립트나 개별 함수에 엄격 모드를 사용하는데 사용되는 명령문입니다. Strict 모드는 JavaScript 다양한 자바스크립트를 제한하는 방법입니다. 장점: 실수로 전역변수를 만드는 것이 불가능합니다. 암묵적으로 실패한 예외를 throw하지 못하는 할당을 만듭니다. 삭제할 수 없는 속성을 삭제하려고 시도합니다. (시도 효과가 없을 때까지) 함수의 매개변수 이름은 고유해야합니다. this는 전역 컨텍스트에서 undefined입니다. 예외를 발생시키는 몇 가지 일반적인 코딩을 잡아냅니다. 헷갈리거나 잘 모르는 기능을 사용할 수 없게 합니다. 단점: 일부 개발자는 익숙하지 않은 기능이 많습니다. function.caller와 function.arguments에 더 이상 접근할 수 없습니다. 서로 다른 엄격한 모드로 작성된 스크립트를 병합하면 문제가 발생할 수 있습니다. 전반적으로 장점이 단점보다 중요하다고 생각합니다. 엄격 모드가 차단하는 기능에 의존하지 않아도 됩니다. 엄격한 모드를 사용하는 것을 추천합니다. 13. Functional Programming 이란 무엇인지 설명해주세요객체 지향 프로그래밍에서는 멤버변수의 상태를 공유하고, 상태를 변경함으로써 예상치 못한 버그를 일으킬 수 있습니다. 이를 보안한 함수형 프로그래밍은 불변성 으로 선언한 값을 복사해 변경하므로, 반환되는 값이 예측이 가능하다는 장점이 있습니다. 또한, 상태를 공유하기보다는 반환되는 값을 이용해 함수를 사용하기에 프로그램의 실행에 있어 영향을 끼치지 않습니다.이것을 고차 함수(High-Order Function), 순수 함수(Pure Function) 라고 합니다. 고차 함수는 1급 함수의 부분집합입니다. 따라서 함수를 변수에 할당할 수 있으며, 매개변수로 전달 할 수 있고 함수를 반환할 수도 있습니다. 이처럼 어떤 방법 으로 해야하는지를 나타내기보다 무엇 과 같은지 생각하는 것을 우리는 선언형 이라고 합니다. 14. 고차함수 (High-Order Function)란 무엇인지 설명해주세요.고차 함수는 함수를 파라미터로 받거나 함수를 리턴하는 함수를 말한다. 반복적으로 실행되는 어떤 작업을 추상화시키는 수단으로 사용한다. 고차 함수의 고전적인 예제는 Array.prototype.map 함수다. 배열을 기반으로 새로운 배열을 만들 때 사용하는데, 이런저런 과정을 생략하고 맵핑 로직만 전달하면 되기 때문에 코드가 무척 간결해진다. 배열에 문자열로 구성되어 있고, 모든 요소에 toUpperCase를 적용해서 새 배열을 만들어야 한다고 하자. map 없이 구현하려면 아래와 같지만 12345678910const names = [&quot;irish&quot;, &quot;daisy&quot;, &quot;anna&quot;];const transformNamesToUppercase = function (names) &#123; const results = []; for (let i = 0; i &lt; names.length; i++) &#123; results.push(names[i].toUpperCase()); &#125; return results;&#125;;transformNamesToUppercase(names); // [&#x27;IRISH&#x27;, &#x27;DAISY&#x27;, &#x27;ANNA&#x27;] .map(transformerFn) 함수를 사용한다면 무척 간단해진다. 1234const transformNamesToUppercase = function (names) &#123; return names.map((name) =&gt; name.toUpperCase());&#125;;transformNamesToUppercase(names); // [&#x27;IRISH&#x27;, &#x27;DAISY&#x27;, &#x27;ANNA&#x27;] Array의 forEach, filter, reduce 등도 모두 고차 함수다. 15. 자바스크립트의 배열(Array)이 실제 자료구조 배열이 아닌데 그 이유는?참조: 자바스크립트 배열은 배열이 아니다 (https://poiemaweb.com/js-array-is-not-arrray) 16. 자바스크립트의 순환참조란? 어떤게 문제이고 해결방법은?참조: 순환 참조 (https://jeonghwan-kim.github.io/dev/2020/03/24/circular-dependancy.html) 17. AJAX에 대해 설명해달라정의Asynchronous Javascript And XML의 약자로 브라우저가 가지고 있는 XMLHttpRequest 객체를 이용해서 서버와 브라우저가 비동기 방식으로 데이터를 교환할 수 있는 통신 기능으로, 데이터를 받아와 전체 페이지를 새로 고치지 않고도 페이지의 일부만을 위한 데이터를 불러올 수 있습니다. 장점 웹페이지의 속도향상 XMLHttpRequest 를 통해 필요로 하는 일부 데이터만 JSON이나 XML형태로 갱신하기 때문에 그만큼의 시간과 자원을 아낄 수 있다. 서버의 처리가 완료될 때까지 기다리지 않고 처리가 가능하다. =&gt; 비동기 처리 방식 지원 단점 Ajax로는 바이너리 데이터를 보내거나 받을 수 없다. Ajax는 클라이언트가 서버에 데이터를 요청하는 클라이언트 풀링 방식을 사용하므로, 서버 푸시 방식의 실시간 서비스는 만들 수 없다. XMLHttpRequest 를 통해 통신하는 경우, 사용자에게 아무런 진행 정보가 주어지지 않는다. (요청이 완료되지 않았는데 사용자가 페이지를 떠나거나 오작동할 우려가 발생하게 된다.) 동작원리Ajax를 이용한 웹 응용 프로그램은 자바스크립트 코드를 통해 웹 서버와 통신을 하며 사용자의 동작에 영향을 주지 않으면서 백그라운드에서 지속해서 서버와 통신할 수 있다. 사용자에 의한 요청 이벤트 발생 JS에서 XMLHttpRequest 객체를 사용해 서버로 요청 전송 XMLHttpRequest 는 비동기로 처리되기 때문에 요청을 전송하고 나서 웹 브라우저는 기다리지 않고 다른 작업을 처리할 수 있다. 서버는 전달받은 XMLHttpRequst 객체를 기반으로 AJAX 요청을 처리 처리된 HTML, XML 또는 JSON 형태의 데이터를 클라이언트측으로 전송 서버로부터 전달받은 데이터를 가지고 사용자 요청 이벤트를 처리하기 위한 Javascript Callback 함수 호출 사용자에 의한 요청 이벤트 완료 18. Same-Origin Policy 정책에 대해 설명해달라Same-Origin Policy 정의웹 어플리케이션 및 브라우저에서 중요한 보안 개념으로, 동일 출처의 리소스에 한해서만 데이터(DOM)에 접근할 수 있도록 하는 웹 브라우저 보안 정책으로, 동일 출처인지 판단하는 기준은 두 URL의 프로토콜, 포트 (명시한 경우), 호스트가 모두 같아야 동일 출처라고 말합니다. 동일 출처 판단 기준URI 를 결정하는 알고리즘은 RFC 6454 에 명시되어 있으며 출처(Origin)는 Protocol, Host, Port 번호 등으로 구성된 정보를 의미합니다. 만약 이 정보들 중 하나라도 다를 경우, 동일 출처 원칙에 위배된 것으로 판단합니다. 아래 표는 URL http://store.company.com/dir/page.html의 출처를 비교한 예시입니다. URL 결과 이유 http://store.company.com/dir2/other.html 성공 경로만 다름 http://store.company.com/dir/inner/another.html 성공 경로만 다름 https://store.company.com/secure.html 실패 프로토콜 다름 http://store.company.com:81/dir/etc.html 실패 포트 다름 (http://는 80이 기본값) http://news.company.com/dir/other.html 실패 호스트 다름 만일 동일 출처 원칙에 위배되는 AJAX 요청을 전송했을 경우, 아래와 같이 전송된 요청에서 Access-Control-Allow-Origin 헤더가 없다는 에러 메시지지를 받게 됩니다. XMLHttpRequest cannot load ‘https://store.company.com&#39;. No ‘Access-Control-Allow-Origin’ header is present on the requested resource. Origin ‘http://store.company.com&#39; is therefore not allowed access. 동일 출처 원칙을 사용하는 이유가장 큰 이유는 브라우저 측면에서의 웹 어플리케이션 보안 강화입니다. XSS 와 같은 스크립트 삽입 공격을 통해서 출처가 다른 웹 어플리케이션에 접근을 방지 웹 어플리케이션은 인증된 사용자 세션정보를 HTTP Cookie에 담아서 광범위하게 사용하곤 하는데, 출처(Origin)가 다른 페이지에서 스크립트를 이용해 해당 쿠키정보를 추출할 수 있기 때문 데이터의 기밀성 또는 일관성을 유지하기 위해서 클라이언트 측에서 관계 없는 사이트에서 제공된 컨탠츠를 분리해야함 동일 출처 원칙 회피방법 document.domain 속성 수정일부 제약이 있으나 페이지의 출처를 변경 가능. 스크립트로 document.domain 의 값을 현재 도메인이나 현재 도메인의 상위 도메인으로 변경할 수 있는데, 상위 도메인으로 설정한 경우 (더 짧은) 상위 도메인을 동일 출처 검사에 사용합니다. CORS(Cross-Orgin Resource Sharing)CORS는 Cross-Orgin Resource Sharing(상호 출처 자원 공유)의 약자로, 현재 접속중인 도메인의 출처와 다른 출처에 리소스를 요청 및 접근을 허가하는 웹 브라우저 보안 정책의 일환입니다. 이 방법은 서버단에서 처리해줘야 하는데, 요청된 리소스를 전송할때 HTTP 헤더에 Access-Control-Allow-Origin 헤더와 접근을 허가하는 값를 추가해 응답(Response) 메시지와 함께 전송하면 브라우저에서도 상호 출처 접근을 허가해 요청한 응답 리소스를 스크립트에서 사용할 수 있습니다. 19. 동일 출처 원칙을 회피하기 위한 방법으로는 무엇이 있으며 구체적으로 설정해달라.상호 출처 공유 원칙(Cross-Origin Resource Policy) 이란동일 출처 원칙 (Same-Origin Policy) 란 웹 어플리케이션 및 브라우저에서 중요한 보안 개념으로 동일 출처의 리소스에 한해서면 데이터에 접근할 수 있도록 하는 웹 브라우저 보안 정책입니다. 동일 출처 판단 기준은 Protocol, Host, Port 번호 등으로 구성된 출저가 모두 같아야 동일 출처라고 판단합니다. Same-Origin: https://www.same.com =&gt; https://www.same.com Cross-Origin: https://www.same.com =&gt; https://www.cross.com 그렇지면 현대의 웹 어플리케이션들은 동일 출처의 Resource 뿐만 아니고 상호 출처의 Resource에도 접근하며 뿐만 아니라 Client-Side와 Server-Side가 분리된 어플리케이션 구조를 띄고 있는 경우도 있습니다. 이럴 경우, 출처가 다르며 Same-Origin Policy 에러를 만나게 되는데, 이를 해결하기 위해 등장한 출처 원칙이 상호 출처 공유 원칙(Cross-Origin Resource Policy) 입니다. 상호 출처 공유 원칙(Cross-Origin Resource Policy) 이란현재 접속중인 도메인의 출차와 다른 상호 출처에 리소스를 요청할때 상호 출처의 Server-side 응답에 추가된 Header Access-Control-Allow-Origin 헤더를 사용해 웹 브라우저측에서 상호 출처의 요청이 웹 어플리케이션에 접근을 허가하는 보안 정책의 일환으로, 웹 어플리케이션은 리소스가 자신의 출처(domain, protocol, port)와 다를때 Cross-Origin HTTP 요청 을 실행합니다. CORS가 작동하는 방식CORS가 작동하는 방식가 작동하는 방식으로는 총 3가지로, Simple requests, Preflighted requests, Requests with credentials이 있습니다. Simple requests아래의 조건을 모두 충족하는 요청의 경우, CORS Preflight를 요청하지 않으며 이를 Simple request라고 칭합니다. 다음 중 하나의 메서드: GET, HEAD, POST POST 방식일 경우 conte-type이 아래 셋 중 하나여야 한다. application/x-www-form-unlencoded multipart/form-data text/plain 유저 에이전트가 자동으로 설정 한 헤더 외의 다음과 같은 수동으로 설정할 수 있는 헤더만 설정한 경우, Accept Accept-Language Content-Language Content-Type (아래의 추가 요구 사항에 유의하세요.) DPR Downlink (en-US) Save-Data Viewport-Width Width Simple requests 예시) 한 웹 어플리케이션에서 다른 출처의 리소스에 대해 접근 및 요청시 클라이언트와 서버간에 간단한 통신을 하고 CORS 헤더를 사용하여 권한을 처리합니다. 이 경우 브라우저가 서버로 전송하는 내용중 요청 헤더의 Origin 이 해당 상호 출처에 접근할 수 있음을 나타내기 위해 서버는 이에 대한 응답으로 Access-Control-Allow-Origin 헤더를 다시 전송합니다. 가장 간단한 접근 제어 프로토콜은 Origin 헤더와 Access-Control-Allow-Origin 을 사용하는 것입니다. 이 경우 서버는 Access-Control-Allow-Origin: *, 으로 응답해야 하며 이는 모든 도메인에서 접근할 수 있음을 의미하고, Access-Control-Allow-Origin: https://foo.example 와 같이 응답할 경우 https://bar.other 의 리소스 소유자가 https://foo.example 의 리소스에 대한 접근 요청 허용을 의미합니다. Preflighted requestsSimple Request 가 아닌 요청의 경우 Preflight Request 에 해당하며 클라이언트에서 상호 출처의 서버로 실제 요청을 보내기 전에 미리 보내는(preflight) 요청으로, OPTIONS HTTP 메서드로 실제 요청이 안전한지 확인하기 위한 목적을 가지고 있습니다. Preflight 요청을 받은 상호 출처(Cross-Origin)는 OPTIONS 메서드를 통해 전달된 Origin 값에 따라서 접근을 허용할지 또는 특정 작업을 수행할 리소스 서버에 대한 접근 허용을 판별하며 접근 허용시 응답 헤더에 Access-Control-Request-* 헤더를 추가해 요청을 전송한 출처(Origin)에게 응답을 전송합니다. 1234Access-Control-Allow-Origin: http://same.comAccess-Control-Allow-Methods: POST, GET, OPTIONSAccess-Control-Allow-Headers: X-CUSTOM-HEADER, Content-TypeAccess-Control-Max-Age: 86400 위 예시는 Preflight Request의 응답 헤더의 예로, Access-Control-Allow-Origin 는 http://same.com 의 접근 허가를 의미하고, Access-Control-Allow-Methods 는 상호 출처의 리소스에 접근할 수 있는 Methods를 의미합니다. 그리고 Access-Control-Allow-Headers 는 실제 요청에서 전송 가능한 사용자 정의 헤더로 대부분 필수로 포함해 전송해야하는 사용자 정의 헤더를 의미하고, Access-Control-Max-Age 는 Preflight Request에 대한 응답을 캐시할 수 있는 시간(초)을 제공합니다. 만약 Preflight Request로 허용되지 않는 요청임이 판명된다면 405 Method Not Allowed 에러를 반환하며 실제 요청은 상호 출처 서버로 전송되지 않습니다. Requests with credentials (인증이 필요한 요청)CORS Request는 기본적으로 Non-Credential 기반의 요청이지만 Cross-Origin에 인증 정보와 함께 리소스 접근 허가를 받아야 하는 경우를 Requests with credentials 이라고 합니다. 이 Request를 위해서는 인증 정보를 갖고 있는 쿠키를 실제 Request의 헤더에 담아 전송해야하며 총 두 가지 작업을 해줘야하고, 그 이후 쿠키와 함께 실제 Request를 전송할 수 있습니다. withCredentials: true 옵션을 추가Cross-Origin에 요청을 전송하는 Origin에서 Simple Request 의 경우에는 실제 Request의 헤더에 담아 Cross-Origin 측으로 전송하며 Cross-Origin 에서는 전송된 쿠키를 기반으로 인증 여부를 확인해 요청한 정보를 전달합니다. Preflighted Request 의 경우에는 Preflight Request의 헤더에 담아 Cross-Origin 측으로 전송하며 2 번 으로 넘어갑니다. (Preflight의 경우에만) Cross-Origin 에서 응답 헤더에 Access-Control-Allow-Crendentials: true 헤더를 추가해 전송1 번을 성공한 Preflighted Request의 경우 Cross-Origin 에서 응답 헤더에 Access-Control-Allow-Crendentials: true 를 추가해 요청한 Origin 에게 응답을 전송하며 Origin 은 쿠키 정보를 담은 헤더와 함께 실제 Request를 보낼 수 있습니다. “Access-Control-Allow-Origin’ header in the response must not be the wildcard ‘*’ when the request’s credentials mode is ‘include” 주의사항으로는 Preflighted Requests 의 경우, Preflight Request의 응답헤더에 Access-Control-Allow-Origin : &quot;*&quot; 으로 헤더에 추가 및 설정할 경우 위와 같은 에러를 유발하므로 요청한 Origin 으로 또는 와일드카드가 아닌 명시적 값으로 반드시 설정해야 합니다. 참조 프론트엔드 기술 조감도 : Babel - ahnheejong님 블로그 Babel이란 무엇인가 - devowen님 블로그 front-end 개발자 인터뷰 문제 - javascript 영역 - Insanehong님 블로그 📋 프론트엔드 개발자를 위한 토막상식 - parksb님 블로그 [JS/Pattern] 대표적인 자바스크립트, 디자인 패턴 정리 (Javascript, Design Pattern) HTML : attribute와 property 의 차이 💻 프론트엔드 면접 질문 - JS #3 - @chris님 블로그 기술면접 준비하기 2 - @heumheum2님 블로그 프론트엔드 면접 핸드북 - 자바스크립트(3) - rhostem님 블로그 ES6 In Depth: 디스트럭처링(Destructuring) 동일 출처 정책 CORS Axios 사용을 위한 PHP CORS 설정 CORS란? CORS를 해결해보자 [WEB] withCredentials 옵션","categories":[{"name":"Blog","slug":"Blog","permalink":"https://joontae-kim.github.io/categories/Blog/"},{"name":"Job","slug":"Blog/Job","permalink":"https://joontae-kim.github.io/categories/Blog/Job/"}],"tags":[{"name":"Front-end","slug":"Front-end","permalink":"https://joontae-kim.github.io/tags/Front-end/"},{"name":"Interview","slug":"Interview","permalink":"https://joontae-kim.github.io/tags/Interview/"},{"name":"Job","slug":"Job","permalink":"https://joontae-kim.github.io/tags/Job/"},{"name":"Javascript","slug":"Javascript","permalink":"https://joontae-kim.github.io/tags/Javascript/"}]},{"title":"Nuxt의 Data Fetching","slug":"nuxt-data-fetching","date":"2021-05-09T15:54:26.000Z","updated":"2021-05-10T07:33:59.719Z","comments":true,"path":"2021/05/10/nuxt-data-fetching/","link":"","permalink":"https://joontae-kim.github.io/2021/05/10/nuxt-data-fetching/","excerpt":"","text":"Nuxt는 Vue.js의 서버사이드 렌더링을 지원하기 위한 프레임워크로써, Vue.js SPA에서 데이터를 호출하는 방식과 다르게 비동기 데이터 호출을 위한 Hook이 따로 존재합니다. 이번 포스트에서는 그 Hook인 fetch와 asyncData Hook에 대해 살펴보겠습니다. fetch &amp; asyncData일단 공식문서의 간략한 설명을 번역하면 아래와 같다. fetch hook (Nuxt 2.12+)은 모든 컴포넌트에서 사용할 수 있고, (client-side 렌더링 중) 렌더링이 진행중인 상태와 에러에 대한 참조(shortcuts)를 제공합니다. asyncData은 오직 page 컴포넌트에서만 사용할 수 있습니다. fetch와 다르게 client-side 렌더링 중 로딩 placeholder를 표시할 수 없습니다: 대신에, 이 hook이 완료될때까지 route navigation을 막으며 실패했을 경우 페이지에 에러를 표시합니다. 아직 두개의 hook에 대해 너무나도 간략한 설명이기에 더 자세히 해보겠습니다. fetchfetch는 컴포넌트 인스턴스가 생성된 후 server-side 렌더링 동안 또는 client-side에서 네비게이션 되는 동안 호출되는 hook으로, 비동기 데이터 호출이 완료되었을때 (async/await를 사용) promise를 반환합니다. 초기 페이지가 렌더링 될때 서버사이드에서 호출 컴포넌트가 mounted 된 후 클라이언트에서 호출 fetch hook은 컴포넌트 레벨에서 아래의 property와 함께 $fetchState와 함께 노출됩니다. pending은 Boolean 값으로 client-side 에서 fetch hook이 호출되었을때 placeholder를 표시하도록 해줍니다. error는 null 또는 fetch hook이 반환한 Error입니다. timestamp는 최신 fetch의 timestamp로써, keep-alive으로 caching 하는 것에 유용합니다. Nuxt에 의해 fetch가 호출되는 것이외에도 컴포넌트에서 수동으로 this.$fetch()를 호출해 fetch를 사용할 수도 있습니다. 123456789101112131415161718192021222324252627&lt;template&gt; &lt;p v-if&#x3D;&quot;$fetchState.pending&quot;&gt;Fetching mountains...&lt;&#x2F;p&gt; &lt;p v-else-if&#x3D;&quot;$fetchState.error&quot;&gt;An error occurred :(&lt;&#x2F;p&gt; &lt;div v-else&gt; &lt;h1&gt;Nuxt Mountains&lt;&#x2F;h1&gt; &lt;ul&gt; &lt;li v-for&#x3D;&quot;mountain of mountains&quot;&gt;&#123;&#123; mountain.title &#125;&#125;&lt;&#x2F;li&gt; &lt;&#x2F;ul&gt; &lt;button @click&#x3D;&quot;$fetch&quot;&gt;Refresh&lt;&#x2F;button&gt; &lt;&#x2F;div&gt;&lt;&#x2F;template&gt;&lt;script&gt; export default &#123; data() &#123; return &#123; mountains: [] &#125; &#125;, async fetch() &#123; this.mountains &#x3D; await fetch( &#39;https:&#x2F;&#x2F;api.nuxtjs.dev&#x2F;mountains&#39; ).then(res &#x3D;&gt; res.json()) &#125; &#125;&lt;&#x2F;script&gt; Option fetchOnServer: Boolean or Function (기본값: true)이며 server-rendering 중에 fetch()를 호출할지 설정할 수 있습니다. fetchDelay: Integer (기본값: 200)이며 millisecond 단위로 최소 실행시간을 설정할 수 있습니다. fetchOnServer가 false 또는 false를 반환할 경우, fetch는 오직 client-side에서만 호출될 것이며 $fetchState.pending은 컴포넌트가 server-rendering일때 true를 반환할 것입니다. 1234567891011121314export default &#123; data() &#123; return &#123; posts: [] &#125; &#125;, async fetch() &#123; this.posts &#x3D; await fetch(&#39;https:&#x2F;&#x2F;api.nuxtjs.dev&#x2F;posts&#39;).then(res &#x3D;&gt; res.json() ) &#125;, &#x2F;&#x2F; call fetch only on client-side fetchOnServer: false&#125; querystring 변경 감지하기fetch hook은 기본적으로 querystring 변경시 호출되지 않는다. 이를 위해 $route.query를 관찰해 $fetch를 호출해야합니다. 12345678export default &#123; watch: &#123; &#39;$route.query&#39;: &#39;$fetch&#39; &#125;, async fetch() &#123; &#x2F;&#x2F; Called also on query changes &#125;&#125; 캐싱&lt;nuxt/&gt;과 &lt;nuxt-child/&gt; 컴포넌트에서 이미 방문했던 페이지의 fetch 호출을 절약하기 위해 keep-alive 디렉티브를 사용할 수 있습니다. 123&lt;template&gt; &lt;nuxt keep-alive &#x2F;&gt;&lt;&#x2F;template&gt; 또한, &lt;nuxt&gt; 컴포넌트에 keep-alive-props prop을 전달함으로써 &lt;keep-alive&gt;에 전달될 props를 명시할 수 있습니다. 1&lt;nuxt keep-alive :keep-alive-props&#x3D;&quot;&#123; max: 10 &#125;&quot; &#x2F;&gt; 메모리상 오직 10개 페이지 컴포넌트만 유지할 수 있습니다. activated hook 사용하기Nuxt는 (ssr을 포함한) 가장 최신의 fetch 호출에 대한 this.$fetchstate.timestamp를 직접 채웁니다. fetch에 30초 캐시를 추가하기 위해 activated hook을 혼합해 fetch property를 사용할 수 있습니다. 12345678910111213141516171819202122&lt;template&gt; ... &lt;&#x2F;template&gt;&lt;script&gt; export default &#123; data() &#123; return &#123; posts: [] &#125; &#125;, activated() &#123; &#x2F;&#x2F; Call fetch again if last fetch more than 30 sec ago if (this.$fetchState.timestamp &lt;&#x3D; Date.now() - 30000) &#123; this.$fetch() &#125; &#125;, async fetch() &#123; this.posts &#x3D; await fetch(&#39;https:&#x2F;&#x2F;api.nuxtjs.dev&#x2F;posts&#39;).then(res &#x3D;&gt; res.json() ) &#125; &#125;&lt;&#x2F;script&gt; 마지막 fetch 호출이 30초 전이었다면, 동일 페이지 내 navigation은 fetch를 호출하지 않을 것입니다. Async Data asyncData는 오직 pages 안에서만 사용가능하고 이 hook 안에서는 this 객체에 접근할 수 없습니다. asyncData는 universal nuxt app의 비동기 데이터 호출을 위한 또 다른 hook으로, fetch와 다르게 컴포넌트 인스턴스에서 비동기 state를 저장하기 위한 property를 설정해줘야 합니다(또는 Vuex actions의 dispatch). asyncData는 간단하게 컴포넌트의 지역 state에 반환된 값을 병합(merge)합니다. 123456789101112131415&lt;template&gt; &lt;div&gt; &lt;h1&gt;&#123;&#123; post.title &#125;&#125;&lt;&#x2F;h1&gt; &lt;p&gt;&#123;&#123; post.description &#125;&#125;&lt;&#x2F;p&gt; &lt;&#x2F;div&gt;&lt;&#x2F;template&gt;&lt;script&gt; export default &#123; async asyncData(&#123; params, $http &#125;) &#123; const post &#x3D; await $http.$get(&#96;https:&#x2F;&#x2F;api.nuxtjs.dev&#x2F;posts&#x2F;$&#123;params.id&#125;&#96;) return &#123; post &#125; &#125; &#125;&lt;&#x2F;script&gt; fetch와 다르게 route transition 동안 asyncData가 완료되고 promise를 반환합니다. 이것이 의미하는 바는 client-side transitions 동안에는 로딩 placeholder(loading placeholder)는 보여지지 않는다는 것입니다 (비록 유저에게 진행상태를 알려주기 위해 진행바를 사용할 수 있을지라도). 대신에 Nuxt는 다음 페이지로 navigation 되기 전 완료되거나 에러 페이지를 보여줄때까지 asyncData hook을 기다립니다. asyncData hook은 오직 page-level 컴포넌트에서 사용할 수 있습니다. fetch와 다르게 asyncData hook은 컴포넌트 인스턴스(this)에 접근할 수 없지만, 인자(argument)로써 context를 받으며 데이터를 호출하기 위해 사용할 있고, Nuxt.js는 자동으로 컴포넌트의 data와 반환된 객체를 병합합니다. 컴포넌트에서 Async data컴포넌트들은 asyncData 메서드를 가지고 있지 않기때문에 컴포넌트 내에서 server-side 비동기 데이터 호출을 할 수 없습니다. 이러한 제약사항에 관해서 3개의 옵션이 있습니다. 버전 2.12+ 또는 최신 버전의 Nuxt에서 new fetch hook 사용하기 mounted hook에서 API 호출 만들고, 로드 되었을때 data property를 설정합니다. 부작용: server side rendering에서 작동하지 않습니다. page 컴포넌트의 asyncData 메서드에서 API 호출 만들고 sub 컴포넌트에 props로 data 전달해줍니다. Server rendering은 잘 작동합니다. 부작용: 페이지의 asyncData는 다른 컴포넌트에 대한 data를 불러오기 때문에 덜 합리적일 수도 있습니다. querystring 변경 감지하기asyncData 메서드는 기본적으로 querystring의 변경시 호출되지 않습니다. 만약 호출을 원한다면, 예를 들어 pagination 컴포넌트를 개발할때, page 컴포넌트의 watchQuery property에서 감지할 수 있는 매개변수를 설정할 수 있습니다. (공식 홈페이지 The watchQuery Property 챕터 참조) 요약지금부터는 공식 홈페이지에서 fetch와 asyncData에 대한 spec에 대해 알아봤으나 난해한 개념을 보충하기 위한 몇 개 사이트의 내용을 요약해보겠습니다. 즉, 아래와 같이 목적을 구분할 수 있다. asyncData는 컴포넌트가 랜더링 되기전에 컴포넌트 데이터를 구성하는 것에 목적 fetch는 컴포넌트가 랜더링 되기전에 비동기 로직을 호출하는 것에 목적 Difference between Asyncdata vs Fetch 출처: https://stackoverflow.com/questions/49251437/difference-between-asyncdata-vs-fetch asyncData는 컴포넌트 레벨에서 설정 가능하며 Vuex store에서 접근 가능합니다. fetch는 컴포넌트 레벨에서 설정할 수 없으며 Vuex store에서 접근할 수 없습니다. asyncData와 fetch 둘다 server-side의 초기 렌더링에서 호출됩니다. 초기 로딩 이후에, asyncData와 fetch는 page의 route가 변경되었을때 호출됩니다. 만약 Nuxt 어플리케이션에서, Vuex store를 (데이터) 중앙 저장소로 이용하고, 어플리케이션 전체에서 Vuex store로 데이터를 접근할 경우 fetch를 사용 만약 Nuxt 어플리케이션에서, Vuex store를 (데이터) 중앙 저장소로 이용하고, 컴포넌트 레벨에서 설정한 옵션을 가지고 있고, 특정 route에서 가져온 data가 오직 1개의 컴포넌트에서 사용될 경우, Vuex store 또는 컴포넌트 레벨에 대한 권한을 가질수 있는 유연성이 필요한 경우, asyncData 사용 기타 블로그fetch 컴포넌트를 로드하기 전에 호출 모든 컴포넌트 에서 사용 가능 Nuxt.js는 컴포넌트가 렌더링되기 전 fetch promise가 종료될 때까지 대기함 fetch는 Vuex store의 data를 접근해 사용할때 사용 첫 번째 인자로 context를 받으며 store와 params를 사용할 수 있음 서버 사이드 렌더링을 위해 서버에서 화면을 구성할 때 컴포넌트가 생성되고 나서 실행됨 브라우저에서 URL 주소를 변경해서 페이지를 이동할 때 asyncData 컴포넌트를 로드하기 전에 호출 page 컴포넌트 에서만 사용 가능 asyncData로 생성한 데이터는 data로 생성한 데이터와 머지되어 사용하는 입장에서는 asyncData와 data는 차이가 없다. 단지 초기화시키는 데이터가 동기적으로 실행되는지 비동기적으로 실행되는지에 대한 차이가 있을 뿐이다. 첫 번째 인자로 context를 받으며 url의 params나 query를 사용할 수 있음 redirect나 error를 활용하여 원하는 페이지로 리다이렉트 시키거나 에러 페이지를 띄워줄 수 있음 만일 vuex가 설정되었다면, store를 사용 가능 asyncData는 컴포넌트를 초기화 하기 전에 실행되기 때문에 메서드 내부에서는 this를 통해 컴포넌트 인스턴스에 접근할 수 없다. 참조 data fetching Difference between Asyncdata vs Fetch nuxt.js 활용하기 Nuxt.js - asyncData(),fetch() https://joshua1988.github.io/vue-camp/nuxt/data-fetching.html#%EC%8B%B1%EA%B8%80-%ED%8E%98%EC%9D%B4%EC%A7%80-%EC%95%A0%ED%94%8C%EB%A6%AC%EC%BC%80%EC%9D%B4%EC%85%98%EA%B3%BC-%EB%8B%A4%EB%A5%B8-%EC%A0%90","categories":[{"name":"Programming","slug":"Programming","permalink":"https://joontae-kim.github.io/categories/Programming/"},{"name":"nuxt","slug":"Programming/nuxt","permalink":"https://joontae-kim.github.io/categories/Programming/nuxt/"}],"tags":[{"name":"vue.js","slug":"vue-js","permalink":"https://joontae-kim.github.io/tags/vue-js/"},{"name":"nuxt.js","slug":"nuxt-js","permalink":"https://joontae-kim.github.io/tags/nuxt-js/"},{"name":"nuxt","slug":"nuxt","permalink":"https://joontae-kim.github.io/tags/nuxt/"},{"name":"data fetching","slug":"data-fetching","permalink":"https://joontae-kim.github.io/tags/data-fetching/"}]},{"title":"Nuxt와 Bootstrap4 기반의 Dashboard 만들기","slug":"nuxt-bootstrap-dashboard-layout","date":"2021-05-05T14:53:27.000Z","updated":"2021-05-07T19:11:37.922Z","comments":true,"path":"2021/05/05/nuxt-bootstrap-dashboard-layout/","link":"","permalink":"https://joontae-kim.github.io/2021/05/05/nuxt-bootstrap-dashboard-layout/","excerpt":"","text":"오늘의 포스트는 Nuxt와 Bootstrap4 기반의 Dashboard 만들기 의 여섯번째 포스트로 Page &amp; UI 개발에 대해 작성해보겠습니다. 지난 포스트에서는 Bootstrap &amp; Bootstrap-vue 환경구성에 대해 작업해봤습니다. 본 포스트에서는 Page &amp; UI 개발에 대해 다뤄보겠습니다. 개발 순서 프로젝트 생성 및 Github Repository 환경구성 Heroku 배포 환경구성 Nuxt &amp; Express API 환경구성 Axios Bootstrap &amp; Bootstrap-vue 환경구성 Page &amp; UI 개발 Layout Layout은 Nuxt Views 구성 중 하나로, 이번 포스트에서 다룰 Layout은 Nuxt의 View 계층 중 상위 레벨에 속하며 header, footer 또는 sidebar와 같은 반복되는 UI 컴포넌트들을 특정 기준으로 그룹화해 특정 페이지등에 공통된 UI를 렌더링 할 수 있도록 합니다. 각 레이아웃에는 Vue 기반의 UI Component와 middleware 및 head 태그 옵션들을 property로 지정할 수 있습니다. Default Layout기본 레이아웃은 메인 레이아웃으로 확장할 수 있으며 layout property를 설정하지 않은 모든 페이지에서 사용가능하도록 설정됩니다. 페이지 구성요소에 포함되는 Layout을 만들때 가장 중요한 것은 &lt;/Nuxt&gt; 태그를 추가하는 것이며 Layout에 필요한 가장 기본적인 코드는 page 컴포넌트에 렌더링하는\u001d 아래의 세줄의 코드 입니다. 12345&#x2F;&#x2F; layouts&#x2F;default.vue&lt;template&gt; &lt;Nuxt &#x2F;&gt;&lt;&#x2F;template&gt; 또한, Navigation, Header 그리고 Footer 등의 더 많은 Component를 추가할 수도 있습니다. 123456789&#x2F;&#x2F; layouts&#x2F;default.vue&lt;template&gt; &lt;div&gt; &lt;TheHeader &#x2F;&gt; &lt;Nuxt &#x2F;&gt; &lt;TheFooter &#x2F;&gt; &lt;&#x2F;div&gt;&lt;&#x2F;template&gt; Custom Layoutlayouts 디렉토리의 top-level 수준의 모든 파일은 page 컴포넌트에서 layout property로 접근 가능한 custom Layout을 만듭니다. 12345678&#x2F;&#x2F; layouts&#x2F;blog.vue&lt;template&gt; &lt;div&gt; &lt;div&gt;My blog navigation bar here&lt;&#x2F;div&gt; &lt;Nuxt &#x2F;&gt; &lt;&#x2F;div&gt;&lt;&#x2F;template&gt; 예를 들어, blog 레이아웃을 만들기 위해 layouts 디렉토리에 blog.vue 레이아웃(layouts/blog.vue)을 생성했고 pages/posts.vue에서 blog 레이아웃을 사용하길 원한다면 pages/posts.vue의 layout property에서 아래와 같이 설정해 사용하면 됩니다. 1234567891011pages&#x2F;posts.vue&lt;script&gt;export default &#123; layout: &#39;blog&#39;, &#x2F;&#x2F; OR layout (context) &#123; return &#39;blog&#39; &#125;&#125;&lt;&#x2F;script&gt; Error Page에러 페이지는 에러가 발생했을때 반드시 볼 수 있는 page 컴포넌트로써, 비로 layouts 폴더에 배치되었지만, 페이지와 같이 다뤄야합니다. Layout이자 Page인 Error Page는 template에서 &lt;Nuxt&gt;를 포함하지 않는데 그 이유는 404, 500 과 같은 에러가 발생했을때 Component로 Error Page를 보여줄 것이기 때문입니다. 다른 page 컴포넌트와 비슷하게 동일한 방법으로 Error Page에 대한 custom layout을 설정할 수 있습니다. 12345678910111213141516&#x2F;&#x2F; layouts&#x2F;error.vue&lt;template&gt; &lt;div class&#x3D;&quot;container&quot;&gt; &lt;h1 v-if&#x3D;&quot;error.statusCode &#x3D;&#x3D;&#x3D; 404&quot;&gt;Page not found&lt;&#x2F;h1&gt; &lt;h1 v-else&gt;An error occurred&lt;&#x2F;h1&gt; &lt;NuxtLink to&#x3D;&quot;&#x2F;&quot;&gt;Home page&lt;&#x2F;NuxtLink&gt; &lt;&#x2F;div&gt;&lt;&#x2F;template&gt;&lt;script&gt;export default &#123; props: [&#39;error&#39;], layout: &#39;blog&#39; &#x2F;&#x2F; you can set a custom layout for the error page&#125;&lt;&#x2F;script&gt; Component기존의 Vue.js에 익숙한 개발자라면 알고 있듯이 페이지 또는 layout에 반복되는 재사용 가능한 UI Component로써, /components 디렉토리에서 생성해 불러올 수 있습니다. 또한, Component에서 특정 데이터가 필요한 경우 API에서 비동기 데이터에 접근하기 위해 Nuxt의 fetch() hook을 사용할 수 있습니다. v2.13 버전부터 Nuxt는 템플릿에서 사용할때 nuxt.config.js에서 아래와 같이 components: true를 설정하면 Component를 자동으로 가져올 수 있도록 활성화할 수 있습니다. 12345&#x2F;&#x2F; nuxt.config.jsexport default &#123; components: true&#125; 아래와 같이 components/ 디렉토리에 TheHeader와 TheFooter 컴포넌트를 생성하면 layouts/default.vue이라는 기본 레이아웃에서 바로 가져올 수 있습니다. 123components&#x2F; TheHeader.vue TheFooter.vue 123456789&#x2F;&#x2F; layouts&#x2F;default.vue&lt;template&gt; &lt;div&gt; &lt;TheHeader &#x2F;&gt; &lt;Nuxt &#x2F;&gt; &lt;TheFooter &#x2F;&gt; &lt;&#x2F;div&gt;&lt;&#x2F;template&gt; Dynamic ImportsComponent의 Dynamic Imports는 lazy loading을 통해 구현할 수 있으며 template에서 Component 태그 이름에 Lazy prefix를 추가해주면 됩니다. 123456789&#x2F;&#x2F; layouts&#x2F;default.vue&lt;template&gt; &lt;div&gt; &lt;TheHeader &#x2F;&gt; &lt;Nuxt &#x2F;&gt; &lt;LazyTheFooter &#x2F;&gt; &lt;&#x2F;div&gt;&lt;&#x2F;template&gt; Lazy prefix가 추가된 Component는 이벤트가 발생했을때 동적으로 불러올 수 있습니다. 123456789101112131415161718192021222324&#x2F;&#x2F; pages&#x2F;index.vue&lt;template&gt; &lt;div&gt; &lt;h1&gt;Mountains&lt;&#x2F;h1&gt; &lt;LazyMountainsList v-if&#x3D;&quot;show&quot; &#x2F;&gt; &lt;button v-if&#x3D;&quot;!show&quot; @click&#x3D;&quot;showList&quot;&gt;Show List&lt;&#x2F;button&gt; &lt;&#x2F;div&gt;&lt;&#x2F;template&gt;&lt;script&gt; export default &#123; data() &#123; return &#123; show: false &#125; &#125;, methods: &#123; showList() &#123; this.show &#x3D; true &#125; &#125; &#125;&lt;&#x2F;script&gt; Nested Directories1234components&#x2F; base&#x2F; foo&#x2F; Button.vue 만약 컴포넌트가 위와 같은 중접 디렉토리(Nested Directories)에 있다면, Component의 이름은 Component가 속한 디렉토리의 경로와 파일이름이 되어야 합니다. 따라서 위 Button Component를 template에서 사용하려면 &lt;BaseFooButton /&gt;와 같이 사용해야 합니다. 그러나 만약 디렉토리 구조를 Component의 이름으로 사용하지 않길 원한다면 nuxt.config.js에 Component가 속한 특정 디렉토리의 경로를 명시해야 하며 다음과 같은 &lt;FooButton /&gt; Component 태그이름을 사용할 수 있습니다. 12345678&#x2F;&#x2F; nuxt.config.jscomponents: &#123; dirs: [ &#39;~&#x2F;components&#39;, &#39;~&#x2F;components&#x2F;base&#39; ]&#125; Layout 및 Component 설계위에서 간략하게 Nuxt의 Layout과 Component 개념에 대해 알아봤으므로 프로젝트에 필요한 설계를 시작해보겠습니다. 이번 프로젝트는 제목에서도 알 수 있듯이 관리자 대시보드 프로젝트로써 필요한 Layout과 Component는 아래와 같습니다. Layout 기본 Dashboard 페이지 레이아웃 (for pages of needed authenticated) 비서비스 페이지 레이아웃 (for pages of not needed authenticated) 에러 레이아웃 (페이지) Component1. 기본 Dashboard 페이지 레이아웃(for pages of needed authenticated) Header Sidebar Main content area (for dashboard) 2. 비서비스 페이지 레이아웃(for pages of not needed authenticated) Header Main content area (for each page content) 3. 에러 레이아웃 Icon depending on Error Status Error Message Action Button area Layout 구현위에서 설계한 Layout을 차례대로 구현해보기전에 각 Layout에 중복되는 Component 이름이 있으므로 Component 디렉토리 구조를 아래와 같이 구성했습니다. 기본 Dashboard 페이지 레이아웃: components/dashboard 비서비스 페이지 레이아웃: components/base 에러 레이아웃: components/error 기본 Dashboard 페이지 레이아웃기본 Dashboard 페이지 레이아웃의 경우 아래와 같은 구조로 개발하려고 합니다. Sidebar와 Content로 구조를 단순화 하고, Content 영역 내부에서 Header와 Main content Area 영역을 구분지어 각 대시보드 페이지의 페이지를 렌더링할 수 있는 영역을 남겨놓도록 기획했습니다. 123456(root) ├─ Sidebar └─ Content ├─ Header └─ Main content Area 비서비스 페이지 레이아웃비서비스 페이지 레이아웃의 경우 아래와 같은 구조로 개발하려고 합니다. Header와 Main content Area로 구조를 단순화 하고, Main content Area 영역에서 추가로 레이아웃을 나눌수 있도록 했으며 각 페이지를 렌더링할 수 있는 영역을 남겨놓도록 기획했습니다. 1234(root) ├─ Header └─ Main content Area 에러 레이아웃비서비스 페이지 레이아웃의 경우 아래와 같은 구조로 개발하려고 합니다. Header와 Main content Area로 구조를 단순화 하고, Main content Area 영역에서 추가로 레이아웃을 나눌수 있도록 했으며 각 페이지를 렌더링할 수 있는 영역을 남겨놓도록 기획했습니다. 123456(root) ├─ Error Message │ ├─ Error Icon (Status Code) │ └─ Error Message └─ Main content Area 마치며 본 포스트에서는 Nuxt.js의 Views 컨셉과 그 요소인 Page, Layout 그리고 Component에 대해 알아보았고, 이번 프로젝트에서 필요한 Layout에 대한 설계와 Component에 대해 정의내려봤습니다. 앞으로는 페이지를 구현할 것이며 중간중간 Layout 또는 Layout에서 사용할 Component가 변경될 수 있을거 같습니다. 다음 포스트에서는 Dashboard 페이지의 첫번째 페이지인 Overview 페이지를 개발해보겠습니다. 감사합니다. 참고 Views views - pages views - layouts views - error-page directory-structure - pages directory-structure - layouts directory-structure - components directory-structure - nuxt-config","categories":[{"name":"Programming","slug":"Programming","permalink":"https://joontae-kim.github.io/categories/Programming/"},{"name":"nuxt","slug":"Programming/nuxt","permalink":"https://joontae-kim.github.io/categories/Programming/nuxt/"}],"tags":[{"name":"vue.js","slug":"vue-js","permalink":"https://joontae-kim.github.io/tags/vue-js/"},{"name":"nuxt.js","slug":"nuxt-js","permalink":"https://joontae-kim.github.io/tags/nuxt-js/"},{"name":"vue","slug":"vue","permalink":"https://joontae-kim.github.io/tags/vue/"},{"name":"nuxt","slug":"nuxt","permalink":"https://joontae-kim.github.io/tags/nuxt/"},{"name":"project","slug":"project","permalink":"https://joontae-kim.github.io/tags/project/"},{"name":"portfolio","slug":"portfolio","permalink":"https://joontae-kim.github.io/tags/portfolio/"},{"name":"bootstrap","slug":"bootstrap","permalink":"https://joontae-kim.github.io/tags/bootstrap/"},{"name":"bootstrap-vue","slug":"bootstrap-vue","permalink":"https://joontae-kim.github.io/tags/bootstrap-vue/"},{"name":"layout","slug":"layout","permalink":"https://joontae-kim.github.io/tags/layout/"}]},{"title":"Nuxt와 Bootstrap4 기반의 Dashboard 만들기","slug":"nuxt-bootstrap-dashboard-5","date":"2021-05-01T09:30:28.000Z","updated":"2021-05-05T14:47:58.392Z","comments":true,"path":"2021/05/01/nuxt-bootstrap-dashboard-5/","link":"","permalink":"https://joontae-kim.github.io/2021/05/01/nuxt-bootstrap-dashboard-5/","excerpt":"","text":"오늘의 포스트는 Nuxt와 Bootstrap4 기반의 Dashboard 만들기 의 다섯번째 포스트로 Bootstrap &amp; Bootstrap-vue 환경구성에 대해 작성해보겠습니다. 지난 포스트에서는 Axios 환경구성에 대해 작업해봤습니다. 본 포스트에서는 Bootstrap 설치와 환경세팅에 대해 다뤄보겠습니다. 개발 순서 프로젝트 생성 및 Github Repository 환경구성 Heroku 배포 환경구성 Nuxt &amp; Express API 환경구성 Axios Bootstrap &amp; Bootstrap-vue 환경구성 Page &amp; UI 개발 Bootstrap &amp; Bootstrap-vueBootstrap은 세계적으로 유명한 UI component library로 웹사이트를 mobile-first &amp; responsive 기능을 지원하는 Sass 기반의 프레임워크이다. Featuring Sass variables and mixins, responsive grid system, extensive prebuilt components, and powerful JavaScript plugins. Bootstrap-vue는 Bootstrap의 다양한 기능들을 Vue.js에 맞게 최적환된 UI 프레임워크로써, 이번 프로젝트에서 사용할것입니다. 설치Nuxt에서 Bootstrap-vue를 설치하는 방법은 총 두가지로, 첫번째는 Nuxt CLI를 통한 앱 생성시 UI Component 옵션에서 선택하는 방법과 두번째로는 직접 선택하는 방법입니다. 12345# With npmnpm install bootstrap-vue# With yarnyarn add bootstrap-vue 설치 후 아래와 같이 nuxt.config.js 파일의 module 프로퍼티에 bootstrap-vue/nuxt를 추가해주면 된다. 이러게 하면 bootstrap.css와 bootstrap-vue.css의 pre-compiled 된 기본 CSS를 포함합니다. 123module.exports &#x3D; &#123; modules: [&#39;bootstrap-vue&#x2F;nuxt&#39;]&#125; 주의할 점은 위와 같은 설치는 Icons 컴포넌트를 설치하지는 않는다는 것입니다. Nuxt.js 모듈에 아이콘을 포함하는 방법은 Bootstrap-vue의 Icons 섹션을 참고하는 것으로 대체하겠습니다. CSS 최적화; SCSS 모듈 최적화설치가 끝나면 nuxt.config.js의 modules property에 추가해주면 bootstrap-vue를 사용할 준비는 모두 끝났다. 그러나… 이렇게 사용할 경우 가장 큰 이슈는 불필요한 SCSS 모듈까지 포함되어 앱의 빌드속도와 렌더링 성능에 이슈가 발생한다. 이와 같은 이슈를 해결하기 위해 공홈의 Using custom Bootstrap SCSS 섹션과 개인적으로 최적화를 위해 사용하는 방법을 적용하고 소개해드리려고 합니다. CSS 최적화의 큰 순서는 먼저 pre-compiled 된 CSS 파일의 자동포함을 비활성화하고, 프로젝트에서 사용할 Bootstrap 및 BootstrapVue의 CSS의 사용자 지정 SCSS 파일을 생성해 import 하는 것입니다. pre-compiled 된 CSS 파일의 자동포함 비활성화Bootstrap SCSS 커스터마이징을 사용하는 경우 아래의 옵션을 false로 설정하여 Bootstrap 및 BootstrapVue pre-compiled 된 CSS 파일의 자동 포함을 비활성화해야 합니다. 1234567module.exports &#x3D; &#123; modules: [&#39;bootstrap-vue&#x2F;nuxt&#39;], bootstrapVue: &#123; bootstrapCSS: false, &#x2F;&#x2F; Or &#96;css: false&#96; bootstrapVueCSS: false &#x2F;&#x2F; Or &#96;bvCSS: false&#96; &#125;&#125; Bootstrap SCSS 커스터마이징 with 일반판(Official)BootstrapVue의 커스터마이징된 SCSS는 Bootstrap SCSS 변수 및 믹스인과 사용자가 설정한 변수 재정의에 의존하며 프로젝트의 사용자 지정 SCSS 파일에 Bootstrap 및 BootstrapVue SCSS를 포함 할 수 있습니다. 먼저 Bootstrap 및 BootstrapVue의 SCSS 환경을 커스터마이징할 custom.scss을 assets/styles 디렉토리에 생성하고, 아래의 코드를 적습니다. (프로젝트의 root에 styles 디렉토리를 생성하셔도 되고, assets 디렉토리에 생성하셔도 됩니다) 12345678910111213141516&#x2F;&#x2F; Custom Bootstrap variable overrides go first$grid-breakpoints: ( xs: 0, sm: 480px, md: 640px, lg: 992px, xl: 1300px);$enable-rounded: false;&#x2F;&#x2F; Then include the following@import &#39;bootstrap&#x2F;scss&#x2F;bootstrap.scss&#39;;@import &#39;bootstrap-vue&#x2F;src&#x2F;index.scss&#39;;&#x2F;&#x2F; And define any of your custom or additional CSS&#x2F;SCSS here,&#x2F;&#x2F; or via an @import 그런 다음 nuxt.config.js 파일의 css Property에 custom.scss 추가해줍니다. 12345css: [ &#39;~&#x2F;assets&#x2F;styles&#x2F;app.scss&#39; &#x2F;&#x2F; or &#x2F;&#x2F; &#39;~&#x2F;assets&#x2F;app.scss&#39;], Bootstrap SCSS 커스터마이징 with 확장판지금부터는 제가 Bootstrap과 같은 Component UI 라이브러리를 사용할때 빌드 사이즈를 줄이기 위한 커스터마이징 입니다. 실제 프로젝트에서 제가 사용하는 기법을 바탕으로 설명해드리겠습니다. 프로젝트 Style 구조화하기구조화에 앞서 먼저 해야할 것은 커스터마이징 할 SCSSS 모듈 구조를 파악하는 것입니다. 이번 프로젝트에서는 Bootstrap &amp; BootstrapVue를 사용하며 이 둘의 모듈 구조는 Bootstrap SCSS 커스터마이징 with 일반판(Official) 섹션에서 소개했던 custom.scss의 아래 코드 입니다. 123&#x2F;&#x2F; Then include the following@import &#39;bootstrap&#x2F;scss&#x2F;bootstrap.scss&#39;;@import &#39;bootstrap-vue&#x2F;src&#x2F;index.scss&#39;; 위 코드에서 알 수 있듯이 bootstrap, bootstrap-vue 디렉토리의 SCSS 파일 를 참고하고 있으며, 이제부터는 UI Component의 모든 style을 node_modules/로부터 직접 참조하는 구조가 아닌 프로젝트의 style 디렉토리 내에서 필요한 SCSS 모듈만 import해 사용하는 방식으로 구조화 해보겠습니다. 위 이미지에서 볼 수 있듯이 assets/styles 디렉토리는 library 디렉토리와 custom 디렉토리로 구성되어 있으며 library 디렉토리 내에는 /bootstrap 과 /bootstrapVue 디렉토리로 각자의 SCSS 모듈을 관리하게 될 것입니다. library 디렉토리: UI Component Library의 SCSS 모듈을 관리 custom 디렉토리: 직접 작성한 SCSS를 관리 Bootstrap 스타일 커스터마이징Bootstrap SCSS 모듈을 커스터마이징 하는 이유는 우리가 프로젝트를 개발할떄 모든 UI 컴포넌트를 사용하지 않을테고, 그럼에도 불구하고 모든 스타일 SCSS 파일들을 빌드한다면 앱의 빌드속도는 물론 앱의 전체 및 페이지 사이즈가 커져 로드 속도 또한 느려지기 때문입니다. 커스터마이징의 시작은 Bootstrap SCSS 파일 구조를 파악하는 것입니다. 아래 이미지의 좌측 탭은 node_modules/bootstrap/scss/bootstrap.scss 파일을 /library/bootstrap 디렉터리에 복사한 것으로, import된 모듈 경로를 수정해준후 필요한 컴포넌트의 스타일만 쓸수 있도록 설정해줍니다. 그리고 다음으로 커스터마이징이 필요한 파일은 아래와 같으며 _bootstrap.scss을 복사 및 작업했던 순서로 반복작업을 해줍니다. node_modules/bootstrap/scss/_variables.scss: bootstrap과 bootstrapVue에서 공통으로 쓰이는 SCSS 변수 파일로 특정 Component의 border-radius 값이나 color 값을 변경할 수 있음 node_modules/bootstrap/scss/_mixins.scss: bootstrap과 bootstrapVue에서 공통으로 쓰이는 SCSS mixin 파일로 _bootstrap.scss에서 비활성화된 컴포넌트와 관련된 mixin 모듈을 비활성화할 수 있음 bootstrap 에 필요한 모듈 커스터마이징을 완료했다면 다음으로는 bootstrapVue 를 bootstrap 과 같은 방식으로 커스터마이징 해주면 되며 모듈 최적화한 디렉토리는 아래와 같다. 마치며프론트엔드 UI를 개발하면서 Custom Style를 직접 개발할 수 있지만 최근에는 워낙 UI Library가 잘 개발되어 있으며 다양한 플랫폼에 맞게 그리고 다양한 디자인 트렌드에 맞게 구성되어 있습니다. 따라서 UI Library를 사용할 경우 위와 같은 커스터마이징을 통해 앱의 불필요한 스타일을 비포함할 수 있으며 특정 UI의 스타일을 수정해 사용할때도 적용할 수 있는 방법입니다. 다음으로는 대망의 페이지 개발입니다. 페이지 개발의 첫번째 순서로, 레이아웃 설계 에 대해 포스팅해보겠습니다.","categories":[{"name":"Programming","slug":"Programming","permalink":"https://joontae-kim.github.io/categories/Programming/"},{"name":"nuxt","slug":"Programming/nuxt","permalink":"https://joontae-kim.github.io/categories/Programming/nuxt/"}],"tags":[{"name":"vue.js","slug":"vue-js","permalink":"https://joontae-kim.github.io/tags/vue-js/"},{"name":"nuxt.js","slug":"nuxt-js","permalink":"https://joontae-kim.github.io/tags/nuxt-js/"},{"name":"vue","slug":"vue","permalink":"https://joontae-kim.github.io/tags/vue/"},{"name":"nuxt","slug":"nuxt","permalink":"https://joontae-kim.github.io/tags/nuxt/"},{"name":"project","slug":"project","permalink":"https://joontae-kim.github.io/tags/project/"},{"name":"portfolio","slug":"portfolio","permalink":"https://joontae-kim.github.io/tags/portfolio/"},{"name":"bootstrap","slug":"bootstrap","permalink":"https://joontae-kim.github.io/tags/bootstrap/"},{"name":"bootstrap-vue","slug":"bootstrap-vue","permalink":"https://joontae-kim.github.io/tags/bootstrap-vue/"}]},{"title":"Nuxt와 Bootstrap4 기반의 Dashboard 만들기","slug":"nuxt-bootstrap-dashboard-4","date":"2021-04-29T18:28:32.000Z","updated":"2021-04-30T17:32:33.111Z","comments":true,"path":"2021/04/30/nuxt-bootstrap-dashboard-4/","link":"","permalink":"https://joontae-kim.github.io/2021/04/30/nuxt-bootstrap-dashboard-4/","excerpt":"","text":"오늘의 포스트는 Nuxt와 Bootstrap4 기반의 Dashboard 만들기 의 네번째 포스트로 Axios에 대해 작성해보겠습니다. 지난 포스트에서는 Nuxt &amp; Express API 환경구성에 대해 작업해봤습니다. 본 포스트에서는 Nuxt에서 Axios를 사용하기 위한 환경세팅과 사용예제까지 다뤄보겠습니다. 개발 순서 프로젝트 생성 및 Github Repository 환경구성 Heroku 배포 환경구성 Nuxt &amp; Express API 환경구성 Axios Bootstrap &amp; Bootstrap-vue 환경구성 Page &amp; UI 개발 AxiosAxios는 browser와 node.js 기반 어플리케이션을 위한 promise 기반의 HTTP client로, 서버 사이드에서는 native node.js http 모듈을 사용하고, 클라이언드 사이드에서는 XMLHttpRequests 기반으로 작동한다. Axios에 대한 자세한 사항은 Axios 공식 문서를 참고해주시고, 이번 포스트에서는 Nuxt에서 사용하기 위한 Axios에 대한 부분만 다뤄보도록 하겠습니다. Axios with Nuxt Nuxt에서 Axios를 사용하기 위해서는 우리가 아는 axios가 아닌 Nuxt에 통합 및 최적화된 nuxt/axios 를 설치해 사용해야한다. 기능 Automatically set base URL for client &amp; server side Exposes setToken function to $axios so we can easily and globally set authentication tokens Automatically enables withCredentials when requesting to base URL Proxy request headers in SSR Fetch Style requests Integrated with Nuxt progress bar Integrated with Proxy Module Auto retry requests with axios-retry 설치설치하는 방법은 두 가지가 있다. 첫째는 Nuxt CLI로 앱 생성시 Nuxt.js modules 선택 옵션에서 설치하는 방법과 두번째는 일반적인 node package 설치 방법이다. 12345&#x2F;&#x2F; Install by yarnyarn add @nuxtjs&#x2F;axios&#x2F;&#x2F; Install by npmnpm install @nuxtjs&#x2F;axios 환경구성설치가 완료되면 root 디렉토리에 위치한 nuxt.config.js 파일의 modules 프로퍼티에 아래와 같이 &#39;@nuxtjs/axios&#39;를 추가해주면 Axios를 통한 모든 요청에 동일한 설정을 적용할 수 있습니다. 123export default &#123; modules: [&#39;@nuxtjs&#x2F;axios&#39;]&#125; 이제 Nuxt app에서 $axios를 사용할 수 있습니다. ✨ 옵션snuxt에서 설정할 수 있는 옵션은 아래와 같다. Runtile Config prfix, host and port baseURL browserBaseURL https progress proxy retry credentials debug proxyHeaders proxyHeaersIgnore headers 하지만… 위 옵션들을 다 하기에는 너무 많으므로 현재 필요한 baseURL만 다뤄봤기 때문에 이 옵션만 다루고 나머지는 추후 포스팅 해보겠습니다. baseURLbaseURL는 서버측 request를 작성하기 위해 사용되는 URL의 기본주소를 정의하는 옵션으로 nuxt.config.js에 아래와 같이 axios property에 baseURL을 지정해주면 된다. 12345&#x2F;&#x2F; Axios module configuration&#x2F;&#x2F; See https:&#x2F;&#x2F;axios.nuxtjs.org&#x2F;optionsaxios: &#123; baseURL: process.env.baseURL || &#39;http:&#x2F;&#x2F;localhost:3000&#39;&#125; process.env.baseURL은 전역 환경변수에 baseURL을 정의한 전역 환경변수로써, process.env.API_URL을 사용할 경우 baseURL을 덮어쓸수 있다(override). 주의할 점은 baseURL과 proxy를 동시에 사용할 수 없으며 proxy 옵션을 사용하고 싶으면 baseURL 대신에 prefix에 정의할 필요가 있다. 123456789&#x2F;&#x2F; Option: Proxyaxios: &#123; proxy: true &#x2F;&#x2F; Can be also an object with default options&#125;,proxy: &#123; &#39;&#x2F;api&#x2F;&#39;: &#39;http:&#x2F;&#x2F;api.example.com&#39;, &#39;&#x2F;api2&#x2F;&#39;: &#39;http:&#x2F;&#x2F;api.another-website.com&#39;&#125; 일반적으로 요청할 full adresss를 입력해야 하지만 아래와 같이 baseURL 옵션을 설정하면 특정 API route의 경로만 입력해도 된다. 123456&#x2F;&#x2F; &#96;baseURL&#96; 미지정await $axios.$get(&#39;http:&#x2F;&#x2F;localhost:3000&#x2F;api&#x2F;something&#39;)&#x2F;&#x2F; &#96;baseURL&#96; 지정await $axios.$get(&#39;&#x2F;api&#x2F;something&#39;) Extension공식적으로 지원하는 확장 기능은 아래와 같다. Adding Interceptors New Axios instance 이번에도 내가 필요한건 Interceptors 기능이므로 이것만 해보겠습니다. Interceptors with AxiosInterceptors 기능은 요청 또는 응답 전에 API 통신 error 등을 handling 할 수 있는 기능들을 axios의 전역 환경에 적용할 수 있는 기능입니다. 먼저, plugins/axios.js를 생성해 아래의 코드를 입력 후 nuxt.config.js 파일에 plugin을 등록해줍니다. 1234567891011121314&#x2F;&#x2F; plugins&#x2F;axios.jsexport default function (&#123; $axios, redirect &#125;) &#123; $axios.onRequest(config &#x3D;&gt; &#123; console.log(&#39;Making request to &#39; + config.url) &#125;) $axios.onError(error &#x3D;&gt; &#123; const code &#x3D; parseInt(error.response &amp;&amp; error.response.status) if (code &#x3D;&#x3D;&#x3D; 400) &#123; redirect(&#39;&#x2F;400&#39;) &#125; &#125;)&#125; 1234567&#x2F;&#x2F; nuxt.config.jsexport default &#123; plugins: [ &#39;~&#x2F;plugins&#x2F;axios&#39; ]&#125; Helpersnuxt/axios는 Interceptors 기능을 확장할 수 있는 Helpers API를 가지고 있습니다. InterceptorsAxios plugin은 Interceptors를 쉽고 빠르게 등록할 수 있도록 도와주며 아래의 함수들은 기본적으로 그 어떠한 값도 반환하지 않습니다. onRequest(config) onResponse(response) onError(err) onRequestError(err) onResponseError(err) 예시: (plugins/axios.js) error에 대해 인터셉트(intercept)할 경우, 오류 전파를 방지하기 위해 resolved promise를 반환합니다. 123456789export default function (&#123; $axios, error: nuxtError &#125;) &#123; $axios.onError(error &#x3D;&gt; &#123; nuxtError(&#123; statusCode: error.response.status, message: error.message, &#125;); return Promise.resolve(false); &#125;)&#125; 사용예제: Axios, Interceptors, Helpers간단하게, Axios를 확장해보는 예제를 진행해보겠습니다. 에러 핸들링 시나리오 404 에러: redirect(404) 500 에러: redirect(500) 이외 에러: Promise.reject({ statusCode, message }) 위 시나리오는 RestAPI 통신시 404, 500 에러가 왔을때 /404, /500 페이지로 redirect하고, 이외의 에러는 return Promise.reject(error)으로 원래의 HTTP error를 return 하려고 한다. 구현 코드는 아래와 같다. 123456789101112131415161718&#x2F;&#x2F; plugin&#x2F;axios.jsexport default function (&#123; $axios, redirect &#125;) &#123; &#x2F;&#x2F; Set baseURL $axios.setBaseURL(process.env.baseURL || &#39;http:&#x2F;&#x2F;localhost:3000&#39;) &#x2F;&#x2F; Add Interceptor $axios.onError((error) &#x3D;&gt; &#123; if (error.response.status &#x3D;&#x3D;&#x3D; 500) &#123; redirect(&#39;&#x2F;500&#39;) &#125; else if (error.response.status &#x3D;&#x3D;&#x3D; 404) &#123; redirect(&#39;&#x2F;404&#39;) &#125; else &#123; return Promise.reject(error) &#125; &#125;)&#125; 그리고 구현된 axios 플러그인을 nuxt.config.js에 등록해줍니다. axios 관련 설정은 아래와 같습니다. 123456789101112&#x2F;&#x2F; baseURL 의 경우, nuxt.config.js 또는 plugin&#x2F;axios.js 중 한 곳에서 설정해주면 됩니다.export default &#123; &#x2F;&#x2F; Plugins to run before rendering page: https:&#x2F;&#x2F;go.nuxtjs.dev&#x2F;config-plugins plugins: [ &#39;~&#x2F;plugins&#x2F;axios&#39; ], &#x2F;&#x2F; Modules: https:&#x2F;&#x2F;go.nuxtjs.dev&#x2F;config-modules modules: [ &#39;@nuxtjs&#x2F;axios&#39; ]&#125; 마치며지금까지 Nuxt에서 Axios 설치, 옵션 세팅 및 확장기능에 대해 다뤄봤습니다. 설치 및 사용하기 위한 옵션들이 기존의 SPA 앱을 만들기 위한 Vue.js에서와 많은 차이점이 있었고, Helper API, Extension 등의 내용을 살펴보면서 Nuxt 기반의 Axios는 어떻게 기능 확장을 할 수 있는지도 연습해봤습니다. 다음 포스팅에서는 본 프로젝트에서 사용할 UI Component인 Boostrap &amp; Boostrap-vue 에 대해 다뤄보겠습니다. 수고 많으셨습니다! 참고 the official for nuxt/axios directory-structure/modules directory-structure/plugins directory-structure/nuxt-config","categories":[{"name":"Programming","slug":"Programming","permalink":"https://joontae-kim.github.io/categories/Programming/"},{"name":"nuxt","slug":"Programming/nuxt","permalink":"https://joontae-kim.github.io/categories/Programming/nuxt/"}],"tags":[{"name":"vue.js","slug":"vue-js","permalink":"https://joontae-kim.github.io/tags/vue-js/"},{"name":"nuxt.js","slug":"nuxt-js","permalink":"https://joontae-kim.github.io/tags/nuxt-js/"},{"name":"vue","slug":"vue","permalink":"https://joontae-kim.github.io/tags/vue/"},{"name":"nuxt","slug":"nuxt","permalink":"https://joontae-kim.github.io/tags/nuxt/"},{"name":"project","slug":"project","permalink":"https://joontae-kim.github.io/tags/project/"},{"name":"portfolio","slug":"portfolio","permalink":"https://joontae-kim.github.io/tags/portfolio/"}]},{"title":"Nuxt와 Bootstrap4 기반의 Dashboard 만들기","slug":"nuxt-bootstrap-dashboard-3","date":"2021-04-29T07:18:23.000Z","updated":"2021-04-29T16:47:19.941Z","comments":true,"path":"2021/04/29/nuxt-bootstrap-dashboard-3/","link":"","permalink":"https://joontae-kim.github.io/2021/04/29/nuxt-bootstrap-dashboard-3/","excerpt":"","text":"오늘의 포스트는 Nuxt와 Bootstrap4 기반의 Dashboard 만들기 의 세번째 포스트로 Nuxt &amp; Express API 환경구성에 대해 작성해보겠습니다. 지난 포스트에서는 Heroku에 Nuxt SSR 앱을 배포하기 위한 환경설정과 배포가 되는 과정에 대해 작업해봤습니다. 본 포스트에서는 Nuxt 앱에 Express 기반의 API 생성과 Nuxt 앱에 API를 연결하는 부분까지 다뤄보겠습니다. 개발 순서 프로젝트 생성 및 Github Repository 환경구성 Heroku 배포 환경구성 Nuxt &amp; Express API 환경구성 Axios Bootstrap &amp; Bootstrap-vue 환경구성 Page &amp; UI 개발 들어가며…Nuxt 앱으로 샘플을 만들때 가장 고민했던 부분이 API 설계였다. 이유인 즉슨, API 설계를 고려하니 개발의 바운더리를 어디까지 정해야 할지 고민이 많이 됐기 때문이다. 정식으로 Database 붙이고, 설계하고, 에러 처리하고 등등 해야할 작업이 많기 때문이다. 그래서 이번 프로젝트는 포폴용이기 때문에 Back-end에서 Database없이 Sample Data로 대체하고 API 설계는 하던데로 controller와 route 설계 및 개발을 하기로 결정했다. Express with my nuxt app?Nuxt CLI를 통해 Nuxt App을 생성할때 Use a custom server framework 질문이 나오면 그때 express를 선택해 Server Template이 생성된 Nuxt app을 생성할 수 있다고 다른 블로그에서 많이 봤는데 CLI로 아무리 생성해봐도 custom server framework에 관한 질문은 나오지 않았다… 그래서 Nuxt의 공식 Github 저장소에 들어가서 issue를 뒤지던 중 2020년까지 넘어가니 아래와 같은 Issue를 찾을 수 있었고, 요약하자면 “deprecated” 되었다고 한다. 뭐… 아무튼… 잘못 사용하는 개발자들이 있었고 “not a good practice for most use cases” 가 있어서 CLI를 통한 앱 생성 질문에서 제거했다는 말이고, 대체 방법으로 API 라우트를 위해 express를 사용하는 방법으로 servermiddleware를 대체 방법으로 추천한다고 한다. The current alternative recommended approach is using a serverMiddleware to use express for API routes (supports HMR as well) or using separate server or serverless functions. 그렇다고 아예 방법이 없는 것이 아니었다. custom backend templates가 있지만 maybe outdated 상태라고 기재해놔서 express template을 사용할까말까 고민하다가 그래도 추천 방법으로 직접 세팅해보는 방법을 선택했다. 아래는 custom backend templates 링크 목록이다. Express: https://github.com/nuxt-community/express-template Koa: https://github.com/nuxt-community/koa-template Addonis: https://github.com/nuxt-community/adonuxt-template Hapi (deprecated): https://github.com/nuxt-community/hapi-nuxt serverMiddleware The current alternative recommended approach is using a serverMiddleware to use express for API routes (supports HMR as well) or using separate server or serverless functions. - from https://github.com/nuxt/create-nuxt-app/issues/563#issuecomment-656611288 현재는 공식적으로 추천하는 방법은 serverMiddleware를 사용하는 것이다. Nuxt.js에 대한 serverMiddleware에 대한 공식 블로그 설명을 참고해보면 아래와 같습니다. Nuxt는 사용자 지정 미들웨어를 추가할 수 있는 connet 인스턴스를 내부적으로 생성합니다. 이를 통해 외부 서버없이 추가 경로 (일반적으로 /api 경로)를 등록 할 수 있습니다. connect 자체가 미들웨어이기 때문에 등록된 미들웨어는 nuxt start와 함께 작동 할뿐만 아니라 express-template과 같은 프로그래밍 방식으로 사용되는 미들웨어로 사용될 때도 작동합니다. Nuxt 모듈은 this.addServerMiddleware()를 사용하여 serverMiddleware를 제공 할 수도 있습니다. 예) Server middleware path: /server-middleware Router base: /admin With prefix: true (default): /admin/server-middleware With prefix: false: /server-middleware Test CaseCustom API endpoint 생성전 먼저 express를 설치해야한다. 1npm i -S express Custom API endpointCustom API endpoint를 생성해보자. 프로젝트 디렉토리의 root 위치에서 api 디렉터리를 생성하고 API endpoint의 Test Case로 test.js을 생성 및 작성해보자. 123456789import express from &#39;express&#39;;const app &#x3D; express()app.get(&#39;&#x2F;&#39;, (req, res) &#x3D;&gt; &#123; console.log(&#39;&#x2F;api&#x2F;test&#39;); res.send(&#39;&#x2F;api&#x2F;test&#39;);&#125;)module.exports &#x3D; app serverMiddleware 설정Test Case로 작성한 test.js Endpoint를 nuxt.config.js의 serverMiddleware property에 추가해주자. 12345678serverMiddleware: [ &#123; path: &#39;&#x2F;test&#39;, handler: &#39;~&#x2F;api&#x2F;test.js&#39; &#125;],&#x2F;&#x2F; 또는&#x2F;&#x2F; serverMiddleware: [&#x2F;&#x2F; &#123; &#39;&#x2F;test&#39;: &#39;~&#x2F;api&#x2F;test.js&#39; &#125;&#x2F;&#x2F; ], serverMiddleware는 Array 형태로 위와 같이 API endpoint를 추가할 수 있으며 각 요소는 path와 handler를 맵핑하는 구조이다. path: client에서 호출할 주소 또는 경로 handler: API endpoint의 함수 목록 API 호출serverMiddleware 까지 완료되었다면 이젠 호출을 해보자. 현재 가지고 있는 Page는 아무 페이지에서 호출 테스트를 진행해보자. 본인은 현재 pages/index.vue만 있기 때문에 아래와 같이 작성헸고, 페이지를 reload하면.. 123456789101112131415161718export default &#123; async created () &#123; await this.callAPITest() &#125;, methods: &#123; async callAPITest () &#123; try &#123; console.log(&#39;callAPITest ~ &#39;) &#x2F;&#x2F; console.log(&#96; ~ &#96;) const res &#x3D; await this.$axios.$get(&#39;&#x2F;test&#x2F;&#39;) console.log(&#39; ~ res &#x3D;&gt; &#39;, res) &#125; catch (e) &#123; console.log(&#39; ~ e &#x3D;&gt; &#39;, e) console.log(&#39; ~ e.response &#x3D;&gt; &#39;, e.response) &#125; &#125; &#125;&#125; 성공!!! 마치며간단한거 같지만 Nuxt CLI에서 custom server template 에 대한 옵션을 deprecated 하면서 다소 빙글빙글 돌아간 느낌이 적지 않지만 그래서 Nuxt의 깃허브 공식 레포지터리에서 원하는 정보를 찾은 후로는 괜찮은 블로그를 많이 찾아 다행이었습니다.이번 포스팅에서 해봤던 구조는 단순한 것으로 더 많은 기능들이 추가되면 최적화 또는 여타 보완해야할 점들이 많을 것으로 추측되며 위와 같은 구조로 Rest API를 연동하면 된다는 소개 정도로 이해하셨으면 좋겠습니다. 다음 포스팅에서는 API 통신을 위한 HTTP 모듈인 Axios에 대해 다뤄보겠습니다. 수고 많으셨습니다! 참고 Nuxt Universal SSR Deployment to Heroku — includes connecting to an API and debugging Vuetify Express with my nuxt app? #563 configuration glossary/configuration dev use express with nuxt.js nuxt with an api/#using-nuxt-programmatically [VueJS] NuxtJS안에 express 적용하기","categories":[{"name":"Programming","slug":"Programming","permalink":"https://joontae-kim.github.io/categories/Programming/"},{"name":"nuxt","slug":"Programming/nuxt","permalink":"https://joontae-kim.github.io/categories/Programming/nuxt/"}],"tags":[{"name":"vue.js","slug":"vue-js","permalink":"https://joontae-kim.github.io/tags/vue-js/"},{"name":"nuxt.js","slug":"nuxt-js","permalink":"https://joontae-kim.github.io/tags/nuxt-js/"},{"name":"vue","slug":"vue","permalink":"https://joontae-kim.github.io/tags/vue/"},{"name":"nuxt","slug":"nuxt","permalink":"https://joontae-kim.github.io/tags/nuxt/"},{"name":"project","slug":"project","permalink":"https://joontae-kim.github.io/tags/project/"},{"name":"portfolio","slug":"portfolio","permalink":"https://joontae-kim.github.io/tags/portfolio/"}]},{"title":"Nuxt와 Bootstrap4 기반의 Dashboard 만들기","slug":"nuxt-bootstrap-dashboard-2","date":"2021-04-28T11:47:24.000Z","updated":"2021-04-29T07:40:27.282Z","comments":true,"path":"2021/04/28/nuxt-bootstrap-dashboard-2/","link":"","permalink":"https://joontae-kim.github.io/2021/04/28/nuxt-bootstrap-dashboard-2/","excerpt":"","text":"오늘의 포스트는 Nuxt와 Bootstrap4 기반의 Dashboard 만들기의 두번째 포스트로 Heroku 배포 환경구성 에 대해 작성해보겠습니다. 지난 포스트에서 Nuxt 프로젝트 생성과 Github Repository 환경구성을 해보았습니다. Nuxt 앱을 생성하기 위한 첫 시작부터 생성과정 그리고 버전관리를 위한 Github Repository를 생성하고 프로젝트에 연결했습니다. 본 포스트에서는 배포전략과 그에 따른 Heroku 서버 생성하기 및 배포 환경설정까지 다뤄보겠습니다. 개발 순서 프로젝트 생성 및 Github Repository 환경구성 Heroku 배포 환경구성 Nuxt &amp; Express API 환경구성 Axios Bootstrap &amp; Bootstrap-vue 환경구성 Page &amp; UI 개발 Heroku 란… Heroku란 컨테이너 기반의 클라우드 플랫폼으로 Paas 서비스로써, Java, Node.js, Python등 여러 언어를 지원하며 Heroku에서 지원하는 Interface에 따라 별도의 인프라 설정없이 손쉽게 앱을 배포할 수 있도록 지원해준다. 회원가입이나 Heroku의 회원가입 및 배포 방법에 대한 정보는 다른 블로그를 참고하시길 바랍니다. 프로젝트 배포 전략Heroku에서 App을 생성하기 전에 먼저, 프로젝트의 배포 전략을 수립해야합니다. 왜냐하면, 배포 전략에 따라 review, staging, production 환경의 서버가 필요할수 있기 때문이다. 본 프로젝트에서는 Git workflow를 아래의 branch와 같이 운용할 계획이며 배포전략은 master 브랜치를 production 서버로, develop 브랜치를 staging 서버로 계획했다. master develop hotfix release feature 배포전략에 따른 Heroku App 생성하기위에서 필요한 배포 서버가 정해졌으므로 production, staging 서버를 생성 및 코드 배포를 위한 환경설정을 진행해보겠습니다. staging 서버 생성 및 배포 환경설정staging 서버는 production 서버에 배포하기 전 테스트와 기능점검을 하기 위한 서버로써 Github 원격 Repository의 develop 브랜치 코드가 운영될 것입니다. 위 이미지는 staging 서버를 생성하는 이미지로, 서버 이름은 nuxt-bootstrap-dashboard-stage로 설정한 후 화면 하단의 Create APP 버튼을 클릭해줍니다. 앱 생성을 완료하면 아래 앱이 비어었는 초기화 상태로 배포방법을 설정하는 화면으로 이동합니다. 아래 staging 서버 배포 설정 1 이미지와 같이 Heroku에서 코드를 배포하는 방식은 총 3가지로, 아래 staging 서버 배포 설정 2 이미지와 같이 Github Repository를 연결한 후 배포할 branch를 설정한 후 해당 branch에 Merge Request가 완료되면 자동으로 배포되도록 설정했습니다. 이제 staging 서버에 배포하기 위한 설정을 완료했습니다. production 서버 또한 위와 같이 생성 및 배포환경 설정을 완료해주면 됩니다. 서버 환경설정위에서 우리는 두개의 서버를 생성 및 배포환경 설정을 완료했습니다. 이번 단계에서는 각 서버의 환경변수를 설정해주겠습니다. Heroku에서는 환경설정하는 방법이 두가지로 첫번째는 Heroku CLI 이고, 두번째는 Heroku에서 각 앱의 대시보드에서 설정해주는 것입니다. 여기서는 두 번째 방법을 통해 설정해주겠습니다. 서버의 환경변수로 설정할 값들은 아래와 같으며 Heroku에서는 각 앱의 Settings 페이지에 접속하면 화면 중간에 Config Vars 섹션이 있고 Reveal Config Vars 버튼을 클릭하면 서버의 환경변수를 입력할 수 있는 입력폼이 노출됩니다. 12heroku config:set HOST&#x3D;0.0.0.0heroku config:set NODE_ENV&#x3D;production &#x2F;&#x2F; or Staging 아래 이미지와 같이 위 변수를 설정해주면 서버 환경설정에 대한 것들은 완료한 상태이며 staging, production 서버 모두 같은 방식으로 설정하면 됩니다. 쉬는 시간!자, 이제 중간지점 까지 왔습니다! Heroku에서 앞으로 필요할 2개의 앱을 생성했고, 자동 배포를 위한 서버 배포설정 그리고 환경변수 설정까지 완료했습니다. 다음으로는 Heroku에서 앱을 가동시키기 위해 코드상에서 설정을 할 차례입니다. Procfile 작성하기Procfile이란 짧게 설명하자면 Heroku에서 앱을 실행시키기 위해 필요한 명령어의 순서를 명세한 파일로, Procfile 파일 생성 후 아래의 명령어를 작성한 후 Github 원격 저장소로 commit &amp; push 하면 Heroku staging 서버에서 변경사항을 배포합니다. 1web: nuxt start 사실 Heroku + Nuxt에 대한 자료가 많지 않아서 하라는데로는 하는데 배포 Process에 대한 설명은 없어서 Build Log를 살펴봤습니다. 궁금한 것만 살펴보면 Build 과정이 시작되면 아래와 Line 5 와 같이 nuxt build npm script를 실행해 빌드 Process를 시작해 Client, Server를 차례로 컴파일을 진행합니다. (Compiling Client: Line 14, Compiling CliServerent: Line 17) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657-----&gt; Build Running build &gt; nuxt-bootstrap-dashboard@1.0.0 build &#x2F;tmp&#x2F;build_1cf41942 &gt; nuxt build ℹ Production build ℹ Bundling for server and client side ℹ Target: server ℹ Using components loader to optimize imports ℹ Discovered Components: .nuxt&#x2F;components&#x2F;readme.md ✔ Builder initialized ✔ Nuxt files generated ℹ Compiling Client ERROR [BABEL] Note: The code generator has deoptimised the styling of &#x2F;tmp&#x2F;build_1cf41942&#x2F;node_modules&#x2F;bootstrap-vue&#x2F;src&#x2F;icons&#x2F;icons.js as it exceeds the max of 500KB. ✔ Client: Compiled successfully in 36.58s ℹ Compiling Server ✔ Server: Compiled successfully in 3.03sHash: e8c131655dbf5ab4f08dVersion: webpack 4.46.0Time: 36579msBuilt at: 04&#x2F;28&#x2F;2021 7:23:00 PM Asset Size Chunks Chunk Names..&#x2F;server&#x2F;client.manifest.json 19.2 KiB [emitted] 4a71c2b.js 642 KiB 5 [emitted] [immutable] [big] vendors&#x2F;app 6535929.js 206 KiB 1 [emitted] [immutable] commons&#x2F;app 93a6776.js 3.04 KiB 3, 2 [emitted] [immutable] pages&#x2F;index 98766dc.js 46.1 KiB 0 [emitted] [immutable] app LICENSES 1.95 KiB [emitted] b6f428a.js 2.3 KiB 4 [emitted] [immutable] runtime bef1150.js 1.43 KiB 2 [emitted] [immutable] components&#x2F;logo + 2 hidden assetsEntrypoint app &#x3D; b6f428a.js 6535929.js 4a71c2b.js 98766dc.jsWARNING in asset size limit: The following asset(s) exceed the recommended size limit (244 KiB).This can impact web performance.Assets: 4a71c2b.js (642 KiB)Hash: 0b8712d7140280abc02bVersion: webpack 4.46.0Time: 3034msBuilt at: 04&#x2F;28&#x2F;2021 7:23:03 PM Asset Size Chunks Chunk Names components&#x2F;logo.js 5.41 KiB 1 [emitted] components&#x2F;logo pages&#x2F;index.js 11.5 KiB 2, 1 [emitted] pages&#x2F;index server.js 299 KiB 0 [emitted] appserver.manifest.json 307 bytes [emitted] + 3 hidden assetsEntrypoint app &#x3D; server.js server.js.map ℹ Ready to run nuxt start -----&gt; Caching build - node_modules -----&gt; Pruning devDependencies Skipping because NODE_ENV is not &#39;production&#39; -----&gt; Build succeeded! 빌드가 완료되면 앱을 실행시킬 준비가 되었다고 Line 49 와 같이 Ready to run nuxt start가 출력되는데 이는 우리가 Procfile 파일에 작성한 web: npm start에 의해 실행되는 것입니다. 그럼…이제 배포를 시도한 앱의 사이트에 접속해보면….짜잔!!! 배포에 성공했습니다! 마치며지금까지 Heroku에 Nuxt 기반의 앱을 배포하기 위한 배포전략과 그에 따른 Heroku 앱 생성 및 Procfile 생성과 Github 연동으로 배포 자동화와 같은 설정을 완료했습니다. 배포는 성공했지만 Nuxt와 Heroku에 대한 많은 자료가 있지 않아 궁금한 사항들에 대해 제대로 설명하지 못한 부분들이 있어 블로그를 쓰면서도 아쉬운 부분이 있습니다. 그러한 사항들을 앞으로 추후 포스팅하겠습니다. 다음 포스팅으로는 Nuxt &amp; Express 환경구성 에 대해 다뤄보겠습니다. 모두들 수고 많으셨습니다! 참고 Deploy Nuxt on Heroku Nuxt Universal SSR Deployment to Heroku — includes connecting to an API and debugging Vuetify 3 services to deploy your Node.js app for free How to Deploy Nuxt.js to Heroku Nuxt Server Side Rendering vs Pre-rendering","categories":[{"name":"Programming","slug":"Programming","permalink":"https://joontae-kim.github.io/categories/Programming/"},{"name":"nuxt","slug":"Programming/nuxt","permalink":"https://joontae-kim.github.io/categories/Programming/nuxt/"}],"tags":[{"name":"vue.js","slug":"vue-js","permalink":"https://joontae-kim.github.io/tags/vue-js/"},{"name":"nuxt.js","slug":"nuxt-js","permalink":"https://joontae-kim.github.io/tags/nuxt-js/"},{"name":"vue","slug":"vue","permalink":"https://joontae-kim.github.io/tags/vue/"},{"name":"nuxt","slug":"nuxt","permalink":"https://joontae-kim.github.io/tags/nuxt/"},{"name":"project","slug":"project","permalink":"https://joontae-kim.github.io/tags/project/"},{"name":"portfolio","slug":"portfolio","permalink":"https://joontae-kim.github.io/tags/portfolio/"}]},{"title":"Nuxt와 Bootstrap4 기반의 Dashboard 만들기","slug":"nuxt-bootstrap-dashboard-1","date":"2021-04-28T07:55:51.000Z","updated":"2021-04-29T07:21:39.248Z","comments":true,"path":"2021/04/28/nuxt-bootstrap-dashboard-1/","link":"","permalink":"https://joontae-kim.github.io/2021/04/28/nuxt-bootstrap-dashboard-1/","excerpt":"","text":"오늘의 포스트는 Nuxt와 Bootstrap4 기반의 Dashboard 만들기의 첫 시작으로 프로젝트 생성 및 Github 환경구성 에 대해 작성해보겠습니다. 지난 포스트에서 Dashboard 개발에 관한 전반적인 사항들을 설계해봤습니다. 그럼 개발을 시작하기 전에 Nuxt 프로젝트 생성과 Github Repository 환경구성을 해보겠습니다. 개발 순서 프로젝트 생성 및 Github Repository 환경구성 Heroku 배포 환경구성 Nuxt &amp; Express API 환경구성 Axios Bootstrap &amp; Bootstrap-vue 환경구성 Page &amp; UI 개발 Nuxt 프로젝트 생성Nuxt는 Vue.js의 Server-Side Rendering을 지원하기 위한 프레임워크로, SSR 뿐만 아니라 Static Site 그리고 SPA 또한 지원한다. (Nuxt에 대한 소개는 추후 다른 포스트에서 계속하기로 하고…) 이제 Nuxt 프로젝트를 생성해보자!!! Nuxt를 생성하기 위한 명령어로는 아래와 같으며 123456789&#x2F;&#x2F; yarnyarn create nuxt-app &lt;project-name&gt;&#x2F;&#x2F; npxnpx create-nuxt-app &lt;project-name&gt;&#x2F;&#x2F; npmnpm init nuxt-app &lt;project-name&gt; 저는 두번째 npx CLI를 통해 생성해보겠습니다. 1npx create-nuxt-app nuxt-bootstrap-dashboard 위 명령어를 실행하면 nuxt 앱을 생성하기 위한 다양한 옵션이 있으며 프로젝트에 맞는 옵션을 선택해주면 프로젝트 초기부터 구조가 잡힌 상태로 생성되면 그렇지 않다고 해서 개발 도중에 환경구성을 추가로 할 수 있다. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162create-nuxt-app v3.6.0? Project name: nuxt-bootstrap-dashboard? Programming language: (Use arrow keys)❯ JavaScript TypeScript? Package manager: (Use arrow keys) Yarn ❯ Npm? UI framework: (Use arrow keys) None Ant Design Vue BalmUI ❯ Bootstrap Vue Buefy Chakra UI Element Framevuerk Oruga Tachyons Tailwind CSS Windi CSS Vant View UI Vuesax (Move up and down to reveal more choices)? Nuxt.js modules: (Press &lt;space&gt; to select, &lt;a&gt; to toggle all, &lt;i&gt; to invert selection)❯◉ Axios - Promise based HTTP client ◯ Progressive Web App (PWA) ◯ Content - Git-based headless CMS? Linting tools: ❯◉ ESLint ◯ Prettier ◯ Lint staged files ◯ StyleLint ◯ Commitlint? Testing framework: None ❯ Jest AVA WebdriverIO Nightwatch ? Rendering mode: (Use arrow keys)❯ Universal (SSR &#x2F; SSG) Single Page App ? Deployment target: (Use arrow keys)❯ Server (Node.js hosting) Static (Static&#x2F;Jamstack hosting) ❯◉ jsconfig.json (Recommended for VS Code if you&#39;re not using typescript) ◯ Semantic Pull Requests ◯ Dependabot (For auto-updating dependencies, GitHub only) Version control system: (Use arrow keys)? Continuous integration: None❯ None GitHub Actions Circle ci ...? Version control system: (Use arrow keys)❯ Git None &#x2F;&#x2F; 설치 시작⠸ Installing packages with npm 아래는 선택한 옵션 목록입니다. 몇 가지 설명을 부연하자면, 이번 프로젝트에서는 UI Component 옵션에서는 Bootstrap Vue 를, Nuxt.js modules 옵션에서는 Axios 를 선택했습니다. 사실 이 둘은 나중에 설치 및 환경구성을 해줘도 되지만 그렇게 되면 환경구성에 대해 직접 해줘야해서 다소 번거로워 되도록이면 프로젝트 생성과정에서 설치해주는게 이득인거 같습니다. 그리고 이외의 Linting tools, Testing framework, Rendering mode 와 같은 부분은 Nuxt 어플리케이션 skeleton을 잡기 위한 프로젝트 옵션으로써 앱 생성 옵션 선택에서 해주는 것이 중요합니다. 12345678910111213✨ Generating Nuxt.js project in nuxt-bootstrap-dashboard? Project name: nuxt-bootstrap-dashboard? Programming language: JavaScript? Package manager: Npm? UI framework: Bootstrap Vue? Nuxt.js modules: (Press &lt;space&gt; to select, &lt;a&gt; to toggle all, &lt;i&gt; to invert selection)? Linting tools: (Press &lt;space&gt; to select, &lt;a&gt; to toggle all, &lt;i&gt; to invert selection)? Testing framework: Jest? Rendering mode: Universal (SSR &#x2F; SSG)? Deployment target: Server (Node.js hosting)? Development tools: (Press &lt;space&gt; to select, &lt;a&gt; to toggle all, &lt;i&gt; to invert selection)? Continuous integration: None? Version control system: Git 생성된 프로젝트의 디렉토리는 아래 이미지와 같습니다. 생성이 완료되면 Command 창에 앱을 구동하기 위한 npm script 로 추후에 개발 환경변수 및 RestAPI를 개발하면서 수정할 예정입니다. 1234567891011121314151617🎉 Successfully created project nuxt-bootstrap-dashboard To get started: cd nuxt-bootstrap-dashboard npm run dev To build &amp; start for production: cd nuxt-bootstrap-dashboard npm run build npm run start To test: cd nuxt-bootstrap-dashboard npm run test Github Repository 환경구성Repository 생성 및 프로젝트 연결 자, 이제 Skeleton을 생성했으니 프로젝트 버전관리를 위해서 Github에 Repository를 생성해 연결해보겠습니다. Github 페이지에서 원격 저장소를 생성하면 아래와 같은 저장소 화면으로 이동하며 우리는 이미 프로젝트를 생성한 후 원격 저장소를 연결하는 것이기 때문에 existing repository from the command line 방법을 따릅니다. 123456789101112&#x2F;&#x2F; 해당 디렉토리의 저장소 초기화git init&#x2F;&#x2F; 로컬 파일 추가 및 커밋git add .git commit -m &quot;Initial Commit&quot;&#x2F;&#x2F; 원격 저장소 주소 설정git remote add origin https:&#x2F;&#x2F;github.com&#x2F;Joontae-Kim&#x2F;Nuxt-Bootstrap-Dashboard.git&#x2F;&#x2F; 원격 저장소로 commit한 파일 pushgit push origin master Develop 브랜치 생성하기 프로젝트의 버전관리를 위해 Gitflow Workflow를 따를 것이고, Default Branch를 develop 브랜치로 변경 후 아래의 브랜치들을 가지고 Workflow를 수행할 것입니다. master: 제품으로 출시될 수 있는 브랜치 develop: 다음 출시 버전을 개발하는 브랜치 feature: 기능을 개발하는 브랜치 release : 이번 출시 버전을 준비하는 브랜치 hotfix : 출시 버전에서 발생한 버그를 수정 하는 브랜치 참고Gitflow Workflow에 대해서는 아래의 참고 URL로 대체합니다. 우린 Git-flow를 사용하고 있어요 Gitflow로 branch를 관리하자 GitFlow with GitHub Git Flow 마치며이상으로 이번 포스트의 주제인 1. 프로젝트 생성 및 Github Repository 환경구성 에 대해서 다뤄봤습니다. 일전에도 Git Flow 기반의 프로젝트 개발을 진행해봤었지만 아직도 햇갈리는 부분도 있고, 실수도 있습니다. 그러나 대규모 프로젝트에 참여해 개발을 진행할땐 팀내 협업을 위해서는 필수적이며 체계적인 배포 버전관리와 기능개발을 위해서도 개발자라면 혼자서라도 한번쯤은 연습 또는 실습해봐야할 개발 환경입니다. 추후에 Git Flow 기반의 프로젝트 개발에 대한 포스트를 작성해보겠습니다. 다음 포스트로는 2. Heroku 환경구성 에 대해 다뤄보겠습니다.","categories":[{"name":"Programming","slug":"Programming","permalink":"https://joontae-kim.github.io/categories/Programming/"},{"name":"nuxt","slug":"Programming/nuxt","permalink":"https://joontae-kim.github.io/categories/Programming/nuxt/"}],"tags":[{"name":"vue.js","slug":"vue-js","permalink":"https://joontae-kim.github.io/tags/vue-js/"},{"name":"nuxt.js","slug":"nuxt-js","permalink":"https://joontae-kim.github.io/tags/nuxt-js/"},{"name":"vue","slug":"vue","permalink":"https://joontae-kim.github.io/tags/vue/"},{"name":"nuxt","slug":"nuxt","permalink":"https://joontae-kim.github.io/tags/nuxt/"},{"name":"project","slug":"project","permalink":"https://joontae-kim.github.io/tags/project/"},{"name":"portfolio","slug":"portfolio","permalink":"https://joontae-kim.github.io/tags/portfolio/"}]},{"title":"Nuxt와 Bootstrap4 기반의 Dashboard 만들기","slug":"nuxt-bootstrap-dashboard-0","date":"2021-04-26T09:33:09.000Z","updated":"2021-04-29T07:21:50.904Z","comments":true,"path":"2021/04/26/nuxt-bootstrap-dashboard-0/","link":"","permalink":"https://joontae-kim.github.io/2021/04/26/nuxt-bootstrap-dashboard-0/","excerpt":"","text":"최근들어 공부하고 블로그 쓰고, 공부하고 블로그 쓰는 코드를 잘 안 쓰는 나날들이 계속되다 보니깐 손가락이 굳어가는 느낌과 살짝 지루하다는 생각이 들어서 공부한걸 써보면서 실습해보는 기회로 Nuxt 기반의 Bootstrap4를 사용한 Dashboard를 만들어보려고 합니다. 왜 Dashboard를 만드나? 일반 사이트가 아닌 Dashboard를 선택한 이유는 일반 사이트를 개발하는 것보다 Javascript를 통해 개발해야할 기술적 요소들이 더 많다고 생각했기 때문이다. 일반 페이지의 경우에는 디자인 + CSS 이 더 집중되어 있다면, 대시보드의 경우에는 기능 + Javascript 에 더 집중되어 있고 여기에 디자인 을 MSG로 첨가할 수도 있기 때문이다. 물론 일반 페이지도 기능을 끼워넣으면 되긴 하지만… 대시보드는 이미 기능이 거기서 거기이기 때문에 기능설계에 대한 힘을 덜 수 있다. Dashboard 구상Dashboard는 음… 이전에 외주나 개인 프로젝트에서도 만들어봤었지만 큰 차이는 없었다. Dashboard를 만들기 위한 ResourceDashboard 템플릿을 만드는 것은 아니니 일단 무엇을 관리하고 어떤 Resource를 관리할지에 대한 시나리오가 있어야 한다. 상상해본것들을 대략 정리해보자면 Resource는 아래와 같다. User Event Admin Traffic Account Transaction Dashboard 페이지 구상위에서 정리한 Resource를 기반으로 아래와 같이 구상해봤다. Overview Traffic &amp; Engagement User List Event Management Profile Sign-in 페이지 상세 정의일단 페이지 구상이 끝났으니 페이지의 컨텐츠를 채워보자. Overview Total Visitor 상단 3 Index 전월대비 지수 (%) New Visitors &amp; Users 상단 3 Index 전월대비 지수 (%) Traffic Share 상단 3 Index Share Type: Desktop, Mobile Unit (%) Views Per Minute 상단 3 Pie Chart 전주대비 지수 (%) Channels 중단 3 Donut Chart Channel Type: Organic Search, Direct, Social, Paid Visit by Notification 중단 9 Push Email Direct Sales Value 하단 6 Linear Graph 전월대비 지수 (%) Data: 2 Weaks Event Rank 하단 6 Table Top 10 Column: Name, Views, Sales, Bounce rate Traffic &amp; Engagement Traffic Share 6 전월대비 지수 (%) Donut Chart Organic Search Direct Social Paid Push Traffic Volumes by Source 6 일주일치 데이터 Line Graph Organic Search Direct Social Paid Push Traffic Source Table 12 Table Column: Traffic Source, Source Type, Share, Changes(from the previous week) User List Search Simple Search Detail Search Sorting ASC / DESC Condition Table 12 Column: Action CheckBox, Name, Date Created, Paid, Notification, Recent, Action Pagination Buttons: Prev, (numbers), Next Event Management Search 6 Simple Search Detail Search Sorting 6 ASC / DESC, Condition Table 12 Column: Index, Title, Date Created, Open Date, Close Date, Margin, Status, Action Pagination Buttons: Prev, (numbers), Next Profile General information 12 Form Field: First Name, Last Name, Birthday, Email, Department Sign-in Form 4 Form Field: Email, Password Password Reset Require 12 Button Login Button Error Message Text 개발기본적으로 Nuxt, Bootstrap &amp; Bootstrap-vue를 기반으로 개발할 것입니다. 개발 환경 Nuxt (SSR) Express (API) Heroku Git &amp; Github Bootstrap &amp; Bootstrap-vue Chart.js (Client) Axios 개발 순서 프로젝트 생성 및 Github Repository 환경구성 Heroku 배포 환경구성 Nuxt &amp; Express API 환경구성 Axios Bootstrap &amp; Bootstrap-vue 환경구성 Page &amp; UI 개발 Chart.js Reference Benchmark Site https://themes.getbootstrap.com/preview/?theme_id=45617 https://coderthemes.com/hyper/creative/pages-login.html https://themes.getbootstrap.com/product-category/admin-dashboard/ Nuxt Module https://modules.nuxtjs.org/?q=bootstra&amp;orderBy=desc https://blog.lichter.io/posts/nuxt-with-an-api/ Nuxt &amp; Express https://github.com/nuxt/create-nuxt-app/issues/563 https://nuxtjs.org/docs/2.x/configuration-glossary/configuration-dev https://bithacker.dev/use-express-with-nuxt-js https://blog.lichter.io/posts/nuxt-with-an-api/#using-nuxt-programmatically Nuxt &amp; Bootstrap-vue https://bootstrap-vue.org/docs#nuxtjs-module https://nuxtjs.org/docs/2.x/directory-structure/modules Nuxt &amp; Chart.js https://www.python2.net/questions-1182484.htm 답변 # 1 참고\u001e https://vue-chartjs.org/guide/#introduction https://code.luasoftware.com/tutorials/vuejs/setup-vue-chartjs-in-nuxt/ Chart.js https://yasminzy.com/vue/chart/#steps https://www.chartjs.org/docs/latest/ ETC https://nuxtjs.org/docs/2.x/features/configuration https://orlandster.github.io/vue-page-transition/#/ 정리 이번 프로젝트의 최대 목표는 ASAP 이다. 가능한 빠르게! 만드는 것이 목표! 중간중간 배우고 사용한걸 정리하자! 개발이 완료되고 스케줄을 고려해서 transition을 작업할지 말지 결정하자!","categories":[{"name":"Programming","slug":"Programming","permalink":"https://joontae-kim.github.io/categories/Programming/"},{"name":"nuxt","slug":"Programming/nuxt","permalink":"https://joontae-kim.github.io/categories/Programming/nuxt/"}],"tags":[{"name":"vue.js","slug":"vue-js","permalink":"https://joontae-kim.github.io/tags/vue-js/"},{"name":"nuxt.js","slug":"nuxt-js","permalink":"https://joontae-kim.github.io/tags/nuxt-js/"},{"name":"vue","slug":"vue","permalink":"https://joontae-kim.github.io/tags/vue/"},{"name":"nuxt","slug":"nuxt","permalink":"https://joontae-kim.github.io/tags/nuxt/"},{"name":"project","slug":"project","permalink":"https://joontae-kim.github.io/tags/project/"},{"name":"portfolio","slug":"portfolio","permalink":"https://joontae-kim.github.io/tags/portfolio/"}]},{"title":"알고리즘 시리즈 - 자료구조 2","slug":"algorithm-data-queue","date":"2021-04-23T08:54:19.000Z","updated":"2021-04-25T16:23:21.640Z","comments":true,"path":"2021/04/23/algorithm-data-queue/","link":"","permalink":"https://joontae-kim.github.io/2021/04/23/algorithm-data-queue/","excerpt":"","text":"이번 포스트에서는 선형 자료구조 중 하나인 큐(Queue)에 대해서 다뤄보겠습니다. 큐 (Queue)선형 자료구조 중 하나인 큐(Queue)는 FIFO(First In First Out, 선입선출) 구조의 자료구조로 LIFO(Last In First Out, 후입선출) 구조의 스택(Stack)과는 반대되는 개념이다. 현실속에서의 큐는 프린터의 출력처리 방식, 매표소 앞의 일렬로 선 대기열, OS의 프로세스 관리 등 데이터가 입력된 시간 순서대로 처리해야 할 필요가 있는 상황ㅇ 이용된다. 구조 큐는 복수의 자료로 이루어져 있으며 복수의 자료가 삽입되어 추출되길 기다리고 있는 곳을 큐 라고 부르며 큐에 자료를 삽입하는 것을 Enqueue, 반대로 자료를 추출하는 것을 Dequeue 라고 하며 LIFO(후입선출)을 개념을 갖고 있다. 아래와 같은 구조를 갖고 있다. Front (Head): 데이터를 추출할 수 있는 위치 Rear (Tail): 데이터를 삽입할 수 있는 위치 Overflow (오버플로우): 큐가 꽉 차서 더 이상 자료를 넣을 수 없는 경우 Underflow (언더플로우): 큐가 비어 자료를 꺼낼 수 없는 경우 큐 기능 (메서드) enqueue(data): 삽입 / 큐의 Rear에 데이터를 삽입 dequeue(): 추출 / 큐의 Front에서 데이터를 추출 rear(): 조회 / 큐의 Rear에 데이터 값을 반환 front(): 조회 / 큐의 Front에 데이터 값을 반환 size(): 조회 / 큐의 데이터 개수 반환 empty(): 조회 / 큐가 비었는지 Boolean을 반환 toString(): 조회 / 큐의 모든 데이터를 문자열로 반환 구현큐를 구현해보자. 큐를 구현하는 방법은 두 가지로, 한 가지는 Javascript의 Array(배열)와 Array의 메서드를 통해 구현하는 방법 그리고 나머지 한 가지는 Linked List와 같이 구현하는 방법으로 총 두가지 입니다. 이번 포스트에서는 두가지 방법 모두 사용해 구현해보겠습니다. 구현 순서는 아래와 같다. Queue 객체 생성 데이터 삽입 기능 (enqueue) 데이터 조회 기능 (front, rear, size, empty, toString) 데이터 추출 기능 (dequeue) Javascript Array를 사용한 Queue 구현 방법Queue 객체 생성하나의 대기열이 될 Queue를 객체 생성방식으로 만들어보겠습니다. 123function Queue () &#123; this.queue &#x3D; []&#125; Queue는 복수의 data로 채워한 하나의 queue를 생성하는 생성자 함수로, 내부 property로 data를 담아둘 queue를 빈 Array([])를 할당한다. Javascript Array를 사용한 Queue 구현 방법에서는 Javascript Array와 메서드를 이용할 것이기 때문에 많은 property가 필요하지 않다. Queue 메서드 구현위에서 정의한 Queue 생성자 함수 내부에 구현해도 되지만 저는 prototype 속성을 사용한 객체 생성 방법으로 구현해보겠습니다. 데이터 삽입 기능123Queue.prototype.enqueue &#x3D; function (data) &#123; this.queue.push(data)&#125; enqueue 메서드는 Queue 객체에 데이터를 삽입하는 메서드로 Javascript의 Array 메서드 중 push를 사용해 queue에 data를 삽입하는 기능을 구현했습니다. 데이터 조회 기능이번에는 큐에 삽입한 데이터를 조회하는 기능을 구현해보겠습니다. 구현할 조회 메서드는 front, rear, size, empty, toString 입니다. front 를 구현해보겠습니다. 12345Queue.prototype.front &#x3D; function (data) &#123; return !this.queue.length ? null : this.queue[this.queue.length - 1]&#125; front 메서드는 Queue 객체에 삽입된 데이터 중 가장 오래된 데이터이자 가장 먼저 추출될 데이터에 대한 조회 기능입니다. 이번에는 rear 를 구현해보겠습니다. 12345Queue.prototype.rear &#x3D; function (data) &#123; return !this.queue.length ? null : this.queue[0]&#125; rear 메서드는 Queue 객체에 삽입된 데이터 중 가장 최근 데이터에 대한 조회 기능입니다. size 를 구현해보겠습니다. 123Queue.prototype.size &#x3D; function (data) &#123; return this.queue.length&#125; size 메서드는 Queue 객체에 삽입된 데이터의 개수를 반환하는 기능을 기능입니다. empty 를 구현해보겠습니다. 123Queue.prototype.empty &#x3D; function (data) &#123; return !this.queue.length&#125; empty 메서드는 Queue 객체의 queue 가 비었는지 조회하는 기능입니다. 마지막으로 toString 를 구현해보겠습니다. 12345Queue.prototype.toString &#x3D; function (data) &#123; return !this.queue.length ? [] : &#96;[$&#123;this.queue.toString()&#125;]&#96;&#125; toString 메서드는 Queue 객체의 queue 를 문자열로 출력하는 기능입니다. 데이터 추출 기능123Queue.prototype.dequeue &#x3D; function (data) &#123; this.queue.shift(data)&#125; dequeue 메서드는 Queue 객체에 데이터를 추출하는 메서드로 Javascript의 Array 메서드 중 shift를 사용해 queue에 삽입된 data 중 가장 마지막에 삽입되었으며 가장 빨리 추출되어질 data를 추출하는 기능입니다. Linked List 구현방법을 사용한 Queue 구현 방법이번에는 Linked List와 같은 구조로 다수의 data와 data로 채워진 Queue를 구현해보겠습니다. 구현할 메서드는 미리 정해둔 메서드 입니다. Data1234function Data (val) &#123; this.value &#x3D; val this.next &#x3D; null&#125; Data는 큐의 요소인 데이터를 생성하는 생성자 함수로, 내부 property로 data 본인의 값인 value와 다음 data를 참조하기 위한 link를 갖는다. Queue 객체 생성큐를 생성할 Queue 생성자 함수를 정의하고, 위에서 정의한 구조와 메서드를 구현하기 위해 필요한 property를 정의했습니다. 12345function Queue () &#123; this.count &#x3D; 0 this.head &#x3D; null this.tail &#x3D; null&#125; Queue 메서드 구현위에서 정의한 Queue 생성자 함수 내부에 구현해도 되지만 저는 prototype 속성을 사용한 객체 생성 방법으로 구현해보겠습니다. 데이터 삽입 기능큐에 데이터를 생성 및 삽입하는 기능을 구현했습니다. 1234567891011121314151617181920212223Queue.prototype.enqueue &#x3D; function (data) &#123; let newData &#x3D; new Data(data) if (!this.head) &#123; this.head &#x3D; newData &#125; else &#123; let current &#x3D; this.head while(current.next) &#123; current &#x3D; current.next &#125; current.next &#x3D; newData &#125; this.tail &#x3D; newData this.count++ return newData&#125;var queue &#x3D; new Queue &#x2F;&#x2F; 큐 객체 생성queue.enqueue(20) &#x2F;&#x2F; 데이터 생성 및 추가queue.enqueue(10)queue.enqueue(18)console.log(queue) enqueue 메서드는 큐에 데이터를 삽입하는 메서드로, 새로운 data를 추가하면 기존 head 데이터에 next가 할당되거나 tail 데이터가 갱신되는 것으로, line 3 ~ line 14 코드와 같이 head의 데이터 할당여부에 따라 처리되는 방식이 다르며 head가 지정되어 있다면 새로운 data가 추가되기전 마지막 data의 data.next에 새로운 데이터를 할당해주고 마지막에 this.tail에 생성된 data를 할당해준다. 위와 같이 구현한 queue를 출력하면 아래와 같습니다. 데이터 조회 기능이번에는 큐에 삽입한 데이터를 조회하는 기능을 구현해보겠습니다. 구현할 조회 메서드는 front, rear, size, empty, toString 입니다. front 메서드를 구현해보겠습니다. 123Queue.prototype.front &#x3D; function () &#123; return this.head.value&#125; front 메서드는 큐 데이터열에서 가장 앞에 있는 즉, 가장 먼저 추출되며 삽입된지 가장 오래된 데이터가 무엇인지 조회하는 메서드 입니다. head property는 데이터를 삽입할때 할당되므로 추가적인 loop 문을 통해 조회를 할 필요가 없습니다. rear 메서드를 구현해보겠습니다. 123Queue.prototype.rear &#x3D; function () &#123; return this.tail.value&#125; rear 메서드는 큐 데이터열에서 가장 뒤에 있는 즉, 현재 데이터열에서 가장 나중에 추출되며 삽입된지 가장 최신의 데이터가 무엇인지 조회하는 메서드 입니다. tail property는 데이터를 삽입할때마다 갱신되므로 추가적인 loop 문을 통해 조회를 할 필요가 없습니다. size 메서드를 구현해보겠습니다. 123Queue.prototype.size &#x3D; function () &#123; return this.count&#125; size 메서드는 큐 데이터열의 크기를 반환하는 메서드로, 큐에 신규 data를 삽입할때마다 갱신되기 때문에 추가적인 loop 문을 통해 조회를 할 필요가 없습니다. empty 메서드를 구현해보겠습니다. 123Queue.prototype.empty &#x3D; function () &#123; return !this.count&#125; size 메서드는 큐 데이터열이 비었는지 Boolean 값을 반환하는 메서드로, Queue 생성자 함수의 size property를 사용하면 됩니다. toString 메서드를 구현해보겠습니다. 12345678910111213Queue.prototype.toString &#x3D; function () &#123; let line &#x3D; [] let current &#x3D; this.head if (!current) &#123; return &#39;&#39; &#125; else &#123; while (current.next) &#123; line.push(current.value) current &#x3D; current.next &#125; return line.toString() &#125;&#125; toString 메서드는 큐에 삽입된 데이터열을 문자열로 출력하는 메서드로, head의 여부에 따라 반환되는 로직을 분리했습니다. 데이터 추출 기능마지막으로 큐의 데이터 추출 기능인 dequeue 메서드를 구현해보겠습니다. 12345678910111213Queue.prototype.dequeue &#x3D; function () &#123; let front &#x3D; this.head this.head &#x3D; front.next let current &#x3D; this.head while (current.next) &#123; current &#x3D; current.next &#125; this.tail &#x3D; current this.count-- return front&#125; dequeue 메서드는 큐의 front에 해당되는 데이터를 출력하는 메서드로, Queue 생성자 함수 내에 저장된 head property를 반환하고 this.head.next에 할당된 value를 this.head로 갱신해준 후 this.tail property 또한 갱신했습니다. 마치며이번 포스트에서는 알고리즘 시리즈의 자료구조 포스팅 중 두번째로, 큐(Queue)의 정의와 구조 및 메서드에 공부해봤습니다. 그리고 정의한 구조와 메서드를 구현해봤습니다. 다음 포스트에서는 링크드 리스트, 큐와 같이 선형 자료구조 중 하나인 스택에 대해서 공부해보겠습니다. 참조 Queue 큐 (자료 구조) 시리즈:수학인듯 과학아닌 공학같은 컴퓨터과학/알고리즘 기초 강의노트 20. 자료구조 - queue(큐) 자료구조(큐, queue) (JavaScript) 자바스크립트 큐(Queue, FIFO) 자료구조 구현 [자바스크립트] Queue 큐 클래스 Queue, Stack, Linked List 정리 큐, 스택, 트리","categories":[{"name":"Programming","slug":"Programming","permalink":"https://joontae-kim.github.io/categories/Programming/"},{"name":"Algorithm","slug":"Programming/Algorithm","permalink":"https://joontae-kim.github.io/categories/Programming/Algorithm/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://joontae-kim.github.io/tags/Algorithm/"},{"name":"알고리즘","slug":"알고리즘","permalink":"https://joontae-kim.github.io/tags/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/"},{"name":"data structure","slug":"data-structure","permalink":"https://joontae-kim.github.io/tags/data-structure/"},{"name":"data","slug":"data","permalink":"https://joontae-kim.github.io/tags/data/"},{"name":"structure","slug":"structure","permalink":"https://joontae-kim.github.io/tags/structure/"},{"name":"자료 구조","slug":"자료-구조","permalink":"https://joontae-kim.github.io/tags/%EC%9E%90%EB%A3%8C-%EA%B5%AC%EC%A1%B0/"},{"name":"Queue","slug":"Queue","permalink":"https://joontae-kim.github.io/tags/Queue/"},{"name":"큐","slug":"큐","permalink":"https://joontae-kim.github.io/tags/%ED%81%90/"}]},{"title":"알고리즘 시리즈 - 자료구조 1","slug":"algorithm-data-linkedList","date":"2021-04-23T08:34:34.000Z","updated":"2021-04-25T16:24:14.511Z","comments":true,"path":"2021/04/23/algorithm-data-linkedList/","link":"","permalink":"https://joontae-kim.github.io/2021/04/23/algorithm-data-linkedList/","excerpt":"","text":"이번 포스트에서는 선형 자료구조 중 하나인 링크드 리스트에 대해서 다뤄보겠습니다. 링크드 리스트링크드 리스트 또는 연결 리스트는 순서를 표현하는 노드들의 집합으로, Javascript의 배열(Array)와 유사한 구조이지만 메모리상의 연속적 위치요소를 갖지 않는다는 차이가 있다. 링크드 리스트에서 가장 중요한 것은 연결이 무엇인가를 파악하는 것 이다. 특징으로는, 순회하는 동안 순서에 상관없이 효율적인 삽입, 삭제가 가능 연속되는 node들이 link로 연결되어 있음 마지막 항목은 null을 가리짐 배열(Array)에 비해 추가, 삽입, 삭제가 용이하나 순차적 탐색이 아닌 경우 성능이 떨짐 탐색 또는 정렬가 main =&gt; Array / 추가, 삭제, 삽입이 main =&gt; Linked List 구조 링크드 리스트는 Node 라고 부르는 복수의 요소로 이루어져 있으며 각 노드는 자신의 값인 데이터와 다음 노드의 위치를 참조하고 있는 링크 를 가지고 있으며 일련의 리스트는 아래와 같이 부를 수 있다. Head: 링크드 리스트의 시작 node Current: 연산의 기준이 되는 node Before: Current node의 참조값인 link 값을 가지고 있는 node Tail: 링크드 리스트의 마지막 node이며 null을 가리킨다 링크드 리스트 기능 (메서드) append(data): 생성 / 리스트에 새로운 node를 추가하면 가장 마지막에 위치함 insert(index, data): 수정 / 특정 index의 node에 데이터 삽입 indexOf(data): 조회 / 특정 데이터의 node index를 반환, 존재하지 않는 경우 -1을 반환 search(data): 조회 / 특정 데이터를 기준으로 node 반환, 존재하지 않는 경우 null 반환 isEmpty(): 조회 / 리스트의 node 유무 반환 size(): 조회 / 리스트의 node 개수 반환 removeAt(index): 삭제 / 특정 위치에 있는 node를 삭제 remove(data): 삭제 / 특정 값을 가진 node를 삭제 구현링크드 리스트를 구현해보자. 구현 순서는 아래와 같다. 링크드 리스트의 요소인 Node 노드 생성 기능 (append) 노드 조회 기능 (indexOf, isEmpty, size) 노드 수정 기능 (insert) 노드 삭제 기능 (remove, removeAt) Node1234function Node (data) &#123; this.data &#x3D; data this.next &#x3D; null&#125; Node는 링크드 리스트의 요소인 node를 생성하는 생성자 함수로, 내부 property로 node 본인의 값인 data와 다음 node를 참조하기 위한 link를 갖는다. Linked List링크드 리스트를 생성할 LinkedList 생성자 함수를 정의하고, 위에서 정의한 구조와 메서드를 구현하기 위해 필요한 property를 정의했습니다. 1234function LinkedList () &#123; this.count &#x3D; 0 this.head &#x3D; null&#125; Linked List 메서드 구현위에서 정의한 LinkedList 생성자 함수 내부에 구현해도 되지만 저는 prototype 속성을 이용해 객체 생성 개념으로 구현해보겠습니다. 노드 생성 기능링크드 리스트에 노드를 생성하는 기능을 구현했습니다. 12345678910111213141516171819202122232425LinkedList.prototype.append &#x3D; function (data) &#123; let node &#x3D; new Node(data) let current &#x3D; null if(this.head &#x3D;&#x3D;&#x3D; null) &#123; this.head &#x3D; node &#125; else &#123; current &#x3D; this.head while(current.next) &#123; current &#x3D; current.next &#125; current.next &#x3D; node &#125; this.count++&#125;var list &#x3D; new LinkedList(); &#x2F;&#x2F; 링크드 리스트 객체 생성list.append(15); &#x2F;&#x2F; node 생성 및 추가list.append(23);list.append(10);console.log(list) &#x2F;&#x2F; 링크드 리스트 출력 링크드 리스트에 노드를 생성한다는 것은 새로운 node를 추가하면 가장 마지막에 들어간다는 것 으로, 노드를 생성 및 링크드 리스트에 추가할때는 line 5 ~ line 15 와 같이 리스트에 head가 있는지 없는지 확인해야 한다. 만약 head가 비었다면(null) 선언해주면 되고, 지정되어 있다면 head를 current에 할당해준 후 while 문의 current.next가 null이 될때까지 선회(loop)한 후 line 14 의 current.next의 current는 마지막 노드이며 마지막 노드의 링크 속성인 current.next에 현재 생성됐고 추가될 node의 정보를 할당해준다. 위와 같이 구현한 후 list를 출력하면 아래와 같습니다. 노드 조회 기능이번에는 링크드 리스트에 삽입한 노드를 조회하는 기능을 구현해보겠습니다. 구현할 조회 메서드는 indexOf, search, isEmpty, size 입니다. indexOf 메서드를 구현해보겠습니다. 123456789101112131415LinkedList.prototype.indexOf &#x3D; function (data) &#123; let current &#x3D; this.head let index &#x3D; 0 while(current) &#123; if (current.data &#x3D;&#x3D;&#x3D; data) &#123; return index &#125; index++ current &#x3D; current.next &#125; return -1&#125; 위 코드는 링크드 리스트 객체에서 인자로 넘겨받은 data를 기준으로 리스트 내 index를 반환하는 함수로 line 4 에서 while 문으로 순회하면서 current.data와 인자 data를 비교한 후 index를 반환한다. search를 구현해보겠습니다. 123456789LinkedList.prototype.search &#x3D; function (data) &#123; let current &#x3D; this.head while (current.data !&#x3D;&#x3D; data) &#123; current &#x3D; current.next &#125; return current&#125; 위 코드는 링크드 리스트 객체에서 data를 기준으로 node를 조회하는 메서드로, while 문 안에서 current.data의 값과 비교해서 동일할때까지 순회하는 구조입니다. size 메서드를 구현해보겠습니다. 123LinkedList.prototype.size &#x3D; function (data) &#123; return this.count&#125; 리스트의 크기값을 반환합니다. isEmpty 메서드를 구현해보겠습니다. 123LinkedList.prototype.isEmpty &#x3D; function (data) &#123; return this.count &#x3D;&#x3D;&#x3D; 0&#125; 생성자 함수 LinkedList에 의해 생성된 객체의 count property를 이용해 리스트가 비었는지 아닌지 반환한다. 노드 수정 기능이번에는 링크드 리스트의 특정 index의 node에 데이터를 삽입하는 기능을 구현해보겠습니다. 구현할 조회 메서드는 insert 입니다. 1234567891011121314151617181920212223242526LinkedList.prototype.insert &#x3D; function (position, data) &#123; if (position &gt;&#x3D; 0 &amp;&amp; position &lt;&#x3D; this.count) &#123; let node &#x3D; new Node(data) let current &#x3D; this.head let previous &#x3D; null let index &#x3D; 0 if (position &#x3D;&#x3D;&#x3D; 0) &#123; node.next &#x3D; current this.head &#x3D; node &#125; else &#123; while (index++ &lt; position) &#123; previous &#x3D; current current &#x3D; current.next &#125; &#125; node.next &#x3D; current previous.next &#x3D; node &#125; this.count++ return node return false&#125; 위 코드는 새로운 node를 생성하고, 특정 위치에 기존 node의 이전과 이후의 node에 연결해주는 메서드이다. position이 0이라면 head를 변경해주면 되고, 그렇지 않을 경우 while 문으로 position까지 선회한 후 이전 node를 나타내는 previous 변수에는 교체 전 node를, current 변수에는 교체 전 node의 다음 node 값을 갖는다. 그리고 while 문이 끝나면 교체해야할 node.next 프로퍼티에 교체대상의 다음 node 값을 할당한 current 변수를 할당하고, 교체대상의 이전 node인 previous.next 프로퍼티에는 새롭게 생성한 node를 할당해준다. 노드 삭제 기능노드 삭제 기능 ()마지막으로 링크드 리스트에 삽입한 노드를 삭제하는 기능을 구현해보겠습니다. 구현할 조회 메서드는 remove, removeAt 입니다. 이번에는 removeAt 메소드를 구현해보겠습니다. 123456789101112131415161718192021222324LinkedList.prototype.removeAt &#x3D; function (position) &#123; if (position &gt; -1 &amp;&amp; position &lt; this.count) &#123; let current &#x3D; this.head let previoud &#x3D; null let index &#x3D; 0 if (position &#x3D;&#x3D;&#x3D; 0) &#123; this.head &#x3D; current.next &#125; else &#123; while (index++ &lt; position) &#123; previous &#x3D; current current &#x3D; current.next &#125; previous.next &#x3D; current.next &#125; this.count-- current.next &#x3D; null return current.data &#125; return null&#125; 위 코드는 특정 index를 기준으로 리스트의 node를 삭제하는 메서드로 먼저 삭제한 node의 index인 position 인자를 검증한 후 Line 7 과 같이 삭제할 index가 head 인지 검증한 후 만약 head라면 다음 node를 head로 할당해주고, 그렇지 않을 경우 while 문으로 선회하면서 삭제할 index의 직전 node에서 멈춘 후 이 node를 previous 변수에 할당하고, previous.next의 값을 current.next.next로 할당해 삭제할 index의 node의 앞과 뒤 node를 이어준다. 이번에는 remove 메소드를 구현해보겠습니다. 1234LinkedList.prototype.remove &#x3D; function (data) &#123; var index &#x3D; this.indexOf(data) return this.removeAt(index)&#125; 위 코드는 indexOf 메서드를 이용해 data를 기준으로 node의 index를 조회해 removeAt 메서드로 삭제해준다. 마치며이번 포스트에서는 알고리즘 시리즈의 자료구조 포스팅 중 첫번째로, 링크드 리스트의 정의와 구조 및 메서드에 공부해봤습니다. 그리고 정의한 구조와 메서드를 구현해봤습니다. 다음 포스트에서는 링크드 리스트와 같이 선형 자료구조 중 하나인 큐에 대해서 공부해보겠습니다. 참조 링크드 리스트 ES6 javascript로 자료구조 List 구현하기 (배웠으면 사용해보자!!) 자료구조(연결 리스트, linked list) 자바스크립트 자료구조 연결 리스트(Linked List) [자바스크립트] LinkedList 연결 리스트","categories":[{"name":"Programming","slug":"Programming","permalink":"https://joontae-kim.github.io/categories/Programming/"},{"name":"Algorithm","slug":"Programming/Algorithm","permalink":"https://joontae-kim.github.io/categories/Programming/Algorithm/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://joontae-kim.github.io/tags/Algorithm/"},{"name":"data structure","slug":"data-structure","permalink":"https://joontae-kim.github.io/tags/data-structure/"},{"name":"data","slug":"data","permalink":"https://joontae-kim.github.io/tags/data/"},{"name":"structure","slug":"structure","permalink":"https://joontae-kim.github.io/tags/structure/"},{"name":"자료 구조","slug":"자료-구조","permalink":"https://joontae-kim.github.io/tags/%EC%9E%90%EB%A3%8C-%EA%B5%AC%EC%A1%B0/"},{"name":"linked list","slug":"linked-list","permalink":"https://joontae-kim.github.io/tags/linked-list/"},{"name":"링크드 리스트","slug":"링크드-리스트","permalink":"https://joontae-kim.github.io/tags/%EB%A7%81%ED%81%AC%EB%93%9C-%EB%A6%AC%EC%8A%A4%ED%8A%B8/"}]},{"title":"알고리즘 시리즈 - 자료구조","slug":"algorithm-data-structrue","date":"2021-04-17T17:20:38.000Z","updated":"2021-04-24T06:36:38.929Z","comments":true,"path":"2021/04/18/algorithm-data-structrue/","link":"","permalink":"https://joontae-kim.github.io/2021/04/18/algorithm-data-structrue/","excerpt":"","text":"이전 포스트인 알고리즘 시리즈 - 시간 복잡도에서는 알고리즘의 성능을 파악하는 척도 중 하나인 시간복잡도와 big-O에 대해서 공부해봤습니다. 시간 복잡도란 문제를 해결하는데 걸리는 시간과 입력의 함수 관계 로 문제에 적합한 자료구조와 그에 따른 알고리즘에 영향을 받으며 알고리즘의 수행 시간은 동일 크기의 다양한 입력에 의해 달라질 수 있다. 자료 구조 접근 검색 삽입 삭제 비고 배열 1 n n n 스택 n n 1 1 큐 n n 1 1 연결 리스트 n n 1 1 해시 테이블 - n n n 완벽한 해시 함수의 경우 O(1) 이진 탐색 트리 n n n n 균형 트리의 경우 O(log(n)) B-트리 log(n) log(n) log(n) log(n) Red-Black 트리 log(n) log(n) log(n) log(n) AVL 트리 log(n) log(n) log(n) log(n) Bloom Filter - 1 1 - 거짓 양성이 탐색 중 발생 가능 위 표는 자료구조 작업별 복잡도 로써 자료구조의 특성에 따라 작업별 시간복잡도가 다름을 알 수 있으며 이번 포스트에서는 상대적으로 입문자 레벨 (참조 - JavaScript 알고리즘 및 자료 구조)에 속하는 아래 데이터 구조에 대해 공부해보겠습니다. 연결 리스트 이중 연결 리스트 큐 스택 해시 테이블 힙 우선순위 큐 자료구조란자료구조란 데이터 값의 모임, 데이터 간의 관계 그리고 데이터가 사용할 수 있는 함수로써, 특정 문제를 해결하기 위한 추상화된 모델링(자료구조)은 시간 복잡도와 공간 복잡도를 줄여주는 효과가 있으며 그에 따라 효율적인 알고리즘을 수행할 수 있다. 프로그램을 설계하거나 문제해결 과정을 설계할때, 우선적으로 어떤 자료구조로 모델링할지 고려되야하며 자료구조가 선택되면 적용할 알고리즘의 폭은 상대적으로 좁혀지기 때문에 그 안에서 복잡도를 분석해가며 알고리즘을 선택하면 되겠다. 자료구조 종류 자료구조는 위 사진에서 볼수 있듯이 단순 / 선형 / 비선형 / 파일 구조로 구분되며 알고리즘 문제풀이에서 많이 사용되는 구조는 선형 / 비선형 구조이다. 선형 구조한 종류의 데이터가 선처럼 길게 나열된 자료구조로써, 데이터 요소에 랜덤 접근여부에 따라서 랜덤 접근 가능 자료구조 - 배열, 해시 / 랜덤 접근 불가능 자료구조 - 스택, 큐, 데크, 링크드 리스트로 구분된다. 선형 구조의 자료 탐색법으로는 아래와 같다. 순차 탐색 이분 탐색 비선형 구조선형 자료구조가 아닌 모든 자료구조로써, 사전적인 정의로 i 번째 값을 탐색한 뒤의 i+1이 정해지지 않은 구조를 의미한다. 비선형 자료구조의 종류와 간략한 정의는 아래와 같다. 그래프 꼭지점과 꼭지점을 있는 변으로 구성 방향 그래프, 무방향 그래프: 변이 방향성을 갖는지 아닌지에 따라 그래프의 유형을 구분할 수 있으며 무방향 그래프는 순환이 없는 그래프이고, 방향 그래프는 변의 방향이 보통 부모를 가리키도록 구현된 그래프이다. 트리 뿌리와 뿌리 또는 다른 꼭지점을 단 하나의 부모로 갖는 꼭짓접들로 이루어진 구조 부모 자식 관계는 변으로 표현된다. 트리의 종류는 연결된 자식의 개수에 따라 구분되는데 일반적으로 1개의 자식을 갖는 구조를 단순 일반 트리, 자식이 최대 2개인 트리를 이진 트리라고 한다. 힙 또한 이진 트리의 한 종류로 이진 트리에 특성을 부여한 것이라 할 수 있다. 마치며이후 포스트 부터는 선형 및 비선형 구조의 각 자료구조에 대해 순서대로 다뤄보겠습니다. 참고 자료 구조 시리즈:수학인듯 과학아닌 공학같은 컴퓨터과학/알고리즘 기초 강의노트 17. 알고리즘, 자료구조 개요 JavaScript를 위한 자료구조 JavaScript 알고리즘 및 자료 구조 [알고리즘]시간복잡도 Big O Data Structure For JavaScript","categories":[{"name":"Programming","slug":"Programming","permalink":"https://joontae-kim.github.io/categories/Programming/"},{"name":"Algorithm","slug":"Programming/Algorithm","permalink":"https://joontae-kim.github.io/categories/Programming/Algorithm/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://joontae-kim.github.io/tags/Algorithm/"},{"name":"data structure","slug":"data-structure","permalink":"https://joontae-kim.github.io/tags/data-structure/"},{"name":"data","slug":"data","permalink":"https://joontae-kim.github.io/tags/data/"},{"name":"structure","slug":"structure","permalink":"https://joontae-kim.github.io/tags/structure/"},{"name":"자료 구조","slug":"자료-구조","permalink":"https://joontae-kim.github.io/tags/%EC%9E%90%EB%A3%8C-%EA%B5%AC%EC%A1%B0/"}]},{"title":"알고리즘 시리즈 - 시간 복잡도","slug":"algorithm-big-O","date":"2021-04-15T06:30:46.000Z","updated":"2021-04-23T07:05:36.807Z","comments":true,"path":"2021/04/15/algorithm-big-O/","link":"","permalink":"https://joontae-kim.github.io/2021/04/15/algorithm-big-O/","excerpt":"","text":"알고리즘 개요지난 포스트인 알고리즘 시리즈 - 시작에서는 우리는 알고리즘을 특정 문제를 해결하기 위한 일련의 계산과정으로 입력, 출력 그리고 계산과정 이 존재한다고 정의했었습니다. 또한 해결해야하는 문제의 특성에 따라 사용하기에 적합한 데이터 형태가 다르며 어떤 데이터 형태와 알고리즘 구조를 설계했느냐에 따라서 알고리즘 성능 분석 기준 중 시간복잡도와 공간복잡도 또한 달라집니다. 이번 포스트에서는 그중에 하나인 시간 복잡도에 대해서 공부해보겠습니다. 시간 복잡도시나리오A라는 지점에서 B 지점을 가야한다고 상상해보자. B 지점은 처음 가는 곳이며 버스를 타고 가야할지, 지하철을 타고 가야할지 그리고 대중교통 선택했다면 어떤 버스를 또는 지하철을 타고 가야하는지 조차 정보가 없다. 네이버맵에서 경로 검색 후 지하철을 타기로 했다. 추천 노선은 총 2개이고, 추천 경로는 총 5개이며 모두 경험이 없는 경로여서 어떤 경로를 선택할지 일일히 탐색해봐야 한다. (경로 탐색중…) 5개의 경로를 모두 탐색했고 그 중 1번의 환승임에도 불구하고 가장 빠르게 도착하는 경로를 선택했다. 시간 복잡도란…위와 같은 경로 탐색의 시간이 바로 시간 복잡도 이다. 위 시나리오 처럼 전혀 데이터가 없어 모든 추천경로를 탐색한 후 비교 분석을 통해 선택한다면 시간은 추천경로의 개수만큼 늘어날 것이고, 만약 개중 데이터가 있는 경로가 있었다면 그중 선택함으로써 추천경로 모두를 탐색하지 않아도 됐을 것이다. 즉, 시간 복잡도란 문제를 해결하는데 걸리는 시간과 입력의 함수 관계 로써, 같은 결과를 내는 다수의 알고리즘이 있다면 가능한 시간이 적게 걸리는 다시말해 시간 복잡도가 낮은 알고리즘이 좋은 알고리즘이라고 판단할 수 있겠다. 기본적인 연산을 수행하는데에 고정된 시간이 걸릴 때, 알고리즘에 의해서 수행되는 기본 연산의 개수를 세어 예측할 수 있다. 알고리즘의 수행 시간은 동일 크기의 다양한 입력에 의해 달라질 수 있기 때문에, 가장 많이 쓰이는 최악의 시간 복잡도의 알고리즘 시간을 T(n)이라고 했을 때, 이것은 크기 n의 모든 입력에 대해 걸리는 최대의 시간으로 정의할 수 있다. 시간 복잡도의 종류 Every-Case Time Complexity ( 𝑇(𝑛) ) 입력 크기 n 이 입력됐을 때, 알고리즘이 연산을 수행하는 횟수 입력 크기에만 종속되며, 어떤 입력값이 들어오더라도 일정하다. The Worst Case Time Complexity( 𝑊(𝑛) ) 입력크기 n 이 주어졌을 때, 알고리즘이 연산을 수행하는 최대 횟수 입력크기와 입력값 모두에 종속되며, 단위연산이 수행되는 횟수가 최대인 경우 선택 The Best Case Time Complexity ( 𝐵(𝑛) ) 입력크기 n 이 주어졌을 때, 알고리즘이 연산을 수행하는 최소 횟수 입력크기와 입력값 모두에 종속되며, 단위연산이 수행되는 횟수가 최소인 경우 선택 The Average Case Time Complexity ( 𝐴(𝑛) ) 입력크기 n 이 주어졌을 때, 알고리즘이 연산을 수행하는 평균 횟수 입력크기와 입력값 모두에 종속되며, 모든 입력에 대해서 단위연산이 수행되는 기대치 점근적 분석법점근적 분석법이란 입력되는 데이터의 크기에 따라 수행 시간간과 공간이 얼마나 차지하는지 알아보는 탐색법으로써, 주어진 데이터의 형태나 실험을 수행하는 환경 또는 실험에 사용한 시스템의 성능 등의 요소에 의해 공평한 결과가 나오기 힘들고, 그 비교가 항상 일정하지 않기 때문에 필요하다. 시간복잡도를 나타내는 점근적 분석법의 표기법으로는 아래와 같으며 주로 최악의 경우인 빅오 표기법 (Big-O Notation) 을 사용하는데 그 이유는 평균의 경우를 사용하면 그 기준을 맞추기 까다롭고 모호할 수 있으며 최악의 경우를 사용하면 “아무리 나빠도 다른 알고리즘 보다는 같거나 좋다.” 라는 비교분석을 따르면 평균에 가까운 성능을 예측하기 쉽기 때문이다. 최상의 경우 : 오메가 표기법 (Big-Omega(Ω) Notation) 평균의 경우 : 세타 표기법 (Theta(θ) Notation) 최악의 경우 : 빅오 표기법 (Big-O Notation) Big-O 시간 복잡도에 가장 큰 영향을 미치는 차항으로 시간복잡도를 나타내는 것으로 알고리즘 실행 시간의 상한선을 나타낸 표기법이다. Big-O 표기법 이라 하며 O(f(n)) 과 같이 표기한다. (O는 order 라고 읽는다.) 12345671 # O(1): 상수T(n)&#x3D;2n # O(n): n이 가장 큰 영향을 미친다.T(n)&#x3D;2n^5+3n^4+n^3+n^2+1 # O(n5): n^5이 가장 큰 영향을 미친다T(n)&#x3D;3n^2+2n+1 # O(n2): n^2이 가장 큰 영향을 미친다. Big-O 표기법의 종류※ 여기서 n이란 입력되는 데이터를 의미합니다. f(n) Name 비고 1 Contant (상수) Operation push and pop on Stack log n Logarithmic (로그) Binary Tree n Linear (선형) for loop n log n Log Linear (선형 로그) Quick Sort, Merge Sort, Heap Sort n2 Quadratic (제곱) Double for loop, Insert Sort, Bubble Sort, Selection Sort 2n Exponential (지수) Fibonacci Sequence Big-O 표기법의 설명 O(1) 상수 시간 문제 해결을 위해 오직 한 단계만 거침 입력되는 데이터 양과 상관없이 일정한 시간 동안 실행 O(log n) 로그 시간 입력 데이터의 크기가 커질수록 처리 시간이 로그(log) 만큼 짧아지는 알고리즘 입력값 n이 주어졌을때, 문제를 해결하는데 필요한 단계들이 연산마다 특정요인에 의해 줄어듬 입력 데이터 10 투입되면 시간은 2배가 걸림 O(n) 직선적 시간 문제를 해결하기 위한 단계의 수와 입력 데이터의 크가 n이 1:1 관계를 가지는 알고리즘 예) 1차원 for loop O(n log n) 선형 로그 시간 입력 데이터의 크기가 커질수록 처리 시간이 로그(log) 만큼 늘어나는 알고리즘 예) 입력 데이터 10 투입되면 시간은 20배가 걸림 대표적 알고리즘: 병합 정렬 알고리즘, 퀵 정렬 알고리즘 O(n2) 제곱 시간 입력 데이터의 크기에 따라 걸리는 시간은 제곱에 비례 이중 루프 내에서 입력 데이터를 처리하는 경우에 나타남 n 값이 커지면 실행 시간이 감당할 수 없을 정도로 늘어남 문제를 해결하기 위한 단계의 수에 해당 대표적 알고리즘: 버블 정렬 알고리즘, 삽입 정렬 알고리즘 (둘다 2중 for loop 구조) O(2n) 지수 시간 입력 데이터의 크기에 따라 걸리는 시간은 2의 n 제곱만큼 비례 보통 문제를 풀기 위한 모든 조합과 방법을 시도할 때 사용됨 대표적 알고리즘: 피보나치 수열, 재귀가 역기능을 할 경우도 해당됨 성능 순서[Excellent] O(1) &lt; O(logn) &lt; O(n) &lt; O(n log n) &lt; O(n2) &lt; O(2n) [Horrible] Big O 표기와 입력 데이터 크기에 따른 성능을 비교| Big O 표기 | 10 개 일때 | 100 개 일때 | 1000 개 일때 ||——|——|——|——|| O(1) | 1 | 1 | 1 || O(log n) | 3 | 6 | 9 || O(n) | 10 | 100 | 1000 || O(n log n) | 30 | 600 | 9000 || O(n2) | 100 | 10000 | 1000000 || O(2n) | 1024 | 1.26e+29 | 1.07e+301 || O(N!) | 3628800 | 9.3e+157 | 4.02e+2567 | Big-O 시간복잡도 계산몇 가지 시간복잡도 Big-O 표기법을 예시로 계산법을 알아보도록 하겠습니다. 문제 1123456function print(arg) &#123; console.log(arg)&#125;print(&#39;hello&#39;)&gt; &quot;hello&quot; 위 코드는 시간 복잡도: O(1) 인 코드로 실행되는 코드 라인은 print 함수 내부 console.log(arg) 뿐이다. 문제 21234567891011function loop(n) &#123; for(let i&#x3D;0;i &lt; n;i++)&#123; console.log(i); &#125;&#125;loop(10)&gt; 1&gt; 2&gt; ....&gt; 10 위 코드는 시간 복잡도: O(n) 인 코드로 실행되는 코드 라인은 loop 함수의 for loop가 n 번만큼 반복하기 떄문이다. 문제 2: 기출변형12345678910function loop2(n) &#123; for(let i&#x3D;0;i&lt;n;i++)&#123; console.log(i); &#125; for(let i&#x3D;0;i&lt;n;i++)&#123; console.log(i); &#125;&#125;loop2(10) 위 코드 loop2 함수 내부에 loop 문이 2개 있지만 시간복잡도 계산에서는 영향이 가장 큰 알고리즘 하나만 계산하기 때문에 O(n2)가 아닌 시간 복잡도: O(n) 입니다. 문제 312345678910function looploop(n) &#123; for(let i&#x3D;0;i&lt;n;i++)&#123; console.log(i); for(let j&#x3D;0;j&lt;n;j++)&#123; console.log(j); &#125; &#125;&#125;looploop(10) 위 코드는 loop에 loop가 있는 이중 loop 문으로 시간 복잡도: O(n2) 입니다. 문제 3: 기출변형123456789101112function looploop2(n) &#123; for(let i&#x3D;0;i&lt;n;i++)&#123; for(let j&#x3D;i;j&lt;n;j++&#123; console.log(j); &#125; &#125; for(let i&#x3D;0;i&lt;n;i++)&#123; console.log(i); &#125;&#125;looploop2(10) 위 코드는 이중 loop문과 단수 loop이 있는 코드로써, ##### 문제 2: 기출변형 에서 언급했듯이 영향이 가장 큰 알고리즘만 시간복잡도에서는 계산하기 때문에 시간 복잡도: O(n2) 이다. 아래 문제는 아래의 데이터를 기반으로 풀어보겠습니다.12345678var attendance &#x3D; &#123; &#39;Kim&#39; : true, &#39;Amili&#39; : false, &#39;Moon&#39; : true, &#39;Koon&#39; : true, &#39;Joon&#39; : true,&#125;var attendanceAges &#x3D; [21, 29, 22, 25, 27] 문제 4123456function isAttendant (name) &#123; return attendance[name]&#125;isAttendant[&#39;Kim&#39;]isAttendant[&#39;Moon&#39;] 위 코드는 isAttendant 함수에 name 인자를 넘겨 attendance 데이터에서 알고 있는 또는 전달받은 key 또는 index에 따라 결과값을 return 하는 함수로 시간 복잡도: O(1) 이다. 문제 5123456789function thisOld(num, array)&#123; var midPoint &#x3D; Math.floor(array.length&#x2F;2); if( array[midPoint] &#x3D;&#x3D;&#x3D; num) return true; if( array[midPoint] &lt; num ) &#x2F;&#x2F; --&gt; only look at second half of the array if( array[midpoint] &gt; num ) &#x2F;&#x2F; --&gt; only look at first half of the array &#x2F;&#x2F; recursively repeat until you arrive at your solution &#125;thisOld(28, attendanceAges) 위 코드는 이진탐색 트리 알고리즘으로, thisOld 함수에 인자로 array 배열과 num을 념겨주고 내부 함수에서는 함수의 결과값을 찾기 위해 array 인자를 계속 반으로 분할하면서 값을 탐색하기 떄문에 배열에서 어느 방향으로 탐색을 시작할지 알고 있으면 탐색시간이 두배로 줄어든다. 따라서 시간 복잡도: O(log n) 인 알고리즘이다. 시간복잡도 줄이는 법일단 시간복잡도를 줄이는 법을 많이 찾아봤지만 자료를 많이 찾아보진 못했고 몇몇 국내외 블로그에서 언급 됐던 것은 아래와 같습니다. 알고리즘에서 시간복잡도에 가장 큰 영향을 끼치는 것은 반복문 이다. #문제1 ~ 3 이 반복문이 시간복잡도를 올리는 그 예이다. 해결해야할 문제 또는 이슈에 맞는 적절한 알고리즘을 설계하라. 알고리즘마다 핸들링 가능한 적절한 문제해결 케이스가 있기 때문에 외워두고 있거나 참고자료를 참고한다면 시간복잡도를 낮출 수 있다. 각 알고리즘의 형태에 맞는 효율적인 자료구조 들을 이용한다면 시간 복잡도를 낮출 수 있다. 부록자료구조 작업별 복잡도 자료 구조 접근 검색 삽입 삭제 비고 배열 1 n n n 스택 n n 1 1 큐 n n 1 1 연결 리스트 n n 1 1 해시 테이블 - n n n 완벽한 해시 함수의 경우 O(1) 이진 탐색 트리 n n n n 균형 트리의 경우 O(log(n)) B-트리 log(n) log(n) log(n) log(n) Red-Black 트리 log(n) log(n) log(n) log(n) AVL 트리 log(n) log(n) log(n) log(n) Bloom Filter - 1 1 - 거짓 양성이 탐색 중 발생 가능 정렬 알고리즘 복잡도 이름 최적 평균 최악 메모리 동일값 순서 유지 비고 거품 정렬 n n2 n2 1 Yes 삽입 정렬 n n2 n2 1 Yes 선택 정렬 n2 n2 n2 1 No 힘 정렬 n log(n) n log(n) n log(n) 1 No 병합 정렬 n log(n) n log(n) n log(n) n Yes 퀵 정렬 n log(n) n log(n) n2 log(n) No 보통 제자리로 O(log(n)) 스택공간으로 수행됨 셀 정렬 n log(n) n log(n) n (log(n))2 1 No 계수 정렬 n + r n + r n + r n + r Yes r - 배열내 가장 큰 수 기수 정렬 n * k n * k n * k n * k n + k Yes 참고 [Algorithm] 알고리즘 시간복잡도에 대하여 웹 개발자를 위한 자료구조와 알고리즘 (#01. 빅오 표기법) Algorithms in plain English: time complexity and Big-O notation 알고리즘의 시간 복잡도와 Big-O 쉽게 이해하기 Know Thy Complexities! 시간복잡도(Time Complexity) 정리 [알고리즘]시간복잡도 Big O","categories":[{"name":"Programming","slug":"Programming","permalink":"https://joontae-kim.github.io/categories/Programming/"},{"name":"Algorithm","slug":"Programming/Algorithm","permalink":"https://joontae-kim.github.io/categories/Programming/Algorithm/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://joontae-kim.github.io/tags/Algorithm/"},{"name":"big-O","slug":"big-O","permalink":"https://joontae-kim.github.io/tags/big-O/"},{"name":"time complexity","slug":"time-complexity","permalink":"https://joontae-kim.github.io/tags/time-complexity/"},{"name":"알고리즘","slug":"알고리즘","permalink":"https://joontae-kim.github.io/tags/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/"},{"name":"빅오","slug":"빅오","permalink":"https://joontae-kim.github.io/tags/%EB%B9%85%EC%98%A4/"},{"name":"시간 복잡도","slug":"시간-복잡도","permalink":"https://joontae-kim.github.io/tags/%EC%8B%9C%EA%B0%84-%EB%B3%B5%EC%9E%A1%EB%8F%84/"}]},{"title":"Prototype 기반의 Javascript","slug":"js-oop-prototype","date":"2021-04-07T14:00:24.000Z","updated":"2021-08-05T09:06:29.215Z","comments":true,"path":"2021/04/07/js-oop-prototype/","link":"","permalink":"https://joontae-kim.github.io/2021/04/07/js-oop-prototype/","excerpt":"","text":"지난 포스트인 Javascript와 객체 지향 프로그래밍 - 객체 지향 프로그래밍(OOP)에서는 객체 지향 프로그래밍의 기본적인 개념, 기본 구성요소, OOP의 기법 또는 특성으로 많이 언급되는 추상화, 캔슐화, 은닉화, 상속성, 다형성 그리고 OOP의 장단점에 대해 공부해보면서 객체 지향 프로그래밍에서 중요시하는 것은 무엇이며 프로그래밍 설계 및 구현시 이반되는 장점에 대해 알 수 있었습니다. 이번 포스트에서 다를 주제는 Prototype 기반의 프로그래밍입니다. Prototype 기반의 프로그래밍?Prototype 이란 사전적 의미는 원형, 원본 이다. 그럼 Prototype 기반의 프로그래밍은 무엇일까? Javascript에서 어디에 쓰는 개념인고…?일단 이전 포스트인 Javascript와 객체 지향 프로그래밍 - 객체 지향 프로그래밍(OOP)에서 언급한 Class에 대해 복기해보면 객체 지향 프로그래밍을 구현하기 위해 추상화된 속성과 메서드를 Class 라는 하나의 틀(template)을 정의하고, 클래스에 의해 생성된 새로운 객체(object)를 클래스의 인스턴스라고 부르며 클래스의 속성과 메서드를 그대로 상속받아 OOP의 기법인 캡슐화와 은닉화, 추상화, 상속성과 다형성의 개념을 구현할 수 있다. 위와 같은 Class의 개념이 Javascript에서는 Prototype 이다. 즉, 프로토타입 기반 프로그래밍이란 객체의 원형인 프로토타입을 이용해 새로운 객체를 만들어내는 프로그래밍 기법으로, 새롭게 생성된 객체는 자기 자신의 원형(Prototype)을 가지며 원형의 속성과 메서드를 상속받거나 확장할 수 있다. 객체 생성법Javascript에서 객체를 생성하는 방법은 총 3가지로 객체 리터럴, Object 생성자 함수, 생성자 함수가 있으며 Javascript에서는 new 연산자와 함께 생성자 함수를 사용해 인스턴스 객체를 생성할 수 있다. 1234567891011121314151617181920var obj &#x3D; &#123; name : &#39;BKJang&#39;, job : &#39;Developer&#39;&#125;&#x2F;&#x2F; Object 생성자 함수var obj &#x3D; new Object();obj.name &#x3D; &#39;BKJang&#39;;obj.job &#x3D; &#39;Developer&#39;;&#x2F;&#x2F; 생성자 함수function Person(name, job) &#123; this.name &#x3D; name; this.job &#x3D; job;&#125;&#x2F;&#x2F; 인스턴스 생성var obj &#x3D; new Person(&#39;BKJang&#39;, &#39;Developer&#39;); 생성자 함수와 new 연산자생성자 함수란 객체 인스터스를 생성하는 함수로, 선언된 일반 함수를 new 키워드와 함께 호출 및 실행하는 함수로, Javascript에서는 두 가지 타입의 생성자 함수가 존재합니다. Array와 Object 와 같은 내장 생성자 함수: 런타임 환경의 실행 컨텍스트 환경에서 자동으로 사용 가능 커스텀 생성자 함수: 객체 타입으로 프로퍼티와 메서드 정의 객체 생성을 위해 우리가 사용할 생성자 함수 타입은 두번째로, 위에서 객체 생성 방법 중 굳이 생성자 함수를 사용하는 이유는 동일한 프로퍼티와 메서드를 갖는 복수의 객체를 생성할때 객체 리터럴 방식보다 유용하기 때문이며 객체 인스턴스를 생성할때 생성자 함수의 this 가 반환되면서 인스턴스 각자의 실행 컨텍스트를 갖게 되어 독립적 실행환경을 유지할 수 있기 때문입니다. new 연산자Javascript에서 new 연산자는 사용자 정의 객체 타입 또는 내장 객체 타입의 인스턴스를 생성할때 사용되며 아래와 같은 문법을 따릅니다. 1new constructor[([arguments])] constructor: 객체 인스턴스의 타입을 기술 또는 명세하는 함수 arguments: constructor와 함께 호출될 값 목록 생성자 함수와 함께 new 연산자를 사용하면…생성자 함수와 함께 new 연산자를 사용하면 아래의 단계를 거쳐 객체 인스턴스가 생성됩니다. 비어있는 객체(&#123;&#125;)를 만듭니다. 생성자 함수의 Prototype Object에 연결된 새 객체(__proto__)를 프로퍼티에 추가합니다. 따라서, new 연산자를 사용함으로써 생성자 함수 prototype에 추가된 프로퍼티와 객체는 생성자 함수에 의해 생성된 모든 인스턴스에서 접근가능(accessible)하다. 새롭게 생성된 객체 인스턴스를 this 컨텍스트로 바인딩한다. i.e.) 생성자 함수에서 this에 대한 모든 참고는 현재 첫번째 단계에서 생성된 객체를 참고한다. 만약 함수가 객체를 반환하지 않는다면 this를 반환한다. 사용자 정의 객체를 생성하기 위해서는…사용자 정의 객체를 생성하기 위해서는 총 2개의 과정이 필요합니다. 이름과 속성을 가진 함수를 작성함으로써 객체 타입을 정의한다. new 연산자와 함께 객체의 인스턴스를 생성한다. 예제 및 실행문맥 분석 (parsing)12345678910111213141516&#x2F;&#x2F; 1. 생성자 함수 정의function Car(make, model, year) &#123; this.make &#x3D; make; this.model &#x3D; model; this.year &#x3D; year; this.introduce &#x3D; function () &#123; console.log(&#96;This Car&#39;s Model is $&#123;this.model&#125; made by $&#123;this.make&#125; in $&#123;this.year&#125;&#96;) &#125;&#125;&#x2F;&#x2F; 2. 객체 인스턴스 생성var myCar &#x3D; new Car(&#39;Eagle&#39;, &#39;Talon TSi&#39;, 1993);myCar.make&gt; &quot;Eagle&quot;myCar.introduce()&gt; &quot;This Car&#39;s Model is &#39;Talon TSi&#39; made by &#39;Eagle in 1993&quot; new Car(...)를 실행하면 Car.prototype 으로부터 상속된 새로운 객체(인스턴스)가 생성된다. make, model, year 인자와 함께 생성자 함수 Car가 호출되며 새롭게 생성된 객체에 this가 바인딩 됩니다. new Car는 new Car()와 동일하고, 예를 들어 인자가 지정되지 않았다면 인자 없이 Car를 호출합니다.3, 생성자 함수에 의해 반환된 객체는 전체 new 표현식의 결과입니다. 만약 생성자 함수가 객체를 반환하지 않는다면, 1 단계에서 생성된 객체가 대신 사용됩니다. (일반적으로 생성자 함수는 값(value)를 반환하지 않으나 만약 객체 생성 과정을 재정의(overide)하려는 경우 그렇게 할 수도 있습니다) 위와 같이 동일한 프로퍼티 또는 멤버와 메서드를 같는 객체를 효율적으로 생성할 수 있는 방법이 생성자 함수이다. 인스턴스가 생성되면 각 인스턴스는 make, model, year라는 프로퍼티와 introduce와 같은 메서드를 동일하게 갖게 된다. 즉, 인스턴스가 생성될 때마다 동일한 프로퍼티와 메서드가 계속 생성되는 것이다. 필요한 만큼. 만약 인스턴스가 매우 많아지거나 각 사이즈가 늘어난다면 메모리를 낭비하게 되는 구조가 된다. 이를 해결하기 위해 개념이 바로 Prototype 기반의 객체지향 프로그래밍 이다. prototype에 대해 공부해본 후 생성자 함수 Car를 수정하고 확장해보자. Javascript에서 Prototype이란?먼저, 프로토타입 기반 프로그래밍에 대해 다시 복기해보면, 아래와 같이 정의했었다. 프로토타입 기반 프로그래밍이란 객체의 원형인 프로토타입 객체를 이용해 새로운 객체를 만들어내는 프로그래밍 기법으로, 새롭게 생성된 객체는 자기 자신의 원형(prototype)을 가지며 원형의 프로퍼티와 메서드를 상속받거나 확장할 수 있다. 그리고 생성자 함수와 new 연산자 섹션의 2번에서 우리는생성자 함수와 new 연산자를 통해 인스턴스를 생성했을때, 생성자 함수의 Prototype Object에 연결된 새 객체(__proto__)를 프로퍼티에 추가한다는 것을 배웠다. 따라서, 생성자 함수에 추가된 속성과 객체는 생성자 함수에 의해 생성된 모든 인스턴스에서 접근 가능(accessible)하게 해주며 Javascript에서 OOP의 개념이 가능하게 해준다. 어떻게 이게 가능할까? Javascript에는 아래와 같이 크게 2가지 개념의 protoype 이 존재하며 이는 Javascript의 함수와 객체에 대한 내부 구조를 더 살펴봐야 한다. 함수의 prototype 프로퍼티가 가리키고 있는 Prototype Object 자기 자신을 만들어낸 인스턴스 객체의 원형을 의미하는 Prototype Link 함수와 객체의 구조Javascript의 모든 객체는 생성과 동시에 정의된 프로퍼티와 메서드를 가진 프로토타입 객체(Prototype Object) 라는 새로운 객체를 복제(Cloning)하여 만드는데 함수의 경우에도 객체 타입으로써 정의 및 분석(parsing) 단계에서 함수 내부에 prototype 프로퍼티를 추가한 후 복제된 프로토타입 객체(Prototype Object) 를 참조하도록 한다. 또한, 프로토타입 객체(Prototype Object) 는 constructor 프로퍼티를 갖는 구조로써, 이는 함수를 참조하는 구조를 갖는다. 단계를 나열하면 아래와 같다. 생성자 함수 function Car (make, model, year) 정의 및 prototype 프로퍼티 추가 생성자 함수 Car의 원형인 프로토타입 객체(Prototype Object) - Car Prototype Object 생성 및 constructor 프로퍼티 추가 생성자 함수 Car의 prototype 프로퍼티는 Car Prototype Object 참조 Car Prototype Object의 constructor는 생성자 함수 Car 참조 즉, Car Prototype Object는 new 연산자와 생성자 함수에 의해 생성될 새로운 인스턴스가 참조할 원형 객체(Prototype Object) 이다. 또한 생성된 인스턴스는 아래와 같은 구조를 갖는데 예를 들어, myCar 인스턴스는 생성자 함수를 참조한 프로퍼티 이외에 __proto__ 프로퍼티를 가지고 있는데 바로 이 프로퍼티가 myCar 라는 객체를 만들어내기 위해 사용된 프로토타입 객체 (Car protototype object)에 대한 숨겨진 연결 이며 이를 Prototype Link라고 한다. 123456789101112131415&#x2F;&#x2F; 인스턴스 &#96;myCar&#96;myCar &#123; introduce: ƒ () make: &quot;Eagle&quot; model: &quot;Talon TSi&quot; year: 1993 __proto__: &#123; constructor: ƒ Car(make, model, year) __proto__: Object &#125;&#125;&#x2F;&#x2F; 인스턴스의 __proto__의 생성자와 생성자 함수의 prototype 프로퍼티의 생성자 비교myCar.__proto__.constructor &#x3D;&#x3D;&#x3D; Car.prototype.constructor&gt; true 예시를 기반으로 생성자 함수, 인스턴스 그리고 프로토타입 객체(Prototype Object) 에 대해 정리해보면, constructor는 생성자 함수 본인이고, prototype은 생성자 함수에 정의한 모든 객체가 공유할 원형으로 하위로 물려줄 연결에 대한 속성 __proto__는 생성자 함수를 new로 호출할 때, 정의해두었던 prototype을 참조한 객체로서 상위에서 물려받은 객체의 프로토타입에 대한 정보 prototype은 생성자 함수에 사용자가 직접 넣는 거고, __proto__는 new를 호출할 때 prototype을 참조하여 자동으로 만들어짐 생성자에는 prototype, 생성자로부터 만들어진 객체에는 __proto__ Prototype Chain (프로토타입 체인)우리는 프로토타입 객체(Prototype Object) 와 프로토타입 링크(Prototype Link) 에 대해 살펴봤습니다. 생성자 함수의 prototype 프로퍼티가 함수의 프로토타입 객체(Prototype Object)를 참고하고 있으며 new 연산자와 생성자 함수에 의해 생성한 인스턴스는 __proto__ 프로퍼티를 통해서 함수 객체의 원형을 참조하고 있음을 알 수 있었다. 따라서 생성된 인스턴스들은 생성자 함수의 프로토타입 객체(Prototype Object) 을 계속 주시하고 있으며 생성자 함수의 prototype 프로퍼티에 프로퍼티 또는 메서드를 추가할 경우 프로토타입 링크(Prototype Link) 의 관계인 인스턴스도 이를 공유받아 추가된 속성들을 활용할 수 있습니다. 이는 그 어떠한 상위 프로토타입 객체도 마찬가지입니다. 이러한 개념이 바로 프로토타입 체인(prototype chain) 이고 다른 객체에 정의된 메소드와 속성을 한 객체에서 사용할 수 있도록 하는 원리입니다. 정확히 말하자면 상속되는 속성과 메소드들은 각 객체가 아니라 객체(인스턴스) 생성자의 prototype 이라는 속성에 정의되어 있습니다. 그리고 위와 같이 객체 인스턴스와 프로토타입 객체 간에 연결을 생성자 함수의 prototype 프로퍼티와 인스턴스 객체의 __proto__ 프로터리를 통해 구성하고 있으며 이 연결을 따라 타고 올라가며 속성과 메소드를 탐색하는 것을 프로토타입 체인(Prototype Chain) 이라고 정리할 수 있습니다. 아래 코드는 프로토타입 체인을 설명하기 위한 예시입니다. 123456789101112131415161718192021222324252627282930&#x2F;&#x2F; #예제 1.function exam1 () &#123; this.x &#x3D; function () &#123; console.log(&#39;hello&#39;); &#125;;&#125;;exam1.x&#x3D;function() &#123; console.log(&#39;world&#39;);&#125;;var exam1A &#x3D; new A();var exam1B &#x3D; new A();exam1A.x();&gt; helloexam1B.x();&gt; hello&#x2F;&#x2F; #예제 2.var exam2 &#x3D; function () &#123; &#125;;exam2.x&#x3D;function() &#123; console.log(&#39;hello&#39;);&#125;;exam2.prototype.x &#x3D; function () &#123; console.log(&#39;world&#39;);&#125;;var exam2A &#x3D; new exam2();var exam2B &#x3D; new exam2();exam2A.x();&gt; worldexam2B.x();&gt; world 프로토타입 객체와 프로토타입 링크 에 대해 잘 이해했다면, ‘#예제1’에서 메서드 메서드 x의 수정이 즉시 반영되지 않는 이유를 금방 눈치챌 수 있을 것입니다. 힌트는 바로 생성자 함수 객체의 메서드를 어디에서 수정했냐 이다. 생성자 함수와 객체 인스턴스는 프로토타입 객체(Prototype Object) 와 연결되어 있으며 생성자 함수 내 메서드의 추가, 변경, 삭제 등의 내부 속성의 변경상태를 공유하기 위해서는 ‘#예제2’ 와 같이 생성자 함수의 prototype 프로퍼티를 통해 정의 및 수정해야 한다. #예제1 의 exam1.x=function () &#123; ~ &#125; 와 같은 수정은 단지 생성자 함수 객체의 메서드를 변경한 것 뿐이다. 잊고 있던 예제를 개선해보자.Javascript의 prototype에 대해 공부하면서 잊고 있었던 Car 생성자 함수의 introduce 메서드 할당을 개선해보자. 1234567891011121314151617181920212223&#x2F;&#x2F; 1. 생성자 함수 정의function Car(make, model, year) &#123; this.make &#x3D; make; this.model &#x3D; model; this.year &#x3D; year; &#x2F;&#x2F; this.introduce &#x3D; function () &#123; &#x2F;&#x2F; console.log(&#96;This Car&#39;s Model is $&#123;this.model&#125; made by $&#123;this.make&#125; in $&#123;this.year&#125;&#96;) &#x2F;&#x2F; &#125;&#125;&#x2F;&#x2F; 2. &#96;introduce&#96; 메서드를 &#96;Car&#96; 함수의 prototype 속성에 추가Car.prototype.introduce &#x3D; function () &#123; console.log(&#96;This Car&#39;s Model is $&#123;this.model&#125; made by $&#123;this.make&#125; in $&#123;this.year&#125;&#96;)&#125;&#x2F;&#x2F; 3. 인스턴스 생성var myCar &#x3D; new Car(&#39;Eagle&#39;, &#39;Talon TSi&#39;, 1993);myCar.make&gt; &quot;Eagle&quot;&#x2F;&#x2F; 4. 인스턴스에서 &#96;introduce&#96; 메서드 호출myCar.introduce()&gt; &quot;This Car&#39;s Model is &#39;Talon TSi&#39; made by &#39;Eagle in 1993&quot; 위와 같이 생성자 함수의 내부에 메서드를 할당하는 대신 prototype 프로퍼티에 메서드를 할당해줌으로써 Car Prototype Object 또한 참조 받으며 생성된 인스턴스 객체들 또한 Prototype Link 속성으로 추가된 메서드 또는 프로퍼티를 공유받아 생성 이후에 할당된 기능들도 실행시킬 수 있게 된다. 마치며Prototype에 대해 학습하면서 몇몇 부분에서 제대로 이해되지 않아 디테일한 부분까지 찾아보다보니 많은 블로그를 찾아보았고 많은 시간을 소모했다고 느꼈지만 끝나고나니 이제서야 왜 Javascript에서 Prototype 기반의 프로그래밍이 중요하고 OOP를 구현하기 위한 기반이라고 했는지 이해하게 되었다. 다음 포스트 주제로는 prototype의 상속에 대해 다뤄보겠습니다. 참고 new Operator ‘new’ 연산자와 생성자 함수 [javascript] new 연산자와 생성자 함수 new operator 자바스크립트 객체 생성자 함수란? Javascript 기초 - Object prototype 이해하기 Javascript: 프로토타입 (prototype) 이해 객체 지향 프로그래밍(생성자와 프로토타입) [Javascript ] 프로토타입 이해하기 자바스크립트는 프로토타입 기반의 객체지향 프로그래밍 언어이다. 함수의 프로토타입 - prototype 자바스크립트 객체지향 프로그래밍 Object prototypes Inheritance in JavaScript Common Misconceptions About Inheritance in JavaScript [JavaScript] 8-1. 객체지향 프로그래밍(클래스 vs 프로토타입) [JavaScript] 8-2. 객체지향 프로그래밍(상속)","categories":[{"name":"Programming","slug":"Programming","permalink":"https://joontae-kim.github.io/categories/Programming/"},{"name":"Javascript","slug":"Programming/Javascript","permalink":"https://joontae-kim.github.io/categories/Programming/Javascript/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://joontae-kim.github.io/tags/javascript/"},{"name":"oop","slug":"oop","permalink":"https://joontae-kim.github.io/tags/oop/"},{"name":"prototype","slug":"prototype","permalink":"https://joontae-kim.github.io/tags/prototype/"},{"name":"object","slug":"object","permalink":"https://joontae-kim.github.io/tags/object/"},{"name":"프로토타입","slug":"프로토타입","permalink":"https://joontae-kim.github.io/tags/%ED%94%84%EB%A1%9C%ED%86%A0%ED%83%80%EC%9E%85/"},{"name":"new","slug":"new","permalink":"https://joontae-kim.github.io/tags/new/"},{"name":"contructor","slug":"contructor","permalink":"https://joontae-kim.github.io/tags/contructor/"},{"name":"new 생성자","slug":"new-생성자","permalink":"https://joontae-kim.github.io/tags/new-%EC%83%9D%EC%84%B1%EC%9E%90/"}]},{"title":"알고리즘 시리즈 - 시작","slug":"algorithm","date":"2021-04-04T09:06:15.000Z","updated":"2021-04-15T16:41:01.660Z","comments":true,"path":"2021/04/04/algorithm/","link":"","permalink":"https://joontae-kim.github.io/2021/04/04/algorithm/","excerpt":"","text":"알고리즘을 공부하기 위해 책과 자료들을 수집해 보고 공부하기만 해서 정리하는 느낌으로 알고리즘 시리즈를 연재해보려고 합니다. 알고리즘에 대한 갈증알고리즘에 대한 필요성은 클립플러를 개발하면서 강하게 느꼈다. 클립플러의 일부 기능 중 clip으로 만들 사이트의 메타태그를 긁어와 유효한 태그를 추천하는 기능을 설계하는데 가장 큰 문제에 봉착했었다. 바로 코딩. 분명 팩토리얼로 단어의 조합을 만들면 된다는 생각은 있는데 팩토리얼 알고리즘 맞는지 그리고 어떻게 구현하는지 까마득했다;;; 그러다 잠시 개발은 중단하고 알고리즘에 대한 기초중의 기초와 중간을 건너띄고 팩토리얼 알고리즘에 대해 공부했다. 기능개발은 했지만 리팩토링은 물론 성능분석도 거의 하지 못했다. 그러다 조언을 구하면 더 나은 코드 설계와 개발실력을 갖추기 위해서는 알고리즘 공부가 도움이 많이 되고, 나중에 취업을 할때에도 도움이 많이 될거라고 했는데… 그렇게 모두의 충고를 과소평가하고 드문드문 보기만 했다;;; 그러다보니 알고리즘에 대한 베이스가 약하고, 코딩 테스트를 보더라도 쉬운 문제까지가 한계였다. 그래서 이번 기회에 알고리즘에 대한 숙제를 시리즈로 연재해보려고 마음 먹었다. 다시 시작하는 마음으로 꼬박꼬박 정리해가면서 다음에 봐도 공부할만한 자료가 될때까지. 먼저 알고리즘에 대해 간략하게 다룬 후 연재를 어떤 방향으로 할지 논해보려고 한다. 알고리즘이란?우리는 이미 알고리즘에 익숙해져있다. 다만, 그러한 것들을 ‘알고리즘’이라고 부르지 않을뿐. 이를테면, 가장 빠른 또는 편한 출근길 또는 퇴근길 경로 탐색 오늘 치킨을 먹을것인가, 주중에 먹을것인가에 대한 기회비용 탐색 한정된 금액 안에서 장보기 위와 같은 과정 모두 알고리즘이라고 할 수 있으며, 특정 문제를 해결하기 위한 일련의 계산과정으로 입력, 출력 그리고 계산과정 이 존재한다. 프로그래밍에서 알고리즘이란 필수적인 것은 아니지만 더 효율적이고 효과적인 방법으로 어떤 결과값(출력)을 만들어낼 수 있는 과학적 접근법으로, 어떤 알고리즘으로 과정을 설계하느냐에 따라 결과가 동일하더라도 프로그램의 속도나 처리방식 등이 크게 차이나는 경우도 있다. 알고리즘의 조건알고리즘은 다음의 조건을 만족해야 한다. 입력: 외부에서 제공되는 자료가 0개 이상 존재한다. 출력: 적어도 2개 이상의 서로 다른 결과를 내어야 한다.(즉 모든 입력에 하나의 출력이 나오면 안됨) 명확성: 수행 과정은 명확하고 모호하지 않은 명령어로 구성되어야 한다. 유한성(종결성): 유한 번의 명령어를 수행 후(유한 시간 내)에 종료한다. 효율성: 모든 과정은 명백하게 실행 가능(검증 가능)한 것이어야 한다. 좋은 알고리즘이란? 분석 기준. 정확성 : 적당한 입력에 대해서 유한 시간내에 올바른 답을 산출하는가를 판단. 작업량 : 전체 알고리즘에서 수행되는 가장 중요한 연산들만으로 작업량을 측정. 해결하고자 하는 문제의 중요 연산이 여러개인 경우에는 각각의 중요 연산들의 합으로 간주하거나 중요 연산들에 가중치를 두어 계산 최적성 :그 알고리즘보다 더 적은 연산을 수행하는 알고리즘은 없는가? 최적이란 가장 ‘잘 - 알려진’ 이 아니라 ‘가장 좋은’의 의미이다 시간 복잡도 (Big-O Notation), (이 부분에 대해서는 연재물로 따로 다루겠습니다.) 기억 장소 사용량 (공간 복잡도) : 수행에 필요한 저장 공간 알고리즘 설계 순서 from leobit님 블로그 - 알고리즘 일반적인 알고리즘 순서 문제 정의 모델 고안 명세 작성 설계 검증 분석(복잡도 등) 구현 테스트 문서화 자연어 ↔ 프로그래밍 언어 사이의 방식을 단계별로 기록 프로그램의 진행 과정에 조금이라도 관심이 있는 사람이라면, 이 의사 코드를 읽고 이해할 수 있을까? 이 의사 코드는 실제 코드로 쉽게 바뀔 수 있을까? 과정을 진행하는데 필요한 단계 중, 빠뜨린 것은 없나? 의사 코드를 읽는 사람들이 이해할 수 있는 용어들을 사용했는가? 알고리즘과 함께 논하는 개념들 시간 복잡도 자료구조 정렬 알고리즘 공부를 준비함과 동시에 취업 및 면접에 대한 자료를 찾고 읽으면서 가장 많이 언급된 것들로 시간 복잡도에 대한 정확한 이해와 각 알고리즘에 대한 시간 복잡도 특성에 대해 암기수준으로 준비를 한다면 면접에서 많은 점수를 딸수 있다고 했습니다. 그리고 자료구조와 정렬의 경우도 마찬가지이다. 알고리즘과 뗄 수 없는 관계이며 각 알고리즘에 맞는 자료구조와 어떤 특징을 가지고 있으며 왜 사용하는지 를 알고 있다면 이 또한 (많은) 점수를 얻을 수 있다고 합니다. 연재 계획앞으로 다룰 주제는 알고리즘과 함께 논하는 개념들 순서로 연재할 것이며 중간중간 문제를 풀어보며 되새김질을 빙자한 복습을 이어가려고 합니다. 주워 들은 팁이 부분은 yena님의 알고리즘 포스팅에서 보고 나 또한 상기하는 목적에서 복붙해왔습니다. 많은 사람들이 공통적으로 얘기하는 사실들이 있다. 처음부터 어려운 걸 하려고 하지 말고, 간단한 것부터 시작하자. 선택한 언어의 문법과 클래스를 잘 파악하자. 풀고 난 후 다른 사람의 풀이 참고하자. 경험이 쌓이면 익숙해진다. 조급해하지 말자. (보실지는 모르겠지만 yena님 감사합니다.) 참조 [Algorithm] 알고리즘 공부 시작 방법 및 순서 알고리즘 프로그래밍 입문 - 알고리즘의 정의 강의노트 17. 알고리즘, 자료구조 개요 시리즈:수학인듯 과학아닌 공학같은 컴퓨터과학/알고리즘 기초 알고리즘(Algorithm)[https://velog.io/@leobit/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98Algorithm]","categories":[{"name":"Programming","slug":"Programming","permalink":"https://joontae-kim.github.io/categories/Programming/"},{"name":"Algorithm","slug":"Programming/Algorithm","permalink":"https://joontae-kim.github.io/categories/Programming/Algorithm/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://joontae-kim.github.io/tags/Algorithm/"},{"name":"알고리즘","slug":"알고리즘","permalink":"https://joontae-kim.github.io/tags/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/"}]},{"title":"Nuxt 라이프사이클","slug":"nuxt-lifecycle","date":"2021-03-18T07:35:59.000Z","updated":"2021-03-19T15:20:57.497Z","comments":true,"path":"2021/03/18/nuxt-lifecycle/","link":"","permalink":"https://joontae-kim.github.io/2021/03/18/nuxt-lifecycle/","excerpt":"","text":"Vue.js를 사용해 웹 어플리케이션 개발할때 라이프사이클에 대한 공부를 제대로 시작하지 고생한 경험이 있는데 Nuxt는 그런 과정을 밟지 않기위해 라이프사이클부터 차근차근 공부해보자. 일단 공식문서 번역과 아래 Nuxt Lifecycle HOOKS 이미지에 대한 내용에 대해 공부해보자. Nuxt Lifecycle 여러분이 어떤 도구(tool)를 사용하든 그 도구의 서두(the hood)에 대해 잘 이해하고 있을때 더 자신있음을 느낄 것입니다. Nuxt.js도 해당됩니다. 이 챕터에서는 여러분에게 프레임워크의 실행순서와 어떻게 함께 작동하는지 서로 다른 부분에 대한 수준 높은 개요를 제공할 것입니다. Nuxt.js 라이프사이클은 빌드 단계 이후에 무엇이 발생되는지, 여러분의 어플리케이션이 어디서 번들되고(bundled), 청크되고(chunked), 최소화(minified) 되는지 설명합니다. 이 단계 이후에 발생하는 것은 여러분이 서버사이드 렌더링(server-side rendering) 활성화 여부에 따라 다릅니다. 만약 여러분이 서버사이드 렌더링 사용한다면, 추가적으로 여러분이 선택한 서버사이드 렌더링의 유형에 따라 달라집니다. Dynamic SSR (nuxt start) 또는 Static Site Generation (nuxt generate). LifecycleServerSSR을 위해서 아래의 단계가 여러분의 어플리케이션에서 모든 초기요청(request) 동안에 실행될 것입니다. 서버 시작 The server starts (nuxt start) 정적 사이트 생성모드를 사용하면, 서버 단계에서는 오직 빌드타임에만 실행되나 모든 페이지에 대해 단 한번만 실행될 것입니다. 생성 프로세스 시작 (nuxt generate) Nuxt hooks serverMiddleware Server-side Nuxt 플러그인(plugins) nuxt.config.js에 정의된 순서대로 (in order as defined in nuxt.config.js) nuxtServerInit 만약 Vuex store를 설정했다면 서버 사이드에서 요청되는 첫번째 생명주기 훅(lifecycle hook)이다 스토어(store)를 미리 채우기(pre-populate) 위해 서버 사이드에서 Vuex 호출한다. 첫번째 인자(argument)는 Vuex context, 두번째 인자는 Nuxt.js context 입니다. 서버 사이드에서 연속적인 스토어 액션(action)을 위해 오직 “entry point”에서 다른 액션을 Dispatch 합니다. 오직 store/index.js에 정의할 수 있습니다. 미들웨어 (Middleware 또는 Route Middleware) 페이지 컴포넌트가 렌더링되기 전에 호출됩니다. 조건을 설정하거나 체크할수도 있으며 페이지를 리다이렉트(redirect)하는데 사용할 수 있습니다. 전역 미들웨어(Global middleware) - 모든 라우트에 영향을 끼치며, route.config.js에 정의합니다. 레이아웃 미들웨어(Layout middleware) - 라우트 그룹에 영향을 끼치며, layout에 정의합니다. 페이지 미들웨어(Page middleware) - 싱글 라우트에 영향을 끼치며, page component에 정의합니다. validate 동적 라우트 파라미터(dynamic route parameter)를 검증하는데 유용합니다. 페이지 컴포넌트가 렌더링 되기 전에 호출됩니다. asyncData 페이지 컴포넌트가 로딩되기 전에 매번 호출됩니다. 컴포넌트 data 프로퍼티와 병합(merge)됩니다. beforeCreate (Vue 라이크사이클 메서드) Vue 인스턴트(instance)가 초기화(initialized) 될때 호출됩니다. created (Vue 라이크사이클 메서드) The new fetch (top to bottom, siblings = parallel) 상태의 일렬화(Serialization of state) (render:routeContext Nuxt.js hook) HTML을 렌더링 할때 일어난다. (render:route Nuxt.js hook) render:routeDone 훅: HTML 파일을 브라우저로 보낼때 일어난다. generate:before Nuxt.js hook HTML 파일들을 생성한다. Full static generation e.g. 정적 페이로드(static payloads)를 추출한다. generate:page (HTML 편집가능(editable)) generate:routeCreated (Route가 생성된다.) generate:done 훅: 모든 HTML 파일들이 생성될때 일어난다. Client여러분이 Nuxt.js의 어떤 모드를 선택하든, 이 부분은 라이프사이클 중에 완전히 브라우저에서 실행된다. HTML 파일을 받는다(Receives). assets 로딩하기 (e.g. JavaScript) Vue Hydration 미들웨어 (Middleware 또는 Route Middleware) 페이지 컴포넌트가 렌더링되기 전에 호출됩니다. 조건을 설정하거나 체크할수도 있으며 페이지를 리다이렉트(redirect)하는데 사용할 수 있습니다. 전역 미들웨어(Global middleware) - 모든 라우트에 영향을 끼치며, route.config.js에 정의합니다. 레이아웃 미들웨어(Layout middleware) - 라우트 그룹에 영향을 끼치며, layout에 정의합니다. 페이지 미들웨어(Page middleware) - 싱글 라우트에 영향을 끼치며, page component에 정의합니다. 클라이언트 사이드(client-side) Nuxt.js 플러그인 nuxt.config.js에 정의된 순서대로 (in order as defined in nuxt.config.js) asyncData (비동기, blocking) 페이지 컴포넌트가 로딩되기 전에 매번 호출됩니다. 컴포넌트 data 프로퍼티와 병합(merge)됩니다. beforeCreate (Vue 라이크사이클 메서드) Vue 인스턴트(instance)가 초기화(initialized) 될때 호출됩니다. created (Vue 라이크사이클 메서드) The new fetch (top to bottom, siblings = parallel) (동기, non-blocking) beforeMount (Vue 라이크사이클 메서드) mounted (Vue 라이크사이클 메서드) NuxtLink 컴포넌트(component)를 사용한 네비게이트(Navigate)클라이언트 사이드 부분과 동일하게 브라우저에서 모든것이 발생하지만 오직 &lt;NuxtLink&gt;를 통해 네비게이팅 될때만 발생합니다. &lt;NuxtLink&gt; 에 대한 더 자세한 정보는 컴포넌트 챕터에서 확인하세요 middleware (비동기, blocking) 전역 미들웨어(Global middleware) 레이아웃 미들웨어(Layout middleware) 라우트 미들웨어(Route middleware) asyncData (비동기, blocking) asyncData (비동기, blocking) [또는 완전히 정적 페이로드(static payload)가 로딩된 후] beforeCreate &amp; created (Vue 라이크사이클 메서드) fetch (동기, non-blocking) beforeMount &amp; mounted 중간 정리Nuxt의 라이프사이클은 전체적으로 서버와 클라이언트 사이드 부분으로 나뉘는 것을 알 수 있으며 각 부분에서 공통으로 실행되는 과정과 아닌 과정이 있음을 확인할 수 있었습니다. 또한, 정적 (Static) 어플리케이션를 만드느냐 SSR(Server-Side Rendering) 또는 유니버설(universal) 어플리케이션을 만드느냐에 따라 과정이 달라질 수 있다. 추가 공부라이프사이클에 대해 공부 및 정리하면서 봤던 내용들에 대해 정리해보자. 1. 활용도가 높고 중요한 몇가지 훅 middleware(클라이언트, 서버) 클라이언트와 서버 모두 훅들이 본격적으로 호출되기 전에, 앱을 만드는 과정에서 미리 정의해놓은 미들웨어들이 먼저 동작합니다. 만약 serverMiddlware을 정의했다면 서버 사이드에서만 렌더링 과정에서 일반 미들웨어가 동작하기 전에 먼저 동작합니다. asyncData(서버 or 클라이언트) 서버 혹은 클라이언트 사이드에서 생명주기 통틀어 한번씩만 호출되는 훅입니다. Vue 인스턴스의 생명주기 이전에 먼저 데이터를 가져와서 렌더링을 하고싶은 경우에 사용합니다. 컴포넌트를 로드하기 전에 항상 호출되며, 페이지 컴포넌트의 경우에만 사용할 수 있습니다. asyncData 의 리턴값은 Vue 인스턴스의 data()와 병합됩니다. beforeCreated, created(클라이언트, 서버) 서버에서 새로운 vue 인스턴스를 생성한 뒤 이를 프리랜더링 하기 때문에 Vue 인스턴스가 서버에서 만들어지는 시점에 created와 beforeCreated 훅이 호출됩니다. 또한 클라이언트에서도 인스턴스를 만들고 $mount 메소드가 호출될 때도 따라 호출됩니다. 즉 서버와 클라이언트 사이드 양쪽에서 호출되는 훅입니다. beforeMount 이후의 훅(클라이언트) 클라이언트 사이드에서만, 하이드레이션 이후에 $mount 메소드가 호출될 때 나머지 Vue 생명주기 훅들이 실행됩니다. 출처: 참조 1 2. Nuxt.js 비동기 데이터 Nuxt.js에는 비동기데이터 가져 오기를 위해 설계된 3가지 후크가 있다. nuxtServerInit : 모든 페이지에 호출되는 VueX 저장소를 미리 채우는 데 사용됩니다. fetch : 페이지 내에서 호출 된 데이터로 VueX 저장소를 미리 채우는 데 사용됩니다. asyncData : data 페이지의 객체와 동기 데이터를 병합하는데 사용된다. 비동기 방식으로 미들웨어를 사용할 수도 있습니다. 즉, 미들웨어를 사용하여 VueX 저장소를 채울 수 있습니다. asyncData 메소드서버사이드에서 데이터를 가져와서 렌더링하고 싶을 때, 이때 pages 컴포넌트를 로딩하기 전에 매번 호출되는 asyncData를 사용하면 된다. pages 컴포넌트에서만 지원됩니다. 서버사이드에서 호출되거나 페이지를 이동할 때 호출 컴포넌트가 렌더링 되기 전에 호출 context 인자 사용가능 nuxt.js가 컴포넌트와 데이터를 자동으로 Merge하는 개념 !! asyncData 안에서 컴포넌트가 생성되기 전에 호출하기 때문에 this를 엑세스할 수 없다. 12345678910111213141516&lt;script&gt;export default &#123; data () &#123; return &#123; title: &#39;&#39; &#125; &#125; asyncData (&#123; params &#125;) &#123; return axios.get(&#96;http:&#x2F;&#x2F;localhost:8080&#x2F;test&#x2F;1&#96;) .then((res) &#x3D;&gt; &#123; &#x2F;&#x2F; 여기서 this는 컴포넌트 생성 전이기에 &#39;undefined&#39; return this.title &#x3D; res.data &#125;) &#125;&#125;&lt;&#x2F;script&gt; 출처: 참조 2 3. asyncData()와 fetch() 두 개의 Hook은 매우 비슷해보이면서 목적은 다름 공통점: 컴포넌트가 로딩되기 전에 매번 호출된다는 점, 첫번째 인자로 컨텍스트 오브젝트를 받음 asyncData 페이지가 로딩되기전에 컴포넌트 data를 미리 지정하여 컴포넌트가 생성될 때 병합하는데에 목적 즉 필요한 컴포넌트의 data를 컴포넌트가 랜더링 되기 전에 미리 지정하여 보다 빠르게 구성한다는 데에 목적을 둠 fetch 주로 비동기 작업을 작성하게 되면, 컴포넌트가 랜더링 되기전에 이 작업을 기다리게 됨 예를들어 유저정보가 필요한 컴포넌트라면 fetch 부분에 유저정보를 가져오는 API를 호출하여 활용할 수 있음 요약하자면, asyncData는 컴포넌트가 랜더링 되기전에 컴포넌트 데이터를 구성하는데에 목적이 있고, fetch는 컴포넌트가 랜더링 되기전에 비동기로직을 호출하는데에 목적이 있다고 생각합니다! 출처: 참조 4 4. 잘 정리된 Nuxt Lifecucle Hooks 출처: 참조 5 참조 (1) 🌧 Nuxt로 살펴보는 서버사이드 렌더링의 핵심 (2) [Nuxt][완] 6. Nuxt.js로 SSR 확인 (3) Vue Server Side Rendering (4) Nuxt.js 에서 asyncData() 와 fetch() 은 차이는 무엇인가요? (5) [번역] Universal application code structure in Nuxt.js","categories":[{"name":"Programming","slug":"Programming","permalink":"https://joontae-kim.github.io/categories/Programming/"},{"name":"nuxt","slug":"Programming/nuxt","permalink":"https://joontae-kim.github.io/categories/Programming/nuxt/"}],"tags":[{"name":"vue.js","slug":"vue-js","permalink":"https://joontae-kim.github.io/tags/vue-js/"},{"name":"nuxt.js","slug":"nuxt-js","permalink":"https://joontae-kim.github.io/tags/nuxt-js/"},{"name":"vue","slug":"vue","permalink":"https://joontae-kim.github.io/tags/vue/"},{"name":"nuxt","slug":"nuxt","permalink":"https://joontae-kim.github.io/tags/nuxt/"},{"name":"lifecycle","slug":"lifecycle","permalink":"https://joontae-kim.github.io/tags/lifecycle/"},{"name":"nuxt lifecycle","slug":"nuxt-lifecycle","permalink":"https://joontae-kim.github.io/tags/nuxt-lifecycle/"}]},{"title":"Nuxt 디렉토리 구조","slug":"nuxt-directory-3","date":"2021-03-18T07:11:39.000Z","updated":"2021-03-18T07:22:59.075Z","comments":true,"path":"2021/03/18/nuxt-directory-3/","link":"","permalink":"https://joontae-kim.github.io/2021/03/18/nuxt-directory-3/","excerpt":"","text":"1.Nuxt 프로젝트 디렉토리막 생성된 nuxt 프로젝트의 디렉토리는 아래와 같다. 디렉토리에 대한 정의를 잘 몰라도 이미 Vue.js를 사용했던 개발자라면 비슷한 구조이며 스캐폴딩이 이미 되어있다는 생각이 들것이다. 각 디렉토리의 역할에 대해 알아보자. staticThe static directory is directly mapped to the server root and contains files that likely won’t be changed. All included files will be automatically served by Nuxt and are accessible through your project root URL. /static/robots.txt will be available at http://localhost:3000/robots.txt /static/favicon.ico will be available at http://localhost:3000/favicon.ico This option is helpful for files like robots.txt, sitemap.xml or CNAME (which is important for GitHub Pages deployment). This directory cannot be renamed without extra configuration. Static AssetsIf you don’t want to use Webpack assets from the assets directory, you can add the images to the static directory. In your code, you can then reference these files relative to the root (/): 12345&lt;!-- Static image from static directory --&gt;&lt;img src&#x3D;&quot;&#x2F;my-image.png&quot; &#x2F;&gt;&lt;!-- webpacked image from assets directory --&gt;&lt;img src&#x3D;&quot;~&#x2F;assets&#x2F;my-image-2.png&quot; &#x2F;&gt; Static Directory ConfigShould you need to you can configure the static/ directory behavior in the nuxt.config.js file. Static asset PrefixIf you deploy Nuxt.js to a subfolder, e.g. /blog/, the router base will be added to the static asset path by default. If you want to disable this behavior, you can set static.prefix to false in the nuxt.config.js. 12345export default &#123; static: &#123; prefix: false &#125;&#125; Default: /blog/my-image.pngWith static.prefix disabled: /my-image.png storeThe store directory contains your Vuex Store files. The Vuex Store comes with Nuxt.js out of the box but is disabled by default. Creating an index.js file in this directory enables the store. This directory cannot be renamed without extra configuration. Activate the StoreNuxt.js will look for the store directory. If it contains a file, that isn’t a hidden file or a README.md file, then the store will be activated. This means that Nuxt will: Import Vuex, Add the store option to the root Vue instance. ModulesEvery .js file inside the store directory is transformed as a namespaced module (index being the root module). Your state value should always be a function to avoid unwanted shared state on the server side. 1234567891011121314151617181920212223242526272829303132333435&lt;!-- store&#x2F;index.js --&gt;new Vuex.Store(&#123; state: () &#x3D;&gt; (&#123; counter: 0 &#125;), mutations: &#123; increment(state) &#123; state.counter++ &#125; &#125;, modules: &#123; todos: &#123; namespaced: true, state: () &#x3D;&gt; (&#123; list: [] &#125;), mutations: &#123; add(state, &#123; text &#125;) &#123; state.list.push(&#123; text, done: false &#125;) &#125;, remove(state, &#123; todo &#125;) &#123; state.list.splice(state.list.indexOf(todo), 1) &#125;, toggle(state, &#123; todo &#125;) &#123; todo.done &#x3D; !todo.done &#125; &#125; &#125; &#125;&#125;) And in your pages/todos.vue, using the todos module: 1234567891011121314151617181920212223242526272829303132333435363738&lt;!-- pages&#x2F;todos.vue --&gt;&lt;template&gt; &lt;ul&gt; &lt;li v-for&#x3D;&quot;todo in todos&quot; :key&#x3D;&quot;todo.text&quot;&gt; &lt;input :checked&#x3D;&quot;todo.done&quot; @change&#x3D;&quot;toggle(todo)&quot; type&#x3D;&quot;checkbox&quot;&gt; &lt;span :class&#x3D;&quot;&#123; done: todo.done &#125;&quot;&gt;&#123;&#123; todo.text &#125;&#125;&lt;&#x2F;span&gt; &lt;&#x2F;li&gt; &lt;li&gt;&lt;input @keyup.enter&#x3D;&quot;addTodo&quot; placeholder&#x3D;&quot;What needs to be done?&quot;&gt;&lt;&#x2F;li&gt; &lt;&#x2F;ul&gt;&lt;&#x2F;template&gt;&lt;script&gt;import &#123; mapMutations &#125; from &#39;vuex&#39;export default &#123; computed: &#123; todos () &#123; return this.$store.state.todos.list &#125; &#125;, methods: &#123; addTodo (e) &#123; this.$store.commit(&#39;todos&#x2F;add&#39;, e.target.value) e.target.value &#x3D; &#39;&#39; &#125;, ...mapMutations(&#123; toggle: &#39;todos&#x2F;toggle&#39; &#125;) &#125;&#125;&lt;&#x2F;script&gt;&lt;style&gt;.done &#123; text-decoration: line-through;&#125;&lt;&#x2F;style&gt; Example folder structureA complex store setup file/folder structure might look like this: 1234567891011121314store&#x2F;--| index.js--| ui.js--| shop&#x2F;----| cart&#x2F;------| actions.js------| getters.js------| mutations.js------| state.js----| products&#x2F;------| mutations.js------| state.js------| itemsGroup1&#x2F;--------| state.js nuxt.configBy default, Nuxt.js is configured to cover most use cases. This default configuration can be overwritten with the nuxt.config.js file. nuxt.config.jsaliasThis option lets you define aliases that will be available within your JavaScript and CSS. 12345678nuxt.config.jsimport &#123; resolve &#125; from &#39;path&#39;export default &#123; alias: &#123; &#39;style&#39;: resolve(__dirname, &#39;.&#x2F;assets&#x2F;style&#39;) &#125;&#125; cssThis option lets you define the CSS files, modules, and libraries you want to include globally (on every page). 123export default &#123; css: [&#39;~&#x2F;assets&#x2F;css&#x2F;main.css&#39;, &#39;~&#x2F;assets&#x2F;css&#x2F;animations.scss&#39;]&#125; envThis option lets you define environment variables that are required at build time (rather than runtime) such as NODE_ENV=staging or VERSION=1.2.3. However, for runtime environment variables runtimeConfig is required. 12345export default &#123; env: &#123; baseURL: process.env.BASE_URL &#125;&#125; More Configuration propertyRefer https://nuxtjs.org/docs/2.x/directory-structure/nuxt-config","categories":[{"name":"Programming","slug":"Programming","permalink":"https://joontae-kim.github.io/categories/Programming/"},{"name":"nuxt","slug":"Programming/nuxt","permalink":"https://joontae-kim.github.io/categories/Programming/nuxt/"}],"tags":[{"name":"vue.js","slug":"vue-js","permalink":"https://joontae-kim.github.io/tags/vue-js/"},{"name":"nuxt.js","slug":"nuxt-js","permalink":"https://joontae-kim.github.io/tags/nuxt-js/"},{"name":"vue","slug":"vue","permalink":"https://joontae-kim.github.io/tags/vue/"},{"name":"nuxt","slug":"nuxt","permalink":"https://joontae-kim.github.io/tags/nuxt/"}]},{"title":"Nuxt 디렉토리 구조","slug":"nuxt-directory-2","date":"2021-03-18T07:05:00.000Z","updated":"2021-04-18T17:11:05.420Z","comments":true,"path":"2021/03/18/nuxt-directory-2/","link":"","permalink":"https://joontae-kim.github.io/2021/03/18/nuxt-directory-2/","excerpt":"","text":"1.Nuxt 프로젝트 디렉토리막 생성된 nuxt 프로젝트의 디렉토리는 아래와 같다. 디렉토리에 대한 정의를 잘 몰라도 이미 Vue.js를 사용했던 개발자라면 비슷한 구조이며 스캐폴딩이 이미 되어있다는 생각이 들것이다. 각 디렉토리의 역할에 대해 알아보자. modules Nuxt Module은 Nuxt 프레임워크의 핵심 기능을 확장하고 통합 및 추가할 수 있다. 사용자가 직접 모듈을 작성할 수 있으며 Nuxt 커뮤니티에 이미 많은 모듈이 공개되어있다. The modules Property 모듈은 프레임워크의 핵심 기능을 확장하고 끝없는 통합을 추가할 수 있는 Nuxt.js 확장기능 이다. 모듈을 설치한 후에는 nuxt.config.js 파일의 모듈 속성 아래에 추가할 수 있습니다. 1234567891011121314151617&lt;!-- nuxt.config.js --&gt;export default &#123; modules: [ &#x2F;&#x2F; Using package name &#39;@nuxtjs&#x2F;axios&#39;, &#x2F;&#x2F; Relative to your project srcDir &#39;~&#x2F;modules&#x2F;awesome.js&#39;, &#x2F;&#x2F; Providing options [&#39;@nuxtjs&#x2F;google-analytics&#39;, &#123; ua: &#39;X1234567&#39; &#125;], &#x2F;&#x2F; Inline definition function () &#123;&#125; ]&#125; 모듈 개발자들은 보통 추가적으로 사용법에 대한 필요한 단계와 상세내역을 제공한다. Nuxt.js은 (the node_modules 내부) node require path를 사용해 모듈 배열에 각 아이템을 확인하려고 하고, 그 후 @ 명칭을 사용하면 srcDir 프로젝트로부터 확인할 것입니다. 모듈은 순서대로 실행되기 때문에 순서가 중요합니다. 모듈은 빌드/런타임을 향상시키기 위해 함수로 내보내야(export) 하고, 선택적으로 모듈의 작업이 끝날때까지 promise를 반환해야 합니다. 런타임에 가져오기 때문에 최신 ES6 기능을 사용한다면, 이미 변환(transpiled)되어있어야 합니다. pages pages 디렉토리는 어플리케이션의 views와 route를 포함합니다. Nuxt.js는 이 디렉토리 내부에 있는 모든 .vue 파일을 읽으며 자동으로 router 구성을 생성합니다. 또한, .js와 .ts 파일을 이용해 route를 생성할 수 있습니다. 모든 페이지 컴포넌트가 Vue 컴포넌트 이지만 가능한 쉽게 universal 어플리케이션의 개발을 할 수 있도록 Nuxt.js는 특별한 속성과 기능을 추가합니다. 123456789101112131415&lt;template&gt; &lt;h1 class&#x3D;&quot;red&quot;&gt;Hello &#123;&#123; name &#125;&#125;!&lt;&#x2F;h1&gt;&lt;&#x2F;template&gt;&lt;script&gt; export default &#123; &#x2F;&#x2F; page properties go here &#125;&lt;&#x2F;script&gt;&lt;style&gt; .red &#123; color: red; &#125;&lt;&#x2F;style&gt; Dynamic PagesDynamic pages can be created when you don’t know the name of the page due to it coming from an API or you don’t want to have to create the same page over and over again. To create a dynamic page you need to add an underscore before the .vue file name or before the the name of the directory, if you want the directory to be dynamic. You can name the file or directory anything you want but you must prefix it with an underscore. 동적 페이지는 API에서 가져온 페이지의 이름을 모르거나 동일한 페이지를 반복해서 만들 필요가 없을때 생성할 수 있습니다. 동적 페이지를 생성하기 위해서 .vue 언더스코어(underscore)를 추가하거나 디렉토리가 동적이길 원한다면 디렉토리의 이름 앞에 언더스코어(underscore)를 추가할 필요가 없습니다. 파일이나 디렉토리에 원하는 이름을 지을수 있지만 이름 뒤에 언더스코어(underscore)를 붙여야합니다. pages 폴더에 _slug.vue 라는 이름의 파일이 있다면 params.slug을 가진 컨텍스트(context)에서 값에 접근할 수 있다. 12345678910111213&lt;!-- pages&#x2F;_slug.vue --&gt;&lt;template&gt; &lt;h1&gt;&#123;&#123; this.slug &#125;&#125;&lt;&#x2F;h1&gt;&lt;&#x2F;template&gt;&lt;script&gt; export default &#123; async asyncData(&#123; params &#125;) &#123; const slug &#x3D; params.slug &#x2F;&#x2F; When calling &#x2F;abc the slug will be &quot;abc&quot; return &#123; slug &#125; &#125; &#125;&lt;&#x2F;script&gt; _book이라는 이름의 폴더에 _slug.vue라는 이름의 파일이 있다면 params.slug와 params.book을 가진 컨텍스트(context)에서 값에 접근할 수 있습니다. 1234567891011121314pages&#x2F;_book&#x2F;_slug.vue&lt;template&gt; &lt;h1&gt;&#123;&#123; this.book &#125;&#125; &#x2F; &#123;&#123; this.slug &#125;&#125;&lt;&#x2F;h1&gt;&lt;&#x2F;template&gt;&lt;script&gt; export default &#123; async asyncData(&#123; params &#125;) &#123; const book &#x3D; params.book const slug &#x3D; params.slug return &#123; book, slug &#125; &#125; &#125;&lt;&#x2F;script&gt; PropertiesasyncData asyncData는 컴포넌트가 로딩되기 전에 매번 호출되며 비동기로 인자로써 컨텍스트(context)를 받을 수 있습니다. 반환된 객체는 data object에 병합됩니다. 1234567&lt;!-- pages&#x2F;index.vue --&gt;export default &#123; asyncData(context) &#123; return &#123; name: &#39;World&#39; &#125; &#125;&#125; fetchEvery time you need to get asynchronous data you can use fetch. Fetch is called on server-side when rendering the route, and on client-side when navigating.비동기 데이터를 가져와야할 필요가 있다면 fetch를 사용할 수 있습니다. server-side에서는 route를 렌더링하기 전에 그리고 client-side에서는 네비게이팅될 때 Fetch가 호출됩니다. 1234567891011121314&lt;script&gt; export default &#123; data() &#123; return &#123; posts: [] &#125; &#125;, async fetch() &#123; this.posts &#x3D; await fetch(&#39;https:&#x2F;&#x2F;api.nuxtjs.dev&#x2F;posts&#39;).then(res &#x3D;&gt; res.json() ) &#125; &#125;&lt;&#x2F;script&gt; head12345export default &#123; head() &#123; &#x2F;&#x2F; Set Meta Tags for this Page &#125;&#125; layout 레이아웃 디렉토리에 정의된 레이아웃을 지정합니다. 12345&lt;!-- pages&#x2F;index.vue --&gt;export default &#123; layout: &#39;blog&#39;&#125; loadinghttps://nuxtjs.org/docs/2.x/directory-structure/pages#loading transitionhttps://nuxtjs.org/docs/2.x/directory-structure/pages#transition scrollToTophttps://nuxtjs.org/docs/2.x/directory-structure/pages#scrolltotop middlewarehttps://nuxtjs.org/docs/2.x/directory-structure/pages#middleware plugins plugins 디렉토리는 Vue.js 어플리케이션의 root에서 인스턴스화되기 전에 실행하려는 JavaScript 플러그인이 포함되어 있습니다. 이 디렉토리는 Vue 플러그인을 추가할수도 있으며 기능 또는 상수를 주입할 수도 있습니다. Vue.use()를 사용할 필요가 있을때마다 plugins/에 파일을 생성하고 nuxt.config.js에 플러그인의 경로를 설정해줘야 합니다. External Packages 서버와 클라이언트에서 HTTP 요청을 수행하기 위해 외부 패키지/모듈을 사용하고 싶을지도 모릅니다(한가지 큰 예가 axios 입니다). Install Package123yarn add @nuxtjs&#x2F;axios&#x2F;&#x2F; ornpm install @nuxtjs&#x2F;axios You can configure for example the axios interceptors to react on possible errors from your API calls across the application. In this example we redirect the user to a custom error page called sorry when we get a 500 status error from our API.예를 들, 어플리케이션 간에 API 요청에서 가능한 에러에 대응하기 위해 axios interceptors를 구성할 수도 있습니다. 이 예는 API에서 500 상태 에러를 받았을때 사용자를 sorry라고 부르는 커스텀 오류 페이지로 리다이렉트합니다. 12345678plugins&#x2F;axios.jsexport default function (&#123; $axios, redirect &#125;) &#123; $axios.onError(error &#x3D;&gt; &#123; if (error.response.status &#x3D;&#x3D;&#x3D; 500) &#123; redirect(&#39;&#x2F;sorry&#39;) &#125; &#125;)&#125; 마지막으로, 모듈과 새롭게 생성된 플러그인을 프로젝트 구성에 추가합니다. 12345nuxt.config.jsmodule.exports &#x3D; &#123; modules: [&#39;@nuxtjs&#x2F;axios&#39;], plugins: [&#39;~&#x2F;plugins&#x2F;axios.js&#39;]&#125; 그리고 나서 이 플러그인을 페이지 컴포넌트에 직접 사용할 수 있습니다: 123456789101112&lt;template&gt; &lt;h1&gt;&#123;&#123; post.title &#125;&#125;&lt;&#x2F;h1&gt;&lt;&#x2F;template&gt;&lt;script&gt;export default &#123; async asyncData (&#123; $axios, params &#125;) &#123; const post &#x3D; await $axios.$get(&#96;https:&#x2F;&#x2F;api.nuxtjs.dev&#x2F;posts&#x2F;$&#123;params.id&#125;&#96;) return &#123; post &#125; &#125;&#125;&lt;&#x2F;script&gt; 모듈을 설치하지 않고 axios를 사용하는 또다른 방법으로는 &lt;script&gt; 태그에 axios를 직접 부르는 것입니다. 1234567891011&lt;!-- pages&#x2F;index.vue --&gt;&lt;script&gt;import axios from &#39;axios&#39;export default &#123; async asyncData (&#123; params &#125;) &#123; const &#123; data: post &#125; &#x3D; await axios.get(&#96;https:&#x2F;&#x2F;api.nuxtjs.dev&#x2F;posts&#x2F;$&#123;params.id&#125;&#96;) return &#123; post &#125; &#125;&#125;&lt;&#x2F;script&gt; 만약 “Cannot use import statement outside a module“ 이라는 오류를 봤다면, 웹팩 로더에서 플러그인을 사용가능하도록 하기 위해 nuxt.config.js에 build &gt; transpile 옵션에서 패키지를 추가해야할지도 모릅니다. 12345nuxt.config.jsbuild: &#123; &#x2F;&#x2F; You can extend webpack config here transpile: [&#39;npm-package-name&#39;],&#125;, Vue Plugins application에서 tooltip을 보여주기 위해 v-tooltip와 같은 Vue 플러그인을 사용하기 원한다면 앱을 런칭하기 전에 플러그인을 설치해야 합니다. 첫번째로 플러그인을 설치합니다. 12345678910&lt;!-- install vue plugin --&gt;npm install v-tooltip&lt;!-- plugins&#x2F;vue-tooltip.js --&gt;import Vue from &#39;vue&#39;import VTooltip from &#39;v-tooltip&#39;Vue.use(VTooltip) The plugins Property 그리고 나서 nuxt.config.js의 플러그인 키안에 파일 경로를 추가합니다. 플러그인 속성을 사용하면 Vue.js 플러그인을 메인 어플리케이션에 쉽게 추가할 수 있습니다. 메인 어플리케이션이 초기화되기 전에 플러그인 속성에 정의된 모든 경로를 가져옵니다. 12345&lt;!-- nuxt.config.js --&gt;export default &#123; plugins: [&#39;~&#x2F;plugins&#x2F;vue-tooltip.js&#39;]&#125; ES6 Plugins 만약 플러그인이 node_modules에 위치해있고 ES6 모듈로 내보내진다면, transpile에서 빌드 옵션에 플러그인을 추가해줘야 합니다. 123456&lt;!-- nuxt.config.js --&gt;module.exports &#x3D; &#123; build: &#123; transpile: [&#39;vue-tooltip&#39;] &#125;&#125; 자세한 빌드 옵션은 빌드 구성사항 문서를 참고할 수 있습니다. ES6 Pluginshttps://nuxtjs.org/docs/2.x/directory-structure/plugins#es6-plugins Client or server side onlyhttps://nuxtjs.org/docs/2.x/directory-structure/plugins#client-or-server-side-only","categories":[{"name":"Programming","slug":"Programming","permalink":"https://joontae-kim.github.io/categories/Programming/"},{"name":"nuxt","slug":"Programming/nuxt","permalink":"https://joontae-kim.github.io/categories/Programming/nuxt/"}],"tags":[{"name":"vue.js","slug":"vue-js","permalink":"https://joontae-kim.github.io/tags/vue-js/"},{"name":"nuxt.js","slug":"nuxt-js","permalink":"https://joontae-kim.github.io/tags/nuxt-js/"},{"name":"vue","slug":"vue","permalink":"https://joontae-kim.github.io/tags/vue/"},{"name":"nuxt","slug":"nuxt","permalink":"https://joontae-kim.github.io/tags/nuxt/"}]},{"title":"Nuxt 디렉토리 구조","slug":"nuxt-directory","date":"2021-03-18T03:49:55.000Z","updated":"2021-04-18T10:14:41.619Z","comments":true,"path":"2021/03/18/nuxt-directory/","link":"","permalink":"https://joontae-kim.github.io/2021/03/18/nuxt-directory/","excerpt":"","text":"1.Nuxt 프로젝트 디렉토리막 생성된 nuxt 프로젝트의 디렉토리는 아래와 같다. 디렉토리에 대한 정의를 잘 몰라도 이미 Vue.js를 사용했던 개발자라면 비슷한 구조이며 스캐폴딩이 이미 되어있다는 생각이 들것이다. 각 디렉토리의 역할에 대해 알아보자. .nuxt .directory를 빌드 디렉토리라고 부르며 기본적으로 숨겨져 있고 동적으로 생성됩니다. nuxt dev를 사용했을땐 이 디렉토리에서 동적으로 생성된 파일들을 찾을 수 있으며 nuxt build를 사용하면 작업물들을 빌드할 수 있습니다. assets assets 디렉토리는 Stylus 또는 Sass files, images 또는 fonts 와 같은 컴파일된 애셋이 포함되어 있습니다. Images vue 템플릿 내부에는, 만약 assets을 링크해야 한다면, 슬래시(/)와 앞에 ~/assets/your_image.png와 같이 사용할 수 있습니다. 123&lt;template&gt; &lt;img src&#x3D;&quot;~&#x2F;assets&#x2F;your_image.png&quot; &#x2F;&gt;&lt;&#x2F;template&gt; css 파일에서 assets 디렉토리에 대한 참조가 필요하다면, 슬래시 없이 ~assets/your_image.png와 같이 사용할 수 있습니다. 1background: url(&#39;~assets&#x2F;banner.svg&#39;); Styles Nuxt.js를 사용하면 모든 페이지에서 포함된 전역으로 설정하기 원하는 CSS 파일/모듈/라이브러리를 정의할 수 있습니다. nuxt.config 에서 CSS 프로퍼티를 사용합으로써 스타일을 쉽게 추가할 수 있습니다. 12345678910export default &#123; css: [ &#x2F;&#x2F; Load a Node.js module directly (here it&#39;s a Sass file) &#39;bulma&#39;, &#x2F;&#x2F; CSS file in the project &#39;~&#x2F;assets&#x2F;css&#x2F;main.css&#39;, &#x2F;&#x2F; SCSS file in the project &#39;~&#x2F;assets&#x2F;css&#x2F;main.scss&#39; ]&#125; Fonts 여러분의 에셋 폴더에 로컬 폰트를 추가해 사용할 수 있습니다. 일단 폰트를 추가하면, 여러분은 @font-face를 사용해 css에서 폰트에 접근할 수 있습니다. 1234-| assets----| fonts------| DMSans-Regular.ttf------| DMSans-Bold.ttf 123456789101112131415@font-face &#123; font-family: &#39;DM Sans&#39;; font-style: normal; font-weight: 400; font-display: swap; src: url(&#39;~assets&#x2F;fonts&#x2F;DMSans-Regular.ttf&#39;) format(&#39;truetype&#39;);&#125;@font-face &#123; font-family: &#39;DM Sans&#39;; font-style: normal; font-weight: 700; font-display: swap; src: url(&#39;~assets&#x2F;fonts&#x2F;DMSans-Bold.ttf&#39;) format(&#39;truetype&#39;);&#125; components 컴포넌트 디렉토리는 Vue.js 컴포넌트들을 포함하고 있으며 컴포넌트들은 페이지의 서로 다른 부분을 구성할 것이고 페이지, 레이아웃 심지어 다른 컴포넌트안에서 불러지고, 재사용할 될 수 있습니다. Fetching Data 컴포넌트에서 API에 동적으로 데이터를 접근하기 위해서 Nuxt의 fetch() hook을 사용할 수 있습니다. $fetchState.pending을 확인함으로써, 데이터가 로드될 때까지 기다리고 있을때 메시지를 표시할 수 있다. 또한, 데이터를 가져오는데 오류가 있을 경우 $fetchState.error를 확인해 오류 메시지를 표시할 수 있습니다. fetch()을 사용하면 data()에서 적절한 프로퍼티에 선언해야 합니다. fetch로부터 받은 데이터는 이러한 속성들에 선언할 수 있습니다. 12345678910111213141516171819202122232425&lt;template&gt; &lt;div&gt; &lt;p v-if&#x3D;&quot;$fetchState.pending&quot;&gt;Loading....&lt;&#x2F;p&gt; &lt;p v-else-if&#x3D;&quot;$fetchState.error&quot;&gt;Error while fetching mountains&lt;&#x2F;p&gt; &lt;ul v-else&gt; &lt;li v-for&#x3D;&quot;(mountain, index) in mountains&quot; :key&#x3D;&quot;index&quot;&gt; &#123;&#123; mountain.title &#125;&#125; &lt;&#x2F;li&gt; &lt;&#x2F;ul&gt; &lt;&#x2F;div&gt;&lt;&#x2F;template&gt;&lt;script&gt; export default &#123; data() &#123; return &#123; mountains: [] &#125; &#125;, async fetch() &#123; this.mountains &#x3D; await fetch( &#39;https:&#x2F;&#x2F;api.nuxtjs.dev&#x2F;mountains&#39; ).then(res &#x3D;&gt; res.json()) &#125; &#125;&lt;&#x2F;script&gt; content content/ 디렉토리에 작성한 @nuxtjs/content 모듈은 Nuxt.js 어플리케이션을 강력하게 만들수 있으며 Git-based Headless CMS 와 같은 역할을 하는 MongoDB와 같은 API를 통해 Markdown, JSON, YAML and CSV 파일들을 불러옵니다. dist 배포 폴더를 간추려 dist 폴더라고 하며 nuxt generate 명령어를 사용해 동적으로 생성하고, 생성된 프로덕션에 준비된 HTML 파일들과 배포하기 위해 필수적인 에셋들이 포함되고, 전략적으로 생성한 Nuxt.js 어플리케이션이 작동합니다. layouts 사이드바 또는 모바일이나 데스크톱에 대한 구별된 레이아웃을 원할 경우 레이아웃은 Nuxt.js 앱의 느낌과 외형을 변경하려고 할때 큰 도움이 됩니다. 이 디렉토리는 추가 설졍없이 이름을 재설정할 수 없습니다. Default Layout layouts/default.vue 파일을 추가하면 메인 레이아웃을 확장할 수 있으며 특정 레이아웃을 가지고 있지 않은 모든 페이지에서 사용할 수 있습니다. 실제로 페이지 컴포넌트에 포함하도록 생성한 레이아웃을 생성할때 &lt;Nuxt&gt; 컴포넌트를 추가해야 합니다. 레이아웃에서 필요한 것은 페이지 컴포넌트를 렌더링 할 세줄의 코드입니다. 1234&lt;!-- layouts&#x2F;default.vue --&gt;&lt;template&gt; &lt;Nuxt &#x2F;&gt;&lt;&#x2F;template&gt; 네비게이션, 헤너, 푸터 등과 같은 더 많은 컴포넌트들을 추가할 수 있습니다. 12345678&lt;!-- layouts&#x2F;default.vue --&gt;&lt;template&gt; &lt;div&gt; &lt;TheHeader &#x2F;&gt; &lt;Nuxt &#x2F;&gt; &lt;TheFooter &#x2F;&gt; &lt;&#x2F;div&gt;&lt;&#x2F;template&gt; 만약 components에 true를 설정하면 컴포넌트를 위한 그 어떠한 import 구분도 필요하지 않습니다. Custom Layout layouts 디렉토리의 (top-level의) 모든 파일은 페이지 컴포넌트에서 레이아웃 속성에 접근 가능한 커스텀 레이아웃을 만듭니다. 블로그 레이아웃을 생성하기 위해 layouts/blog.vue에 아래의 코드를 저장합니다. 123456&lt;template&gt; &lt;div&gt; &lt;div&gt;My blog navigation bar here&lt;&#x2F;div&gt; &lt;Nuxt &#x2F;&gt; &lt;&#x2F;div&gt;&lt;&#x2F;template&gt; 그리고나서 페이지에서 아래와 같이 여러분의 커스텀 레이아웃을 설정해야 합니다. 123456789&lt;script&gt;export default &#123; layout: &#39;blog&#39;, &#x2F;&#x2F; OR layout (context) &#123; return &#39;blog&#39; &#125;&#125;&lt;&#x2F;script&gt; middleware middleware 디렉토리는 어플리케이션 미들웨어를 포함하며 페이지 하나 또는 페이지 그룹 또는 레이아웃리 렌더링되기 전에 작동할 수 있는 커스텀 함수들을 정의할 수 있습니다. 공유된 middleware는 middleware/ 디렉토리에 배치해야 하며 파일이름은 미들웨어의 이름이 될 것 입니다(middleware/auth.js는 auth 미들웨어가 됩니다). 또한 페이지 특정 미들웨어는 직접 함수로 사용할 수 있습니다.anonymous middleware를 참고하세요. 미들웨어는 첫번째 인자로 the context 를 받습니다. 123456export default function (context) &#123; &#x2F;&#x2F; Add the userAgent property to the context context.userAgent &#x3D; process.server ? context.req.headers[&#39;user-agent&#39;] : navigator.userAgent&#125; universal 모드에서 미들웨어는 (예를 들어 앱에 바로 접속하거나 페이지를 새로고침할때, Nuxt 어플리케이션에서 처음 요청할때) 서버사이드에서 그리고 다른 라우트로 네이게이팅될때 클라이언트 사이드에서 단 한번만 호출됩니다. ssr: false를 설정하면, 미들웨어는 두 가지 상황에서 클라이언트 사이드에서만 호출됩니다. 미들웨어는 아래의 순서대로 실행됩니다. nuxt.config.js (파일 내부 순서대로) 매칭된 레이아웃 매칭된 페이지 Router Middleware 미들웨어는 비동기적일 수 있으며 이를 위해 Promise를 반환하거나 async/await를 사용해야합니다. 123456789&lt;!-- middleware&#x2F;stats.js --&gt;import http from &#39;http&#39;export default function (&#123; route &#125;) &#123; return http.post(&#39;http:&#x2F;&#x2F;my-stats-api.com&#39;, &#123; url: route.fullPath &#125;)&#125; 그러고나서 nuxt.config.js에서 router.middleware key를 사용해야 합니다. 1234567&lt;!-- nuxt.config.js --&gt;export default &#123; router: &#123; middleware: &#39;stats&#39; &#125;&#125; 이제 모든 라우트 변경에 대해 stats 미들웨어가 호출됩니다. 또한 특정 레이아웃 또는 페이지에 대한 (복수의) 미들웨어를 추가할 수 있습니다. 1234&lt;!-- pages&#x2F;index.vue &#x2F; layouts&#x2F;default.vue --&gt;export default &#123; middleware: [&#39;auth&#39;, &#39;stats&#39;]&#125; Named middleware middleware/ 디렉토리 내부에 파일을 생성함으로써 named 디렉토리를 생성할 수 있으며 미들웨어 이름이 될 것입니다. 12345678&lt;!-- middleware&#x2F;authenticated.js --&gt;export default function (&#123; store, redirect &#125;) &#123; &#x2F;&#x2F; If the user is not authenticated if (!store.state.authenticated) &#123; return redirect(&#39;&#x2F;login&#39;) &#125;&#125; 1234567891011&lt;!-- pages&#x2F;secret.vue --&gt;&lt;template&gt; &lt;h1&gt;Secret page&lt;&#x2F;h1&gt;&lt;&#x2F;template&gt;&lt;script&gt; export default &#123; middleware: &#39;authenticated&#39; &#125;&lt;&#x2F;script&gt; Anonymous middleware 만약 오직 특정 페이지만을 위한 미들웨어를 사용하고자 한다면 직접 함수(또는 함수 배열)를 사용할 수 있습니다. 12345678910111213141516&lt;!-- pages&#x2F;secret.vue --&gt;&lt;template&gt; &lt;h1&gt;Secret page&lt;&#x2F;h1&gt;&lt;&#x2F;template&gt;&lt;script&gt; export default &#123; middleware(&#123; store, redirect &#125;) &#123; &#x2F;&#x2F; If the user is not authenticated if (!store.state.authenticated) &#123; return redirect(&#39;&#x2F;login&#39;) &#125; &#125; &#125;&lt;&#x2F;script&gt;","categories":[{"name":"Programming","slug":"Programming","permalink":"https://joontae-kim.github.io/categories/Programming/"},{"name":"nuxt","slug":"Programming/nuxt","permalink":"https://joontae-kim.github.io/categories/Programming/nuxt/"}],"tags":[{"name":"vue.js","slug":"vue-js","permalink":"https://joontae-kim.github.io/tags/vue-js/"},{"name":"nuxt.js","slug":"nuxt-js","permalink":"https://joontae-kim.github.io/tags/nuxt-js/"},{"name":"vue","slug":"vue","permalink":"https://joontae-kim.github.io/tags/vue/"},{"name":"nuxt","slug":"nuxt","permalink":"https://joontae-kim.github.io/tags/nuxt/"}]},{"title":"nuxt.js - 시작하기","slug":"nuxt-intro","date":"2021-03-17T17:08:33.000Z","updated":"2021-03-18T04:00:50.336Z","comments":true,"path":"2021/03/18/nuxt-intro/","link":"","permalink":"https://joontae-kim.github.io/2021/03/18/nuxt-intro/","excerpt":"","text":"포트폴리오용 nuxt 앱이 필요했던 참에 신규 프로젝트에서 nuxt로 어플리케이션을 제작해야해서 정리 및 공부겸 포스팅을 하기로 했다. 1.Nuxt란?Nuxt란 NuxtJS를 사용하여 신뢰 있는 Vue.js 애플리케이션을 구축하세요. 웹 개발을 간단하고 강력하게 만드는 오픈 소스 프레임워크로 서버 사이드 렌더링 (SSR)과 정적 사이트 생성을 지원해준다. 1) 소개Nuxt.js의 소개를 본다면 이렇게 명시하고 있다. 주요 범위는 UI Rendering이며, 클라이언트/서버 배포를 추상화한다. Nuxt.js의 목표는 기본 프로젝트 베이스로 사용할 수 있으며 Node.js 기반의 프로젝트를 유연하게 사용할 수 있는 프레임 워크를 만드는 것이다. Nuxt.js는 서버 사이드 렌더링 된 Vue.js 응용 프로그램의 개발을 위해 이에 필요한 모든 구성을 사전 설정한다. Nuxt.js는 nuxt generate 라는 배포 옵션을 제공한다. nuxt gererate를 통해 vue.js를 정적인 응용 프로그램으로 빌드한다. - 우리는 이 옵션이 마이크로 서비스가 있는 웹 응용 프로그램 개발의 다음 단계일 수 있다고 생각한다. Nuxt.js는 단일 응용 페이지(SPA)를 신속하게 만들 수 있다. Nuxt.js는 비동기 데이터, 미들웨어, 레이아웃 등과 같이 클라이언트 측과 서버 측 사이에서 개발하는 데 도움이 되는 많은 기능을 제공한다. Nuxt.js 설치만으로 이미 scaffolding(프로젝트 구조화)을 해주므로 딱히 프로젝트 구조에 대해서 고민할 필요가 없다. Vue.js 하나하나 잡아줘야 할 라우팅을 Nuxt.js에서 파일을 생성하는 것만으로 라우팅을 자동으로 생성해 준다. layout, store, middleware와 같은 요소들을 이미 구분을 지어주고 필요한 항목들을 처리해주기 때문에 순전히 개발에만 집중하면 된다. Server-Side-Rendering에 필요한 요소가 이미 준비가 되어있다. webpack을 통한 빌드 시스템이 이미 구현되어 있다. 그저 npm run만 해주면 된다. 2) 특징 Vue 파일 작성 코드 분할 자동화 서버사이드 렌더링 강력한 비동기 데이터 기반 라우팅 시스템 정적 파일 전송 ES6/ES7 지원 JS &amp; CSS 코드 번들링 및 압축 html의 head 태그 관리 Hot reloading의 지원 SASS, LESS, Stylus 등의 전처리기 지원 일단 위 소개만 보면 안 쓸 이유가 없다.2.Nuxt 시작하기Nuxt 기반의 application을 생성하기 위해서는 Vue CLI가 설치되어 있어야 한다. 1) 프로젝트 생성프로젝트 생성에는 총 3가지 방법이 있습니다. vue-cli를 통한 nuxt.js 설치12345678910111213&lt;!-- vue cli 설치 --&gt;npm i -g @vue&#x2F;clinpm i -g @vue&#x2F;cli-init&lt;!-- nuxt 프로젝트 생성 및 의존성 모듈 설치 --&gt;vue init nuxt-community&#x2F;starter-template &lt;project-name&gt;cd &lt;project-name&gt;npm i&lt;!-- 패키지 매니저를 통한 nuxt 프로젝트 생성 --&gt;npx create-nuxt-app &lt;project-name&gt; yarn create nuxt-app &lt;project-name&gt;npm init nuxt-app &lt;project-name&gt; 저는 vue-cli가 이미 설치된 환경에서 작업하고 있으므로 npx 패키지 매니저를 통해 nuxt application을 생성해보겠습니다. 1npx create-nuxt-app [프로젝트명] 2) 프로젝트 설정123456789101112131415161718192021222324252627282930313233343536373839404142434445464748? Project name: [프로젝트명]? Programming language:&gt; JavaScript TypeScript? Package manager: Yarn&gt; Npm? UI framework:&gt; None Ant Design Vue Bootstrap Vue Buefy Bulma Element Framevuerk iView Tachyons Tailwind CSS Vuesax Vuetify.js? Nuxt.js modules:? Choose custom server framework &lt;None (Recommended)&gt;&gt; None (Recommended) AdonisJs Express Fastify Feathers hapi Koa Micro? Linting tools:(*) ESLint( ) Prettier( ) Lint staged files( ) StyleLint? Testing framework: None&gt; Jest AVA? Rendering mode: Universal (SSR &#x2F; SSG)&gt; Universal (SSR) Single Page App? Deployment target: Server (Node.js hosting)? Development tools: (Press &lt;space&gt; to select, &lt;a&gt; to toggle all, &lt;i&gt; to invert selection)? Continuous integration: None? Version control system:&gt; Git None 3) 프로젝트 실행123456789101112131415161718Successfully created project [프로젝트명] To get started: cd [디렉토리명] npm run dev To build &amp; start for production: cd [디렉토리명] npm run build npm run start To test: cd [디렉토리명] npm run testcd [디렉토리명] &amp;&amp; npm run dev 4) 프로젝트 생성 디렉토리막 생성된 nuxt 프로젝트의 디렉토리는 아래와 같다. 디렉토리에 대한 정의를 잘 몰라도 이미 Vue.js를 사용했던 개발자라면 비슷한 구조이며 스캐폴딩이 이미 되어있다는 생각이 들것이다. 여기까지 nuxt 프로젝트의 생성과 막 생성된 디렉토리까지 살펴봤습니다. 다음 포스트에서는 프로젝트의 디렉토리에 대해 살펴보겠습니다. 참조 Installation - Official NuxtJS [Nuxt.js] 개념부터 설치까지 빠르게 배우기 12.[Nuxt.js] 프로젝트, 설정, 라우팅 Nuxt로 알아보는 SPA, SSR 그리고 Static Web Free Nuxt.js Tutorial — Vue Mastery Course","categories":[{"name":"Programming","slug":"Programming","permalink":"https://joontae-kim.github.io/categories/Programming/"},{"name":"nuxt","slug":"Programming/nuxt","permalink":"https://joontae-kim.github.io/categories/Programming/nuxt/"}],"tags":[{"name":"vue.js","slug":"vue-js","permalink":"https://joontae-kim.github.io/tags/vue-js/"},{"name":"nuxt.js","slug":"nuxt-js","permalink":"https://joontae-kim.github.io/tags/nuxt-js/"},{"name":"vue","slug":"vue","permalink":"https://joontae-kim.github.io/tags/vue/"},{"name":"nuxt","slug":"nuxt","permalink":"https://joontae-kim.github.io/tags/nuxt/"}]},{"title":"서버 사이드 렌더링과 클라이언트 사이드 렌더링","slug":"scrssr","date":"2021-03-17T13:49:29.000Z","updated":"2021-09-30T10:49:55.510Z","comments":true,"path":"2021/03/17/scrssr/","link":"","permalink":"https://joontae-kim.github.io/2021/03/17/scrssr/","excerpt":"","text":"이번 포스팅은 Vue.js &amp; Nuxt.js를 하기 전에 서버사이드 렌더링과 클라이언트 사이트 렌더링에 대해 짧게나마 정리해보는 것이 필요하다고 생각되서 쓰게 되었다. 1. SSR과 CSR의 MVC 패턴SSR과 CSR은 HTLM 페이지 렌더링 방식으로 아래의 이미지처럼 Rendering을 어디서 하냐에 따라 Server-Side 또는 Client-Side로 구분된다. (그 외에 Rehydration, Prerendering 방식이 있긴한데 여기선 생략 - 참고 - developers.google.com의 웹 렌더링 포스팅) Server-Side MVC 패턴의 경우, Rendering 및 HTML Serving을 위한 View와 Controller가 Server에서 처리하지만 Client-side MVC 패턴의 경우에는 서버로부터 서비스 진입 초기에 HTML 파일 + JS 파일 및 리소스 파일 등을 모두 다운 받은후 Client에서 직접 Controller와 View를 담당한다. 2. SSR (Server-Side Rendering, 서버 측 렌더링) SSR의 위 순서를 이해해보자. 사용자가 웹사이트를 요청한다. 서버가 “렌더링 하기 위한(Ready to Render)” HTML 파일(들)을 만든다. 브라우저가 HTML 파일을 빠르게 렌더링 할 수 있지만, 사이트는 아직 상호작용(interactive)할 수 없다. 브라우저가 Javascript를 다운로드한다. 사용자가 컨텐츠를 볼 수 있으며 상호작용(interactions)이 기록된다. 브라우저가 JS 프레임워크를 실행한다. 기록된 상호작용(들)이 실행될 수 있고, 페이지가 상호작용(interactive)한다. 3. CSR (Client-Side Rendering, 클라이언트 측 렌더링)CSR의 위 순서를 이해해보자. 사용자가 웹사이트를 요청한다. CDN이 빠르게 JS가 연결된 링크와 함께 HTML 파일(들)을 제공한다. 브라우저가 HTML 파일을 다운로드 한 후, JS를 다운로드 한다. 그동안, 사용자는 사이트를 볼 수 없다. 브라우저는 Javascript를 다운로드 한다. JS가 실행되고 API가 데이터를 요청하는 동안 사용자는 placeholder를 본다. 서버가 API에 대한 응답으로 데이터를 제공한다. API 응답으로 온 데이터는 placeholder를 채우고, 페이지가 상호작용(interactive)한다. 4. SSR과 CSR의 성능SSR과 CSR의 Rendering 순서에는 확연히 차이가 존재하며 이에 따라 성능에서도 차이가 존재한다. 아래 목록은 브라우저 렌더링에 있어서 어떤 장단점이 있는지 설명하는데 도움이 되며 또한 렌더링 방식에 따른 최적화를 하는데에도 도움이 되는 지표들이다. TTFB (Time to First Byte): (첫 번째 바이트까지의 시간) - 링크를 클릭한 시점부터 처음으로 콘텐츠의 바이트가 들어오는 시간차 FP (First Paint): 픽셀이 처음으로 사용자에게 표시되는 시점 FCP (First Contentful Paint): 요청 콘텐츠(기사(article) 본문 등)가 표시되는 시점 TTI (Time to Interactive): 페이지가 상호작용 가능하게 될 때까지의 시간 (이벤트 발생 등). 1) SSR Performance 기본적으로 서버 사이드 렌더링은 브라우저에서 응답을 받기 전에 처리되므로 클라이언트에서 데이터 요청 및 템플릿 작성을 위한 추가 요청작업이 발생하지 않아 First Paint 및 First Contentful Paint가 빠르게 생성되며 서버에서 페이지 로직 및 렌더링을 실행하면 많은 JS를 클라이언트에 보내지 않아도 되므로 Time to Interactive를 빠르게 수행할 수 있다. 2) CSR Performance 기본적으로 클라이언트 사이드 렌더링은 JS를 사용해 브라우저에서 페이지를 직접 렌더링 하는 방식으로 가장 처음에 언급한 CSR의 MVC 패턴 을 보면 렌더링 구조를 이해할 수 있다. 서버 사이드에 해당 웹사이트에 대한 자원을 요청하면, 프론트엔드에 대한 bundle.js 또는 app.js와 index.html을 다운받고 번들링 파일을 브라우저의 JS Parser에서 분석한 다음, controller에 해당하는 router 의 정보에 따라 html을 동적으로 생성하는 동시에 사용자에게 보여줄 데이터를 동적으로 요청 및 view 처리해줌에 따라 First Paint 및 First Contentful Paint가 SSR 렌더링 방식보다 오래 걸리며 TTI 또한 오래 걸린다는 단점이 있다. 그럼 왜? CSR 렌더링 방식을 쓰지???바로 웹사이트 초기 진입시의 FCP 및 TTI가 오래 걸릴뿐이지 그 다음부터는 CSR의 구조 특성상 페이지 이동에 따라 html 파일을 서버에서 reqeust 하는 것이 아닌 클라이언트 단에서 control하며 필요한 데이터면 request하면 되기 때문에 페이지 이동간의 FCP 및 TTI는 SSR보다 좋은 성능을 보인다. 그리고 lazy loading 또는 code splitting을 한다면 페이지별로 필요한 Javascript와 그 외 리소스만 불러올 수 있어서 초기 Rendering 속도를 개선해볼수 있는 가능성도 있다. 5) 정리정리하자면 각 장단점 또는 차이는 아래와 같으며, 두 렌더링 방식 중 각 어플리케이션의 구조 또는 서비스 페이지의 특징에 따라 적절히 사용하는 것이 중요하다.대표적으로, 초기 View 로딩 속도, SEO 문제, 보안 문제가 있다. SSR CSR 초기 View 로딩 속도 CSR에 비해 렌더링 해야하는 파일이 적어 초기 View 로딩 속도가 빠름. 브라우저에서 페이지를 직접 렌더링해야 하므로 초기에는 오래 걸림. SEO 페이지에 대한 meta 정보가 렌더링시 이미 포함되어 있기 때문에 크롤러봇에서 데이터를 수집해가는데 용이함. 렌더링시 JS 파싱, 로딩 및 실행 순서 때문에 크롤러봇이 데이터를 수집하는데 어려움이 있음. 보안 문제 사용자에 대한 정보를 서버측에서 Session으로 관리 사용자에 대한 정보를 LocalStorage나 Cookie에서 관리해 XSS 공격에 취약함 SSR 방식의 경우, 초기 로딩속도가 빠르고, SEO 측면에서 유리하지만 View 변경시 서버에 계속 새로운 HTML 파일을 요청해야 하므로 서버에 부담이 큼 CSR 방식의 경우, 초기 로딩속도는 느리지만 그 다음 페이지 이동 및 처리에 있어 필요한 데이터만 요청하면 되므로 서버에 부담이 적고, 빠르게 처리할 수 있으나 SEO 측면에서 Google 크롤러봇을 제외하곤 Javascript를 실행시키지 못해 데이터 수집하는데 어려움이 있음 참조 웹 렌더링 11. 서버사이트 렌더링, 클라이언트 사이드 렌더링 서버사이트 렌더링 그리고 클라이언트 사이드 렌더링 CSR, SSR 서버 사이드 렌더링(SSR)과 클라이언트 사이드 렌더링(CSR) SPA에서의 SSR과 CSR","categories":[{"name":"Study","slug":"Study","permalink":"https://joontae-kim.github.io/categories/Study/"},{"name":"Rendering","slug":"Study/Rendering","permalink":"https://joontae-kim.github.io/categories/Study/Rendering/"}],"tags":[{"name":"Rendering","slug":"Rendering","permalink":"https://joontae-kim.github.io/tags/Rendering/"},{"name":"CSR","slug":"CSR","permalink":"https://joontae-kim.github.io/tags/CSR/"},{"name":"SSR","slug":"SSR","permalink":"https://joontae-kim.github.io/tags/SSR/"},{"name":"Client Side Rendering","slug":"Client-Side-Rendering","permalink":"https://joontae-kim.github.io/tags/Client-Side-Rendering/"},{"name":"Server Side Rendering","slug":"Server-Side-Rendering","permalink":"https://joontae-kim.github.io/tags/Server-Side-Rendering/"}]},{"title":"Webpack에서 asset 압축 설정하기","slug":"webpack-compression-plugin","date":"2020-12-02T18:55:44.000Z","updated":"2021-09-30T10:52:11.743Z","comments":true,"path":"2020/12/03/webpack-compression-plugin/","link":"","permalink":"https://joontae-kim.github.io/2020/12/03/webpack-compression-plugin/","excerpt":"","text":"최근 진행하고 있는 외주 프로젝트에서 이미지 및 js, css 관련 최적화 과정 진행 중 webpack의 압축 관련 설정을 살펴보던 중 참고할만한 링크들을 찾았다. 공식 링크 https://webpack.js.org/plugins/compression-webpack-plugin/ https://github.com/webpack-contrib/compression-webpack-plugin webpack3 버전 compressions-wepack-plugin https://webpack-3.cdn.bcebos.com/plugins/compression-webpack-plugin/ js module for image compression https://www.npmjs.com/package/browser-image-compression demo: https://donaldcwl.github.io/browser-image-compression/example/basic.html webpack plugin for image compression https://github.com/tcoopman/image-webpack-loader#readme https://github.com/Klathmon/imagemin-webpack-plugin#readme blog https://web.dev/use-imagemin-to-compress-images/ https://coderrocketfuel.com/article/compress-a-png-image-size-by-up-to-75-percent-with-node-js webpack loader for image trace https://github.com/EmilTholin/image-trace-loader#readme","categories":[{"name":"Study","slug":"Study","permalink":"https://joontae-kim.github.io/categories/Study/"},{"name":"Webpack","slug":"Study/Webpack","permalink":"https://joontae-kim.github.io/categories/Study/Webpack/"}],"tags":[{"name":"webpack","slug":"webpack","permalink":"https://joontae-kim.github.io/tags/webpack/"},{"name":"CompressionWebpackPlugin","slug":"CompressionWebpackPlugin","permalink":"https://joontae-kim.github.io/tags/CompressionWebpackPlugin/"},{"name":"compression","slug":"compression","permalink":"https://joontae-kim.github.io/tags/compression/"},{"name":"asset","slug":"asset","permalink":"https://joontae-kim.github.io/tags/asset/"},{"name":"image","slug":"image","permalink":"https://joontae-kim.github.io/tags/image/"}]},{"title":"Javascript와 객체 지향 프로그래밍","slug":"js-oop-2","date":"2020-11-02T12:10:12.000Z","updated":"2021-08-05T08:40:26.644Z","comments":true,"path":"2020/11/02/js-oop-2/","link":"","permalink":"https://joontae-kim.github.io/2020/11/02/js-oop-2/","excerpt":"","text":"지난 포스트인 Javascript와 객체 지향 프로그래밍 - 절차 지향 프로그래밍 &amp; 객체 지향 프로그래밍 편에서 Javascript의 객체 지향에 대해 공부하면서 느꼈던 어려움과 절차지향과 객체지향에 대해 정리를 해보았습니다. 이번 포스트에서는 객체지향 프로그래밍이란 무엇인지 공부해보겠습니다. 객체 지향 프로그래밍 이란이전 포스트에서 언급했듯이 객체 지향 프로그래밍이란 “누가 어떤 일을 할 것인가” 를 중심으로 구현된 프로그래밍 패러다임으로써, 다음과 같이 정리해볼수 있을거 같습니다. 현실 세계의 개체를 기계의 부품처럼 하나의 객체로 만들어, 기계적인 부품들을 조립하여 제품을 만들듯이 소프트웨어를 개발할 때에도 객체들을 조립해서 작성할 수 있도록 하는 기법이다. 객체 지향의 “객체”는 현실 세계의 사물을 나타내는데 각 객체는 자신의 정보를 가지고 있는 독립적인 개체(Entity)로써 각각의 성격을 띄고 있으며 이 객체가 유기적으로 상호작용 하여 작게는 하나의 기능, 크게는 하나의 어플리케이션을 프로그래밍 하는 방법이다. 그렇다면 객체 지향 프로그래밍의 “객체”의 기본 구성 요소는 무엇일까? 기본 구성요소위에서 언급했듯이 OOP의 객체(object)는 현실 세계의 사물을 나타낸다고 했다. 즉, 현실 세계의 사물은 각각의 동작(기능)과 상태를 가지고 있으며 여러 동작은 유기적으로 움직이며 상호간 침범하지 않도록 또는 방해되지 않도록 설계되어 있다고 설명할 수 있다. 대표적인 예로 사람 이다. OOP의 기본 구성요소를 설명하기 전에 현실 세계의 사물을 먼저 정의한 이유는 OOP의 기본 구성요소 또한 같기 때문이다. 1) 클래스 (class)클래스란 1개 이상의 유사 객체의 공통된 특성(속성과 메서드)을 데이터 추상화 과정을 통해 구현한 하나의 틀(template)로써, 객체지향 프로그램의 기본적인 사용자 정의 데이터형(user defined data type)이라고 할 수 있다. 다른 클래스 또는 외부 요소와 독립적으로 디자인하여야 한다. 클래스에 의해 생성된 새로운 객체(object)를 클래스의 인스턴스라 하며, 클래스로부터 새로운 객체를 생성하는 것을 인스턴스화 라고 한다. 최상위 클래스 또는 메타 클래스는 상위 클래스를 갖지 않는 유일한 클래스로 클래스 계층 트리의 최상단에 위치하는 클래스이며, 슈퍼 클래스는 특정 클래스의 상위 클래스이고, 서브 클래스는 특정 클래스의 하위 클래스이다. 2) 객체 (object)클래스의 인스턴스를 객체(object)라고 하며 필요한 속성(Attribute)과 속성을 처리하기 위한 메서드(Method)를 가진 하나의 소프트웨어 모듈이며 다른 객체들과 구별될 수 있는 이름이 있고, 실제 메모리상에 할당된 것으로 실제 프로그램에서 사용되는 데이터이다. 속성(Attribute) 객체가 가지고 있는 정보 또는 상태를 나타내며 객체의 속성, 데이터, 변수, 상수 또는 자료구조라고도 부른다. 메서드(Method) 객체가 가진 기능으로 객체의 속성을 처리하는 하나의 알고리즘이다. 객체가 메시지를 받아 실행해야 할 객체의 구체적인 연산을 정의한 것, 전통적 시스템의 함수(Function)나 프로시저(Procedure)에 해당하는 연산 기능을 수행한다. 메소드는 다른 객체로부터 메시지를 받았을 때 수행하게 된다. 3) 메시지 (message)메시지는 객체 간의 상호작용을 하는 데 사용되는 수단으로, 객체에게 어떤 행위를 하도록 지시하는 명령 또는 요구 사항이다.클래스로부터 생성된 객체를 사용하는 방법으로서 객체에 명령을 내리는 것이 메시지라 할 수 있다. 메시지의 구성 요소 : 메시지를 받는 객체의 이름, 객체가 수행할 메소드 이름, 메소드를 수행할 때 필요한 인자 메시지를 받은 수신 객체는 요구된 메소드를 수행하여 결과를 반환하게 된다. OOP 기법 (특성)객체 지향 프로그래밍이란 “누가 어떤 일을 할 것인가” 이며 1개 이상의 유사 객체의 공통된 특성(속성과 메서드) 가진 클래스를 통해 객체를 생성하고 상호 유기적으로 메시지를 주고 받으며 결과를 반환한다고 정리해볼 수 있으며 OOP의 기법 및 특성이 모두 담겨져 있다. 1) 캡슐화 (Encapsulation) 자료 부분과 연산(또는 함수) 부분 등 정보처리에 필요한 기능을 한 테두리로 묶는 것 연관된 데이터와 함수를 함께 묶어 외부와 경계를 만들고 필요한 인터페이스만을 밖으로 드러내는 과정 객체지향 기법의 정보 은닉 과 밀접한 기법 장점 높은 재사용성 인터페이스의 단순화 변경 또는 수정이 발생할때 오류의 파급효과가 적음 응집력이 향상됨 2) 은닉화 (Information Hiding) 캡슐화에서 가장 중요한 개념으로, 다른 객체에게 자신의 정보를 숨기고 자신의 연산만을 통하여 접근을 허용하는 것 정보 은닉은 고려되지 않은 영향(side effect)들을 최소화함을 목적으로 함 따라서, 외부 객체가 접근하거나 사용하지 못하므로 유지보수와 소프트웨어 확장 시 오류를 최소화 할 수 있음 3) 추상화 (Abstraction) 자료 추상화는 불필요한 정보는 숨기고 중요한 정보만을 표현함으로써 프로그램을 간단히 만드는 것으로, 모델화하는 것을 의미 자료 추상화를 통해 정의된 자료형을 추상 자료형이라고 함 추상 자료형은 자료형의 자료 표현과 자료형의 연산을 캡슐화한 것으로 접근 제어를 통해서 자료형의 정보를 은닉할 수 있다. 객체 지향 프로그래밍에서 일반적으로 추상 자료형을 클래스, 추상 자료형의 인스턴스를 객체, 추상 자료형에서 정의된 연산을 메소드(함수), 메소드의 호출을 생성자라고 한다. 4) 상속성 (Inheritance) 상속은 새로운 클래스가 기존의 클래스의 자료와 메서드를 이용할 수 있게 하는 기능 상속을 받는 새로운 클래스를 부클래스, 파생 클래스, 하위 클래스, 자식 클래스라고 하며 새로운 클래스가 상속하는 기존의 클래스를 기반 클래스, 상위 클래스, 부모 클래스라 함 상속을 통해서 기존의 클래스를 상속받은 하위 클래스를 이용해 프로그램의 요구에 맞추어 클래스를 수정할 수 있고, 클래스 간의 종속 관계를 형성함으로써 객체를 조직화할 수 있다. 다중 상속 클래스가 2개 이상의 클래스로부터 상속받을 수 있게 하는 기능 클래스들의 기능이 동시에 필요할 때 용이하나 클래스의 상속 관계에 혼란을 줄 수 있음 (예: 다이아몬드 상속) 프로그래밍 언어에 따라 사용 가능 유무가 다르므로 주의해서 사용해야 한다. JAVA는 지원하지 않음 5) 다형성 (Polymorphism) 상이한 클래스들이 동일한 메서드명을 갖는 것 또는 한 메시지가 객체에 따라 다양한 방식으로 응답할 수 있는 것을 의미함 일반적으로 오버라이딩이나 오버로딩을 의미함 오버라이딩: 같은 이름의 메소드가 여러 클래스에서 다른 기능을 하는 것 오버로딩: 같은 이름의 메소드가 인자의 개수나 자료형에 따라서 다른 기능을 하는 것 다형 개념을 통해서 프로그램 안의 객체 간의 관계를 조직적으로 나타낼 수 있음 6) 연관성 (Relationship) 관계성의 종류 의미 특성 is-member-of 연관화 링크 개념과 유사 is-instance-of 분류화 객체 및 클래스의 인스턴스를 표현 is-part-of 집단화 상향식, 단일 상속, 복합 객체 (composite object) 표현에 유용 is-a 특수화, 일반화 하향식, 다중 상속, 복잡한 객체 표현에 유용 두 개 이상의 엔티티 형에서 데이터를 상호 참조하는 클래스간의 연관관계를 정의 객체간의 관계를 세부적으로 정의하여 구현 용이 관계성의 종류 is-member-of (연관화, association) 공통된 의미(semantic)를 서로 연관된 집단으로 표현하는 방법으로 링크(link)와 그 의미가 유사 객체들의 물리적, 또는 개념적 연결을 두 개 이상의 객체와 클래스로 표현 즉, 연관화는 관련되지 않은 클래스들간의 의미적 연결 is-instance-of (분류화, classification) 공통된 속성에 의하여 정의된 객체 및 클래스에 있어 구성원들의 인스턴스 즉, 분류화는 동일한 형의 특성을 갖는 객체들이 모여 클래스를 구성하는 것 여기서, 클래스는 객체들의 본질에 대한 추상화 is-part-of (집단화, aggregation) 서로 관련 있는 여러 개의 객체를 묶어 한 개의 상위 객체 생성 여러 개의 속성을 묶어 사용자 정의형의 엔티티를 만드는 수단으로 사용 한 객체에서 하나 이상의 객체는 사용자 표정의 형이 될 때 복합 객체(composite object) 즉, 복합 객체의 종속 성분을 모델링하기 위해 사용되며, 이들 복합 성분 클래스 관계를 통해 복합 속성 계층(composite attribute hierarchy)을 형성 is-a 일반화 (generalization) 일반화는 객체들에 있어 공통적인 성질들을 상위 객체로 정의하고, 특수화(specialization)된 객체들을 하위의 부분형(subtype) 객체로 정의 특수화 (specialization) 일반화와 개념과 같으나, 클래스를 보는 시점에 있어 상위의 클래스에서 하위의 클래스를 보는 관점(특수화의 역은 일반화) 하위 개념으로 내려 갈수록 인스턴스는 특수화 클래스로 모델화되는 실세계 객체들을 겹치지 않는 서브 클래스로 나누거나 상이한 실세계 상황으로 나누기 위해 사용 OOP 장단점1) 장점 자연적인 모델링이 가능함 코드의 재사용성 증가 소프트웨어의 유지보수성 향상 대형 프로젝트 개발에 적합 2) 단점 처리속도가 상대적으로 느림 다중 객체 생성에 따른 메모리 사용량 증가 객체 설계의 복잡도에 따른 설계시간 소용 시간 강한 응집력 (Strong Cohesion)과 약한 결합력 (Weak Coupling)위의 장점들을 관통하는 객체 지향 프로그래밍의 중요한 특성은 강한 응집력(Strong Cohesion)과 약한 결합력(Weak Coupling) 을 지향한다는 점이다. 소프트웨어 공학에서 말하는, 응집력(cohesion) 프로그램의 한 요소가 해당 기능을 수행하기 위해 얼마만큼의 연관된 책임과 아이디어가 뭉쳐있는지를 나타내는 정도. 프로그램의 한 요소가 특정 목적을 위해 밀접하게 연관된 기능들이 모여서 구현되어 있고, 지나치게 많은 일을 하지 않으면 그것을 응집력이 높다고 표현함. 결합력(coupling) 프로그램 코드의 한 요소가 다른 것과 얼마나 강력하게 연결되어 있는지, 얼마나 의존적인지를 나타내는 정도. 결합력이 낮다는 것은 한 요소가 다른 요소들과 관계를 크게 맺고 있지 않은 상태를 의미함. OOP의 경우 클래스에 하나의 문제 해결을 위해 데이터를 모아 놓은 객체를 활용한 프로그래밍을 지향하므로 응집력을 강화하며, 클래스 간에 독립적으로 디자인함으로써 결합력을 약하게 할 수 있다. 마치며사실 자바스크립트를 사용하면서 OOP에 대한 기술부채가 있었고, Javascirpt의 Prototype 기반의 객체지향 설계 및 구현과 같은 자료를 읽어도 근본이 되는 OOP에 대한 단순 암기식 지식 때문인지 이해는 되지만 시원하지 않았다. 그러나 이번 포스트를 쓰기 위해 공부하고 작성하는 동안 어플리케이션 전체를 그리고 그 내부의 세부 기능을 설계와 구현의 관점에서 OOP가 어떻게 바라보는지 이해할 수 있었다. 다음 포스팅은 Prototype 기반의 Javascript 객체지향 에 대해서 작성해보겠습니다. 참고 객체지향 프로그래밍 객체 지향 기법의 구성 요소 객체지향 기법 객체지향 연관성 객체 지향 프로그래밍(OOP : Object Oriented Programming) 개념 및 활용 정리 소프트웨어 개발의 기초 - OOP 다형성에 대해서 설명해보세요","categories":[{"name":"Programming","slug":"Programming","permalink":"https://joontae-kim.github.io/categories/Programming/"},{"name":"Javascript","slug":"Programming/Javascript","permalink":"https://joontae-kim.github.io/categories/Programming/Javascript/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://joontae-kim.github.io/tags/javascript/"},{"name":"oop","slug":"oop","permalink":"https://joontae-kim.github.io/tags/oop/"},{"name":"object","slug":"object","permalink":"https://joontae-kim.github.io/tags/object/"}]},{"title":"자바스크립트 알고리즘 - 시작 (a.k.a 자료 모으기)","slug":"js-algorithm","date":"2020-10-27T18:26:36.000Z","updated":"2021-03-17T09:43:20.379Z","comments":true,"path":"2020/10/28/js-algorithm/","link":"","permalink":"https://joontae-kim.github.io/2020/10/28/js-algorithm/","excerpt":"","text":"강좌 (동영상) https://www.udemy.com/course/coding-interview-bootcamp-algorithms-and-data-structure/ https://www.udemy.com/course/coding-interview-question-data-structures-algorithm/ 유튜브 강좌 https://www.youtube.com/playlist?list=PLLXdhg_r2hKA7DPDsunoDZ-Z769jWn4R8 강좌 (블로그) 7 JavaScript data structures you must know https://www.educative.io/blog/javascript-data-structures#wrap-up 깃헙 JavaScript 알고리즘 및 자료 구조 볼만한 알고리즘 단편 블로그 7 Javascript data structure you must know Javascript 알고리즘 개요 빅오 표기법(Big o notation)과 자바스크립트 취업을 위한 알고리즘 공부법 [Algorithm] 알고리즘 공부 시작 방법 및 순서 볼만한 알고리즘 블로그 시리즈 Javascript 공부/Data Structure + Algorithms - soldonii.tistory.com Javascript 공부/알고리즘 풀이 - soldonii.tistory.com","categories":[{"name":"Programming","slug":"Programming","permalink":"https://joontae-kim.github.io/categories/Programming/"},{"name":"Algorithm","slug":"Programming/Algorithm","permalink":"https://joontae-kim.github.io/categories/Programming/Algorithm/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://joontae-kim.github.io/tags/javascript/"},{"name":"Algorithm","slug":"Algorithm","permalink":"https://joontae-kim.github.io/tags/Algorithm/"},{"name":"알고리즘","slug":"알고리즘","permalink":"https://joontae-kim.github.io/tags/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/"},{"name":"lecture","slug":"lecture","permalink":"https://joontae-kim.github.io/tags/lecture/"},{"name":"reference","slug":"reference","permalink":"https://joontae-kim.github.io/tags/reference/"},{"name":"자바스크립트","slug":"자바스크립트","permalink":"https://joontae-kim.github.io/tags/%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8/"}]},{"title":"프론트엔드 면접 질문 리스트 - Network","slug":"interview-question-network","date":"2020-10-26T08:19:23.000Z","updated":"2021-08-11T16:54:29.914Z","comments":true,"path":"2020/10/26/interview-question-network/","link":"","permalink":"https://joontae-kim.github.io/2020/10/26/interview-question-network/","excerpt":"","text":"프론트엔드 면접 준비를 위한 질문 리스트 정리Network아래질문 리스트를 기반으로 면접 질문 &amp; 답변 목록을 작성할 예정이고, 지속적으로 보충 or 보수할 계획입니다. 업데이트 날짜 2020-10-26 2021-07-20 network 질문 목록 수정 질문 목록 HTTP와 HTTPS의 정의와 차이점은 무엇인가 HTTP 메서드는 무엇이 있으며 어떤 요청이 있을때 사용하나 GET, POST 방식의 차이점은 무엇인가 POST과 PUT의 차이점은 무엇인가 PUT과 PATCH의 차이 TCP와 UDP는 무엇이며 차이점은 무엇인가 TCP 3-WAY-HANDSHAKE DNS ROUND ROBIN 방식인이란 Http 1.1과 2.0는 무엇이며 의 차이는 무엇인가 프록시의 정의와 기능은 무엇인가 HTTP 통신에서 사용자의 상태를 파악할 수 있는 방법은 무엇이 있는가 - Cookie, Session, Auth with Token 1. HTTP와 HTTPS의 정의와 차이점은 무엇인가HTTP 정의HTTP란 Hyper Text Transper Protocol의 약자로, 서버와 클라이언트가 서로 정보를 주고받을 수 있는 프로토콜입니다. TCP/IP 위에서 동작하며 well-known 포트인 80번 포트를 사용하여 통신합니다. HTTP 통신의 특징은 비연결성(Connectionless), 무상태성(Stateless) 프로토콜이라는 점입니다. 비연결성 (Connectionless) 비연결이란 클라이언트가 서버에게 리소스를 요청한 후 응답을 받으면 연결을 끊는다는 의미로 지속적으로 연결을 유지할시 서버의 부담이 가중될 수 있으나 리소스를 요청할 때마다 연결해야 하는 오버헤드(Overhead) 비용이 발생합니다. 이를 위해 Connection: keep-alive 속성으로 지속적 연결 상태(Persistent connection)를 유지할 수 있으며 기존의 연결을 재사용할 수 있습니다. 무상태성 (Stateless)무상태성이란 서버가 클라이언트의 요청을 각각 독립적으로 여겨 클라이언트의 요청을 식별할 수 없다는 뜻입니다. 이를 위해서 쿠키, 세션 또는 토큰 방식의 OAuth 및 JWT를 사용해 각 클라이언트가 어떤 상태이며 어디서 왔는지 식별 가능한 상태를 보충할 수 있습니다. HTTPS 정의HTTPS란 (HyperText Transfer Protocol over TLS/SSL)의 약자로, 기존의 HTTP를 SSL 또는 TLS로 암호화한 프로토콜입니다. TCP의 연결이 이루어진 후 TLS를 통해 암호화 설정이 되고 통신을 하는 방식으로, 443번 포트를 사용하며, 네트워크 상에서 중간에 제3자가 정보를 볼 수 없도록 대칭키 / 공개키 암호화를 지원하고 있다. 암호화 전송에 필요한 개념으로는 암화화, 복호화, 키 등이 있으며 암호화에는 공개키 / 개인키, 대칭키 / 비대칭키 암호화 및 인증기관이 있습니다. 암호화 전송에 필요한 개념 암호화: 어떤 정보를 암호화된 정보로 바꾸는 것 복호화: 암호화된 정보를 다시 원래 정보로 바꾸는 것 키: 암호화, 복호화할 때 쓰는 비밀번호 HTTPS는 공통 키 방식과 비대칭 키 방식을 같이 사용합니다 암호화에 사용되는 키 공개키 / 개인키 암호화 공개키: 모두가 볼 수 있는 키 개인키: 소유자만이 가지고 있는 키로 암/복호화에 사용됨 공개키 암호화: 공개키로 암호화를 하면 개인키로만 복호화할 수 있다. =&gt; 개인키는 나만 가지고 있으므로, 나만 볼 수 있다. 개인키 암호화: 개인키로 암호화하면 공개키로만 복호화할 수 있다. =&gt; 공개키는 모두에게 공개되어 있으므로, 내가 인증한 정보임을 알려 신뢰성을 보장할 수 있다. 대칭키 / 비대칭키 암호화 대칭키: 서버와 클라이언트가 암호화/복호화에 동일한 비밀키를 사용하는 방식, 키를 공유하는데 어려움이 있으나 속도가 빠르다. 비대칭키: 서버와 클라이언트가 암호화/복호화에 각각 다른 비밀키를 사용하는 방식, 공개키를 통해서 암호화를 하고 비밀키를 통해서 복호화를 한다. 공개키는 공개해도 상관없으니 키 관리에 어려움이 없으나, 속도가 느리다. 인증기관 클라이언트가 접속을 요청한 서버가 의도한 서버가 맞는지 인증해주는 역할을 하는 보증된 기업들이다. 클라이언트는 서버에 요청을 해서 CA가 발급한 인증서를 받은 뒤 CA의 공개키로 복호화하여 신뢰할 만한 인증서인지 검증한다. CA의 공개키로 복호화되는 암호화는 오직 CA의 비밀키로 암호화한 경우밖에 없기 때문에 복호화되면 신뢰할 만한 것이다. 동작방식 HTTPS는 대칭키 암호화를 사용 하며 다음과 같은 과정을 거친다. 클라이언트가 서버에게 접속요청을 하면 서버는 CA에서 발급받은 인증서를 보낸다. 인증서에는 CA의 비밀키로 암호화된 사이트정보와 공개키가 들어있다. 클라이언트는 인증서를 받아 CA의 공개키로 복호화하여 접속요청한 서버가 신뢰할만한지 검증한다. 복호화가 되면 인증서가 신뢰할 만하기 때문에 데이터를 주고받을 대칭키를 생성한다. 대칭키를 서버의 공개키로 암호화하여 서버에게 전송한다. 서버는 자신의 비밀키로 클라이언트가 보낸 대칭키를 복호화한 뒤 그 대칭키를 통해 데이터를 주고받는다. HTTP와 HTTPS 차이 HTTP는 암호화가 추가되지 않았기 때문에 보안에 취약한 반면, HTTPS는 안전하게 데이터를 주고받을 수 있다. HTTPS를 이용하면 암호화/복호화의 과정이 필요하기 때문에 HTTP보다 속도가 느리다. (오늘날에는 거의 차이를 못느낄 정도이다.) HTTPS는 인증서를 발급하고 유지하기 위한 추가 비용이 발생하다. 그렇다면 언제 HTTP를 쓰고, 언제 HTTPS를 쓰는 것이 좋겠는가? 개인 정보와 같은 민감한 데이터를 주고 받아야 한다면 HTTPS를 이용해야 하지만, 단순한 정보 조회 등만을 처리하고 있다면 HTTP를 이용하면 된다. 2. HTTP 메서드는 무엇이 있으며 어떤 요청이 있을때 사용하나HTTP 메서드는 클라이언트가 서버에 요청하는 방법을 정의한 것으로 주어진 리소스에 수행하길 원하는 행동을 나타냅니다. HTTP 메서드에는 GET, POST, PUT, DELETE, PATCH 등이 있습니다. GET: 서버에게 리소스 조회를 요청한다. (READ, 조회) POST: HTTP 본문(body)에 생성할 데이터를 삽입하여 서버에게 전송한다. (CREATE, 생성) PUT: HTTP 본문(body)에 서버에게 수정할 데이터를 삽입하여 전송한다. (UPDATE, 수정) DELETE: 서버에게 리소스 삭제를 요청한다. (DELETE, 삭제) PATCH: PUT과 비슷하지만 일부만 수정한다는 점에서 다르다. OPTIONS: 웹서버에서 지원되는 메소드의 종류를 확인할때 사용합니다. 3. GET, POST 방식의 차이점은 무엇인가GET GET 은 서버로부터 정보를 조회하기 위해 설계된 메소드입니다. GET은 요청을 전송할 때 필요한 데이터를 Body에 담지 않고, 쿼리스트링을 통해 전송 합니다. 쿼리스트링 이란? URL의 끝에 ?와 함께 이름과 값으로 쌍을 이루는 요청 파라미터를 쿼리스트링이라고 부릅니다. 만약, 요청 파라미터가 여러 개이면 &amp;로 연결합니다. GET은 불필요한 요청을 제한하기 위해 요청이 캐시될 수 있습니다. js, css, 이미지 같은 정적 컨텐츠는 데이터양이 크고, 변경될 일이 적어서 반복해서 동일한 요청을 보낼 필요가 없습니다. 정적 컨텐츠를 요청하고 나면 브라우저에서는 요청을 캐시해두고, 동일한 요청이 발생할 때 서버로 요청을 보내지 않고 캐시된 데이터를 사용합니다. 그래서 프론트엔드 개발을 하다보면 정적 컨텐츠가 캐시돼 컨텐츠를 변경해도 내용이 바뀌지 않는 경우가 종종 발생합니다. 이 때는 브라우저의 캐시를 지워주면 다시 컨텐츠를 조회하기 위해 서버로 요청을 보내게 됩니다. 데이터가 Header의 URI에 담겨서 전송되므로 데이터 크기가 제한적이며 데이터가 사용자에게 그대로 노출되어 보안이 필요한 경우 적절하지 않다. GET 요청은 캐싱이 가능하므로 데이터가 사용자에게 노출되어도 상관없다면 적극적으로 활용하는게 좋다. 요약 데이터를 전달할 때 URL에 데이터를 포함시켜 요청 데이터를 Header에 포함시켜 전송 URL에 데이터가 노출되어 보안에 취약 전송하는 길이에 제한이 있음 POST POST 는 리소스를 생성/변경하기 위해 설계되었기 때문에 GET과 달리 전송해야될 데이터를 HTTP 메세지의 Body에 담아서 전송합니다. HTTP 메세지의 Body는 길이의 제한없이 데이터를 전송 할 수 있습니다. 그래서 POST 요청은 GET과 달리 대용량 데이터를 전송 할 수 있습니다. 이처럼 POST는 데이터가 Body로 전송되고 내용이 눈에 보이지 않아 GET보다 보안적인 면에서 안전 하다고 생각할 수 있지만, POST 요청도 크롬 개발자 도구, Fiddler와 같은 툴로 요청 내용을 확인할 수 있기 때문에 민감한 데이터의 경우에는 반드시 암호화해 전송 해야 합니다. 데이터의 크기가 GET 방식보다 현저하게 크며 데이터가 일반 사용자에게 노출되지 않으므로 안정적으로 데이터를 전송할 수 있다. POST는 대부분 데이터의 변경을 위해서 사용한다. 요약 URL에 데이터를 노출하지 않고 요청 데이터를 Body에 포함시겨 전송 URL에 데이터가 노출되지 않아 기본보안은 되어있음 전송하는 길이에 제한이 없음 4. POST와 PUT의 차이점은 무엇인가주요 차이점은 다음과 같습니다. 구분 POST PUT 개념 HTTP body에 생성할 데이터를 삽입하여 서버에게 전송합니다.CREATE 또는 INSERT의 개념. 생성 HTTP body에 수정할 데이터를 삽입하여 서버에게 전송한다.UPDATE 의 개념. 수정 멱등화 멱등화 하지 않음즉, 동일한 리소스 주소로 다수의 요청을 전송하는 경우, 매번 새로운 리소스가 생성되기 때문에 멱등하지 않는다. 멱등화 함즉, 동일한 리소스 주소로 다수의 요청을 전송하는 경우, 새로운 리소스가 생성되는 것이 아니라 요청에 명시된 동일한 리소스를 수정하기 때문에 여러번 요청해도 멱등하다. 5. PUT과 PATCH의 차이주요 차이점은 다음과 같습니다. 구분 PUT PATCH 개념 해당 자원의 전체를 교체한다. 해당 자원의 일부를 수정한다. 멱등화 멱등화 함즉, 자원 전체를 변경하기 때문에 동일 자원에 대해서 동일하게 PUT을 처리하는 경우, 멱등하게 처리된다. 멱등화 하지 않음즉, 자원의 일부를 변경하기 때문에 멱등성을 보장할 수 없다. 멱등(idempotent)함 이란 같은 작업을 계속 반복해도 같은 결과가 나오는 경우 를 의미한다. 동일한 자원에 대한 GET 요청이라면 클라이언트에 반환되는 모든 응답은 동일해야 한다. 특정 자원에 대한 DELETE 의 경우도 자원은 더이상 이용할 수 없어야 하며, DELETE 요청을 재전송 할지라도 자원은 여전히 사용할 수 없는 상태여야 한다. 6. TCP와 UDP는 무엇이며 차이점은 무엇인가TCP신뢰성과 순차적인 전달이 필요한 경우 사용한다. TCP 서비스는 송신자와 수신자 모두가 소켓이라고 부르는 종단점을 생성함으로써 이루어진다. TCP는 멀티캐스팅이나 브로드캐스팅을 지원하지 않는다. 특징 연결형 서비스 가상회선 방식으로 패킷을 교환한다. 전송 순서를 보장 수신여부를 확인한다. 1대1 통신이다. 신뢰성이 높다 속도는 상대적으로 UDP에 비해 느리다. 3-way handshaking과정을 통해 연결을 설정하고 4-way handshaking을 통해 해제한다. 흐름제어 및 혼잡제어를 제공. Q) 흐름제어(Flow Control)와 혼잡제어(Congestion Control)이란? 흐름제어 는 데이터를 송신하는 곳과 수신하는 곳의 데이터 처리 속도를 조절하여 수신자의 버퍼 오버플로우를 방지하는 것입니다. 예를 들어 송신하는 곳에서 감당이 안되는 수준으로 데이터를 빠르게 많이 보내면 수신자에서 문제가 발생하기 때문입니다. 혼잡제어 는 네트워크 내의 패킷 수가 넘치게 증가하지 않도록 방지하는 것입니다. 만약 정보의 소통량이 과다하면 패킷을 조금만 전송하여 혼잡 붕괴 현상이 일어나는 것을 막습니다. UDP비연결형 프로토콜이며 손상된 세그먼트의 수신에 대한 재전송을 하지 않는다. UDP를 사용하는 것에는 DNS가 있다. 사전에 설정이 필요하지 않으며 그 후에 해제가 필요하지 않다. 특징 비연결형 서비스이다. 데이터그램 방식으로 패킷 교환 전송 순서가 바뀔 수 있다. 수신 여부를 확인하지 않는다. 1대1 or 1대N or N대N 통신이다. 신뢰성이 낮다. 속도가 상대적으로 TCP에 비해 빠르다 7. TCP 3-WAY-HANDSHAKE Client는 Server에 접속 요청 메세지(SYN)을 전송하고 SYN_SEND 상태가 된다. Server는 SYN 요청을 받고 Client에 요청을 수락(SYN+ACK)하고 SYN_RECEIVED 상태가 된다. Client는 Server에게 수락 확인(ACK)를 보내고 Server는 ESTABLISHED 상태가 된다. 8. DNS ROUND ROBIN 방식DNS를 이용해서 하나의 서비스에 여러 대의 서버를 분산 시키는 방법이다. 동일한 이름으로 여러 레코드를 등록 시키면 질의 할 때마다 다른 결과를 반환하며, 이 동작을 이용함으로써 여러 대의 서버에 처리를 분산 시킬 수 가 있다. 단점은 아래와 같다. 서버의 수 만큼 공인 IP 주소가 필요하다. DNS 질의 결과 캐싱으로 인해 균등하게 분산되지 않는다. 서버가 다운되어도 확인이 어렵다. 9. Http 1.1과 2.0의 차이는http 1.1http 2.0 기존 HTTP/1.x 버전의 성능향상에 초점을 맞춘 프로토콜 HTTP 메시지 전송 방식의변화 바이너리 프레이밍 계층 사용 파싱, 전송속도 증가, 오류발생 가능성 감소 스트림을통한 양방향 전송을 통해 요청과 응답 멀티플렉싱이 가능 Head of Line Blocking 해결 Stream Prioritization 리소스간 우선 순위를 설정 가능. 서버 푸시 가능. Header 압축. 헤더의 크기를 줄여 페이지 로드시간 감소. http 1.1와 http 2.0의 차이10. 프록시 서버의 기능클라이언트가 프록시 서버를 통해서 다른 네트워크 서비스에 간접적으로 접근을 할 수 있게 하는 것을 말한다. 프록시 서버는 요청된 내용들을 캐시에 저장을하고 다음에 같은 요청이 들어온다면 캐시에 저장된 정보를 제공함으로써 전송시간을 줄일 수 있다. 11. HTTP 통신에서 사용자의 상태를 파악할 수 있는 방법은 무엇이 있는가 - Cookie, Session, TokenHTTP 통신으로 사용자의 인증 상태 또는 사용자 식별을 할 수 있는 방법으로는 Cookie, Session, Token 기반의 인증방법이 있습니다. 이 방법들은 HTTP 프로토콜의 특성인 비상태성(Stateless)을 보완하기 위해 개발된 방법들로 전통적 방법으로는 그리고 전통적 방법으로는 Cookie, Session 기반의 사용자 인증 방법이 있으며 Cookie, Session의 단점과 한계를 보완해 사용자 인증 상태 및 식별자를 보다 안전하고 효율적으로 관리하는 방법이 Token 기반의 인증방법 입니다. Cookie와 SessionCookie와 Session은 HTTP의 특성인 Stateless를 보완하기 위해 등장한 개념으로, 사용자가 특정 페이지를 이동하거나 로그인 상태를 기억해야할때 HTTP 통신의 header에 담아 전송하기 위한 목적을 가지고 있습니다. Cookie 란 웹 서버가 브라우저에게 지시해 웹 브라우저에 저장되는 데이터로써 서버가 클라이언트의 요청을 식별하는데 사용되고, Session이란 브라우저가 서버에 연결되어 있는 동안 서버측에 저장되고 유지되는 데이터의 집합으로, 사용자가 웹 사이트에 방문해 서버에 요청을 보내게 되면, 사용자의 정보를 서버에 저장하고 그 정보의 식별자를 Set-Cookie 헤더에 담아 클라이언트에게 전송합니다. 이 둘의 차이점은 Cookie의 경우 서버에서 전송된 민감한 정보를 포함한 모든 사용자의 정보를 브라우저의 쿠키에 저장해야하지만, Session의 경우 사용자 정보에 대한 식별자만을 전달해 인증하면 되기 때문에 서버에 접근하는 트래픽양이 증가해도 Cookie와 비교했을때 상대적으로 적은 부하를 일으킬 수 있으나 이 또한 서버의 메모리를 차지하고 있는 리소스이기 때문에 부하가 늘어나면 서버에서 사용자의 정보를 조회하는 과부하가 늘어날 수 있다는 단점이 있습니다. 또한, Cookie의 경우 브라우저에 사용자의 정보가 기록되기 때문에 위변조의 가능성이 높아 보안에 취약하며, 세션 또한 세션키가 중간에 탈취 당할 수 있기 때문에 보안에 완벽하다고 할 수 없습니다. TokenToken 기반의 사용자 인증 방식은 Cookie와 Session의 문제점을 보완하기 위해 도입됐으며 핵심은 암호화 알고리즘을 통해 보호할 데이터를 토큰으로 치환하여 원본 데이터 대신 토큰을 사용하는 방식입니다. Token은 서버에서 정한 암호화 알고리즘과 치환하기 위한 여러 값들을 기반으로 사용자 정보를 의미를 알 수 없는 문자열 형태로 치환하기 때문에 중간에 탈취 당했다 하더라고 암호화 되어있어 공격자가 치환되기 전의 데이터를 알아내는 것은 매우 어렵습니다. Token 기반의 대표적인 인증 방식으로는 JWT가 있습니다. JWT JWT란 JSON Web Token의 약자로, 사용자가 로그인 요청을 전송하면 서버는 JSON 기반의 사용자의 정보를 생성하며 이를 기반으로 암호화된 토큰을 발행합니다. 따라서, JWT는 토큰 자체가 의미를 갖는 Claim 기반의 토큰 방식이며 여기서 Claim이란 권한으로 사용자에 대한 프로퍼티 또는 속성을 의미합니다. 또한, 발행된 토큰은 사용자의 정보를 서버측 또는 브라우저에 저장하는 것이 아닌 자체가 의미를 갖는 토큰이므로 보안성 강화를 위해 토큰의 유효시간을 설정해 탈취되었다 하더라도 이미 무의미한 토큰이 되도록 합니다. JWT의 가장 큰 특징은 다음과 같습니다. JWT 자체가 암호화된 JSON 기반의 문자열 데이터 토큰 자체가 Claim(권한) 기반이라는 점 토큰을 HTTP 헤더에 추가해 통신하기 때문에 따로 보관하지 않으며 서버에 부하가 발생시키지 않음 토큰 탈취로 인한 보안성 강화를 토큰에 대한 유효시간을 설정해 일정주기로 갱신 JWT의 구조는 Header, Payload, Signature (서명)으로 구성되어 있으며 Header: 토큰의 타입과 해싱 알고리즘을 명시. JWT를 어떻게 검증하는가(Verify) 하는가에 대한 내용을 담고 있음 Payload: 토큰에 대한 내용으로써 Claim Set이라고 부르며 JWT에 대한 토큰 생성자의 정보, 생성 일시와 같은 JWT에 대한 내용을 담고 있음 Signature (서명): Header의 인코딩 값과 Payload의 인코딩 값을 `. (dot) 을 구분자로 해서 연결 및 병합한 후 문자열을 서명한 값 참조 신입 개발자 기술면접 준비하기 - baealex님 블로그 네트워크 면접질문 - dont-wook94님 블로그 [Web] HTTP와 HTTPS 및 차이점 - mangkyu님 블로그 http - Must-Know-About-Frontend https - Must-Know-About-Frontend HTTP 응답코드 메소드 정리 GET, POST, PUT, PATCH, DELETE, TRACE, OPTIONS - 자바공작소님 블로그 Cookie, Session, Token이란? - sdy-study님 블로그 [🙈HTTP/인증] JWT (JSON Web Token)🐵 - victorydntmd님 블로그","categories":[{"name":"Blog","slug":"Blog","permalink":"https://joontae-kim.github.io/categories/Blog/"},{"name":"Job","slug":"Blog/Job","permalink":"https://joontae-kim.github.io/categories/Blog/Job/"}],"tags":[{"name":"Front-end","slug":"Front-end","permalink":"https://joontae-kim.github.io/tags/Front-end/"},{"name":"Interview","slug":"Interview","permalink":"https://joontae-kim.github.io/tags/Interview/"},{"name":"Job","slug":"Job","permalink":"https://joontae-kim.github.io/tags/Job/"},{"name":"Network","slug":"Network","permalink":"https://joontae-kim.github.io/tags/Network/"}]},{"title":"프론트엔드 면접 질문 리스트 - JS","slug":"interview-question-js-1","date":"2020-10-26T08:19:17.000Z","updated":"2021-08-12T10:15:37.279Z","comments":true,"path":"2020/10/26/interview-question-js-1/","link":"","permalink":"https://joontae-kim.github.io/2020/10/26/interview-question-js-1/","excerpt":"","text":"프론트엔드 면접 준비를 위한 질문 리스트 정리Javascript아래질문 리스트를 기반으로 면접 질문 &amp; 답변 목록을 작성할 예정이고, 지속적으로 보충 or 보수할 계획입니다. 업데이트 날짜 2020-10-26 2021-07-02 Javascript 질문 목록 수정 2021-07-23 2021-07-24 2021-07-25 Javascript 질문 추가 및 수정 답변 추가 및 수정 질문 목록 질문 목록 자바스크립트의 원시 타입(Primitive Data Type)은 몇가지이며, 전부 말해달라 Number, String, Boolean, Null, Undefined, Symbol Null vs Undefined Pass by Value &amp; Pass by Reference function foo() &#123;&#125; 와 var foo = function() &#123;&#125; 에서 foo 의 차이가 무엇인지 설명해보세요. 함수 선언식과 함수 표현식의 차이 이벤트 루프와 동시성 모델에 대해서 설명해달라 실행 컨텍스트(Execution Context)에 대해 설명해달라 Javascript Scope Chaining이란 무엇인가 scope란 무엇이며 var, let, const에 대해 설명해달라 전역 scope를 사용했을 때 장단점에 관해 설명해달라 자바스크립트의 호이스팅(Hoisting)은 어떻게 이루어져 있는가 클로저(Closure)란 무엇이며, 어떻게 사용하는지, 왜 이러한 패턴을 사용하는가 This 자바스크립트에서 This는 몇가지로 추론 될수 있는가, 아는대로 말해달라 일반함수의 this와 화살표 함수의 this는 어떻게 다른가? use strict모드에서의 this? Call, Apply, Bind 함수에 대해 설명해달라 객체 지향 프로그래밍(Object Oriented Programming)과 프로토타입이란 무엇인가 OOP에 특징에 대해 설명해달라(상속, 캡슐화 등등…) 현실에 상황을 예로 들어 OOP의 개념으로 설계과정을 설명해달라 ex) 축구를 게임으로 만든다거나, 기타 어떠한 상황이라도 좋다 프로토타입 상속이 이루어지는 법 OOP와 함수형 프로그래밍의 차이 함수형 프로그래밍에 대해 설명해달라 함수형 프로그래밍에 개념에서 순수함수란 무엇인가 OOP와 함수형 프로그래밍의 가장 큰 차이점은 무엇인가 즉시 실행 함수(IIFE)란 무엇이며 언제 사용하는 것인가 비동기 프로그래밍 동기 함수와 비동기 함수란 무엇인가 Callback, Promise 란 무엇이며 각각의 장단점에 대해 설명해달라 Promise 코드가 어떻게 구성되어있는가 Async, Await는 무엇이며 Promise의 차이는 1. 자바스크립트의 원시 타입(Primitive Data Type)은 몇가지이며, 전부 말해달라프로그래밍 언어에서 자료형(types) 또는 데이터 타입(data type) 이란 숫자형(정수형, 실수형), 논리값(Boolean), 문자(String) 등의 데이터를 식별하는 분류 (indentifier) 로써, Javascript에서는 다음과 같이 Boolean, Null, Undefined, Number, String, Object 데이터 유형이 있으며 Symbol은 ECMAScript 6에 신규 추가되었습니다. 이 데이터 유형은 원시형(Primitives)과 참조형(Reference)으로 구분할 수 있으며 원시형 데이터 타입 (Primitives) 으로는 Boolean Null Undefined Number String Symbol 이 있습니다. 원시형(Primitives) 데이터 타입의 특징은 아래와 같습니다. 단 하나의 값만 가질 수 있음 변수에 할당될 때 스택 메모리 상에 고정된 크기로 저장 모든 원시 값은 불변 (immutable)의 성질로 변형 불가 즉, 원시값을 교체할 수는 있지만, 직접 변형할 수는 없음 객체가 아니면서 메서드도 가지지 않는 데이터 Null의 경우, 겉보기엔 원시 값처럼 보이는 있지만, 사실 Object 이며, 모든 구조화된 자료형은 prototype chain 에 따라 Null의 자손이다. 대부분의 경우, 원시 값은 언어 구현체의 가장 저수준(low level) 에서 나타남. 원시 값 자체와, 원시값을 할당한 변수를 혼동하지 않는 것이 중요! 변수: 새로운 값을 다시 할당 가능 원시값: 객체, 배열, 함수와 달리 변형 불가능 값에 의한 전달 (pass-by-value) 방식으로 전달 Number, String, Boolean, Null, Undefined, (Symbol) 부록 - Reference Type (참조형) 객체는 데이터와 그 데이터에 관련한 동작(절차, 방법, 기능)을 모두 포함할 수 있는 개념적 존재 즉, Property와 Method를 포함할 수 있는 독립적 주체이자 복합적 구조의 데이터 데이터가 동적 바인딩 되므로 실행중에도 그 값이 변동될 수 있으며, 선언될때 크기가 정해져 있지 않음 JavaScript는 객체 기반의 스크립트 언어로써 JavaScript를 이루고 있는 거의 모든 것이 객체이다. 원시 타입을 제외한 나머지 값들(배열, 함수, 정규표현식 등)은 모두 객체이다. 참조 타입은 변수의 값이 저장된 메모리 블럭의 주소를 가지고 있고 자바스크립트 엔진이 변수가 가지고 있는 메모리 주소를 이용해서 변수의 값에 접근한다. 변수에 할당이 될 때 값이 직접 해당 변수에 저장될 수 없으며 변수에는 데이터에 대한 참조만 저장 변수의 값이 저장된 힙 메모리의 주소값을 저장 객체와 함수 는 언어의 다른 기본 요소임. 객체 =&gt; 값을 위한 컨테이너 함수 =&gt; 어플리케이션이 수행할 수 있는 절차 (procedure) Null vs UndefinedUndefined는 변수를 선언하고 값을 할당하지 않은 상태, Null은 변수를 선언하고 빈 값을 할당한 상태(빈 객체)이다. 즉, Undefined는 자료형이 없는 상태이다.따라서 typeof 를 통해 자료형을 확인해보면 null은 object로, undefined는 undefined가 출력되는 것을 확인할 수 있다. 123456789typeof null // &#x27;object&#x27;typeof undefined // &#x27;undefined&#x27;null === undefined // falsenull == undefined // truenull === null // truenull == null // true!null // trueisNaN(1 + null) // falseisNaN(1 + undefined) // true Null null은 원시값(Primitive Type) 중 하나 로, 어떤 값이 의도적으로 비어있음을 표현 한다. undefined는 값이 지정되지 않은 경우를 의미하지만, null의 경우에는 해당 변수가 어떤 객체도 가리키고 있지 않다는 것을 의미한다. null은 undefined 처럼 전역 객체의 속성 중 하나가 아니라 리터럴 값 이다. Undefined undefined는 원시값(Primitive Type) 으로, 선언한 후에 값을 할당하지 않은 변수나 값이 주어지지 않은 인수에 자동으로 할당된다. 이 값은 전역 객체의 속성 중 하나 로, 전역 스코프에서의 변수이기도 하다. 따라서 undefined 변수의 초기 값은 undefined 원시 값이다. 아래의 경우에 변수가 undefined를 반환한다. 값을 할당하지 않은 변수 메서드와 선언에서 변수가 할당받지 않은 경우 함수가 값을 return 하지 않았을 때 2. Pass by Value &amp; Pass by ReferencePass by Value, Pass by Reference 는 인수(Arguements)를 함수에 전달할때 데이터 유형에 따라 어떻게 넘겨줄지 결정하는 것으로, Call by ~ 는 함수의 입장에서, Pass by ~ 는 인수의 입장에서 설명되는 차이가 있다. Pass by Value (값의 복사에 의한 전달)Pass by Value는 인자로 넘기는 값을 그대로 복사해서 함수에 전달하는 방식입니다. 주로 Javascript 데이터 유형 중 원시값의 데이터 유형이 Pass by Value가 일어납니다. 12345678910111213141516171819202122232425function callByValue(varOne, varTwo) &#123; console.log(&quot;Inside Call by Value Method&quot;); varOne = 100; varTwo = 200; console.log(&quot;varOne =&quot; + varOne +&quot;varTwo =&quot; +varTwo); &#125;let varOne = 10; let varTwo = 20;console.log(&quot;Before Call by Value Method&quot;); console.log(&quot;varOne =&quot; + varOne +&quot;varTwo =&quot; +varTwo); callByValue(varOne, varTwo) console.log(&quot;After Call by Value Method&quot;); console.log(&quot;varOne =&quot; + varOne +&quot;varTwo =&quot; +varTwo); output will be : --------------- Before Call by Value Method varOne = 10 varTwo = 20 Inside Call by Value Method varOne = 100 varTwo = 200 After Call by Value Method varOne = 10 varTwo = 20 Pass by Reference (참조에 의한 전달)Pass by Reference는 인자로 넘기는 값의 메모리상의 주소 를 복사해 함수에 전달하는 방식입니다. 주로 Javascript 데이터 유형 중 객체 유형의 데이터가 Pass by Reference가 일어납니다. 만약 우리가 메서드에 인자로써 객체 또는 배열을 전달한다면 객체의 값을 변경할 수 있는 가능성이 생깁니다. 3. function foo() &#123;&#125; 와 var foo = function() &#123;&#125; 에서 foo 의 차이가 무엇인지 설명해보세요. 함수 선언식(Function Declarations)과 함수 표현식(Function Expressions)의 차이 함수 선언식(Function Declarations)일반적 함수 선언과 비슷한 형태 123456// 예시function funcDeclarations() &#123; return &#x27;A function declaration&#x27;;&#125;funcDeclarations(); // &#x27;A function declaration&#x27; 함수 표현식(Function Expressions)유연한 자바스크립트 언어의 특징을 활용한 선언 방식 12345// 예시var funcExpression = function () &#123; return &#x27;A function expression&#x27;;&#125;funcExpression(); // &#x27;A function expression&#x27; 함수 선언식(Function Declarations)과 함수 표현식(Function Expressions)의 차이 함수 선언식은 호이스팅에 영향을 받지만, 함수 표현식은 호이스팅에 영향을 받지 않는다. 함수 선언식은 코드를 구현한 위치와 관계없이 자바스크립트의 특징인 호이스팅에 따라 브라우저가 자바스크립트를 해석할 때 맨 위로 끌어 올려진다. 예를 들어, 아래의 코드를 실행할 때 1234567891011// 실행 전funcDeclarations();funcExpression();function funcDeclarations() &#123; return &#x27;worked&#x27;;&#125;var funcExpression = function () &#123; return 10 + 20;&#125;; Javascript 해석기에 의해 분석된 코드는 호이스팅이 적용되 아래와 같습니다. 12345678910111213// 실행 시function funcDeclarations() &#123; return &#x27;It/&#x27;s func Declarations&#x27;;&#125;var funcExpression;funcDeclarations(); // &#x27;It/&#x27;s func Declarations&#x27;funcExpression(); // Uncaught TypeError: funcExpression is not a functionfuncExpression = function () &#123; return &#x27;It/&#x27;s func Expression&#x27;;&#125;; funcExpression 에 할당될 function 로직은 호출된 이후에 선언되므로, funcExpression 는 함수로 인식하지 않고 변수로 인식한다. 즉, 선언은 위에서 됐지만 할당이 아래에서 이루어집니다. 함수 표현식(Function Expressions)의 장점 함수 표현식이 호이스팅에 영향을 받지 않는다 Closure 로 사용 (With Scope) Callback 으로 사용 (다른 함수의 인자로 넘길 수 있음) 함수 표현식을 사용한 Closure 생성12345678910111213function tabsHandler(index) &#123; return function tabClickEvent(event) &#123; // 바깥 함수인 tabsHandler() 의 index 인자를 여기서 접근할 수 있다. console.log(index); // 탭을 클릭할 때 마다 해당 탭의 index 값을 표시 &#125;;&#125;var tabs = document.querySelectorAll(&#x27;.tab&#x27;);var i;for (i = 0; i &lt; tabs.length; i += 1) &#123; tabs[i].onclick = tabsHandler(i);&#125; 위 코드는 .tab class를 가진 DOM 요소에 tabsHandler 함수를 onClick 이벤트로 바인드하는 예제로 각 탭을 클릭했을때 tabsHandler의 인자로 전달된 i 를 반환하도록 설계되어 있다.여기서 주목할 점은 탭을 클릭했을때 tabsHandler의 내부 tabClickEvent에서 console.log(index) 하기 위해 클로저 속성을 이용해 tabsHandler 함수가 가지고 있는 index 변수에 접근하며 각 탭을 클릭할때마다 서로 다른 클로저로써 서로 다른 변수 i를 참조 및 할당하고 있습니다. 그러나 만약 아래와 같이 각 탭을 클릭했을때 console.log(i) 하는 코드를 실행한다면 스코프틑 for loop문의 스코프에 존재하는 변수 i를 참조할 것이며 이에 따라 loop 문의 최종 i 값인 3을 반환할 것입니다. 12345678var tabs = document.querySelectorAll(&#x27;.tab&#x27;);var i;for (i = 0; i &lt; tabs.length; i += 1) &#123; tabs[i].onclick = function (event) &#123; console.log(i); // 어느 탭을 클릭해도 항상 tabs.length (i 의 최종 값) 이 출력 &#125;;&#125; 함수 표현식을 사용한 Callback 사용일반적으로 함수 표현식은 특정 변수에 할당해 사용하지만 그렇지 않은 경우 아래와 같이 콜배감함수로 사용할 수 있습니다. 1234567891011var arr = [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;];arr.forEach(function (ele) &#123; console.log(ele)&#125;);var digits = [1, 2, 3];var sum = arr.reduce(function (sum, ele) &#123; sum += ele return sum&#125;, 0); 4. 이벤트 루프와 동시성 모델에 대해서 설명해달라이벤트 루프는 Javascript의 동시성(Concurrency)을 지원하기 위한 개념 으로, 웹 브라우저에서는 애니메이션 효과를 보여주면서 마우스 이벤트를 입력 받아서 처리하고, Node.js기반의 웹서버에서는 동시에 여러 개의 HTTP 요청을 처리하기도 하는데 이는 Javascript가 이벤트 루프를 이용해서 비동기 함수 로직에 대한 동시성을 지원하기 때문이다. 이벤트 루프를 설명하기 위해서는 Javascript Engine이나 런타임 환경을 먼저 설명해야 합니다. Javascript의 대표적인 엔진으로 V8을 예로 들면, V8 엔진의 Memory Heap과 Call Stack으로 구성되어 있으며 Memory Heap은 메모리 할당이 일어나는 곳으로 구조화 되지 않은 넓은 개념의 메모리 영역을 지칭하고, Call Stack은 코드 실행 순서에 따라 호출 스택이 쌓이는 곳으로 하나의 작업을 완료하기 위해 제공되는 환경입니다. 그리고 Web APIs는 DOM Event, AJAX, Timer Event와 같은 사용자 인터렉션 또는 비동기 처리를 담당하며 Task Queue는 비동기 함수들이 완료된 후 실행될 콜백들이 대기하는 부분으로 FIFO의 큐 형태의 배열입니다. 이러한 구조적 메커니즘에서 Event Loop의 역할을 설명하면 만약 Timer 또는 AJAX 비동기 로직이 실행됐을 경우, 비동기 함수가 실행되고 콜백함수가 Task Queue로 이동 및 대기하는데, 비동기 함수의 작업이 완료된 후 Call Stack이 비었을 경우, Event Loop가 이를 감지해 Task Queue에서 비동기 로직 이후 실행될 콜백함수를 불러와 Call Stack에 삽입하는 역할을 합니다. 즉, Event Loop는 Javascript Engine, Web APIs 그리고 Task Queue를 지속적으로 관찰하며 동시성(Concurrency)을 지원하는 핵심개념입니다. 이런 식으로 이벤트 루프 는 ‘현재 실행중인 태스크가 없는지’와 ‘태스크 큐에 태스크가 남아있는지’ 를 반복적으로 확인합니다. 정리하면, Event Loop: (함수)호출 스택이 비워질 때마다 큐에서 콜백 함수를 꺼내와서 실행하는 역할을 함 ‘현재 실행중인 태스크가 없을 때’(주로 호출 스택이 비워졌을 때) 태스크 큐의 첫 번째 태스크를 꺼내와 실행한다. 언제나 그렇듯이, 함수를 호출하면 그 함수의 사용을 위한 새로운 스택 프레임이 생성된다. 자세한 내용은 아래 링크 참조 javascript 작동원리: https://joontae-kim.github.io/2020/10/09/javascript-operation/ 자바스크립트와 이벤트 루프: https://meetup.toast.com/posts/89 프라미스(Promise)와 이벤트 루프 내용도 추가 참고 HTML 이벤트루프 스펙 정의: https://html.spec.whatwg.org/multipage/webappapis.html#event-loops 5. 실행 컨텍스트(Execution Context)에 대해 설명해달라실행 컨텍스트 란 “실행 가능한 코드를 형상화 하고 구분하는 추상적인 개념으로 코드가 실행되고 있는 구역 또는 범위” 로 정의할 수 있습니다. Javascript 엔진은 코드를 실행하기 위해서는 변수, 인자 객체, 스코프 그리고 This에 대한 정보를 알고 있어야 하는데 이와 같은 정보는 실행 컨텍스트에 따라 달라지며 실행 컨텍스트 또한 실행 구역 또는 범위에 따라 전역 실행 컨텍스트와 함수 실행 컨텍스트로 구분됩니다. 전역 실행 컨텍스트는 전역 환경에서 실행되고 있는 코드의 환경 이고, 함수 실행 컨텍스트 는 전역 컨텍스트에서 호출 및 실행된 함수의 영역에서 실행되고 있거나 함수가 실행될때마다 생성되는 코드의 환경 입니다. 모든 실행 컨텍스트는 공통된 구조로 Lexical Environment (렉시컬 환경)과 Variable Environment (변수 환경)를 갖으며 이 둘은 변수의 참조를 기록하는 환경 이라고 할 수 있습니다. 1234ExecutionContext &#x3D; &#123; LexicalEnvironment &#x3D; &lt;ref. to LexicalEnvironment in memory&gt;, VariableEnvironment &#x3D; &lt;ref. to VariableEnvironment in memory&gt;&#125; Lexical Environment 는 Javascript 코드에서 변수 또는 함수 식별자를 맵핑하기 위해 사용되는 객체로, 식별자란 참조 대상에 대한 식별자로써 변수나 함수의 이름을 참조하며 변수는 함수 객체, 배열 객체를 포함한 실제 객체 또는 원시값에 대한 참조 입니다. Lexical Environment의 내부는 Outer Environment Reference 와 Environment Record 로 구성되어 있습니다. Outer Environment Reference 는 식별자 검색을 위해 외부 Lexical Environment를 참조하는 포인터로 중첩된 Javascript 코드에서 스코프 탐색을 위해 사용됩니다. Environment Record 는 현재 유효범위 내의 값에 식별자들의 바인딩을 기록하는 객체로 모든 지역변수를 프로퍼티로 저장하며 this 와 같은 기타 정보도 여기에 저장됩니다. 1234567891011Lexical Environment &#x3D; &#123; Outer Environment Reference, Environment Record: &#123; Object Environment Record, Declarative Environment Record: &#123; Function Environment Record, Module Environment Record &#125;, This Binding &#125;&#125; Variable Environment 은 Lexical Environment와 같이 function, 변수 식별자가 바인딩된다는 점이 동일하지만 만들어진 변수 선언 및 함수 선언에 대한 바인딩을 유지합니다. 또한, Lexical Environment는 코드 실행중에 실행 컨텍스트 내에서 변경될 수 있지만 Variable Environment는 항상 그 값을 초기화 및 선언 상태로 유지하며 일시적으로 Lexical Environment 하위에 새로운 환경을 가리키며 임시 바인딩을 보유합니다. 12345678EnvironmentRecord: &#123; Outer Environment Reference, Environment Record: &#123; Object Environment Record, Declarative Environment Record, This Binding &#125;&#125; Lexical Environment 와 Variable Environment 의 또다른 차이점으로는 Lexical Environment 은 let 과 const 키워드에 의한 함수 및 변수 선언의 바인딩을 저장하고, Variable Environment 은 var 키워드로 선언된 바인딩을 저장합니다. 자세한 내용은, 아래 링크 참조. 자바스크립트 실행 컨텍스트(Execution Context) 2 - 정의와 구조 https://joontae-kim.github.io/2020/10/15/excution-context-2/ 자바스크립트 실행 컨텍스트(Execution Context) 3 - 실행 컨텍스트의 생성과 실행 https://joontae-kim.github.io/2020/10/18/execution-context-example/ 6. Javascript Scope Chaining이란 무엇인가Javascript의 스코프 체인이란 현재 렉시컬 스코프에서 선언된 변수 또는 함수의 식별자를 검색할때, 식별자가 없는 경우 상위 렉시컬 스코프로 식별자를 연쇄적으로 찾아가는 식별자 조회 방식을 말합니다. 상위 렉시컬 스코프를 참조하기 위해 Javascript에서는 실행 컨텍스트에서 Lexical Environment 를 활용하는데 실행 컨텍스트 란 “실행 가능한 코드를 형상화 하고 구분하는 추상적인 개념으로 코드가 실행되고 있는 구역 또는 범위” 로써, 실행 컨텍스트는 새로운 실행문이 생성될때 마다 공통된 구조로 Lexical Environment (렉시컬 환경)과 Variable Environment (변수 환경)를 생성합니다. 1234ExecutionContext &#x3D; &#123; LexicalEnvironment &#x3D; &lt;ref. to LexicalEnvironment in memory&gt;, VariableEnvironment &#x3D; &lt;ref. to VariableEnvironment in memory&gt;&#125; 여기서 Lexical Environment 란 Javascript 코드에서 변수 또는 함수 식별자를 맴핑하기 위해 사용되는 객체로 식별자란 참조 대상에 대한 식별자로써 변수나 함수의 이름을 참조하며 원시값과 함수 객체, 배열 객체를 포함한 실제 객체에 대한 참조로써, 내부에는 Outer Environment Reference 와 Environment Record 가 있습니다. 바로 이 Outer Environment Reference 가 식별자 검색을 위해 외부 Lexical Environment를 참조하는 포인터로써 중첩된 Javascript 코드에서 스코프 탐색을 위해 사용됩니다. 1234Lexical Environment &#x3D; &#123; **Outer Environment Reference**, Environment Record&#125; 7. scope란 무엇이며 var, let, const에 대해 설명해달라Scope란 Javascript에서 ‘변수에 접근할 수 있는 범위’ 로, 자바스크립트 엔진이 참조의 대상이 되는 식별자 (Identifier)를 검색할때 사용하는 규칙의 집합입니다. 선언되는 환경에 따라 전역 스코프와 지역 스코프로 구분할 수 있으며 전역 스코프는 말 그래도 전역환경에 선언되어 어느 곳에서든지 해당 변수에 접근할 수 있는 범위이고, 지역 스코프 는 해당 범위에서만 접근할 수 있으며 범위를 벗어난 곳에서는 접근할 수 없다는 의미입니다. 지역 스코프의 경우 함수 스코프가 있으며 ES6(ES2015) 에서 let 과 const 키워드가 추가되면서 블록 스코프가 추가됐습니다. Javascript는 대부분의 프로그래밍 언어가 블록 레벨 스코프(Block-level Scope)를 따르는 것과 다르게 함수 레벨 스코프(Function-level Scope) 를 따르는데 함수 레벨 스코프(Function-level Scope)함수를 선언할 때마다 새로운 스코프를 생성하며 함수 내에서 선언된 변수는 함수 내에서만 유효하고 함수 외부에서는 참조할 수 없음을 의미합니다. 즉, 함수 내부에서 선언한 변수는 지역 변수라는 뜻입니다. 블록 레벨 스코프(Block-level Scope)모든 코드 블록(함수, if 문, while 문 등) 내에서 선언된 변수는 코드 블록 내에서만 유효하며 코드 블록 외부에서는 참조할 수 없습니다. 즉, 코드 블록 내부에서 선언한 변수는 지역 변수라는 뜻입니다. 함수 레벨 스코프와 블록 레벨 스코프의 차이는 변수를 선언하는 var, let, const 키워드의 호이스팅 방식에 있는데, var 키워드의 경우, 선언 단계와 초기화 단계가 한번에 이루어지기 때문에 해당 함수 스코프의 영역에서 선언되기 전에 접근할 수 있지만 undefined 를 반환하고, let 이나 const 키워드의 경우, 호이스팅의 선언 단계와 초기화 단계가 분리되어 진행되며 해당 선언문에 도달했을때 이루어지기 때문에 TDZ(일시적 사각지대) 로 인해 해당 스코프의 최상위로 끌어올려지지(hoisting) 않아 해당 블록 스코프에서만 접근할 수 있습니다. 또한, Javascript의 실행 컨텍스트를 언급할때 등장하는 스코프로 렉시컬 스코프 가 있는데, 렉시컬 스코프 란 함수를 어디에 선언했는지에 따라서 상위 스코프가 결정된다는 뜻 으로 함수의 Outer Lexical Scope 가 함수의 호출이 아니라 함수의 선언에 따라 결정된다는 것입니다. 예를 들자면, 전역변수 var x = 1 이 있고, 전역 함수 function first() , function second() 가 있습니다. first 함수 내부에서는 var x = 10 전역변수 x의 값을 재할당하며 second() 함수가 호출되면 console.log(x) 가 실행되며 호출은 first 함수 에서 호출된다고 할때 second() 함수에서 실행될 console.log(x) 의 x 는 선언 당시의 전역변수 x 의 값인 1 입니다. 왜냐하면 second 함수에서 렉시컬 스코프에 따라서 함수를 선언한 시점의 상위 스코프인 전역 환경을 참조하기 때문입니다. var, let, and const 차이점JavaScript는 변수를 선언하기 위해 언어의 복잡성을 더하는 세개의 다른 키워드가 있습니다. 3개의 키워드 차이점은 스코프(scope), 호이스팅(hoisting) 그리고 재할당(reassignment)에 바탕을 두고 있습니다. Keyword Scope Hoisting Can Be Reassigned Can Be Redeclared var Function scope Yes Yes Yes let Block scope No Yes No const Block scope No No No 8. 전역 scope를 사용했을 때 장단점에 관해 설명해달라전역 scope를 사용했을시의 장점 으로는 어플리케이션 수준에서 장점이 있을수 있는데, 절대 불변의 고정값을 가진 변수를 전역 환경에서 const 로 선언했을 경우, 모듈 또는 함수에서 일일이 선언해주지 않아도 Javascript 엔진이 Scope Chain에 따라서 변수값을 자동으로 참조할 수 있습니다. 기본값을 가지는 변수를 전역 환경에서 const 로 또는 let 으로 선언했을 경우, 기본값을 참조하는 함수의 경우 전역환경에서 자동으로 참조할 것이며 이를 만약 수정해줄경우 전역변수의 값만 수정하면 자동으로 다른 함수에서도 변수의 값을 참조하기 위해 전역변수의 값을 추적해 참고할 것입니다. 단점 으로는 전역 변수를 선언할 경우 다른 개발자와의 협업에서 우연히 같은 변수 이름을 사용해서 이전의 변수를 덮어쓴다는 불상사가 발생할 수 있으며 변수 값에 대한 불필요한 메모리를 소모할 가능성이 크다는 것입니다. 9. 자바스크립트의 호이스팅(Hoisting)은 어떻게 이루어져 있는가호이스팅이란 인터프리터가 자바스크립트 코드를 해석함에 있어서, 전역(Global) 스코프 또는 함수 스코프 안에서 var 로 선언한 변수나 함수 선언식 등을 해당 스코프의 최상위로 옮기는 동작을 말합니다. 호이스팅은 3단계에 걸쳐 생성되는데, 선언 단계(Declaration phase)변수를 실행 컨텍스트의 변수 객체(Variable Object)에 등록한다. 이 변수 객체는 스코프가 참조하는 대상이 된다. 초기화 단계(Initialization phase)변수 객체(Variable Object)에 등록된 변수를 위한 메모리 공간을 확보한다. 이 단계에서 변수는 undefined로 초기화된다. 할당 단계(Assignment phase)undefined로 초기화된 변수에 실제 값을 할당한다. var 키워드로 선언된 변수는 선언 단계와 초기화 단계가 한번에 이루어진다. (선언 및 초기화 단계) 즉, 스코프에 변수를 등록(선언 단계)하고 메모리에 변수를 위한 공간을 확보한 후, undefined로 초기화(초기화 단계)한다. 따라서 변수 선언문 이전에 변수에 접근하여도 스코프에 변수가 존재하기 때문에 에러가 발생하지 않는다. 다만 undefined를 반환한다. (할당 단계) 이후 변수 할당문에 도달하면 비로소 값이 할당된다. 이러한 현상을 변수 호이스팅(Variable Hoisting) 이라 한다. 123456789// 스코프의 선두에서 선언 단계와 초기화 단계가 실행된다.// 따라서 변수 선언문 이전에 변수를 참조할 수 있다.console.log(foo); // undefinedvar foo;console.log(foo); // undefinedfoo = 1; // 할당문에서 할당 단계가 실행된다.console.log(foo); // 1 let 키워드로 선언된 변수는 선언 단계와 초기화 단계가 분리되어 진행된다. 즉, 스코프에 변수를 등록(선언단계)하지만 초기화 단계는 변수 선언문에 도달했을 때 이루어진다. 초기화 이전에 변수에 접근하려고 하면 참조 에러(ReferenceError)가 발생한다. 즉, 변수를 위한 메모리 공간이 아직 확보되지 않았기 때문이다. 따라서 스코프의 시작 지점부터 초기화 시작 지점까지는 변수를 참조할 수 없다. 스코프의 시작 지점부터 초기화 시작 지점까지의 구간을 ‘일시적 사각지대(Temporal Dead Zone; TDZ)’ 라고 부른다. 123456let foo = 1; // 전역 변수&#123; console.log(foo); // Uncaught ReferenceError: Cannot access &#x27;foo&#x27; before initialization let foo = 2; // 지역 변수&#125; 위 예제의 경우, 전역 변수 foo의 값이 출력될 것처럼 보이지만 ES6의 선언문도 여전히 호이스팅이 발생하기 때문에 참조 에러(ReferenceError) 가 발생한다. ES6의 let으로 선언된 변수는 블록 레벨 스코프를 가지므로 코드 블록 내에서 선언된 변수 foo는 지역 변수이다. 따라서 지역 변수 foo도 해당 스코프에서 호이스팅되고 코드 블록의 선두부터 초기화가 이루어지는 지점까지 일시적 사각지대(TDZ)에 빠진다. 따라서 전역 변수 foo의 값이 출력되지 않고 참조 에러(ReferenceError) 가 발생한다. 10. 클로저(Closure)란 무엇이며, 어떻게 사용하는지, 왜 이러한 패턴을 사용하는가클로저(Closure) 는 주변 상태에 대한 참조와 함께 번들로 묶인 또는 포함된 함수와 변수의 조합인 렉시컬 환경(lexical environment)입니다. 다른 말로, 클로저는 내부 함수에게 외부 변수의 스코프에 접근할 수 있도록 해주는 것이다. Javascript에서 클로저는 함수가 생성될 때마다 생성된다. 자바스크립트 실행 컨텍스트(Execution Context) 에 대해 알고 있다면 대략 무슨 뜻인지 이해할 수 있다. 즉, 함수와 함수의 참조 환경인 Lexical Environment의 조합으로 구성된 함수 로써 자식함수가 부모함수의 Scope를 Outer Lexical Environment 로 참조(Reference)함으로써 Closer의 장점인 은닉화, 캡슐화 등의 장점을 통해 Public/Private 메서드를 흉내 낼 수 있다. 11. This; 자바스크립트에서 This란 무엇인가?this의 값은 함수가 호출되는 방식에 따라 달라집니다. 함수를 호출할 때 new 키워드를 사용하는 경우,함수 내부에 있는 this는 완전히 새로운 객체입니다. apply, call, bind가 함수의 호출/생성에 사용되는 경우,함수 내의 this는 인수로 전달된 객체입니다. obj.method()와 같이 함수를 메서드로 호출하는 경우,this는 함수가 프로퍼티인 객체입니다. 함수가 전역 스코프에서 익명함수로 호출되는 경우,위의 조건 없이 호출되는 경우 this는 전역 객체입니다. 브라우저에서는 window 객체입니다. 엄격 모드(‘use strict’) 일 경우, this는 전역 객체 대신 undefined 가 됩니다. 위의 규칙 중 다수가 적용되면 더 상위 규칙이 승리하고 this 값을 설정합니다. 일반함수의 this와 화살표 함수의 this는 어떻게 다른가?함수가 ES2015 화살표 함수인 경우, 위의 모든 규칙을 무시하고 생성된 시점에서 주변 스코프의 this 값을 받습니다. 화살표 함수와 일반 함수는 this가 다른 곳을 가리키는데, 화살표 함수의 this는 바로 상위 스코프의 this를 가리킨다. 일반 함수는 this가 동적으로 바인딩 됩니다.일반 함수의 this는 내부 함수, 콜백 함수: 전역 객체, 객체의 메소드, 생성자 함수 입니다. use strict 모드에서의 this?엄격 모드(‘use strict’) 일 경우, this는 전역 객체 대신 undefined 가 됩니다. 12. Call, Apply, Bind 함수에 대해 설명해달라(구분해서 알고있자) Call과 Apply Bind Call, Apply 함수123456function add(a, b) &#123; return a + b;&#125;console.log(add.call(null, 1, 2)); // 3console.log(add.apply(null, [1, 2])); // 3 Call과 Apply는 함수를 호출하는데 사용하며 , 첫 번째 매개변수는 함수 내에서 this의 값으로 사용됩니다. 그러나 이 둘의 차이점은 .Call은 쉼표로 구분된 인수를 두 번째 인수로 취하고 .Apply는 인수의 배열을 두 번째 인수로 취합니다. Call은 C: Comma 로 구분되며, Apply는 인수 배열인 A: arguments 라고 기억하면 쉽습니다. 그냥 실행하는 것이 아닌 첫 번째 this로 setting 하고싶은 객체를 넘겨주어 this를 바꾸고 나서 실행한다. call과 apply의 차이점은 첫 번째 인자(this를 대체할 값)를 제외하고, 실제 함수 호출에 필요한 파라미터를 넣어야 한다. call 과 다르게 apply 함수는 두 번째 인자부터 모두 배열에 넣어야 한다. Bind 함수1234567891011121314const module = &#123; x: 42, getX: function() &#123; return this.x; &#125;&#125;;const unboundGetX = module.getX;console.log(unboundGetX()); // The function gets invoked at the global scope// expected output: undefinedconst boundGetX = unboundGetX.bind(module);console.log(boundGetX());// expected output: 42 Bind 함수가 call과 apply와 다른 점은 함수를 실행하지 않으며 새로운 바인딩한 함수를 만듭니다 . 바인딩한 함수는 원본 함수 객체를 감싸는 함수로, ECMAScript 2015에서 말하는 특이 함수 객체(exotic function object) 입니다. 바인딩한 함수를 호출하면 일반적으로 래핑된 함수가 호출 됩니다. 13. 객체 지향 프로그래밍(Object Oriented Programming)과 프로토타입이란 무엇인가객체 지향 프로그래밍(Object Oriented Programming, 이하 OOP) 이란?객체 지향 프로그래밍이란 “누가 어떤 일을 할 것인가” 를 중심으로 구현된 프로그래밍 패러다임으로써, 객체 지향의 “객체”는 현실 세계의 사물을 나타내는데 각 객체는 자신의 정보를 가지고 있는 독립적인 개체(Entity)로써 각각의 성격을 띄고 있으며 이 객체가 유기적으로 상호작용 하여 작게는 하나의 기능, 크게는 하나의 어플리케이션을 프로그래밍 하는 방법 입니다. OOP의 기본 요소 클래스 (class)클래스란 1개 이상의 유사 객체의 공통된 특성(속성과 메서드)을 데이터 추상화 과정을 통해 구현한 하나의 틀(template) 로써, 객체지향 프로그램의 기본적인 사용자 정의 데이터 타입(user defined data type)이라고 할 수 있다. 다른 클래스 또는 외부 요소와 독립적으로 디자인하여야 한다. 클래스에 의해 생성된 새로운 객체(object)를 클래스의 인스턴스라 하며, 클래스로부터 새로운 객체를 생성하는 것을 인스턴스화 라고 한다. 객체 (object) 클래스의 인스턴스를 객체(object)라고 하며 필요한 속성(Attribute)과 속성을 처리하기 위한 메서드(Method)를 가진 하나의 소프트웨어 모듈이며 다른 객체들과 구별될 수 있는 이름이 있고, 실제 메모리상에 할당된 것으로 실제 프로그램에서 사용되는 데이터이다. 속성(Attribute) 객체가 가지고 있는 정보 또는 상태를 나타내며 객체의 속성, 데이터, 변수, 상수 또는 자료구조 메서드(Method) 객체가 가진 기능으로 객체의 속성을 처리하는 하나의 알고리즘이다. 객체가 메시지를 받아 실행해야 할 객체의 구체적인 연산을 정의한 것, 전통적 시스템의 함수(Function)나 프로시저(Procedure)에 해당하는 연산 기능을 수행한다. 메소드는 다른 객체로부터 메시지를 받았을 때 수행하게 된다. 메시지 (message) 메시지는 객체 간의 상호작용을 하는 데 사용되는 수단으로, 객체에게 어떤 행위를 하도록 지시하는 명령 또는 요구 사항이다. 클래스로부터 생성된 객체를 사용하는 방법으로서 객체에 명령을 내리는 것이 메시지라 할 수 있다. 메시지의 구성 요소 : 메시지를 받는 객체의 이름, 객체가 수행할 메소드 이름, 메소드를 수행할 때 필요한 인자 메시지를 받은 수신 객체는 요구된 메소드를 수행하여 결과를 반환하게 된다. OOP의 장/단점 장점 자연적인 모델링이 가능함 코드의 재사용성 증가 소프트웨어의 유지보수성 향상 대형 프로젝트 개발에 적합 단점 처리속도가 상대적으로 느림 다중 객체 생성에 따른 메모리 사용량 증가 객체 설계의 복잡도에 따른 설계시간 소용 시간 OOP에 특징에 대해 설명해달라(상속, 캡슐화 등등…)( 실제 예제는 https://developer.mozilla.org/ko/docs/Learn/JavaScript/Objects/Object-oriented_JS 를 참고하자 ) 객체 지향 프로그래밍이란 “누가 어떤 일을 할 것인가” 이며 1개 이상의 유사 객체의 공통된 특성(속성과 메서드) 가진 클래스를 통해 객체를 생성하고 상호 유기적으로 메시지를 주고 받으며 결과를 반환한다고 정리해볼 수 있으며 총 6가지 있습니다. 캡슐화 (Encapsulation) 은닉화 (Information Hiding) 추상화 (Abstraction) 상속성 (Inheritance) 다형성 (Polymorphism) 연관성 (Relationship) 캡슐화 (Encapsulation) 자료 부분과 연산(또는 함수) 부분 등 정보처리에 필요한 기능을 한 테두리로 묶는 것 연관된 데이터와 함수를 함께 묶어 외부와 경계를 만들고 필요한 인터페이스만을 밖으로 드러내는 과정 객체지향 기법의 정보 은닉 과 밀접한 기법 장점 높은 재사용성 인터페이스의 단순화 변경 또는 수정이 발생할때 오류의 파급효과가 적음 응집력이 향상됨 은닉화 (Information Hiding) 캡슐화에서 가장 중요한 개념으로, 다른 객체에게 자신의 정보를 숨기고 자신의 연산만을 통하여 접근을 허용하는 것 정보 은닉은 고려되지 않은 영향(side effect)들을 최소화함을 목적으로 함 따라서, 외부 객체가 접근하거나 사용하지 못하므로 유지보수와 소프트웨어 확장 시 오류를 최소화 할 수 있음 추상화 (Abstraction) 자료 추상화는 불필요한 정보는 숨기고 중요한 정보만을 표현함으로써 프로그램을 간단히 만드는 것으로, 모델화하는 것을 의미 자료 추상화를 통해 정의된 자료형을 추상 자료형이라고 함 추상 자료형은 자료형의 자료 표현과 자료형의 연산을 캡슐화한 것으로 접근 제어를 통해서 자료형의 정보를 은닉할 수 있다. 객체 지향 프로그래밍에서 일반적으로 추상 자료형을 클래스, 추상 자료형의 인스턴스를 객체, 추상 자료형에서 정의된 연산을 메소드(함수), 메소드의 호출을 생성자라고 한다. 상속성 (Inheritance) 상속은 새로운 클래스가 기존의 클래스의 자료와 메서드를 이용할 수 있게 하는 기능 상속을 받는 새로운 클래스를 부클래스, 파생 클래스, 하위 클래스, 자식 클래스라고 하며 새로운 클래스가 상속하는 기존의 클래스를 기반 클래스, 상위 클래스, 부모 클래스라 함 상속을 통해서 기존의 클래스를 상속받은 하위 클래스를 이용해 프로그램의 요구에 맞추어 클래스를 수정할 수 있고, 클래스 간의 종속 관계를 형성함으로써 객체를 조직화할 수 있다. 다중 상속 클래스가 2개 이상의 클래스로부터 상속받을 수 있게 하는 기능 클래스들의 기능이 동시에 필요할 때 용이하나 클래스의 상속 관계에 혼란을 줄 수 있음 (예: 다이아몬드 상속) 프로그래밍 언어에 따라 사용 가능 유무가 다르므로 주의해서 사용해야 한다. JAVA는 지원하지 않음 다형성 (Polymorphism) 상이한 클래스들이 동일한 메서드명을 갖는 것 또는 한 메시지가 객체에 따라 다양한 방식으로 응답할 수 있는 것을 의미함 일반적으로 오버라이딩이나 오버로딩을 의미함 오버라이딩: 같은 이름의 메소드가 여러 클래스에서 다른 기능을 하는 것 오버로딩: 같은 이름의 메소드가 인자의 개수나 자료형에 따라서 다른 기능을 하는 것 다형 개념을 통해서 프로그램 안의 객체 간의 관계를 조직적으로 나타낼 수 있음 연관성 (Relationship) 두 개 이상의 엔티티 형에서 데이터를 상호 참조하는 클래스간의 연관관계를 정의 객체간의 관계를 세부적으로 정의하여 구현 용이 관계성의 종류 관계성의 종류 의미 특성 is-member-of 연관화 링크 개념과 유사 is-instance-of 분류화 객체 및 클래스의 인스턴스를 표현 is-part-of 집단화 상향식, 단일 상속, 복합 객체 (composite object) 표현에 유용 is-a 특수화, 일반화 하향식, 다중 상속, 복잡한 객체 표현에 유용 프로토타입 상속이 이루어지는 법상속 이란 부모 생성자의 기능을 물려받으면서 새로운 기능도 추가하는 것을 의미합니다. 그렇다면 Prototype 기반의 Javascript는 어떻게 상속을 지원할까요? 정확히 얘기하자면, Prototype 기반의 Javascript는 상속 보다는 위임에 가깝습니다. JavaScript는 흔히 **프로토타입 기반 언어(prototype-based language)**라 불립니다. 모든 객체들이 메소드와 속성들을 상속 받기 위한 템플릿으로써 **프로토타입 객체(prototype object)**를 가진다는 의미입니다. 프로토타입 객체도 또 다시 상위 프로토타입 객체로부터 메소드와 속성을 상속 받을 수도 있고 그 상위 프로토타입 객체도 마찬가지입니다. 이를 **프로토타입 체인(prototype chain)**이라 부르며 다른 객체에 정의된 메소드와 속성을 한 객체에서 사용할 수 있도록 하는 근간입니다. 정확히 말하자면 상속되는 속성과 메소드들은 각 객체가 아니라 객체의 생성자의 prototype이라는 속성에 정의되어 있습니다. JavaScript에서는 객체 인스턴스와 프로토타입 간에 연결(많은 브라우저들이 생성자의 prototype 속성에서 파생된 __proto__ 속성으로 객체 인스턴스에 구현하고 있습니다.)이 구성되며 이 연결을 따라 프로토타입 체인을 타고 올라가며 속성과 메소드를 탐색합니다. 객체의 프로퍼티에 접근할 때, 해당 객체에 해당 프로퍼티가 없으면 JavaScript 엔진은 객체의 __proto__과 __proto__의 __proto__ 등을 보고 프로퍼티 정의가 있을 때까지 찾고, 만약 객체의 프로퍼티에 접근할 때 해당 객체에 해당 프로퍼티가 없으면 프로토타입 체인 중 하나에 있거나 프로토타입 체인의 끝에 도달할 때까지 찾습니다. 이 동작은 고전적인 상속을 흉내내지만, 실제로 상속보다 위임에 더 가깝습니다. 자바스크립트에서 상속을 진행할 때는 프로토타입끼리 연결을 하는데, 부모 프로토타입을 Object.create()나 setPropertyOf() 메서드를 사용하여 자식 프로토타입과 연결할 수 있습니다. 이런 이유로 직접적인 상속을 구현 할수는 없지만 프로토타입 확장을 이용한 상속과 같은 의미를 구현할 수 있다고 말하곤 합니다. 14. OOP와 함수형 프로그래밍의 차이함수형 프로그래밍에 대해 설명해 주세요.순수함수와 보조함수의 조합을 통해 로직내에 존재하는 조건문과 반복문을 제거하여, 복잡성을 해결하고 변수의 사용을 억제하여 상태 변경을 피하려는 프로그래밍 패러다임이다. 함수형 프로그래밍에 개념에서 순수함수 란순수함수는 같은 입력이 주어지면 같은 출력을 반환해야하고, side effect(부작용)이 없어야한다. 결국, 함수형 프로그래밍은 순수함수를 통해 side effect를 최대한 억제하여 오류를 피하고 프로그램의 안전성을 높이려는 노력의 한 방법이다. OOP와 함수형 프로그래밍의 차이객체지향과 함수형의 차이는 상태를 관리하는 점 입니다. 객체지향은 동작하는 부분을 캡슐화해서 이해할 수 있게 하고, 함수형 프로그래밍은 동작하는 부분을 최소화해서 코드 이해를 돕는다. 마이클 페더스 - ‘레거시 코드 활용 전략’ 저자 객체 지향: 상태를 저장하는 필드와 필드를 이용해 기능을 제공하는 메소드를 붙여서 클래스를 만든다. 즉, 항상 새로운 자료구조를 사용하게 되는 셈입니다. 함수형 프로그래밍: 몇몇 자료구조(list, set, map)를 이용해 최적화된 동작을 만들어냅니다. 15. 즉시 실행 함수(IIFE)란 무엇이며 언제 사용하는 것인가즉시 실행 함수(IIFE)란 정의되자마자 즉각적으로 실행되는 자바스크립트 함수(Function) 중 하나로, 종류는 기명 즉시 실행 함수 (함수의 이름이 있는 즉시 실행 함수) 와 익명 즉시 실행 함수 (함수의 이름이 없는 즉시 실행 함수) 가 있다. 형태1234567891011// 익명 즉시 실행 함수(function(arg) &#123; // statements&#125;)(params);// 기명 즉시 실행 함수var print = (function (arg) &#123; // statements&#125;)(params); console.log(print); 언제 사용하나 불필요한 충돌을 최소화하고 단 한번만 실행하는 초기화 코드에 많이 사용한다. 변수를 전역 스코프에서 변수를 선언하지 않기 때문에 전역 내 또는 내부 함수 또는 블록 스코프와 충돌 없이 구현할 수 있다. 특정 스코프를 만들 때 사용한다 익명 함수로써 레퍼런스 없이 즉각적으로 실행되기 때문에 특정 스코프를 만들 때 유용하게 사용할 수 있다. 15. 비동기 프로그래밍동기 함수(Synchronous)와 비동기 함수(Asynchronous)이란 동기 함수 는 블로킹 인 반면, 비동기 함수 는 논블로킹 처리이다. 동기 함수 에서는 다음 명령문이 실행되기 전에 앞 명령문이 완료됩니다. 이 경우, 프로그램은 명령문의 순서대로 정확하게 평가되고 명령문 중 하나가 매우 오랜 시간이 걸리면 프로그램 실행이 일시중지 될 가능성이 있습니다. 비동기 함수 는 일반적으로 파라미터를 통해서 콜백을 받고, 비동기 함수가 호출된 후 즉시 다음 줄 실행이 계속됩니다. 콜백은 비동기 작업이 완료되고 호출 스택이 비어 있을 때만 호출됩니다. 웹 서버에서 데이터를 로드하거나 데이터베이스를 쿼리하는 등의 무거운 작업을 비동기식으로 수행하여, 메인 스레드가 긴 작업을 완료할 때까지 블로킹하지 않고 다른 작업을 계속할 수 있습니다(브라우저의 경우 UI가 중지됨). Callback, Promise 란 무엇이며 각각의 장단점에 대해 설명해달라정의 Callback Function자바스크립트의 비동기성을 표현하는 가장 일반적인 기법으로, 호출된 함수를 알려줘서 다른 프로그램이나 다른 모듈에서 함수를 호출하게 하는 방법입니다.특정 함수에 매개변수로 전달되는 함수를 의미하며 함수를 전달받은 함수 안에서 호출됩니다.단점으로는 콜백지옥에 빠지면 로직이 어려워지고 가독성이 떨어지며 error 처리가 어려워질 수 있습니다. PromisePromise는 비동기 처리 로직을 추상화한 객체와 그것을 조작하는 방식으로, Callback 함수의 단점인 콜백지옥을 해결하며 동기 처리 시점을 명확하게 표현할 수 있도록 도와줘 비동기 메서드에서 마치 동기 메서드처럼 값을 반환할 수 있습니다. Callback 대신에 Promise를 사용할 때의 장점과 단점은 무엇인가요 장점가독성이 떨어질 수 있는 콜백 지옥을 피할 수 있습니다..then()을 이용하여 가독성 좋은 연속적인 비동기 코드를 쉽게 작성할 수 있습니다.Promise.all()을 사용하여 병렬 비동기 코드를 쉽게 작성할 수 있습니다. 단점약간 더 복잡한 소스코드(논쟁의 여지가 있음).ES2015를 지원하지 않는 이전 브라우저에서 이를 사용하기 위해서는 polyfill을 로드해야 합니다. Promise 코드가 어떻게 구성되어있는가Promise 는 비동기 연산이 종료된 이후의 결과값이나 실패 이유를 처리하기 위한 처리기를 연결할 수 있도록 하며 프로미스를 사용하면 비동기 메서드에서 마치 동기 메서드처럼 값을 반환할 수 있습니다. 다만 최종 결과를 반환하지는 않고, 대신 프로미스를 반환해서 미래의 어떤 시점에 결과를 제공합니다. Promise 의 작동방식을 이해하기 위해서는 Promise의 가장 뛰어난 장점 중의 하나인 chaining 에 대해 이해할 필요가 있습니다. Promise 는 비동기 작업의 최종 완료 또는 실패를 나타내는 객체로써, 기본적으로 promise는 함수에 콜백을 전달하는 대신에, 콜백을 첨부하는 방식의 객체입니다. promise가 성공했을때는 .then(successCallback) 와 같이 .then() 메서드를 통해 비동기 처리가 성공했을때 반환된 결과값을 처리할 콜백함수를 전달하면 되고, 실패했을시에는 .catch(failureCallback) 와 같이 .catch() 메서드를 통해 실패햇을때 에러 핸들링할 콜백함수를 전달해주면 된다. 1234567891011121314151617181920// Case: 콜백 함수로 처리doSomething(function(result) &#123; doSomethingElse(result, function(newResult) &#123; doThirdThing(newResult, function(finalResult) &#123; console.log(&#x27;Got the final result: &#x27; + finalResult); &#125;, failureCallback); &#125;, failureCallback);&#125;, failureCallback);// Case: Promise로 처리doSomething().then(function(result) &#123; return doSomethingElse(result);&#125;).then(function(newResult) &#123; return doThirdThing(newResult);&#125;).then(function(finalResult) &#123; console.log(&#x27;Got the final result: &#x27; + finalResult);&#125;).catch(failureCallback); Async &amp; Await는 무엇이며 Promise의 차이는 무엇인가Async &amp; Await 는 비동기 코드를 동기식으로 표현하는 더 나은 방법으로 ES8(ES2017) 에 등장했습니다. async 함수는 async 키워드로 선언된 함수이며 그 안에 await 키워드가 허용됩니다. async 및 await 키워드를 사용하면 프로미스 체인을 명시적으로 구성할 필요 없이 비동기식 프라미스 기반 동작을 보다 깔끔한 스타일로 작성할 수 있습니다. await 키워드는 Promise 객체를 받아 처리하고, 만약 비동기 함수가 아닌 동기적 함수라면 리턴 값을 그대로 받는다. Async 함수는 Promise 객체를 통해 비동기적으로 처리된 내용을 동기적인 코드 진행 순서로 보여주는 역할을 합니다. Async &amp; Await 구문의 반환값은 비동기 함수에 의해 반환된 값으로 해결되거나 비동기 함수 안에서 다뤄지지 않은 또는 예외처리로 거부된 Promise 입니다. 1234567891011121314151617181920// Case: Promise로 처리function getProcessedData(url) &#123; return downloadData(url) // returns a promise .catch(e =&gt; &#123; return downloadFallbackData(url) // returns a promise &#125;) .then(v =&gt; &#123; return processDataInWorker(v) // returns a promise &#125;)&#125;// Case: Async &amp; Await 처리async function getProcessedData(url) &#123; try &#123; let v = await downloadData(url) return processDataInWorker(v) &#125; catch (e) &#123; throw (e) // error handling &#125;&#125; 참고 Front End Interview Handbook Javascript 모음 - @cyongchoi님 블로그 front-end 개발자 인터뷰 문제 - javascript 영역 - taepcsiandwe님 블로그 &lt;FE면접질문&gt; #3. JavaScript (Part 1) &lt;FE면접질문&gt; #4. JavaScript (Part 2) 프론트엔드 개발자 면접 질문 #1 MDN 상속과 프로토타입 MDN Object prototypes MDN promise 사용하기 자바스크립트 이벤트 버블링 캡쳐링 완벽정리 자바스크립트 비동기 프로그래밍 (promise, async, await) 정리 즉시 실행 함수(Immediately-invoked function expression) - jihyehwang09님 블로그 프론트엔드 개발자를 위한 토막상식 - parksb님 블로그","categories":[{"name":"Blog","slug":"Blog","permalink":"https://joontae-kim.github.io/categories/Blog/"},{"name":"Job","slug":"Blog/Job","permalink":"https://joontae-kim.github.io/categories/Blog/Job/"}],"tags":[{"name":"Front-end","slug":"Front-end","permalink":"https://joontae-kim.github.io/tags/Front-end/"},{"name":"Interview","slug":"Interview","permalink":"https://joontae-kim.github.io/tags/Interview/"},{"name":"Job","slug":"Job","permalink":"https://joontae-kim.github.io/tags/Job/"},{"name":"Javascript","slug":"Javascript","permalink":"https://joontae-kim.github.io/tags/Javascript/"}]},{"title":"프론트엔드 면접 질문 리스트 - FE (Browser)","slug":"interview-question-fe","date":"2020-10-26T08:19:05.000Z","updated":"2021-07-26T18:43:43.151Z","comments":true,"path":"2020/10/26/interview-question-fe/","link":"","permalink":"https://joontae-kim.github.io/2020/10/26/interview-question-fe/","excerpt":"","text":"프론트엔드 면접 준비를 위한 질문 리스트 정리Front-end아래질문 리스트를 기반으로 면접 질문 &amp; 답변 목록을 작성할 예정이고, 지속적으로 보충 or 보수할 계획입니다. 업데이트 날짜 2020-10-26 2021-07-26 질문 목록 브라우저의 렌더링 과정에 대해서 상세하게 설명해달라 DOM을 건드리는 방식과 아닌 방식들의 차이는 무엇인가 CORS(Cross-Origin Resource Sharing)는 무엇인가 왜 이러한 방법이 정의 되었으며, 본인이 코드를 작성하면서 CORS와 관련하여서 경험하였던 이슈는 무엇인가 라이브러리와 프레임워크에 대해서 설명해달라 프로세스와 스레드의 차이는 무엇인가 CSR과 SSR의 차이 가비지컬렉터의 역할은? 어떻게 동작하나요? 크로스 브라우징이란 무엇인가요? 우아한 퇴보와 점진적 향상은 무엇인가요? UA문자열을 이용하여 기능 검출(feature detection)과 기능 추론(feature inference)의 차이점을 설명 하시오 FOUC (Flash Of Unstyled Content) 가 무엇이며 어떻게 해결할수 있나요? 코드 의존성과 DRY원칙 번외 호스팅 IP DNS HTTP ISP 클라이언트 to 클라이언트의 전체 흐름 1. 브라우저의 렌더링 과정에 대해서 상세하게 설명해달라렌더링 이란 서버로부터 HTML 파일을 받아 브라우저에 뿌려주는 과정 이고, 중요 렌더링 경로 (Critical Rendering Path)이란 브라우저에서 화면이 그려지기까지의 주요한 과정으로, 브라우저가 HTML, CSS, Javascipt를 화면에 픽셀로 변화하는 일련의 단계 를 말하며 이를 최적화하는 것은 렌더링 성능을 향상시킵니다. 간략하게 HTML 마크업을 Parsing(처리)하여 DOM 트리를 빌드한다. (“무엇을” 그릴지 결정한다.) (DOM 파싱) CSS Parsing(처리)하여 CSSOM 트리를 빌드한다. (“어떻게” 그릴지 결정한다.) (CSS 파싱) DOM 및 CSSOM 을 결합하여 렌더링 트리를 형성한다. (“화면에 그려질 것만” 결정) (Combination) 렌더링 트리에서 레이아웃을 실행하여 각 노드의 기하학적 형태를 계산한다. (“Box-Model” 을 생성한다.) (Layout) 개별 노드를 화면에 페인트한다.(or 래스터화) (Painting) 렌더링이 완료된 상태에서 사용자의 인터랙션에 의해 화면의 일부 영역이 변경된다면, 리플로우 또는 리페인트가 발생한다. 개략적인 과정 은 아래와 같다. 웹 페이지 또는 어플리케이션에 대한 요청은 HTML 요청으로 시작됩니다. 서버는 응답 헤더 또는 데이터로 HTML을 반환합니다. 브라우저는 HTML을 분석하고 수신된 bytes를 DOM 트리로 변환하기 시작합니다. 브라우저는 스타일시트, 스크립트 또는 포함된 이미지 참조인 외부 자원에 대한 링크를 찾을때마다 요청을 시작합니다. 불러온 Assets를 다룰 때까지 나머지 HTML을 분석하는 작업하는 일부 요청은 중단되며 차단됩니다. 파싱은 CSS file을 만났을때도 계속되지만 특히 async 또는 defer 속성이 없는 &lt;script&gt; 태그를 만났을 경우에는 렌더링을 멈추고 HTML 파싱을 중단합니다. 비록 브라우저의 프리로드(preload) 스캐너가 이 과정을 가속화하지만 과도한 스크립트는 여전히 심각한 병목현상이 될 수 있습니다. 메인 스레드가 HTML, CSS를 분석하는 동안 Preload scanner는 스크립트와 이미지를 검색할 것이고 다운로드 받기 시작할 것입니다. 스크립트가 DOM 트리 구성 프로세스를 막지 않도록 보장하기 위해, 만약 Javascript 파싱 또는 실행 순서가 중요하지 않다면 async 또는 defer 속성을 추가해야 합니다. CSS를 받기 위해 대기하는 것은 HTML 분석 또는 다운로딩은 막지 않지만 Javascript는 종종 HTML 요소에서 CSS 속성을 조회하는데 영향을 끼치기 때문에 막습니다. 브라우저는 CSSOM 구축 작업이 끝날때까지 요청을 만들고 DOM을 생성하는 HTML을 계속해서 분석합니다. DOM과 CSSOM이 완료되면 브라우저는 렌더 트리를 생성하고 보여지는 컨텐츠를 위해 스타일을 계산합니다. (Layout) 레이아웃 은 너비, 높이 그리고 렌더 트리 안에서 모든 노드들의 위치를 결정하는 과정으로, 각 노드의 위치를 계산하기 위해 렌더 트리에서 레이아웃을 작동시키는 것입니다. 페이지 안에서 각 오브젝트의 크기와 위치에 대한 결정도 추가됩니다. 리플로우 는 페이지의 특정 부분 또는 전체 도큐먼트의 어떤 연속적인 크기와 위치에 대한 결정입니다. 렌더트리가 완료된 후 모든 렌더 트리 요소들에 대한 위치와 크기가 정의된 레이아웃이 만들어집니다. 일단 완료되면 레이지는 렌더링되거나 또는 화면에 ‘그려집니다(painted)’. 2. DOM을 건드리는 방식과 아닌 방식들의 차이 이 질문에 대한 핵심 or 예상 의도모던 js 프레임워크의 가상돔 (Virtual Dom)에 대한 질문 직접 DOM을 건드리는 경우 DOM의 구조를 파악하고 있어야하며, 클래스명이다 태그명이 바뀌는 경우 다시 DOM을 변경해야한다. Angular의 경우 view와 model을 연결시키는 바인딩 작업이 있고 변화 감지를 통해서 상태를 보고 있다가 업데이트 되는 방식이다. React와 Vue의 경우 가상 DOM이 있고, 가상 DOM이 실제 DOM과 비교하여 state가 변화되었는지 감지 한다. 3. CORS(Cross-Origin Resource Sharing)1) 정의교차 출처 자원 공유(Cross-Origin Resource Sharing)의 줄임말로, 여기서 말하는 오리진이란 도메인(domain)을 naver.com 라고 한다면 오리진(origin)은 https://www.naver.com/PORT 으로 차이는 프로토콜과 포트번호의 포함 여부이다. __특정 오리진에서 작동하고 있는 웹 어플리케이션이 다른 오리진 서버로이 엑세스를 오리진 사이의 HTTP 요청에 허가를 할 수 있는 체계__를 말한다. Cross-Origin Resource Sharing 표준은 웹 브라우저가 사용하는 정보를 읽을 수 있도록 허가된 출처 집합을 서버에게 알려주도록 허용하는 특정 HTTP 헤더를 추가함으로써 동작한다. HTTP Header Description Access-Control-Allow-Origin 접근 가능한 url 설정 Access-Control-Allow-Credentials 접근 가능한 쿠키 설정 Access-Control-Allow-Headers 접근 가능한 헤더 설정 Access-Control-Allow-Methods 접근 가능한 http method 설정 2) 목적 Same-Origin Policy 웹 시큐리티의 중요한 정책 중 하나로 Same-Origin Policy 가 있다. 이는 오리진 사이의 리소스 공유 제한을 둬 아래와 같은 위험을 막고자 함 XSS (Cross Site Scripting) CSRF (Cross-Site Request Forgeries) XSS 공격자가 악성 스크립트를 신뢰할 수 있는 웹사이트에 삽입하는 방법 유저가 웹 사이트에 접속하는 것으로 정상적이지 않은 요청이 클라이언트에서 실행되는 것 Cookie 내 Session 정보를 탈취 당하는 등의 예 종류 Stored XSS: 보호되지 않고 검수되지 않은 사용자 입력으로 인한 취약점(데이터 베이스에 직접 저장되어 다른 사용자에게 표시됨) Reflected XSS: 웹 페이지에서 직접 사용되는 URL의 비보안에 의해 발생하는 취약점 DOM based XSS: 웹페이지에서 직접 사용되는 URL의 비보안에 의해 발생한 취약점이라는 점에서 reflected XSS와 비슷하지만 DOM based XSS는 서버측으로 이동하지 않는다. CSRF 웹 어플리케이션의 유저가 의도하지 않은 처리를 웹 어플리케이션에서 실행되는 것 악의적인 웹사이트, 전자 메일, 블로그, 인스턴트 메시지 또는 프로그램으로 인해 사용자의 웹 브라우저가 사용자가 인증 된 다른 신뢰할 수 있는 사이트에서 원치 않는 작업을 수행 할 때 발생하는 공격 유형이다. 접근 권한이 있는 사용자만이 접근할 수 있는 요청이 멋대로 실행되는 등의 예 이 취약점은 브라우저가 세션 쿠키, IP주소 또는 각 요청과 유사한 인증 리소스를 자동으로 보내는 경우에 발생 할 수 있다. 3) CORS와 관련 경험 또는 이슈REST API 서버 와 Web 서버 의 분리로 CORS를 해결해야 했으며 REST API 서버에 Role-based 구조를 띄고 있어 리소스 서버에 접근하기 전에 권한 검증을 위해 Preflight Request 를 구현했었음 Preflight Request 는 실제 요청 전에 인증 헤더를 전송해 서버의 접근 허용 여부를 미리 체크하는 테스트 요청으로, 서버 측에서는 브라우저가 해당 도메인에서 CORS를 허용하는지 알아보기 위해 preflight 요청을 보내는데, HTTP OPTION 메서드를 사용하며 Access-Control-Request-* 형태의 헤더로 전송한다. 이는 브라우저가 강제하며 HTTP OPTION 요청 메서드를 이용해 서버로부터 지원 중인 메서드들을 내려 받은 뒤, 서버에서 approval(승인) 시에 실제 HTTP 요청 메서드를 이용해 실제 요청을 전송하는 것이다. 개발시 참고했던 링크: Understanding Cross-Origin Resource Sharing 4. 라이브러리와 프레임워크에 대해서 설명해달라라이브러리와 프레임워크의 차이는 자유도의 차이 인것 같다. 프레임워크는 짜여진 패턴이나 틀 기반에서 내가 코딩을 하는 것이고, 라이브러리는 내가 가져다 사용해서 자유롭게 사용하는 방식이다. 1) 라이브러리라이브러리는 단순 활용가능한 도구들의 집합을 말합니다 즉, 개발자가 만든 클래스에서 호출하여 사용, 클래스들의 나열로 필요한 클래스를 불러서 사용하는 방식을 취하고 있습니다. 2) 프레임워크뼈대나 기반구조를 뜻하고, 제어의 역전 개념이 적용된 대표적인 기술입니다 소프트웨어에서의 프레임워크는 ‘소프트웨어의 특정 문제를 해결하기 위해서 상호 협력하는 클래스와 인터페이스의 집합’ 이라 할 수 있으며, 완성된 어플리케이션이 아닌 프로그래머가 완성시키는 작업을 해야합니다. 객체 지향 개발을 하게 되면서 통합성, 일관성의 부족이 발생되는 문제를 해결할 방법중 하나라고 할 수 있습니다. 3) 차이라이브러리와 프레임워크의 차이는 제어 흐름에 대한 주도성이 누구에게/어디에 있는가에 있습니다. 즉, 어플리케이션의 Flow(흐름)를 누가 쥐고 있느냐에 달려 있습니다 프레임워크는 전체적인 흐름을 스스로가 쥐고 있으며 사용자는 그 안에서 필요한 코드를 짜 넣으며 반면에 라이브러리는 사용자가 전체적인 흐름을 만들며 라이브러리를 가져다 쓰는 것이라고 할 수 있습니다. 다시 말해, 라이브러리는 라이브러리를 가져다가 사용하고 호출하는 측에 전적으로 주도성이 있으며 프레임워크는 그 틀안에 이미 제어 흐름에 대한 주도성이 내재(내포)하고 있습니다. 프레임워크는 가져다가 사용한다기보다는 거기에 들어가서 사용한다는 느낌/관점으로 접근할 수 있습니다. 5. (OS) 프로세스와 스레드의 차이 이 질문에 대한 핵심운영체제에서 작업을 실행할때 자원을 할당하는 단위를 알고 있느냐와 프로그램을 멀티 쓰레드를 구현할때 장/단점을 알고 있느냐에 대한 질문 이다. 1) 프로세스 (Process)컴퓨터에서 연속적으로 실행되고 있는 프로그램 프로그램 이란 실행 가능한 명령어의 집합으로, 여기서 얘기하는 프로그램이란 “디스크에 저장된 실행 가능한 명령어의 집합인지의 여부” 라고 말할 수 있다. 프로그램과 프로세스의 관계를 OOP (객체 지향 프로그래밍)의 클래스와 인스턴스 와 빗대어 예를 들면, 1개의 클래스에서 여러 인스턴스가 생성되듯이 1개의 프로그램에서 여러 프로세스가 생성되고 동시에 존재 가능. “메모장” 이라는 프로그램 은 하나이지만, 여러개의 메모장 (각 메모장 프로그램의 프로세스) 이 실행될 수 있으며 동시에 존재 가능 커널 메모리 안에서 관리되는 PCB(Process Control Block) 정보 외에 유저가 사용하는 메모리 공간상의 프로세스 정보는 아래와 같다. Code: 프로그램의 실제 코드 저장 Data: 프로세스가 실행될째 정의된 전역 변수. Static 변수들을 저장 Heap: 프로세스 런타임 중 동적할당 변수들을 저장 Stack: 함수 실행 등의 서브루틴 정보 저장 2) 쓰레드 (Tread)한 프로세스 내에서 동작되는 여러 실행의 흐름 프로세스가 할당 받은 자원 (주소 공간이나 자원)을 이용하는 실행의 단위 운영체제적으로는 한 프로세스 안의 스레드들은 스택(Stack)을 제외한 프로세스의 나머지 공간(Code, Data, Heap)과 시스템 자원을 공유 한 스레드가 프로세스 자원을 변경하면, 다른 스레드도 그 변경 결과를 즉시 반영한다. 3) 프로세스와 쓰레드의 차이 프로세스는 운영체제로부터 독립된 시간, 공간 자원을 할당 받아 실행된다는 점이고, 스레드는 한 프로세스 내에서 많은 자원을 공유하면서 병렬적으로(Concurrently) 실행된다는 것이다. 다른 차이는 모두 이 근본적인 차이에서 비롯된다. 스레드는 프로세스 보다 독립적이다. 자원의 할당과 공유 측면에서, 스레드는 프로세스의 하위 집합으로 여러 스레드가 동일 프로세스의 자원을 공유하지만 프로세스는 보유한 자원에 대한 별개의 주소 공간을 갖고 공유해야하며 스레드는 이 주소 공간을 공유한다. 프로세스간 통신은 스레드간 통신보다 어렵다. 프로그램의 안정성 측면에서는 스레드는 단순히 공유 변수의 수정만으로도 스레드간 통신을 구현할 수 있으며 프로세스는 OS가 제공하는 IPC 메커니즘을 통해서만 통신할 수 있으며 시스템에 의해 관리된다. 다만, 상대적으로 프로세스가 나을 수 있다. Context Switch 측면에서도, 프로세스보다 스레드가 “일반적으로” 더 빠르고 자원소모가 적다. 프로세스는 Switch 될때 Context를 PCB 등에 저장하는 등 오버헤드가 발생하나 스레드는 상대적으로 부하가 적다. 그러나 OS, 배포버전 그리고 프로세스의 지원 환경에 따라 이 점은 달라질 수 있다. 차이 프로세스 스레드 지원 할당 여부 실행 시마다 새로운 자원 할당 동일 프로세스 내 자원을 공유 자원 공유 여부 일반적으론 자원 공유 하지 않으나 같은 프로그램의 경우 코드를 공유 동일 프로세스 내 스레드들은 스택을 제외한 자원을 공유 독립성 여부 일반적으로 독립적 프로세스 내 하위 집합 주소 소유 여부 별개의 주소 공간을 갖음 주소 공간을 공유 통신 여부 오직 시스템이 제공하는 IPC 방법으로만 통신 공유 변수 수정 등 자유롭게 동일 프로세스 내 타 스레드와 소통 Context Switch 일반적으로 프로세스 보다 스레드의 Context Switching이 더 빠를 수 있음 OS, 배포버전 또는 프로세스 내 환경에 따라 유동적임 6. CSR과 SSR의 차이1) SSR (Server-Side Rendering, 서버 측 렌더링) 클라이언트 측 또는 유니버설 앱을 서버의 HTML로 렌더링합니다. 서버 렌더링은 탐색에 대한 응답으로 서버의 페이지에 대한 전체 HTML을 생성합니다. 이렇게 하면 브라우저에서 응답을 받기 전에 처리되므로 클라이언트에서 데이터 가져 오기 및 템플릿 작성에 대한 추가 왕복이 발생하지 않습니다. 2) CSR (Client-Side Rendering, 클라이언트 측 렌더링) 브라우저에서 애플리케이션을 렌더링합니다. 일반적으로 DOM을 사용합니다. 클라이언트 측 렌더링 (CSR)은 JavaScript를 사용하여 브라우저에서 페이지를 직접 렌더링하는 것을 의미합니다. 모든 로직, 데이터 가져오기, 템플릿 및 라우팅은 서버가 아닌 클라이언트에서 처리됩니다. 3) CSR SSR 장단점 4) CSR과 SSR의 차이대표적으로, 초기 View 로딩 속도, SEO 문제, 보안 문제가 있다. SSR CSR 초기 View 로딩 속도 CSR에 비해 렌더링 해야하는 파일이 적어 초기 View 로딩 속도가 빠름. 브라우저에서 페이지를 직접 렌더링해야 하므로 초기에는 오래 걸림. SEO 페이지에 대한 meta 정보가 렌더링시 이미 포함되어 있기 때문에 크롤러봇에서 데이터를 수집해가는데 용이함. 렌더링시 JS 파싱, 로딩 및 실행 순서 때문에 크롤러봇이 데이터를 수집하는데 어려움이 있음. 보안 문제 사용자에 대한 정보를 서버측에서 Session으로 관리 사용자에 대한 정보를 LocalStorage나 Cookie에서 관리해 XSS 공격에 취약함 5) 정리 SSR 방식의 경우, 초기 로딩속도가 빠르고, SEO 측면에서 유리하지만 View 변경시 서버에 계속 새로운 HTML 파일을 요청해야 하므로 서버에 부담이 큼 CSR 방식의 경우, 초기 로딩속도는 느리지만 그 다음 페이지 이동 및 처리에 있어 필요한 데이터만 요청하면 되므로 서버에 부담이 적고, 빠르게 처리할 수 있으나 SEO 측면에서 Google 크롤러봇을 제외하곤 Javascript를 실행시키지 못해 데이터 수집하는데 어려움이 있음 6) SPA + SSR ?일단 서버와 클라이언트가 Node.js 라면 가능하다 (Isomorphic Javascript). 즉, 서버와 클라이언트가 동일한 코드로 동작한다는 의미로, React의 경우 Next.js와 같이 React SSR 라이브러리를 이용해서도 구현할 수 있으며 Vue.js의 경우 Nuxt.js를 이용해 구현할 수 있다. 7. 가비지컬렉터의 역할은? 어떻게 동작하나요?메모리 할당을 추적하고 할당된 메모리 영역이 필요하지 않은 영역일 경우를 판단해서 회수하는 것.자바스크립트에서 변수는 직접적으로 참조 값(문자열, 객체, 배열 등)을 담고 있지 않고, 해당 값을 메모리 상에 저장 된다. 그래서 참조 값을 생성하고나서 더이상 참조할 것이 없거나 비어졌을 때 가비지 컬렉터가 동작해서 메모리가 반환됨. (메모리를 다시 재사용할 수 있는 상태가 된다) 8. 크로스 브라우징이 무엇인가요?크로스 브라우징은 웹 표준에 따라 서로 다른 OS 또는 플랫폼에 대응하는 것을 말한다. 브라우저별 렌더링 엔진이 다른 상황 등 어떠한 상황 속에서도 문제 없이 동작하게 하는 것을 목표로 한다. 프론트엔드 개발자는 여러가지 전략을 세울 수가 있는데, feature detection(기능 탐지)을 사용해서 해당 기능이 해당 브라우저에 있는지를 확인하는 방법을 사용할 수도 있다. 특히 한 쪽 환경에 최적화를 하는 것 보다, 전체적인 웹 표준을 지키는 데에 노력해야 한다. 1) 적용 기능의 지원 브라우저 파악 또는 Tool 사용caniuse 사이트에서 스펙 조회 또는 크로스 브라우저 테스트 툴 사용 (BrowserStack, lambdaTest, Experitest) 2) 모든 환경에서 지원해야 한다면 라이브러리를 사용하자대중적인 라이브러리는 호환성 이슈를 해결하기 위한 좋은 전략이다. ( ex) jQuery, underscore.js extJS, HTML5 polypill 라이브러리 ) 직접 구현시 ‘기능 탐지’를 이용하자 (feature detection!)12345if (isIE) &#123; attachEvent();&#125; else &#123; addEventListener();&#125; 3) 브라우저 표준에 맞게 스타일(CSS) 지원하기Reset CSS 또는 Normalize.css를 사용합니다. 아직 웹 표준이 안된 CSS 기능을 지원해주기 위해 각 브라우저들의 엔진을 벤더 프리픽스(Vender Prefix) 수동으로 또는 autoprefixer 를 자동으로 추가하자. 4) Reset.css과 Normalize.cssreset.css는 기본적으로 제공되는 브라우저 스타일 전부를 제거 하기 위해 사용된다. reset.css가 적용되면 &lt;H1&gt;~&lt;H6&gt;, &lt;p&gt;, &lt;strong&gt;, &lt;em&gt; 등 과 같은 표준 요소는 완전히 똑같이 보이며 브라우저가 제공하는 기본적인 styling 이 전혀 없다. normalize.css는 브라우저 간 일관된 스타일링을 목표로 한다. &lt;H1&gt;~&lt;H6&gt;과 같은 요소는 브라우저간에 일관된 방식으로 굵게 표시됩니다. 추가적인 디자인에 필요한 style 만 CSS 로 작성해주면 된다. 즉, normalize.css는 모든 것을 “해제”하기보다는 유용한 기본값을 보존하는 것이다. 예를 들어, sup 또는 sub 와 같은 요소는 normalize.css가 적용된 후 바로 기대하는 스타일을 보여준다. 반면 reset.css를 포함하면 시각적으로 일반 텍스트와 구별 할 수 없다. 또한 normalize.css 는 reset.css 보다 넓은 범위를 가지고 있으며 HTML5 요소의 표시 설정, 양식 요소의 글꼴 상속 부족, pre-font 크기 렌더링 수정, IE9 의 SVG 오버플로 및 iOS 의 버튼 스타일링 버그 등에 대한 이슈를 해결해준다. 9. 우아한 퇴보와 점진적 향상은 무엇인가요사용자가 항상 최신 기술을 사용할 수 있는 환경에서 서비스를 사용하지는 않는다. 특히 웹사이트를 만들 때는 최신 브라우저와 구식 브라우저를 모두 신경써야 한다. 점진적 향상법과 우아한 성능저하법은 최신과 구식에 대응하기 위한 방법을 말한다. (참고) 점진적 향상법은 기본적으로 구식 기술 환경에서 동작할 수 있는 기능을 구현하고, 최신 기술을 사용할 수 있는 환경에서는 더 나은 사용자 경험을 제공할 수 있는 최신 기술을 제공하는 방법이다. 즉, 구식 환경에서도 충분히 서비스를 사용할 수 있고, 최신 환경이라면 더 나은 기능들을 사용할 수 있도록 만드는 것이다. 구식 브라우저를 사용하는 사용자에게 100만큼의 기능을 제공하고, 최신 브라우저를 사용하는 사용자에게는 130정도의 기능을 제공하도록 웹사이트를 만든다고 보면 된다. 우아한 성능저하법은 점진적 향상법과 반대이다. 이는 최신 기술을 기반으로 기능을 구현한 뒤, 구형 기술에 기반한 환경에서도 유사하게 동작하도록 만드는 방법이다. 최신 브라우저에서는 100만큼의 기능을 제공하고, 구식 브라우저에서는 50정도의 기능만을 제공하게 웹사이트를 만드는 것이다. img 태그에 alt 속성을 지정함으로써 이미지를 보여주지 못하는 환경에서 이미지를 텍스트로 대체하는 것이 대표적인 예시다. 요약 우아한 퇴보 란 최신 브라우저를 위한 어플리케이션을 구축하는 동시에 그것이 구형 브라우저에서도 계속 작동하도록 하는 구축방법이고, 점진적 향상 는 기본 수준의 사용자 환경에 대한 응용 프로그램을 구축하지만 브라우저가 이를 지원할 경우 기능을 강화하는 방법입니다. 10. UA문자열을 이용하여 기능 검출(feature detection)과 기능 추론(feature inference)의 차이점을 설명 하시오UA 문자열 User Agent String의 약어로 브라우저에서 어떤 사이트에 접속하면 서버는 요청한 브라우저가 어떤 브라우저인지에 따라 그에 맞게 결과를 보여준다. 예를들어 내가 Chrome으로 Naver를 들어가면 Naver 서버에는 User Agent로 아래 값을 받게 될 것이다. 이러한 정보는 광고 솔루션에서 유저를 트래킹할 때도 유용하고, 특정 브라우저에서 사이트 이용을 제한할 때도 사용 할 수 있다. 1&quot;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_5) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/84.0.4147.89 Safari/537.36&quot;; 기능 검출(feature detection)브라우저가 환경이 특정 기능을 제공하거나 제공하지 않을 수있는 단서를 프로그래밍 방식으로 테스트하여 런타임 환경 간의 차이를 처리하기 위해 웹 개발에 사용되는 기술스크립트가 호출하는 기능을 사용자의 브라우저가 지원하는지 체크하는 것을 말한다. 다음은 브라우저가 GPS를 지원하는지 확인하는 코드다. 12345if (&quot;geolocation&quot; in navigator) &#123; // navigator.geolocation를 사용할 수 있습니다&#125; else &#123; // 부족한 기능 핸들링&#125; 기능 추론(feature inference)feature detection 처럼 기능을 확인하는 것은 똑같지만, A 라는 기능이 있을 때 B 도 있을거라고 추론하기 때문에 특정 상황이 아니면 사용 하지 않는 기법이다. 기능 추론도 기능 검출처럼 브라우저가 특정 기능을 지원하는지 체크하는 것이다. 하지만 ‘A기능을 지원하면 B기능도 지원할 것이다.’라는 추론이 바탕이 된다. 별로 좋지 않은 방법이다. CaseUA 문자열을 가지고 해당 유저의 환경에 대한 정보를 모두 가져 올 수 있는것을 활용해 두 패턴에 대해 예시를 들어 설명 해보자면 호환성 문제로 인해 Internet Explorer 지원을 하지 않기로 한 웹 서비스가 있다고 해보자. 그럼 이때 FE 개발자는 UA를 가지고 Internet Explorer 를 감지 할 수 있을 것이다. 12345678if (navigator.userAgent == &quot;Chrome&quot;) &#123; // navigator.userAgent는 UA 를 얻을 수 있는 메서드 // do original things&#125; else &#123; alert(&quot;IE에서는 동작하지 않습니다. chrome을 이용하세요&quot;); // Feature Detection의 예시 history.push(&quot;http://chrome-download-link&quot;); // Featrue inference의 예시&#125; 두 방식을 pseudo code 로 구현한 내용이다. alert()으로 알려주는 방식은 IE에서 잘 동작해서 경고를 띄워주겠지만(IE에서 페이지를 이동 해 주는 메서드가 없다는 전제) Feature inference 방식으로 작성한 history.push()는 IE에서 지원하지 않기 때문에 작동하지 않을 가능성이 크다.둘의 차이는 얼마나 추론과 탐지를 하느냐인데, 후자인 Feature inference는 특정 상황이 아니라면 사용하지 말아야 한다. 11. FOUC (Flash Of Unstyled Content) 가 무엇이며 어떻게 해결할수 있나요?FOUC란 무엇인가FOUC(Flash of Unstyled Content)는 브라우저로 웹문서에 접근했을때, 미처 CSS의 스타일이 모두 적용되지 못한 상태에서 화면이 표시되어 발생하는 화면 깜박임, 스타일의 적용 전과 적용 후가 그대로 화면에 노출된 상태로 변경되는 현상등을 일컫는다. 이 현상은 특히 IE(Internet Explorer) 브라우저에서 확인되는데 최신의 IE11에서도 여전히 발생되는 문제이다. 이는 해당 웹문서의 사용자 경험을 떨어뜨리는 요인으로 작용한다. FOUC 원인FOUC가 발생하는 주된 원인은 브라우저의 동작 방식과 연관이 있다. 브라우저는 마크업에 참조된 모든 부수적인 파일들을 모아 즉시 DOM(Document Object Model)을 생성 가장 빠르게 분석할 수 있는 글의 내용부분을 화면에 표시 화면에 표시된 내용을 선언된 마크업의 순서에 따라 스타일을 적용하고 스크립트를 실행 최근의 웹문서들은 여러 개의 CSS 파일을 참조하고 DOM 구조를 변경하므로 이는 더욱 빈번하게 발생하고 있다. 웹문서들은 종종 프린터와 무선 장치를 위한 CSS 규칙으로 브라우저 화면 이외의 다른 미디어에 대한 스타일 참조를 포함한다. 웹문서는 @import로 스타일 파일을 가져오고, 다른 CSS를 참조할 수 있다. 온라인 광고와 동영상과 검색 엔진같은 다른 곳에서 삽입된 콘텐츠는 종종 코드 블록 내에서 자신의 스타일 규칙을 구술한다. 웹 문서가 모두 불러와진 후 자바스크립트를 이용해 DOM 구조를 변경한다. 무엇보다도 최근에 많이 사용되고 있는 웹폰트의 경우에도 IE 브라우저에서는 FOUC를 유발해 매우 산만하고 아름답지 못한 경험을 선사한다. FOUC 해결책 FOUC를 최소화하기 위해서는 기본적으로 &lt;head&gt; 요소안에 CSS를 링크하고, @import의 사용을 자제해야 한다. 자바스크립트의 선언순서, 위치를 변경함으로써 극복 가능하거나, 매우 짧아질 수 있다.(성능을 위해 &lt;/body&gt; 요소 앞에 자바스크립트를 위치시키곤 하는데 이를 &lt;head&gt; 안으로 위치를 변경해 본다.) FOUC를 유발하는 구역을 숨겼다가 문서의 스타일이나 스크립트가 모두 적용되면 보여준다. FOUC를 유발하는 구역을 숨겼다가 다시 보여주는 방법을 아래에서 설명한다. 1234567891011&lt;html class=&quot;no-js&quot;&gt; &lt;head&gt; &lt;style&gt; .js #fouc &#123;display: none&#125; &lt;/style&gt; &lt;script&gt; (function(H)&#123;H.className=H.className.replace(/\\bno-js\\b/,&#x27;js&#x27;)&#125;)(document.documentElement) &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;fouc&quot;&gt; ... &lt;/div&gt; &lt;!-- /#fouc --&gt; &lt;script&gt; document.getElementById(&quot;fouc&quot;).style.display=&quot;block&quot;; &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; html 태그에 .no-js를 추가하고 head 태그에 스타일과 자바스크립트를 추가한다. 해당 자바스크립트는 브라우저의 자바스크립트가 활성화되어 있을 경우, html 태그의 클래스를 .js로 변경한다. 숨겨질 구역에 ID 값으로 fouc를 추가했다. 위와 같이 페이지 전체를 감싸는 영역을 지정하면 빈 페이지를 보여주다가 모든 리소스가 로드되면 페이지를 보여주게 된다. 12. 코드 의존성과 DRY원칙어떤 스크립트는 다른 추가적인 스크립트를 필요로 하기도 한다. 이때 다른 스크립트에 의존하는 스크립트를 작성할 때 해당 스크립트에 의존성이 있다고 표현한다. jQuery를 활용하는 스크립트는 의존성이 있다고 할 수 있다. 이런 경우 주석을 통해 의존성을 명시하는 것이 좋다. DRY원칙은 Don’t Repeat Yourself의 줄임말로, 소프트웨어 개발 원칙을 말한다. 한국어로는 중복배제라고 한다. 같은 작업을 수행하는 코드를 두 번 작성했다는 이를 코드 중복이라고 하는데, DRY원칙은 이러한 코드 중복을 지양하자는 원칙이다. 코드 중복의 반대 개념으로는 코드 재사용(Code reuse)이 있다. 코드 재사용은 같은 코드가 스크립트의 다른 곳에서 한 번 이상 사용되는 것을 말한다. 함수를 활용하는 것은 코드 재사용의 좋은 예로, 재사용 가능한 함수를 헬퍼 함수(Helper function)라고 한다. 코드 재사용을 권장하기 위해 개발자들은 작은 스크립트를 작성하는데, 이때문에 코드 재사용은 코드 사이에 더 많은 의존성을 만든다 번외호스팅 호스팅(hosting)이란 서버 컴퓨터의 전체 또는 일정 공간을 이용할 수 있도록 임대해 주는 서비스이다. 즉, 호스팅 업체가 회사나 개인에게 항시 가동중인 서버를 임대 해 주고 그 대가를 받는 서비스가 호스팅이다. Web을 제공하는 회사들은 대부분 별도의 호스팅 서버를 운용하여 외부 요청에 응답한다. 즉, 24시간 꺼지지 않도록 해야하며 필요하다면 이중화구조로 장애 발생시에도 응답에 문제가 없도록 대처 할 수 있도록 구성해야 한다. 최근에 Twitch에서 스트리머들의 생방송을 본 적이 있는데, 이때에도 A 라는 스트리머가 방송을 종료하며 B 라는 스트리머에게 시청자들을 호스팅 한다는 개념이 등장한다. 쉽게 이해하기 위해서는 영어 단어 그대로 Host + ~ing 이므로 주최(Host)하다 로 이해할 수도 있을 것 같다. IPInternet Protocol의 준말로 송신 호스트와 수신 호스트가 패킷 교환 네트워크에서 정보를 주고받는 데 사용하는 정보 위주의 규약(프로토콜, Protocol)이며, OSI 네트워크 계층에서 호스트의 주소지정과 패킷 분할 및 조립 기능을 담당한다. 그냥 쉽게 데이터가 어떤 규약에 의해 주고받아지고, 이를 분해해서 보내고 조립해서 사용자에게 보여주는 규약이다. 그리고 이를 기반으로 한 IP 주소는 장치들이 서로의 위치를 인식하고 통신하기 위해 사용하는 번호이다. IP주소는 모든 네트워크를 지원하는 장비에 할당되어있다. 우리가 쓰는 스마트폰부터, 랩탑, 데스크탑, 심지어 애플워치나 인공지능 스피커까지 다양하게 있다. DNS위에서 설명한 IP 주소의 형태는 IPv4 기준으로 172.16.254.1 같은 표기법을 가지고 있는데, 사용자가 매번 이런 IP 주소를 외우기는 쉽지 않기 때문에 더 쉽게 IP 주소를 알아내개 위해 만든 것이 Domain이고 이를 관리하는 곳이 Domain Name Server(DNS)이다. DNS의 주 기능은 특정 컴퓨터(또는 네트워크로 연결된 임의의 장치)의 주소를 찾기 위해, 사람이 이해하기 쉬운 도메인을 숫자로 된 식별 번호(IP 주소)로 변환해 준다. DNS에는 우리가 아는 KT나 LG유플러스를 시작으로, CloudFlare나 Google 도 DNS 를 가지고 있다. 우리가 흔히 사용하는 www.google.com 이나 www.naver.com 도 Domain으로 DNS에서 IP 주소로 변환된다. 당연히 이런 이름들은 중복되서는 안되기 때문에 DNS에서는 이를 조절해준다. 또한 서로 다른 DNS로 정보를 전달하는 시간때문에 DNS 등록 직후 바로 조회되지 않고 각 DNS 업데이트 주기에 맞추어 1~2일 정도 있다가 사용 가능해지기도 한다. HTTP간단하게 Request와 Response를 통해 이뤄지는 통신 구조로 두 서버끼리 연락할 때 그 방식을 정해놓은 규약이라고 보면 된다. 우리가 흔히 쓰는 GET, POST, DELETE, PATCH, PUT ··· 는 HTTP Request이고, 200 OK, 300 Rediredt, 404 Not Found 등은 HTTP Response의 종류이다. 또한 무상태 Stateless이기 때문에 단순히 통신만으로는 로그인 정보, 방문 횟수 등의 브라우저 정보를 저장할 수 없고 이를 위해서는 쿠키나 세션을 이용해야만 한다. HTTP 규약은 전통적으로 HTTP/1.x을 사용되었지만 TLS 추가, 속도 및 기능이 개선된 HTTP/2를 사용하는 것이(아마 나도모르게 사용하고 있겠지만) 여러모로 더 낫다. ISPSP(Internet service provider)는 인터넷에 접속하는 수단을 제공하는 주체를 가리키는 말이다. 쉽게 말해 Web(거미줄)을 물리적으로 만드는 곳이라고도 볼 수 있는데, 대륙간 통신이나 적도에서 극지방에 이르기까지 광섬유를 산넘고 바다건너 지하에다가 쭉 깔아두는 회사라고 보면 된다. 혹자는 위성 인터넷을 쓰면 되지 않느냐고하는데, 맞다. 위성 인터넷도 하나의 대안일 수 있지만 위성까지 왕복하는 거리가 광섬유로 연결하는 것보다 배이상 길기 때문에 지연시간도 거기에 정비례하게 되기 때문에 속도나 안정성 측면에서 광섬유로 연결하는것이 낫다. ISP도 다 같은 ISP가 아니고 Tier 1, 2, 3으로 구분된 제공자로 구분된다. Tier 1은 주로 대륙간 트래픽 교환을 담당하고 Tier 2는 Tier 1과 3을 이어주는 중매및 피어링을 담당한다.(다른 ISP끼리 트래픽을 교환하는 것) 우리가 가장 가까이에서 볼 수 있는 Tier는 Tier 3으로 대한민국에서는 KT, Uplus 등이 이에 해당한다. 클라이언트 to 클라이언트의 전체 흐름 전체적인 흐름은 사용자가 특정 도메인 주소를 주소창에 입력하는 것부터 시작해서 요청한 도메인의 컨텐츠가 화면에 나오는 것까지를 다룬다. 다음은 www.google.com을 요청하는 것을 예시로 한다. 웹 서버로 요청 사용자는 주소창에 www.google.com을 입력한다. 브라우저는 해당 도메인을 HTTP 규약에 맞춰 데이터 패킷을 준비한다. 준비된 패킷은 랜선 혹은 AP를 통해 해당 지역의 Tier 3 ISP 까지 전달된다. 이때 클라이언트는 빠른 응답을 위해 Cache Server에 캐싱 해 놓은 결과가 있는지 먼저 확인하고 만약 캐시된 데이터가 있으면 더 진행하지 않고 이를 다시 클라이언트에 되돌려준다. ISP는 DNS를 겸하기도 하기 때문에 요청으로 들어온 www.google.com의 IP 주소를 확인한다. 만약 해당 DNS에 정보가 없다면 다른 DNS 서버에 해당 도메인이 있는지 확인한다. 216.58.220.142 가 www.google.com 의 IP 주소임을 브라우저가 알게 된다. 브라우저는 해당 IP 주소로 HTTP Request를 보낸다. Google의 WAS(Web Application Server)는 요청을 받아서 DB작업 필요하다면 이를 처리한다. 사용자 요청에 맞는 컨텐츠를 Status Code같은 내용과 함께 HTTP Response로 돌려 보낸다. 다시 수많은 Router들과 ISP를 거쳐 사용자의 브라우저에 컨텐츠가 도달한다. 웹 서버로부터 응답 받고 브라우저가 하는 일 처음 브라우저가 응답을 받으면, 브라우저가 가지고있는 파서를 이용해 HTML문서를 브라우저가 이해할 수 있는 DOM 트리 형식으로 파싱한다. CSS를 파싱하여 스타일 구조체의 형식으로 만든다. 이를 CSSOM이라고 한다. DOM과 CSSOM을 실제 화면에 표현하기 위한 데이터 구조인 렌더링 트리로 변환한다. 해당 렌더링 트리를 그리고 화면에 표시한다. 참조 HTML 기초 - 3 (렌더링이란?) CORS(Cross-origin Resource Sharing) CORS 개념과 간단한 XSS ,CSRF 소개 프레임워크와 라이브러리의 차이점 Process와 Thread의 차이 프로세스와 스레드의 차이 [OS] 프로세스와 스레드의 차이 A Closer Look at Client-Side &amp; Server-Side Rendering 서버 사이드 렌더링(SSR)과 클라이언트 사이드 렌더링(CSR) SPA에서의 SSR과 CSR 웹 렌더링 프론트엔드 개발자 면접 질문(기술면접) 정리 기능이 제한된 브라우저의 페이지는 어떻게 처리하나요? 어떤 기술/프로세스를 사용하나요? 브라우저 별로 스타일이 다른 문제를 어떤 접근 방법으로 해결하나요? 개발자-인터뷰-문제-javascript-영역 [과학을 이해하는 개발자] 화면 깜빡임(FOUC) 문제해결 Javascript 기초 - 별에서 온 그대, Web이 동작하는 방식 - samslow님 블로그","categories":[{"name":"Blog","slug":"Blog","permalink":"https://joontae-kim.github.io/categories/Blog/"},{"name":"Job","slug":"Blog/Job","permalink":"https://joontae-kim.github.io/categories/Blog/Job/"}],"tags":[{"name":"Front-end","slug":"Front-end","permalink":"https://joontae-kim.github.io/tags/Front-end/"},{"name":"Interview","slug":"Interview","permalink":"https://joontae-kim.github.io/tags/Interview/"},{"name":"Job","slug":"Job","permalink":"https://joontae-kim.github.io/tags/Job/"}]},{"title":"프론트엔드 면접 질문 목록","slug":"interview-question-list","date":"2020-10-26T05:38:17.000Z","updated":"2021-07-22T05:33:56.017Z","comments":true,"path":"2020/10/26/interview-question-list/","link":"","permalink":"https://joontae-kim.github.io/2020/10/26/interview-question-list/","excerpt":"","text":"Interview Question Summary프론트엔드 면접 준비를 위한 질문 리스트 정리!아래 질문 리스트를 기반으로 면접 질문 &amp; 답변 목록을 작성할 예정이고, 지속적으로 보충 or 보수할 계획입니다. 업데이트 날짜 2020-10-26 2020-10-28 FE (Browser) 질문 목록 수정 Security 항목 추가 FE (Browser) 브라우저의 렌더링 과정에 대해서 상세하게 설명해달라 DOM을 건드리는 방식과 아닌 방식들의 차이 CORS(Cross-Origin Resource Sharing)는 무엇인가 왜 이러한 방법이 정의 되었으며, 본인이 코드를 작성하면서 CORS와 관련하여서 경험하였던 이슈는 무엇인가 라이브러리와 프레임워크에 대해서 설명 프로세스와 스레드의 차이 CSR과 SSR의 차이 가비지컬렉터의 역할은? 어떻게 동작하나요? 크로스 브라우징이란 무엇인가요? 우아한 퇴보와 점진적 향상은 무엇인가요 Security 보안은 서버쪽에서 많이 신경쓰고 있지만, 프론트엔드 개발에서 보안관련 이슈는 어떠한 것들이 있는가 Wireshark 에 대해 알고 있는가 HTTP 통신의 문제점에 대해서 아는대로 말해달라 CORS(Cross-Origin Resource Sharing)는 무엇인가 왜 이러한 방법이 정의 되었으며, 본인이 코드를 작성하면서 CORS와 관련하여서 경험하였던 이슈는 무엇인가 간단한 데이터를 클라이언트로만 관리 할수 있는가, 이와 관련해서 브라우저 에서 어떠한 것들을 지원하고 있는가, 예를 들면 소셜 로그인같은 것들에 대한 브라우저 종료시 발생하는 문제에 대응 경험이 있는가 Network Http와 Https 통신 방식의 차이? 웹 프로토콜이란 CORS(Cross-Origin Resource Sharing)는 무엇인가 왜 이러한 방법이 정의 되었으며, 본인이 코드를 작성하면서 CORS와 관련하여서 경험하였던 이슈는 무엇인가 RESTful API 가 무엇인가, 아는대로 다 말해달라 Programming 타입스크립트를 사용해본 경험이 있는가, 타입스크립트에 대한 본인의 생각과 도입시의 장점을 말해달라 메소드 체이닝이란 무엇이며, 이것의 장단점은 무엇인가? 메모라이제이션이란 배포를 해본적이 있는가? 어떻게 배포를 해보았나 쓰로틀링과 디바운스 JS 실행 컨텍스트(Execution Context)에 대해 설명해달라 DOM (Document Object Model) 이벤트 버블링(Event Bubbling), 이벤트 캡쳐링(Event Capturing)에 대해서 설명하세요. 이벤트 위임(event delegation)에 대해 설명하세요. Javascript Scope Chaining 전역 scope를 사용했을 때 장단점에 관해 설명해주세요. 이벤트 루프와 동시성 모델에 대해서 설명 document load와 DOM Content Loaded의 차이 document load : DOM을 비롯한 모든 asset이 로드된 후 발생 DOM Content Loaded : 초기 html 문서가 완전히 로드되고 나면 파싱 후 발생 attribute와 property attribute : HTML 마크업에서 정의 property : DOM에서 정의 호스트 객체(Host Objects)와 네이티브 객체(Native Objects)의 차이점은 무엇인가요? 호스트 객체 : 빌트인 또는 네이티브 객체에 포함되지 않은 사용자에 의해 생성된 객체 ⇒ js는 빌트인 및 네이티브 객체 구성 후 호스트 객체를 해석 네이티브 객체 : 브라우저 혹은 구동 엔진에 내장되어 있는 객체 DOM이 이에 해당 ⇒ 구동앤잔 별 사용성이 달라서 크로스 브라우징 문제를 바랭시키기도 함 자바스크립트의 원시 타입(Primitive Data Type)은 몇가지이며, 전부 말해달라 Number, String, Boolean, Null, Undefined, (Symbol) null vs undefined use strict 은 무엇이고, 사용했을 때 장단점에 관해서 설명해주세요. 클로져(Closure)는 무엇이며, 자바스크립트의 Number Type은 다른 언어들과 차이점이 무엇인가, 왜 하나만 존재하는가 자바스크립트의 순환참조란? 어떤게 문제이고 해결방법은? function foo() &#123;&#125; 와 var foo = function() &#123;&#125; 에서 foo 의 차이가 무엇인지 설명해보세요. ES6에서 화살표 함수와 일반 함수의 차이는 자바스크립트의 배열(Array)이 실제 자료구조 배열이 아닌데 그 이유는? 자바스크립트의 호이스팅(Hoisting)은 어떻게 이루어져 있는가 클로저(Closure)란 무엇이며, 어떻게 사용하는지, 왜 이러한 패턴을 사용하는가 This 자바스크립트에서 This는 몇가지로 추론 될수 있는가, 아는대로 말해달라 일반함수의 this와 화살표 함수의 this는 어떻게 다른가? Call, Apply, Bind 함수에 대해 설명해달라 use strict모드에서의 this? 프로토타입이란 객체 지향 프로그래밍(Object Oriented Programming) OOP에 특징에 대해 설명해달라(상속, 캡슐화 등등…) 현실에 상황을 예로 들어 OOP의 개념으로 설계과정을 설명해달라ex) 축구를 게임으로 만든다거나, 기타 어떠한 상황이라도 좋다 프로토타입 상속이 이루어지는 법 함수형 프로그래밍(Function Programming) 함수형 프로그래밍에 대해 설명해달라 함수형 프로그래밍에 개념에서 순수함수란 무엇인가 OOP와 함수형 프로그래밍의 가장 큰 차이점은 무엇인가 OOP와 함수형 프로그래밍의 차이 ES6 크롬 정도의 브라우저를 제외하곤 ES6 스펙에 대한 지원이 완벽하지 않다. 해결방법은 무엇인가 Babel이란? babel은 컴파일러 인가 ? 트랜스파일러인가 ES6 에서 추가된 스펙에 대해 아는대로 다 말해달라 var 와 let, const의 차이점은 무엇인가 (function scope와 block scope의 개념에서) Class 는 무엇이고, Prototype, fucntion의 ES5 스펙만으로 Class를 구현할수 있는가 익명함수와 함수 즉시 호출 비동기 프로그래밍 동기 함수와 비동기 함수 AJAX란 무엇인가 Callback 함수란 Promise 함수 Promise와 Callback의 차이점은 무엇이며 각각의 장단점에 대해 설명해달라 Promise란 무엇이며 코드가 어떻게 구성되어있는가 async, await는 무엇이며 Promise의 차이는 고차함수 (High-Order Function) JSON이 무엇이며 사용하면 어떠한 장점이 있나요? JSONP의 동작 크로스 도메인 이슈에 의해 ajax 요청이 허용 되지 않아 우회용으로 많이 쓰임 ⇒ script 태그를 통해 callback 쿼리 매게 변수를 요청함 모듈 패턴과 전통적 상속, 각각의 장단점을 Call by value &amp; call by ref 디자인 패턴 CSS CSS cascading system CSS 적용 우선순위 CSS selector 동작원리 선택자 하위 선택자 : 부모요소에 포함딘 모든 하위 요소에 스타일 적용 자식 선택자 : 부모 바로 아래 자식 요소에만 적용 float float 속성 해제 방법 이미지 대체 컨텐츠 이미지 숨기기 inline vs inline-box px and em inline vs inline block Progressive Rendering 개발사 접두어 반응형과 적응형 웹 반응형 웹의 3요소 미디어 쿼리, 플루이드 그리드, flexible img @media속성 모바일 우선 전략 w3c box iebox Position 요소 자식 중앙 정렬 And 나머지는 여기서 =&gt; https://yangshun.github.io/front-end-interview-handbook/kr/css-questions HTML Doctype 표준모드와 쿼크모드 다국어 서비스 제공방법 HTML5를 개방형 웹 플랫폼으로 간주할 때, HTML5의 구성 요소는 무엇인가요? &lt;script async&gt;, &lt;script defer&gt; 사이의 차이점을 설명하세요. script async : 페이지 파싱과 동시에 비동기적으로 진행 script defer : html 구문 분석이 끝나면 스크립트 파일 실행 script : html 파싱 도중 정지하고 실행 window 객체란 무엇입니까? DOM 블록요소와 인라인요소 웹 스토리지 쿠키, 로컬 스토리지, 세션 스토리지의 정의와 차이점 FOUC 브라우저로 웹 문서에 접근할 때 CSS 스타일이 미적용된 모습이 화면에 노출되며 생기는 깜빡임 CSS를 &lt;head&gt; 안에 import하고 @import 사용 자제 FOUC를 보여주는 요소를 js를 통해 숨긴 후 script가 모두 적용된 후 보여줌 XML과 HTML XML은 웹 브라우저 외에도 포괄적으로 사용되는 형식으로 데이터 교환에 특화되어 있으며 이것 만으론 데이터를 가지고 있을 뿐 화면에 표시되지 않는다. HTML은 웹 브라우저에서 사용하는 문서 형식이며 XHTML은 HTML규격이 가진 문제를 극복하고 확장기능을 제공한다. CSS와 JS 문서의 위치 CSS를 안에 넣으면 페이지 로딩 중 스타일 적용이 안 된 DOM의 모습을 안보이게 하고 js를 앞에 놓으면 CSS로딩 직후 로딩 되어 사용자가 조금 빠르다고 느낄 수 있다. 기능이 제한된 브라우저 페이지 만들기 우아한 퇴보, 점진적 향상 Single Page Application 최초 한 번 페이지를 전체 로드한 후 데이터만 변경하여 사용 가능한 어플리케이션 클라이언트 사이드 랜더링 : 서버는 JSON 파일만 보내주고 html을 그리는 건 자바스크립트가 담당 html 다운로드 ⇒ js 다운로드 및 해석 ⇒ Fetch Data 서버 사이드 랜더링 : html 다운로드 ⇒ 사용자가 봄 Vue Vue를 선택한 이유 Vue의 장점 vue에서의 라이프사이클? vue와 React의 차이? 가상돔 (virtual DOM) 면접관을 Vue.js 비사용자라고 가정하고 Vue.js에 설명하고 장단점을 말해달라 Vue.js의 Life-cycle에 대해 아는대로 말해달라 Vue.js 에서 DOM은 어느 시점에 생성되나 Computed와 Methods의 차이점은 무엇인가 가상돔(Virtual DOM) 개념은 무엇이며, DOM과의 차이점 가상돔의 개념이 사용되게된 배경은 무엇인가 최근의 프레임워크를 사용할때 외부 라이브러리와의 결합시에 더 나은 코드 작성법을 고민해본적이 있는가 DOM을 직접 조작하는 D3.js 같은 라이브러리와의 결합시에 예상되는 문제점이 있는가 State 관리 Vuex 상태 관리 &amp; Redux 개발외 질문 목록 왜 개발자가 되려고 하는가 개발자로서의 본인의 비전을 이야기 해달라 비전공자로써 갖고 있는 컴플렉스가 있는가 운영체제같은 컴퓨터공학(cs)에 대한 기초지식이 있는가 최근에 관심갖거나 공부 하고 싶은 개발 기술은 무엇인가 프로젝트 협업 과정을 경험한 적이 있는가 공부 방법 개발자가 되기 위해서 어떻게 공부하였는가 학습시 주로 이용하는 웹페이지나, 동영상 강좌 페이지는 어디인가 최근의 읽은 개발 관련 서적은 무엇인가 즐겨 보는 개발 관련 유튜브가 있는가 회사 기술 스택에 맞추어 단기간 내에 언어와 프레임워크를 학습 하여야 할 때, 어떻게 공부하고 해결할 것인가 포트폴리오 제작시에 비인기 라이브러리를 사용한 경험이 있는가 이러한 비인기 라이브러리에 대한 정보를 어디서 얻는가 왜 활용하였는가 FE 개발 환경 Eslint가 무엇인가요 Webpack이란 패키지매니저로 어떤거 사용? npm npm과 yarn은 어떤게 다른가 AMP AMP의 개념은 무엇이고 기존의 것에 비해 장점은 무엇인가 최근의 프레임워크들과의 조합을 고려해 본적이 있는가 ex) vue-amp.. package.json 파일의 역할 package.json에서 dependencies와 devDependencies의 차이는 git 두 명의 프론트엔드 개발자가 있다 git을 관리하는 방식? git pull request rebase 와 다른 방법 자료구조(Data Structure) &amp; 알고리즘 자료구조에 대해 공부한 적이 있는가 Binary Search Tree 에 대해 알고 있는가, 설명해달라 Graph 에서 다른 노드를 참조하는 구조를 코드로 구현 할수 있는가 https://daniel-park.tistory.com/category/Alogorithm?page=1 https://www.educative.io/blog/javascript-data-structures 리스트 관련 링크 https://velog.io/@honeysuckle/%EC%8B%A0%EC%9E%85-%ED%94%84%EB%A1%A0%ED%8A%B8%EC%97%94%EB%93%9C-%EB%A9%B4%EC%A0%91-%EC%A7%88%EB%AC%B8-%EB%AA%A8%EC%9D%8C https://mber.tistory.com/2 https://sunnykim91.tistory.com/121 https://devowen.com/283 https://devowen.com/276 인터뷰 관련 링크 브라우저는 어떻게 동작하는가? http://d2.naver.com/helloworld/59361 최신 웹사이트와 꼼꼼한 개발자들을 위한 완벽 프론트엔드 체크리스트 https://github.com/kesuskim/Front-End-Checklist 예비 개발자들의 기술 면접 준비를 위한 자료 https://github.com/JaeYeopHan/Interview_Question_for_Beginner 프론트엔드 인터뷰 핸드북 https://github.com/yangshun/front-end-interview-handbook/tree/master/Translations/Korean Awesome Interview Questions https://github.com/MaximAbramchuck/awesome-interview-questions 프론트엔드 면접 문제 은행 https://github.com/h5bp/Front-end-Developer-Interview-Questions/tree/master/Translations/Korean","categories":[{"name":"Blog","slug":"Blog","permalink":"https://joontae-kim.github.io/categories/Blog/"},{"name":"Job","slug":"Blog/Job","permalink":"https://joontae-kim.github.io/categories/Blog/Job/"}],"tags":[{"name":"Front-end","slug":"Front-end","permalink":"https://joontae-kim.github.io/tags/Front-end/"},{"name":"Interview","slug":"Interview","permalink":"https://joontae-kim.github.io/tags/Interview/"},{"name":"Job","slug":"Job","permalink":"https://joontae-kim.github.io/tags/Job/"}]},{"title":"Javascript와 객체 지향 프로그래밍","slug":"javascript-oop","date":"2020-10-21T17:03:05.000Z","updated":"2021-04-06T15:55:18.326Z","comments":true,"path":"2020/10/22/javascript-oop/","link":"","permalink":"https://joontae-kim.github.io/2020/10/22/javascript-oop/","excerpt":"","text":"“객체 지향 언어”와 “프로토타입 기반”의 JavascriptJavascript를 소개할때 가장 먼저 언급되는 키워드로 “Javascript는 객체 지향 언어로써…” 또는 “Javascript는 Prototype 기반 언어로써…” 라는 말일것이다. 그 어떤 입문서적 또는 온라인 입문 강좌를 둘러봐도 빠지지 않는 말이고 Javascript의 성질을 잘 이해하고 잘 쓰고 있다고 하려면 저 두 가지는 반드시 이해하고 있어야 한다고 많이들 얘기한다. 예전에도 객체 지향과 prototype에 대해 공부했었으니 이번에는 조금이라도 더 낫겠지 싶은 마음으로 다시 자료들을 찾아봤다. 이전에도 공부하면서 참고했던 블로그들을 검색하고 모아놓고, MDN에서도 설명하는 객체 지향과 프로토타입에 관한 포스팅들도 읽고 또 읽었다. 읽고 정리하다보면 차근차근 이해되고, 이해가 되지 않는 부분은 상세히 설명해주시는 개인 블로그와 해외 블로그도 많이 참고했다. 그래서?읽고, 정리하고, 예제를 살펴보는 몇 번의 과정 끝에 머리속 결론은… “그래서?” 였다. 무엇을 말하는지는 이해는 됐다. 좀 더 정확하게 표현하자면, Javascript에서는 객체지향을 어떻게 구현했는지는 피상적인 수준에서 이해가 됐다. Javascript는 객체 지향 언어로써 Java의 Class와 다르게 Prototype으로 객체 지향 언어를 구현하고 있다는 것을. 그리고 객체는 현실 세계의 사물을 나타내는데 생성자 함수를 통해 “객체 지향”의 객체를 생성할 수 있으며 생성자 함수 내에 속성(property)과 행동(method)를 지정하면 생성된 객체들은 공통된 속성과 행동을 사용할 수 있으며 필요에 따라서는 객체의 원형(prototype)에 메서드를 추가하거나 상속을 구현해 확장할 수도 있다는 것을. 근데 뭔가 확 와닿지 않았다. 그냥 이해를 하고 넘어가면 될거 같았지만 한번쯤 “왜 객체 지향일까?” 에 대해 deep하게 파보고 싶었다. 일단 검색하기 전에 왜 이해가 안 가는지부터 알아내는 것이 먼저라고 생각했다. 코드 되새김질과 장애물 발견일단 객체 지향적 코드와 익숙한지 점검해보기 위해 이전에 짰던 코드부터 조금씩 되새겨봤다. 특정 기능을 구현하기 위해서 함수를 만들고 그 안에 변수와 로직을 설계하고 로직이 너무 길어지거나 타 함수와 중복되는 로직이 있을 경우 따로 분리해 처리함수를 구현 및 호출하는 구조로 재설계 및 구현하고 마지막으로 처리된 데이터를 반환(return) 특정 메소드를 구현하기 위해 위와 같은 플로우로 많이 개발했고 객체 지향 프로그래밍 관점에서 말하는 구조와 다르다는 것까지는 이해했다. 그리고 한가지 궁금한 점이 생겼다. “객체 지향에서는 그럼 특정 기능에 대한 함수 실행절차는 어떻게 구현되지???” 바로 이 질문 때문에 이해는 됐지만 겉도는 느낌이 들었던 것이었다. 더 알아보자. 객체와 절차(원론적이고 개념적인 내용은 생략하겠습니다.) 구글링을 열심히 한 결과 나와 같은 고민을 한 사람들이 있었고 여러 포스팅에서 공통적으로 언급됐던 링크가 있었고 바로 스파게티코드님의 “객체지향 vs 절차지향??” 였다. 결론부터 말하자면, 객체지향적 개발 패러다임이든 절차지향적 개발 패러다임인 방법론적 차이만 있을뿐 둘다 정해진 알고리즘에 따라 순서대로 실행되는건 마찬가지라는 것 이다. 아래는 자판기의 간단한 기능에 대해 두 패러다임을 비교분석한 예제입니다. 기능개발 분석 알고리즘 분석 위 그림에서 볼 수 있듯이 분석과 알고리즘 구현에 있어서 실행 내용은 모두 같으나 처리하고자 하는 방식이 다를뿐이다. 스파게티코드님은 블로그에서는 아래와 같이 정리했다. 절차지향은 프로그램을 “기능 중심”으로 구현 하고, 객체지향은 “누가 어떤 일을 할 것인가”를 중심으로 구현 객제지향은 절차를 ‘간소화’ 해주는 것이지 결코 절차를 무시하는 것이 아니다. 객체란 기존의 방식인 변수 따로, 함수 따로의 분산적이고 통일성 없는 실행절차 과정을 추상화 과정으로 통합하여 표현대상(문제해결 대상)을 좀 더 모듈화 또는 캡슐화 하기 쉽게 도와주는 도구에 불과하며 객체지향 프로그래밍은 단지 이러한 객체(데이터)의 디자인을 먼저 한뒤 데이터플로우를 짜고 진행 시나리오를 설계해 나아가는 방식의 개발 방법론일 뿐이다. 어찌보면 이 모듈성 강화의 부산물인 은닉화, 상속 및 다형성을 통한 확장성과 재사용성, 이에 기반한 생산성과 유지보수의 용이성이 OOP의 진정한 특징이자 정체성일지도 모른다. 플로우차트(절차 지향)를 먼저 하느냐 데이터모델링(객체 지향)을 먼저 하느냐의 차이일뿐 그 이후로는 둘다 정해진 알고리즘에 따라 순서대로 실행되는건 마찬가지. 다만, OOP 방식에 충실한 프로그래밍은 모듈화가 더 체계적으로 될 수 있다는 것이다. 즉, 두 패러다임 모두 정해진 또는 설계된 알고리즘에 따라 실행되지만 절차지향은 기능을 중심으로 설계되어 알고리즘에 따라 실행되는 것이고, 객체지향의 경우 문제해결 대상(객체)에 초점을 맞추어 각 대상이 해야하는 기능(함수)과 데이터(변수)를 정리하고(추상화와 모듈화) 각 실행 단계에 따라서 필요한 대상을 생성해(객체의 인스턴스화) 특정 행위를 위한 기능과 데이터만을 호출하는 방식으로 알고리즘에 따라 실행된다는 것이다. 마치며거의 3일 동안 “객체지향…. 객체지향…. 객체지향…. 왜 객체지향일까…”, “뭔 뜻인지는 알겠는데 객체는 그럼 어떻게 함수들을 실행해가는걸까…” 등 뭔가에 가로막힌 느낌을 갖고 객체지향을 공부했었는데 이젠 한결 가벼운 마음과 가까워진 개념으로 조금더 쉽게 공부하고 정리하고 사용할 수 있을거 같다. 그리고 3일 동안 중간중간 시간도 빠듯한데 괜히 공부하고 외우는 것으로 끝낼까 했는데… 신기하게도 이번 3일이라는 시간동안 봐왔던 스파게티코드님의 “객체지향 vs 절차지향??” 이라는 블로그와 jhnyang님의 “[C/C++] 절차지향언어와 객체지향언어의 관점 차이, 절차지향 프로그래밍과 객체지향 프로그래밍은 무엇일까요 “ 그리고 이 외의 여러 블로그를 읽으면서 이해한 객체지향의 의도를 이해한 것이 기술적 문서만 봤을때보다 머리에 훨씬 오래 남고, 굳이 암기하려고 하지 않아도 자연스레 머리에 남는 현상을 느껴 시간은 소비했지만 암기보다 좋은 효과를 느껴 반반의 이득을 얻었다고 정리하고 싶다. 참고 객체지향 vs 절차지향?? jhnyang님의 “[C/C++] 절차지향언어와 객체지향언어의 관점 차이, 절차지향 프로그래밍과 객체지향 프로그래밍은 무엇일까요 “ 명령형 프로그래밍 절차지향과 객체지향 언어의 차이, 장단점, 코드 비교, 용도 총정리 객체 지향","categories":[{"name":"Programming","slug":"Programming","permalink":"https://joontae-kim.github.io/categories/Programming/"},{"name":"Javascript","slug":"Programming/Javascript","permalink":"https://joontae-kim.github.io/categories/Programming/Javascript/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://joontae-kim.github.io/tags/javascript/"},{"name":"oop","slug":"oop","permalink":"https://joontae-kim.github.io/tags/oop/"},{"name":"prototype","slug":"prototype","permalink":"https://joontae-kim.github.io/tags/prototype/"},{"name":"object-oriented-javascript","slug":"object-oriented-javascript","permalink":"https://joontae-kim.github.io/tags/object-oriented-javascript/"}]},{"title":"Javascript 객체(Object) - 기본","slug":"js-object","date":"2020-10-21T04:22:42.000Z","updated":"2020-10-31T18:18:40.155Z","comments":true,"path":"2020/10/21/js-object/","link":"","permalink":"https://joontae-kim.github.io/2020/10/21/js-object/","excerpt":"","text":"Javascript의 데이터 타입(Data type)에 대해 공부할때 우리는 원시형(Primitives Type 또는 기본형)과 참조형(Reference Type) 데이터로 분류할 수 있으며 원시형을 제외한 모든 데이터 유형은 객체라고 정의했었습니다. 그렇다면 Javascript에서 객체란 무엇이며, Javascript에서의 객체 유형과 내부 속성인 property와 method에 대해서 알아보겠습니다. 객체(Objects)에 대한 기본정의Javascript에서 객체란 Pass by Reference 분류되는 데이터 타입으로써 메모리상의 식별자(Indentifier)을 통해 참조된다. 또한 &#123;key: value&#125; 와 같은 키와 값이 매핑된 복합적 형태의 데이터 구조로 키는 문자열이고 값은 원시값 또는 다시 객체가 할당될 수도 있다. Javascript 의 객체 구성요소 Javascript의 표준인 ECMAScript에서는 Object에 대해 크게 3가지로 분류하고 있습니다. Built-In Object Native Object Host Object Built-In Object (내장 객체)Built-In 객체 에는 Javascript 엔진이 구동되는 시점에서 즉시 제공 되는 객체로써 Global, Object, String, Number, Boolean, Date, Array, Math, RegExp, Error 가 있다. 위 객체들은 전역 객체(Global Object), 래퍼 객체(Wrapper Object), 표준 객체 (Standard Object)로 구성되어 있으며 래퍼 객체(Wrapper Object) 는 원시 타입의 프로퍼티에 접근하려고 할때 생성되는 임시 객체를 말하고, 표준 객체 (Standard Object) 는 다른 객체의 기초가 되는 핵심 객체로서 자주 사용되는 객체로는 Number , Math , Date , String , Array 가 있다. Native Object (브라우저 내장 객체)내장 객체와 똑같이 Javascript 엔진이 구동되는 시점에서 즉시 제공되는 객체이며 내장 객체이지만, 차이점은 브라우저마다 구성을 다르기 때문에 내장객체와 다르다고 한다. 브라우저 내장 객체로는 BOM(Browser Object Model) 과 DOM(Document Object Model) 가 있다. Host Object (사용자 정의 객체)Host 객체 는 말 그대로 Host === 사용자 가 생성한 객체로, constructor 혹은 Object Literal(객체 리터럴) 방식을 사용자(혹은 개발자)가 정의하고 확장한 것으로 Built-In 객체 와 Native Object(브라우저 내장 객체) 가 생성된 이후에 구성된다. 이번에 우리가 다루게 될 객체는 Built-In 객체 이자 최상위 레벨의 객체(Top-Level-Object) 인 Object 객체 입니다. 객체 참조 - 프로퍼티와 메소드우리는 객체 리터럴 방식으로 생성한 person 이라는 객체 하나를 가지고 있다. 12345678910var person = &#123; last: &#x27;James&#x27;, first: &#x27;Bond&#x27;, getLastName () &#123; return this.last; &#125;, getFirstName () &#123; return this.first &#125;&#125; 위 person 객체의 last 프로퍼티에 접근해 값을 얻고자 한다면 우리가 사용할 수 있는 방법은 두가지이다. 아래 코드를 보자. 123456// 점(.) 표기법person.last // &#x27;James&#x27;person.getLastName() // &#x27;James&#x27; (메소드 호출)// 대괄호 표기법person[&#x27;last&#x27;] // &#x27;James&#x27; 객체 이름(person)은 네임스페이스 처럼 동작하며 객체 내에 캡슐화 된 프로퍼티에 접근하기 위해서 점 표기법과 대괄호 표기법 둘다 사용 가능하며 메서드에 접근하기 위해서는 점 표기법을 사용하면 된다. 한가지 흥미로운 점은 Javascript에서 Array 요소 접근법인 대괄호 표기법이 객체에서도 사용되는 것인데 배열의 각 요소를 인덱스 숫자로 매핑하는 것과 유사하게 객체는 각 프로터피를 &#123;key: value&#125; 구조로 매핑하며 따라서 객체에서도 한 프로퍼티에 접근하기 위해 대괄호 표현법에서 프로퍼티의 key를 사용할 수 있는 것입니다. 이러한 점 때문에 객체가 간혹 연관배열 (associative arrays) 이라고 불리며 배열이 숫자를 값에 연결하는 것과 같은 방법으로 스트링을 값에 매핑합니다. 객체 생성자우리는 Javascript 코드로 크고 작은 기능들을 개발하면서 수 많은 객체를 생성하게 된다. 이 객체들은 Built-In 객체 인 Object 객체 의 인스턴스(instance) 입니다. 그럼 객체를 생성하는 방법으로는 위에서 사용하는 리터럴 방식 외에는 무엇이 있을까? 리터럴 표기법을 통한 객체 생성Javascript에서 객체를 생성하기 위한 가장 일반적이고 쉬운 방법으로 프로퍼티와 메소드를 직관적으로 설정할 수 있다. 12345var cat = &#123; name: &#x27;나비&#x27;, age: 3, family: &#x27;korean Short Hair&#x27;&#125; 생성자 함수 (Constructor function)을 통한 객체 생성Javascript에서는 new 연산자를 사용하여 객체를 생성하고 초기화할 수 있는데 이때 사용되는 메소드를 생성자(constructor) 라고 하며, 이 메소드는 새롭게 생성되는 객체를 초기화하는 역할을 합니다. 123456789 // Cat에 관한 생성자 함수function Cat (name, age, family) &#123; this.name = name; // name에 관한 프로퍼티 this.age = age; // age에 관한 프로퍼티 this.family = family; // family에 관한 프로퍼티&#125;// cat 객체는 Cat라는 프로토타입을 갖게 된다.var cat = new Cat(&#x27;나비&#x27;, 3, &#x27;korean Short Hair&#x27;) Object Create() 메소드를 통한 객체 생성Object.create() 메소드는 지정된 프로토타입(prototype) 객체와 프로퍼티를 가지는 새로운 객체를 생성할 수 있으며 사용자가 프로토타입 객체를 직접 명시할 수 있다는 특징이 있다. 12345var cat = Object.create(null, &#123; name: &#x27;나비&#x27;, age: 3, family: &#x27;korean Short Hair&#x27;&#125;); 프로퍼티와 메소드 그리고 this아래의 person 객체를 보자. 코드를 훓어보면 대략 사람의 이름이 설정되어 있는것으로 추측할 수 있으며 그 속성을 반환(return) 하는 함수들이 있다는 정도로 추측 또는 알 수 있다. 바로 사람의 이름과 같은 속성을 프로퍼티(property) , 속성을 반환(return) 하는 함수를 메소드(method) 라고 한다. 12345678910var person = &#123; last: &#x27;James&#x27;, first: &#x27;Bond&#x27;, getLastName () &#123; return this.last; &#125;, getFirstName () &#123; return this.first &#125;&#125; 프로퍼티 (Property)프로퍼티란 객체에 붙은 변수(Variable) 로써 프로퍼티가 객체의 속성을 규정한다고 할 수 있다. 프로퍼티와 변수는 기본적으로 똑같으며 프로퍼티의 이름은 대소문자를 구별 하며 객체 이름 또한 해당되며 Javascript의 문자열 또는 문자열로 변환 가능한 어떤 것도 가능하나 빈 문자열(&#39;&#39;)의 경우 가능은 하나 Javascript의 식별자(Indentifier)로써 적합하지 않다(- , &#39;&#39;, 숫자로 시작하는 이름도 해당). 메소드 (Method)메소드란 객체의 프로퍼티 중 함수인 것으로 일반 함수와 같은 방식으로 정의할 수 있다. ECMAScript 6 부터 더 짧은 구문으로 메서드를 정의할 수 있게 됐다. 1234var obj = &#123; foo: function() &#123;&#125;, bar: function() &#123;&#125;&#125;; 1234var obj = &#123; foo() &#123;&#125;, bar() &#123;&#125;&#125;; 주의할 점 은 단축 구문은 기명(named) 함수로 정의해야한다. 왜냐하면 메모리에서 함수를 참조하기 위한 식별자(Identifier)가 생기기 때문입니다. thisJavascript에서 this 는 함수가 실행될 때 this가 호출되고 있는 함수 또는 객체의 스코프를 가리키는 키워드로써, 객체 메서드 내부의 this 는 객체를 가리킨다. 본 섹션의 person 객체의 메서드에서 호출하고 있는 this 키워드가 그 예이다. getter 와 setter 메소드getter 메소드 는 특정 프로퍼티의 값을 받아오기 위한 메소드이자 접근자 프로퍼티 이며 setter 메소드 는 특정 프로퍼티의 값을 설정하기 위한 메소드로 ECMAScript 5 에 정의되었다. getter 메소드get 구문은 어떤 프로퍼티에 접근할 때마다 해당 프로퍼티의 값을 계산해 반환하거나 내부 변수의 상태를 명시적인 함수 호출없이 보여주고 싶을때 사용할 수 있다. 12&#123;get prop() &#123; ... &#125; &#125;&#123;get [expression]() &#123; ... &#125; &#125; 위 구문에서 prop 은 주어진 함수를 바인딩할 프로퍼티의 이름이고, [expression] 은 ES6부터 함수의 이름을 계산(computed) 하기 위한 표현식을 사용할 수 있다. get 구문을 이용할 떄는 다음을 유의해야 한다. 숫자나 문자열로 구성된 식별자를 이용할 수 있습니다. getter는 절대로 매개변수를 가져서는 안 됩니다. (Incompatible ES5 change: literal getter and setter functions must now have exactly zero or one arguments 를 참조하세요.) 하나의 객체 리터럴에 또다른 getter나 데이터 바인딩은 불가능합니다. (&#123; get x() &#123; &#125;, get x() &#123; &#125; &#125; 나 &#123; x: ..., get x() &#123; &#125; &#125; 는 사용할 수 없습니다.) getter는 delete 연산자를 이용해 삭제할 수 있습니다. 기본적인 사용법은 아래와 같다. 12345678var obj = &#123; log: [&#x27;example&#x27;,&#x27;test&#x27;], get latest() &#123; if (this.log.length == 0) return undefined; return this.log[this.log.length - 1]; &#125;&#125;console.log(obj.latest); // &quot;test&quot; setter 메소드set 구문은 특정 프로퍼티의 값을 변경하기 위해 함수를 실행하기 위해 사용한다. 12&#123;set prop(val) &#123; . . . &#125;&#125;&#123;set [expression](val) &#123; . . . &#125;&#125; 위 구문에서 prop 은 주어진 함수를 바인딩할 프로퍼티의 이름이고, val 은 prop에 설정될 값을 가지고 있는 변수명이다. [expression] 은 ES6 부터 추가된 세부 문법으로 주어진 함수에 바인딩 되는 프로퍼티의 이름을 계산(computed) 을 통해 얻을 수 있다. 그리고 주의할 점은 실제 값을 가지는 프로퍼티와 프로퍼티의 setter 를 동시에 갖는 것은 불가능하다. 왜냐하면 Setter는 유사 객체(pseudo property) 타입을 생성하는 메소드이기 때문이며 getter 또한 동일하다. set 문법을 사용할 때 다음을 유의한다: 숫자혹은 문자로된 식별자를 가질 수 있다; 한 개의 파라메터만 가질 수 있다.(더 자세한 정보는 Incompatible ES5 change: literal getter and setter functions must now have exactly zero or one arguments를 본다); 오브젝트 리터럴에 동일한 property에 대한 다른 set 이나 데이터 항목이 올 수 없다.( &#123; set x(v) &#123; &#125;, set x(v) &#123; &#125; &#125; 그리고 &#123; x: ..., set x(v) &#123; &#125; &#125; 는 허용되지 않는다.) setter는 delete operator를 사용하여 제거할 수 있다. 기본 사용법은 아래와 같다. 123456789101112var cat = &#123; set currentSnack (snack) &#123; this.snacks[this.snacks.length] = snack; &#125;, snacks: []&#125;cat.currentSnack = &#x27;달고나&#x27; // 달고나cat.snacks // [&#x27;달고나&#x27;]cat.currentSnack = &#x27;커피&#x27; // 커피cat.snacks // [&#x27;달고나&#x27;, &#x27;커피&#x27;]cat.currentSnack // undefined cat 객체의 유사 객체(pseudo property)로 currentSnack 이 정의되었으며 이 프로퍼티의 매개변수인 snack 이 설정될 때마다 snacks 프로퍼티의 값이 갱신된다. 참조 Javascript 객체 기본 - https://developer.mozilla.org javascript 기초 - Object 이해하기 - http://insanehong.kr Working with objects - https://developer.mozilla.org setter - https://developer.mozilla.org getter - https://developer.mozilla.org 객체의 생성 - http://tcpschool.com 객체의 개념 - http://tcpschool.com Javascript 객체(Object)","categories":[{"name":"Programming","slug":"Programming","permalink":"https://joontae-kim.github.io/categories/Programming/"},{"name":"Javascript","slug":"Programming/Javascript","permalink":"https://joontae-kim.github.io/categories/Programming/Javascript/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://joontae-kim.github.io/tags/javascript/"},{"name":"Object","slug":"Object","permalink":"https://joontae-kim.github.io/tags/Object/"}]},{"title":"함수 (function)","slug":"js-function","date":"2020-10-20T09:21:06.000Z","updated":"2020-10-25T10:36:03.092Z","comments":true,"path":"2020/10/20/js-function/","link":"","permalink":"https://joontae-kim.github.io/2020/10/20/js-function/","excerpt":"","text":"기본적으로 함수란 특정 기능을 구현한 집합체, 특정 문제 또는 필요로 하는 요구사항를 해결하기 위해 수행하는 코드의 묶음 또는 블록으로, Javascript에서 함수는 한번 구현해놓으면 재호출해 코드의 재사용성을 높일 수 있으며 함수 내 특정 변수를 숨기기 위한 캡슐화와 기능을 세분화해 코드의 유지보수의 용이성과 확장성을 높힐 수 있습니다. Javascript 함수(Function)의 구조는 아래와 같이 구성되어 있습니다. 함수명(function name) 함수블록 내에서 처리하기 위해 전달되는 매개변수들(Parameter)과 인자(Argument) 함수의 기능을 구현하기 위한 몸체(function body) 또는 구문(statement) 1234567// 함수 정의function name(para, meter) &#123; // statement&#125;// 함수 호출name(&#x27;argue&#x27;, &#x27;ment&#x27;) Javascript에서 함수(Function)은 원시값과 객체 데이터 타입 중 객체(Object)에 속하는 타입으로, 특히 Javascript의 함수는 일급 객체(First-class object) 로써 동적 생성과 리터럴 방식으로 함수를 생성할 수 있으며 변수(Variable), 배열(Array) 내 요소, 객체의 프로퍼티(Property) 등에 할당 가능하다는 특징을 가지고 있습니다. 함수 정의하기Javascript에서 함수를 정의하기 위한 방법으로는 여러가지가 있으며 대표적으로는 함수 선언문(Declarations), 표현식(expressions) 그리고 ECMAScript 6에서 추가된 화살표 함수(Arrow function)이 있다. 비고 : Function 생성자(constructor)로 함수를 정의하는 것은 JS 엔진 최적화를 방해 또는 기타 다른 문제를 유발할 수 있는 이유로 권장되지 않는 방식입니다. 함수 선언문(Declarations)Javascript에서 함수를 정의하기 위해 사용되는 가장 대표적인 방법으로, 서두에서 언급한 함수 구조를 띄고 있다. 1234567// 함수 정의function decFunction(para, meter) &#123; return para + meter&#125;// 함수 호출decFunction(&#x27;argu&#x27;, &#x27;ment&#x27;) // &#x27;argument&#x27; 함수명 : 함수 또는 구현된 기능을 대표하기 위한 함수의 이름으로 일반적 함수 호출, 재귀적 호출 그리고 실행 컨텍스트에서 memory 상에 함수를 올리기 위한 식별자(Identifier)의 목적으로 함수 선언문에서는 생략할 수 없는 필수요소이다. 매개변수 : 함수 등에서 사용되는 전달된 값을 받는 변수로써, 함수의 기능상 외부 환경에서 데이터를 받아 가공 및 반환이 필요할 경우 함수 내부로 전달하는 역할을 하며 콤마(,) 로 구분하여 최대 255개까지 받을 수 있습니다. 함수 구문 : 함수의 로직을 담당하는 부분으로 중괄호 &#123;&#125; 안에 매개변수를 받아 데이터를 처리하거나 DOM을 조작하는 등 필요에 따른 특정 기능을 담고 있는 중추적 부분입니다. 인자: 함수에 전달되는 인수의 배열집합으로써, 정확히는 유사배열 객체로 arguments 객체라 칭하며 매개변수를 통해 전달받은 함수 외부환경의 값, 변수 또는 참조 반환값 : 함수 내부에서 처리된 값으로 return 키워드를 통해 처리된 값을 반환할 수 있다. 또한 함수의 코드상 종료시점에 return 구문이 없다면 함수는 undefined 를 반환하도록 Javascript에서는 설계되어 있다. 함수 표현식(expressions)함수 선언문(Declarations)과 다르게 함수를 변수에 할당한다는 점이 다른 점으로 함수의 일급 객체(First-Class Object) 의 특성을 이용한 함수식이다. 구조적 요소는 함수 표현식과 같으나 코드상 구조는 변수에 할당한다는 점이 다르다. 아래를 보자. 12345678910111213// Anonymous function expression (익명 함수 표현)var expFunction = function (para, meter) &#123; return para + meter&#125;// Named function expression (기명 함수 표현)var expNamedFunction = function namedFunction (para, meter) &#123; return para + meter&#125;console.log(expFunction(&#x27;argu&#x27;, &#x27;ment&#x27;)); // &#x27;argument&#x27;console.log(expNamedFunction(&#x27;argu&#x27;, &#x27;ment&#x27;)); // &#x27;argument&#x27;console.log(namedFunction(&#x27;argu&#x27;, &#x27;ment&#x27;)); // Uncaught ReferenceError: expNamedFunction is not defined 함수 표현식은 함수명을 생략하는 익명 함수 방식의 선언이 일반적이지만 기명 함수 표현으로 생성했을 경우, 스택 트레이스에 함수 이름이 포함되어 오류의 원인을 쉽게 찾을 수 있다는 이점 이 있습니다. 그리고 함수를 할당 받은 변수는 기명 함수라고 할지라도 함수명을 저장하는 것이 아니라 기명이든 익명이든 함수의 참조값을 저장하게 된다. 위 두개의 함수 정의문은 모두 함수 리터럴 방식 의 함수생성법으로 결국 Function Contstructor 함수로 함수 정의 방식을 단축화한 것으로 *일종의 축약법(short-way)*이라고 할 수 있다. 클로저(Javascript의 클로저 개념은 다룰게 많기때문에 여기서는 함수와 클로저의 관계와 중심적 내용만 다루고 넘어가겠습니다. 자세한 내용은 포스팅할 예정입니다.) Javascript의 함수를 언급할때 빠지지 않는 것이 있다면 바로 Closure 일 것이다. Closer 란 무엇인지 MDN에서 정의한 Closure 에 대한 내용을 보자. A closure is the combination of a function bundled together (enclosed) with references to its surrounding state (the lexical environment). In other words, a closure gives you access to an outer function’s scope from an inner function. In JavaScript, closures are created every time a function is created, at function creation time. closure 는 주변 상태에 대한 참조와 함께 번들로 묶인 (포함된) 함수의 조합입니다. (lexical environment). 다른 말로, 클로저는 내부 함수에게 외부 변수의 스코프에 접근할 수 있도록 해주는 것이다. Javascript에서 클로저는 함수가 생성될 때마다 생성된다. 이전에 포스팅한 자바스크립트 실행 컨텍스트(Execution Context) 에 대해 알고 있다면 대략 무슨 뜻인지 이해할 수 있다. 즉, 함수와 함수의 참조 환경인 Lexical Environment의 조합으로 구성된 함수로써 자식함수가 부모함수의 Scope를 Outer Lexical Environment 로 참조(Reference)함으로써 Closer의 장점인 은닉화, 캡슐화 등의 장점을 통해 Public/Private 메서드 를 흉내낼 수 있다. 이해를 돕기 위해 예제를 보자. 123456789function isUnder30 (age) &#123; let min = 30; function checkAge (age) &#123; return age &lt; min; &#125; return checkAge(age)&#125;isUnder30(29) // true 위 예제는 중첩 함수로써, 위에서 말한 클로저의 정의와 환경에 충족하고 있다. 실행 환경을 분석해보자. 실행 컨텍스트 스택에 전역 실행 컨텍스트 push isUnder30 가 호출 및 실행되면서 isUnder30 함수의 실행 컨텍스트가 push Lexical Environment에 변수 min, 내부함수 checkAge 그리고 Outer Lexical Environment로써 전역 실행 컨텍스트가 정의 및 참조되고 외부함수로 정의 가능한 isUnder30 함수가 checkAge 함수를 return 하면서 checkAge 함수를 호출하고 isUnder30 함수의 함수 실행 컨텍스트는 종료된다. 그리고 내부함수인 checkAge 가 호출 및 실행되면서 checkAge 함수의 함수 실행 컨텍스트가 push Lexical Environment에 변수 min, 인자 age 그리고 Outer Lexical Environment로써 isUnder30 함수 실행 컨텍스트가 정의 및 참조되고 실행되는 동안 min 변수 값을 내부 스코프에서 검색하지 못함으로써 Outer Lexical Environment에서 검색해서 값을 가지고 와서 return age &lt; min; 결과값을 반환(return) 하면서 checkAge 함수의 실행 컨텍스트 또한 종료된다. 위 순서를 보면 checkAge 가 isUnder30 보다 오래 유지되었고, checkAge가 실행되는 동안 isUnder30의 지역 스코프을 참조해 값을 반환하고 종료되었다. 이처럼 내부함수가 외부함수보다 오래 유지되었고, 내부함수가 외부함수의 지역 스코프(=Outer Lexical Environment)를 참조 및 접근할 수 있는 함수를 **클로저(Closure)**라고 한다. 함수 호이스팅호이스팅이란 변수와 함수 선언을 코드가 실행되기 이전에 그들의 스코프의 최상위로 옮기는 Javascript 메커니즘으로 함수와 변수가 전역이든 지역 스코프든 그들의 스코프에 상관없이 최상위로 옮겨집니다. 그렇다면 함수는 호이스팅에 어떤 영향을 받으며 함수의 정의 방법에 따른 호이스팅의 차이는 어떻게 될까? 함수 선언문12345678910function firstDecFn(para, meter) &#123; return para + meter&#125;firstDecFn(&#x27;argu&#x27;, &#x27;ment&#x27;) // &#x27;argument&#x27;secondDecFn(&#x27;argu&#x27;, &#x27;ment&#x27;) // &#x27;argument&#x27;function secondDecFn(para, meter) &#123; return para + meter&#125; 기본적으로 함수 선언문은 Javascript 호이스팅의 기본 타겟 중 하나로 위 예제에서 firstDecFn 함수처럼 먼저 선언하고 후에 호출하든 secondDecFn 함수처럼 먼저 호출하고 나중에 선언하든 함수 선언문은 Javascipt의 호이스팅으로 모두 최상위로 끌어올려져 정상작동합니다. 함수 표현문12345678910var firstDecFn = function (para, meter) &#123; return para + meter&#125;firstDecFn(&#x27;argu&#x27;, &#x27;ment&#x27;) // &#x27;argument&#x27;secondDecFn(&#x27;argu&#x27;, &#x27;ment&#x27;) // Uncaught TypeError: secondDecFn is not a functionvar secondDecFn = function (para, meter) &#123; return para + meter&#125; 결론부터 말하면 함수 표현문은 hoisting(끌어올림) 되지 않는다. 왜냐하면 Javascript Engine의 Parser 부분을 이해하면 쉬운데 Parser는 스크립트 내 변수를 분석할때 변수의 선언과 할당이 분리해 실행한다. 설명을 위해 간단한 변수 호이스팅을 예를 들어보자. 12345678// 우리가 작성한 코드console.log(x);var x = 100;-----------------------------------------------------------------------------------// JavaScript Parser가 해석한 코드var x;console.log(x);x = 100; 위 예제에서 “우리가 작성한 코드” 부분을 보면 console.log(x) 에서 변수 x를 호출하고, 다음줄에 var x = 100 이라고 선언했다. 그러나 “JavaScript Parser가 해석한 코드” 를 보면 선언과 할당 이 분리되어 있음을 볼 수 있다. 이러한 원리가 바로 Hoisting이고 함수 표현식으로 작성된 함수 또한 이 원리를 따르며 함수표현식의 예제를 Javascript가 해석한 코드로 변환하면 아래와 같다. 123456789101112var firstDecFn;var secondDecFn;firstDecFn = function (para, meter) &#123; return para + meter&#125;firstDecFn(&#x27;argu&#x27;, &#x27;ment&#x27;) // &#x27;argument&#x27;secondDecFn(&#x27;argu&#x27;, &#x27;ment&#x27;) // Uncaught TypeError: secondDecFn is not a functionsecondDecFn = function (para, meter) &#123; return para + meter&#125; 그렇다면 함수 표현식은 hoisting에 적용받지 못해 TypeError도 나는데 쓰지 말아야할까? 그것은 아니다. 함수 표현식이 가지고 있는 장점 또한 있다. 클로저 사용 콜백 함수 (함수의 인자로서 함수표현식으로 선언된 함수를 전달) 즉시 실행 함수 (IIFE) 매개변수(Parameter)와 인자(Argument)설명을 위해 예제 함수를 만들어보자. 12345function example(pa,ra,me,ter) &#123; return pa + ra + me + ter&#125;example(&#x27;ar&#x27;, &#x27;gu&#x27;, &#x27;me&#x27;, &#x27;nt&#x27;) 위 예제를 보면 example 함수는 pa,ra,me,ter 라는 데이터를 받아 반환(return)하고, example 함수가 호출될때 &#39;ar&#39;, &#39;gu&#39;, &#39;me&#39;, &#39;nt&#39; 이라는 데이터를 넘겨줬다. 쉽게 정의하자면, 함수내에서 활용하느냐와 함수안으로 넘겨주느냐 의 차이이다. 편의상 이렇게 정의 가능하며 정확한 정의는 함수 정의하기 섹션의 함수 선언문 에서 정의한 내용이다. 매개변수 : 함수 등에서 사용되는 전달된 값을 받는 변수로써, 함수의 기능상 외부 환경에서 데이터를 받아 가공 및 반환이 필요할 경우 함수 내부로 전달하는 역할을 하며 콤마(,) 로 구분하여 최대 255개까지 받을 수 있습니다. 인자: 함수에 전달되는 인수의 배열집합으로써, 정확히는 유사배열 객체로 arguments 객체라 칭하며 매개변수를 통해 전달받은 함수 외부환경의 값, 변수 또는 참조이다. 매개변수 (Parameter)매개변수란 ‘함수 등에서 사용되는 전달된 값을 받는 변수’ 로, 함수에서 정의한 매개변수가 충분히 오지 않으면 undefined 로 정의되며 ECMAScript 6 부터는 Default Parameter 와 Rest Parameter 가 추가 되었다. 매개변수 기본 처리방식123456function example(pa,ra,me,ter) &#123; console.log(`me =&gt; $&#123;me&#125;, ter =&gt; $&#123;ter&#125;`) // me =&gt; undefined, ter =&gt; undefined return pa + ra + me + ter&#125;example(&#x27;argu&#x27;, &#x27;ment&#x27;) // argumentundefinedundefined Default Parameter (기본 매개변수)전달값이 없거나 undefined 인 경우 파라미터에 기본값으로 초기화 될 값을 할당 123456function example(pa,ra,me = &#x27;me&#x27;,ter = &#x27;nt&#x27;) &#123; console.log(`me =&gt; $&#123;me&#125;, ter =&gt; $&#123;ter&#125;`) // me =&gt; me, ter =&gt; nt return pa + ra + me + ter&#125;example(&#x27;ar&#x27;, &#x27;gu&#x27;) // argument Rest Parameter (나머지 매개변수)파라미터의 갯수가 불확실해 Array (배열) 로 인수를 넘길때 사용할 수 있다. 123456function double(...theArgs) &#123; return theArgs.map(x =&gt; x + x);&#125;double(2, 1, 2, 3); // [4, 2, 4, 6]double(2, 1, 2, 3, 9, 5); // [4, 2, 4, 6, 18, 10] 인자 (Argument)인자(Argument)는 함수에 전달되는 인수의 배열집합 또는 모든 함수 내에서 이용 가능한 지역변수 로서 함수 호출시 전달되는 값을 할당 또는 참조해 함수 내에서 사용할 수 있습니다. 함수 내에서는 arguments 로 호출할 수 있으며 정확시는 유사객체 배열(array-like object) 에 속한다. 따라서 Javascript의 built-in function 중 Array 관련 메서드를 사용할 수 없으며 length 속성은 사용 가능합니다. argument 객체는 배열과 같이 인덱스로 접근가능합니다. 12345678910function arg () &#123; console.log(arguments.length) for(let i=0; i&lt;arguments.length; i++) &#123; console.log(arguments[i]) &#125;&#125;arg(1, 2, 3)// 1// 2// 3 arguments 를 Array 로 변환하기12var args = Array.from(arguments);var args = [...arguments]; Function 프로토타입 객체와 프로퍼티JavaScript에 함수는 Data Type에서 객체(Object)에 속하며, 모든 JavaScript 함수는 사실 Function 객체입니다. 12345678910// 함수 정의function square(number) &#123; return number * number;&#125;// 함수 프로퍼티 추가 Casesquare.x = 10;square.y = 20;console.log(square.x, square.y); // 10, 20 아래의 함수 생성법들은 모두 true 를 반환하며 전역 Function 객체는 자신만의 메서드 또는 속성이 없으나 그 자체로 함수이기에 Function.prototype에서 프로토타입 체인을 통해 일부 메서드 및 속성을 상속 받습니다. 12345678910// 즉시 실행 함수 (IIFE)(function()&#123;&#125;).constructor === Function // true// 함수 선언식function deFn () &#123; return &#x27;body&#x27; &#125;deFn.constructor === Function // true// 함수 표현식var exFn = function () &#123; return &#x27;body&#x27; &#125;exFn.constructor === Function // true 또한, 함수는 일반 객체와 다른 함수만의 프로퍼티와 메서드를 갖습니다. Function 프로토타입 객체 Function.length : 함수에 의해 기대되는 인수의 수 지정 Function.name : 함수명 Function.prototype.constructor : 객체의 프로토타입을 만드는 함수 지정 Function.arguments (deprecated) 메서드 Function.prototype.apply(this, [arg1, arg2, ... argn]) : 함수를 호출하고 함수의 this 객체에 제공된 thisArg 를 설정합니다. 인자는 Arrat 객체로 전달할 수 있습니다. Function.prototype.bind(this, binding object) : 호출될때, 함수의 this 가 제공된 thisArg 로 설정된 새로운 함수가 생성된다. 선택적으로, 주어진 일련의 인자(arguments)는 새로 바인딩 된 함수가 호출되는 경우 인수보다 우선적으로 추가됩니다. Function.prototype.call(this, arg1, arg2, ... argN) : 주어진 this 값과 개별적으로 제공되는 인수를 사용하여 함수를 호출한다. 화살표 함수 (Arrow Function)ES6 부터 함수를 생성하는 방법으로 함수 표현식보다 단순하고 간결한 화살표 함수 =&gt; 가 추가되었다. 특징 함수 표현식보다 구문이 짧고, 자신의 this, arguments, super 또는 new.target을 바인딩 하지 않는다 항상 익명 함수이다. 메소드 함수가 아닌 곳에 즉, 인자로서 부모 함수가 넘겨줄 callback 함수에 적합하다. 함수 생성자 (function constructor)로서 사용할 수 없다. 반환해야 할 값이 있을때 return 과 &#123;&#125; 를 생략할 수 있다. 1234function double (n) &#123; return n * 2;&#125;let double = n =&gt; n * 2 12345const numbers = [0, 2, 4, 6, 8];let double = n =&gt; n * 2console.log(numbers.map(double));console.log(numbers.map(number =&gt; number * 2));// expected output: Array [0, 4, 8, 12, 16] 기본 구문12345678910(param1, param2, …, paramN) =&gt; &#123; statements &#125;(param1, param2, …, paramN) =&gt; expression// 다음과 동일함: =&gt; &#123; return expression; &#125;// 매개변수가 하나뿐인 경우 괄호는 선택사항:(singleParam) =&gt; &#123; statements &#125;singleParam =&gt; &#123; statements &#125;// 매개변수가 없는 함수는 괄호가 필요:() =&gt; &#123; statements &#125; 고급 구문12345678910// 객체 리터럴 표현을 반환하기 위해서는 함수 본문(body)을 괄호 속에 넣음:params =&gt; (&#123;foo: bar&#125;)// 나머지 매개변수 및 기본 매개변수를 지원함(param1, param2, ...rest) =&gt; &#123; statements &#125;(param1 = defaultValue1, param2, …, paramN = defaultValueN) =&gt; &#123; statements &#125;// 매개변수 목록 내 구조분해할당도 지원됨var f = ([a, b] = [1, 2], &#123;x: c&#125; = &#123;x: a + b&#125;) =&gt; a + b + c;f(); // 6 (화살표 함수의 자세한 내용에 대해서는 추후 포스팅할 예정입니다.) 참조 https://ko.javascript.info/function-basics https://developer.mozilla.org/ko/docs/Web/JavaScript/Guide https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Functions https://poiemaweb.com/js-function https://joshua1988.github.io/web-development/javascript/function-expressions-vs-declarations/ https://developer.mozilla.org/en-US/docs/Web/JavaScript/Closures https://ko.javascript.info/arrow-functions-basics","categories":[{"name":"Programming","slug":"Programming","permalink":"https://joontae-kim.github.io/categories/Programming/"},{"name":"Javascript","slug":"Programming/Javascript","permalink":"https://joontae-kim.github.io/categories/Programming/Javascript/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://joontae-kim.github.io/tags/javascript/"},{"name":"function","slug":"function","permalink":"https://joontae-kim.github.io/tags/function/"},{"name":"arrow function","slug":"arrow-function","permalink":"https://joontae-kim.github.io/tags/arrow-function/"}]},{"title":"프론트엔드 취준 관련 링크 모음","slug":"front-end-interview-link-collection","date":"2020-10-20T04:40:20.000Z","updated":"2021-04-02T11:32:29.920Z","comments":true,"path":"2020/10/20/front-end-interview-link-collection/","link":"","permalink":"https://joontae-kim.github.io/2020/10/20/front-end-interview-link-collection/","excerpt":"","text":"프론트엔드 지원 관련 링크 모음개발자분들 블로그 박성범 개발자님 깃허브 블로그 - https://parksb.github.io/articles.html 캡틴 판교님 깃허브 블로그 - https://joshua1988.github.io/tech/ roy-jung님 깃허브 블로그 - https://roy-jung.github.io/ ALL [IT 개발자와 일할 때 필요한 모든 개발지식] A to Z 자료 모음집 By 그랩 - https://www.grabbing.me/IT-A-to-Z-By-1e1fbc981b7c4c03ac44943085ac8304 📋 프론트엔드 개발자를 위한 토막상식 - https://parksb.github.io/article/0.html 구직 관련 블로그 link DevOwen의 구직 이야기 Ch1. 마음가짐 :: DevOwen - https://devowen.com/287 이직을 준비하면서 - Today I Learned - https://vallista.kr/2019/07/03/%EC%9D%B4%EC%A7%81%EC%9D%84-%EC%A4%80%EB%B9%84%ED%95%98%EB%A9%B4%EC%84%9C/ 28세 요우의 개발자 이직 대탐험 - https://luckyyowu.tistory.com/382 2018 종합선물세트 for 취준생 - https://www.slideshare.net/LuckyYoWu/2018-for 인터뷰 관련 블로그 link [Interview] 인터뷰 경험 - 프론트 (야놀자) - https://daniel-park.tistory.com/42 이직초보 어느 개발자의 이력서 만들기 - https://woowabros.github.io/experience/2017/07/17/resume.html 이력서 및 경력기술서 관련 link 주니어 개발자 경력기술서 작성하기 :: GoGo - https://gogomalibu.tistory.com/119 [youtube], [인터뷰] 면접관이 좋아하는 이력서 쓰기 - https://www.youtube.com/watch?v=JM-Tz6dGH1U [youtube], 개발자 고민 상담, “이력서는 매력이 있어야지” - https://www.youtube.com/watch?v=zVDxL99tQiA 포트폴리오 관련 link [youtube], 초보개발자 포트폴리오 준비 이것으로 끝 / 프로그래머 되는법 / 프로그래머 공부 / 프로그래머 취업https://www.youtube.com/watch?v=_h3mGruXUSk 면접 질문 리스트 link &lt;FE 면접질문&gt; #1. 웹 브라우저 &amp; HTML &lt;FE 면접질문&gt; #3. Javascript 프론트엔드 개발자 면접 질문(기술면접) 정리 - https://sunnykim91.tistory.com/121 프론트엔드 개발자 면접 질문 모음 - https://mber.tistory.com/2 프론트엔드 면접 질문 모음 - https://velog.io/@honeysuckle/%EC%8B%A0%EC%9E%85-%ED%94%84%EB%A1%A0%ED%8A%B8%EC%97%94%EB%93%9C-%EB%A9%B4%EC%A0%91-%EC%A7%88%EB%AC%B8-%EB%AA%A8%EC%9D%8C 이번 기술 면접 중 기억나는 질문과 답변들 (프론트엔드). 이번에 이직하게 된 회사 기술 면접에서 주고 받았던 질문과 답변들 중… | by Jim Kim | Medium - https://medium.com/@jimkimau/%EC%9D%B4%EB%B2%88-%EA%B8%B0%EC%88%A0-%EB%A9%B4%EC%A0%91-%EC%A4%91-%EA%B8%B0%EC%96%B5%EB%82%98%EB%8A%94-%EC%A7%88%EB%AC%B8%EA%B3%BC-%EB%8B%B5%EB%B3%80%EB%93%A4-712daa9a2dc 스타트업 면접 전에 점검해야 하는 10가지 | ㅍㅍㅅㅅ - https://ppss.kr/archives/227105 프론트엔드 관련 질문 관련 link 프론트엔드 개발자를 위한 토막상식 - https://parksb.github.io/article/0.html 이직하려는 친구에게 보내는 프런트엔드 개발 면접 질문 - https://joshua1988.github.io/web-development/interview/frontend-questions/ 면접 질문 Javascript link JavaScript 질문 | Front End Interview Handbook - https://yangshun.github.io/front-end-interview-handbook/kr/javascript-questions 알고리즘 및 코딩테스트 관련 link ‘Alogorithm’ 카테고리의 글 목록 - https://daniel-park.tistory.com/ [youtube], IT개발자가 추천하는 코딩테스트 공부법, 포트폴리오 준비방법 | 5년차 웹개발 현직자는 이렇게 취준했다 - https://www.youtube.com/watch?v=rqNaabU2FmY&amp;t=209s","categories":[{"name":"Blog","slug":"Blog","permalink":"https://joontae-kim.github.io/categories/Blog/"},{"name":"Job","slug":"Blog/Job","permalink":"https://joontae-kim.github.io/categories/Blog/Job/"}],"tags":[{"name":"Front-end","slug":"Front-end","permalink":"https://joontae-kim.github.io/tags/Front-end/"},{"name":"Interview","slug":"Interview","permalink":"https://joontae-kim.github.io/tags/Interview/"},{"name":"Job","slug":"Job","permalink":"https://joontae-kim.github.io/tags/Job/"}]},{"title":"자바스크립트 실행 컨텍스트(Execution Context) 3 - 실행 컨텍스트의 생성과 실행","slug":"execution-context-example","date":"2020-10-18T11:33:00.000Z","updated":"2021-07-23T06:00:59.136Z","comments":true,"path":"2020/10/18/execution-context-example/","link":"","permalink":"https://joontae-kim.github.io/2020/10/18/execution-context-example/","excerpt":"","text":"실행 컨텍스트 관련 첫번째 포스트인 자바스크립트 실행 컨텍스트(Execution Context) 에서는 실행 컨텍스트란 무엇인지 그리고 유형은 어떠한 것들이 있으며 Javascript 엔진이 실행 컨텍스트를 어떻게 관리하는지 알아보았습니다. 실행 컨텍스트 관련 두번째 포스트인 자바스크립트 실행 컨텍스트(Execution Context) 2 - 정의와 구조 에서는 실행 컨텍스트의 정의와 ES5 이후의 Scope Chain의 변화 그리고 실행 컨텍스트의 세부구조에 대해 다뤄봤습니다. 그리고 마지막 포스트로는 실행 컨텍스트의 생성과 실행 과정에 대해 참고중이던 영문 포스트의 일부분을 번역하면서 구조와 각 세부 프로퍼티에 대해 정리해보고, Creation Phase 와 Execution Phase 에 대해서 알아보며 끝마치도록 하겠습니다. 참고 영문 포스트: Understanding Execution Context and Execution Stack in Javascript 번역 포스트의 “How is the Execution Context created?” 부분만 발췌하여 번역하였음을 알려드립니다. Javascript 실행 컨텍스트와 실행 스택 이해하기Javascript 프로그램이 내부적으로 실행되는 방법 학습하기How is the Execution Context created?지금까지, 우리는 Javascript 엔진이 실행 컨텍스트를 어떻게 관리하는지 살펴봤습니다. 그럼 지금부터는 Javascript 엔진이 실행 컨텍스트를 생성하는 방법에 대해 이해해보록 하겠습니다. 실행 컨텍스트는 두 단계로 나뉘어 생성됩니다: 생성 단계 (Creation Phase) 실행 단계 (Execution Phase) 1. 생성 단계실행 컨텍스트는 생성 단계 동안 아래의 컨포넌트가 발생합니다: LexicalEnvironment 컴포넌트가 생성된다. VariableEnvironment 컴포넌트가 생성된다. 그럼 실행 컨텍스트는 개념적으론 아래와 같이 나타낼 수 있다. 1234ExecutionContext &#x3D; &#123; LexicalEnvironment &#x3D; &lt;ref. to LexicalEnvironment in memory&gt;, VariableEnvironment &#x3D; &lt;ref. to VariableEnvironment in memory&gt;,&#125; Lexical EnvironmentThe official ES6 문서에 정의된 Lexical Environment 는 Lexical Environment는 ECMAScript 코드의 lexical 중첩 구조 상에서 특정 변수와 함수에 대한 인식자(Identifier)들을 정의하는데 사용되는 명세 유형입니다. Lexical Environment는 Environment Record와 outer Lexical Environment에 대한 가능한한 null 참조로 구성되어 있다. 간단하게 말해, lexical environment 는 인식자(identifier)-변수(variable) 매핑(mapping) 을 유지하고 있는 구조입니다. (여기서 identifier 란 변수/함수들의 이름을 참고하는 것이고, variable 은 [함수 객체와 배열 객체를 포함하는] 실질적 객체 또는 기본값에 대한 참조값이다.) 예를 들어, 아래의 코드 조각을 생각해보자. 123456var a = 20;var b = 40; function foo() &#123; console.log(&#x27;bar&#x27;);&#125; 위 코드 조각의 lexical environment는 아래와 같이 나타낼 수 있다. 12345lexicalEnvironment = &#123; a: 20, b: 40, foo: &lt;ref. to foo function&gt;&#125; 각 Lexical Environment는 세가지 컴포넌트를 가지고 있다. Environment Record Reference to the outer environment This binding Environment RecordEnvironment Record는 lexical environment 안에 저장된 변수와 함수의 선언이 있는 곳이다. 또한, environment record 는 두가지 타입이 있습니다. Declarative environment record — 이름에서 알 수 있듯이 변수와 함수의 선언에 대한 것으로 추측할 수 있다. 함수 코드에 대한 lexical environment는 declarative environment record를 포함하고 있다. Object environment record — 전역(global) 코드의 lexical environment는 objective environment record를 포함하고 있다. 변수와 함수에 대한 선언과 구분지어, object environment record는 또한 전역 바인딩 객체(global binding object) (browser의 경우 window 객체)를 저장한다. 그리고 바인딩된 객체에 대한 각각의 속성(브라우저의 경우, window 객체에 browser에 의해 제공되는 속성과 메서드들이 포함된다)에 대해 새로운 엔트리가 레코드 안에 생성된다. Note — 함수 코드 를 위해서, Environment Record 는 또한 인덱스와 함수에 전달된 인자 사이의 관계에 대한 매핑과 함수로 전달된 인자들에 대한 길이(숫자, number) 에 대한 정보를 담고있는 인자(arguments) 객체를 포함한다. 123456function foo(a, b) &#123; var c = a + b;&#125;foo(2, 3);// argument objectArguments: &#123;0: 2, 1: 3, length: 2&#125;, Reference to the Outer Environmentreference to the outer environment 는 현재 실행 컨텍스트의 외부(outer) lexical environment에 대해 접근하는 것을 의미합니다. 이것은 JavaScript engine이 현재 lexical environment에서 변수를 찾지 못한다면 외부 환경(outer environment)에서 찾을 수 있음을 의미합니다. This Binding이 컴포넌트에서는 this 의 값을 결정하거나 설정합니다. 전역(global) 실행 컨텍스트에서 this 는 전역 객체를 참조합니다. (브라우저에서 this 는 Window 객체를 참조한다.) 함수 실행 컨텍스트에서 this 는 함수가 호출되는 방식에 따라 달라진다. 만약 객체 참조 방식에 따라 함수가 호출될 경우, this 값은 해당 객체로 설정되고 그렇지 않으면 this 는 전역 객체 또는 (strict mode 에서는) undefined 로 설정된다. 예를 들어, 1234567891011121314const person = &#123; name: &#x27;peter&#x27;, birthYear: 1994, calcAge: function() &#123; console.log(2018 - this.birthYear); &#125;&#125;person.calcAge(); // &#x27;calcAge&#x27;가 &#x27;person&#x27; 객체 참조로 호출됐기 때문에 &#x27;this&#x27;는 &#x27;person&#x27;를 참조한다.const calculateAge = person.calcAge;calculateAge();// 어떠한 객체 참조도 주어지지 않았기 때문에 &#x27;this&#x27;는 전역 window 객체를 참조한다. 추상적으로, lexical environment는 아래와 같은 가상의 코드로 나타낼 수 있다: 1234567891011121314151617181920GlobalExectionContext &#x3D; &#123; LexicalEnvironment: &#123; EnvironmentRecord: &#123; Type: &quot;Object&quot;, &#x2F;&#x2F; 인식자(Identifier) binding은 여기로 이동한다. &#125; outer: &lt;null&gt;, this: &lt;global object&gt; &#125;&#125;FunctionExectionContext &#x3D; &#123; LexicalEnvironment: &#123; EnvironmentRecord: &#123; Type: &quot;Declarative&quot;, &#x2F;&#x2F; 인식자(Identifier) binding은 여기로 이동한다. &#125; outer: &lt;Global or outer function environment reference&gt;, this: &lt;depends on how function is called&gt; &#125;&#125; Variable Environment:또한 Environment Record는 실행 컨텍스트에서 VariableStatements 에 의해 생성된 binding을 보관하는 Lexical Environment 이다. 즉, Variable Environment 또한 Lexical Environment이며 위에서 정의한 것처럼 Lexical Environment의 모든 속성과 컴포넌트들을 가지고 있다. ES6에서 LexicalEnvironment 컴포넌트 and the VariableEnvironment 컴포넌트의 한가지 차이점은 LexicalEnvironment 는 함수 선언과 변수 (let 과 const) 바인딩을 저장하는데 사용되고, VariableEnvironment 는 오직 변수 (var) 바인딩을 저장하는데 사용된다. 실행 단계이 단계에서는, 모든 변수에 대한 할당이 끝났으며 마침내 코드가 실행된다. Example이상의 개념을 이해하기 위해 몇 가지 예를 보자. 12345678let a = 20;const b = 30;var c;function multiply(e, f) &#123; var g = 20; return e * f * g;&#125;c = multiply(20, 30); 이 코드를 실행시키면, Javascript 엔진은 전역(global) 코드를 실행하기 위한 전역 실행 컨텍스트를 생성한다. 그럼 생성 단계에서 전역 실행 컨텍스트는 아래와 같은 가상의 코드처럼 될 것이다. 12345678910111213141516171819202122GlobalExectionContext = &#123; LexicalEnvironment: &#123; EnvironmentRecord: &#123; Type: &quot;Object&quot;, // 인식자(Identifier) binding은 여기로 이동한다. a: &lt; uninitialized &gt;, b: &lt; uninitialized &gt;, multiply: &lt; func &gt; &#125; outer: &lt;null&gt;, ThisBinding: &lt;Global Object&gt; &#125;, VariableEnvironment: &#123; EnvironmentRecord: &#123; Type: &quot;Object&quot;, // 인식자(Identifier) binding은 여기로 이동한다. c: undefined, &#125; outer: &lt;null&gt;, ThisBinding: &lt;Global Object&gt; &#125;&#125; 실행 단계 동안에는, 변수 할당이 끝났으며 전역 실행 컨텍스트는 아래와 같은 가상의 코드처럼 될 것입니다. 12345678910111213141516171819202122GlobalExectionContext = &#123; LexicalEnvironment: &#123; EnvironmentRecord: &#123; Type: &quot;Object&quot;, // 인식자(Identifier) binding은 여기로 이동한다. a: 20, b: 30, multiply: &lt; func &gt; &#125; outer: &lt;null&gt;, ThisBinding: &lt;Global Object&gt; &#125;, VariableEnvironment: &#123; EnvironmentRecord: &#123; Type: &quot;Object&quot;, // 인식자(Identifier) binding은 여기로 이동한다. c: undefined, &#125; outer: &lt;null&gt;, ThisBinding: &lt;Global Object&gt; &#125;&#125; multiply(20, 30) 함수에 대한 호출이 발생했을때, 새로운 함수(function) 실행 컨텍스트가 함수 코드를 실행하기 위해 생성된다. 그리고 함수 실행 컨텍스트는 생성 단계동안 아래와 같은 가상의 코드처럼 될 것입니다. 1234567891011121314151617181920FunctionExectionContext = &#123; LexicalEnvironment: &#123; EnvironmentRecord: &#123; Type: &quot;Declarative&quot;, // 인식자(Identifier) binding은 여기로 이동한다. Arguments: &#123;0: 20, 1: 30, length: 2&#125;, &#125;, outer: &lt;GlobalLexicalEnvironment&gt;, ThisBinding: &lt;Global Object or undefined&gt;, &#125;, VariableEnvironment: &#123; EnvironmentRecord: &#123; Type: &quot;Declarative&quot;, // 인식자(Identifier) binding은 여기로 이동한다. g: undefined &#125;, outer: &lt;GlobalLexicalEnvironment&gt;, ThisBinding: &lt;Global Object or undefined&gt; &#125;&#125; 이후, 실행 컨텍스트는 함수(function) 내에서 변수 할당이 끝났다는 의미로 실행 단계를 거치고 함수 실행 컨텍스트는 실행 단계동안 아래와 같은 가상의 코드처럼 될 것입니다. 1234567891011121314151617181920FunctionExectionContext = &#123; LexicalEnvironment: &#123; EnvironmentRecord: &#123; Type: &quot;Declarative&quot;, // 인식자(Identifier) binding은 여기로 이동한다. Arguments: &#123;0: 20, 1: 30, length: 2&#125;, &#125;, outer: &lt;GlobalLexicalEnvironment&gt;, ThisBinding: &lt;Global Object or undefined&gt;, &#125;, VariableEnvironment: &#123; EnvironmentRecord: &#123; Type: &quot;Declarative&quot;, // 인식자(Identifier) binding은 여기로 이동한다. g: 20 &#125;, outer: &lt;GlobalLexicalEnvironment&gt;, ThisBinding: &lt;Global Object or undefined&gt; &#125;&#125; 함수가 완료된 후에, 반환된 값은 c 에 저장되고, 전역(global) lexical environment가 업데이트 됩니다. 그 후, 전역 코크는 완료되고, 프로그램은 끝난다. Note — 여러분은 let 과 const 로 정의된 변수는 생성 단계 동안에 그 어떠한 값(value)도 연결되지 않으며 var 로 정의된 변수는 undefined 로 설정된다는 것을 주의해야 합니다. 이것은 생성 단계에서 코드에서 변수와 함수 선언에 대해 스캔하고, 함수 선언이 환경에 함수 전체적으로 저장되는 동안, 변수는 처음에 (var 의 경우) undefined 로 설정되거나 (let 과 const 의 경우) 비초기화(uninitialized) 상태로 유지되기 때문입니다. 이게 여러분이 let 과 const 변수가 선언되기 전에 접근하려고 할때 참조 에러(reference error)가 발생하는 것과 달리 var 로 선언된 변수는 (undefined 로) 선언되기 전에 접근할 수 있는 이유입니다. 이것이 바로, 우리가 호이스팅(hoisting) 이라고 부르는 것입니다. Note — 실행단계 동안에, Javascript 엔진이 소스 코드(source code) 상에서 선언한 실제 위치에서 let 변수에 대한 값을 찾지 못한다면 이 변수에는 undefined 값이 할당될 것입니다. Conclusion우리는 Javascript 프로그램들이 내부적으로 어떻게 실행되는지 살펴봤습니다. 여려분이 멋진 Javascript 개발자가 되기 위해 이러한 모든 개념들을 배울 필요는 없지만, 위와 같은 개념에 대한 왠만한 이해력은 Hoisting, Scope, and Closure 와 같은 다른 개념들도 더 쉽고 더 깊게 이해할 수 있도록 도울 것입니다.","categories":[{"name":"Programming","slug":"Programming","permalink":"https://joontae-kim.github.io/categories/Programming/"},{"name":"Javascript","slug":"Programming/Javascript","permalink":"https://joontae-kim.github.io/categories/Programming/Javascript/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://joontae-kim.github.io/tags/javascript/"},{"name":"javascript engine","slug":"javascript-engine","permalink":"https://joontae-kim.github.io/tags/javascript-engine/"},{"name":"execution context","slug":"execution-context","permalink":"https://joontae-kim.github.io/tags/execution-context/"},{"name":"execution","slug":"execution","permalink":"https://joontae-kim.github.io/tags/execution/"},{"name":"context","slug":"context","permalink":"https://joontae-kim.github.io/tags/context/"}]},{"title":"자바스크립트 실행 컨텍스트(Execution Context) 2 - 정의와 구조","slug":"excution-context-2","date":"2020-10-14T16:40:35.000Z","updated":"2021-07-23T06:17:01.574Z","comments":true,"path":"2020/10/15/excution-context-2/","link":"","permalink":"https://joontae-kim.github.io/2020/10/15/excution-context-2/","excerpt":"","text":"실행 컨텍스트 관련 첫번째 포스트인 자바스크립트 실행 컨텍스트(Execution Context) 에서는 실행 컨텍스트란 무엇인지 그리고 유형은 어떠한 것들이 있으며 Javascript 엔진이 실행 컨텍스트를 어떻게 관리하는지 알아보았습니다. 이번 포스트에서는 Javascript 엔진이 실행 컨텍스트를 어떻게 생성하며 실행 컨텍스트는 어떠한 구조로 이루어져 있는지 알아보겠습니다. 실행 컨텍스트의 물리적 구조를 설명하기에 앞서 일부 블로그의 내용이 ECMAScript의 ES5 이전의 개념으로 작성되어 있었습니다. 그래서 ES5 이전의 내용과 ES5 이후의 구조를 비교하기 위해 많은 블로그와 ECMAScript 의 공식 문서(ecma-262)의 Executable Code and Execution Contexts 내용을 참고하였고 용어 및 구조에 있어서 변경사항이 있었습니다. ES5 이전과 이후ES5 이전과 이후의 차이가 크진 않습니다. 그러나 최신 스펙으로 공부하고 알고 있는것이 맞다고 생각되었고 짧게나마 제가 공부하면서 알게된 변경사항에 대해 정리해보았습니다. 실행 컨텍스트를 실행하기 위해 보유하는 프로퍼티 ES5 이전: 변수 객체 (Variable Object) Scope Chain this (Context Object) ES5 이후 Lexical Environment Variable Environment Variable Object, Activation Object, Scope Chain 등의 개념이 Lexical Environment로 변경됨 실행 컨텍스트에서 “this”를 관리하는 주체 ES5 이전: 실행 컨텍스트 객체가 직접 ES5 이후: Lexical Environment “Scope Chain”의 변화Javascript는 Lexical Scope를 갖는 언어로써, 식별자 탐색을 위한 참조가 ES5 이후 아래와 같이 변경되었다. ES5 이전: Scope Chain ES5 이후 Lexical nesting structure Logical nesting of Lexical Environment values Chain(사슬) 의 구조보다는 nesting(중첩) 의 의미를 강조에 의미를 둠 실행 컨텍스트와 그 구조실행 컨텍스트 1편인 자바스크립트 실행 컨텍스트(Execution Context) 에서 정의했듯이 실행 컨텍스트란 “실행 가능한 코드를 형상화 하고 구분 하는 추상적인 개념으로 코드가 실행되고 있는 구역 또는 범위“ 로써 각 실행 컨텍스트는 아래와 같은 모양을 갖으며 이는 ES5 이전의 구조인 실행 컨텍스트 안에 3개의 프로퍼티(Variable Object, Scope Chain, this Object)를 갖는 구조와 다르다. 1. 실행 컨텍스트그림의 가장 좌측에 그리고 최상위 개념인 실행 컨텍스트 는 “코드가 실행되고 있는 구역 또는 범위” 라는 정의에 맞게 아래와 같이 어느 영역에서 호출 및 실행되고 있느냐에 따라 구분할 수 있으며 각 컨텍스트에 따라서 하위 개념 및 구조 또한 달라진다. 전역(Global) 영역 에서 실행되고 있으면 전역 실행 컨텍스트 전역 컨텍스트에서 호출 및 실행된 함수(Function)의 영역 에서 실행되고 있으면 함수 실행 컨텍스트 그리고 모든 실행 컨텍스트는 아래와 같은 공통된 구조를 갖으며, 짧게 정의하자면, 변수의 참조를 기록하는 환경이라 할 수 있겠다. 1234ExecutionContext = &#123; LexicalEnvironment = &lt;ref. to LexicalEnvironment in memory&gt;, VariableEnvironment = &lt;ref. to VariableEnvironment in memory&gt;&#125; 위 두개의 프로퍼티는 초기화 시에는 같은 객체를 바라보고 있으며 실행 컨텍스트가 호출 및 실행 영역에 따라 구분되는 것과 마찬가지로 각 바라보는 또는 Linked Object가 달라진다. 전역(Global) 실행 컨텍스트 의 프로퍼티라면 Global Lexical Environment / Global Variable Environment 일반 함수(Function) 실행 컨텍스트 의 프로퍼티라면 Lexical Environment / Variable Environment 2. Lexical Environment한글로 “어휘적 환경” 또는 “정적 환경”라고 할 수 있으며 Javascirpt 코드에서 변수 또는 함수 식별자를 맵핑(identifier-variable mapping)하는데 사용되는 객체로 아래와 같은 환경으로 구성되어 있다. (여기서 식별자(identifier) 란 참조 대상 식별자로써 변수나 함수의 이름을 참조하며 변수 는 함수 객체와 배열 객체를 포함한 실제 객체 또는 원시값에 대한 참조이다.) Lexical Environment Outer Environment Reference 또는 Reference to the outer environment Environment Record 2.1 Outer Environment Reference식별자(identifier) 검색을 위해 외부 Lexical Environment를 참조하는 포인터로 중첩된 Javascript 코드에서 스코프 탐색을 위해 사용된다. Global Lexical Environment 의 Outer Environment Reference 값은 null 일반 Function 환경에서의 Lexical Environment 의 Outer Environment Reference 값은 해당 실행환경(Execution Context)의 상위 실행환경의 Lexical Environment를 참조 2.2 Environment Record현재 유효범위 내의 값에 식별자들의 바인딩을 기록하는 객체로 모든 지역 변수(변수, 함수 등)를 프로퍼티로 저장하며 this 와 같은 기타 정보도 여기에 저장된다. 현재 레코드 타입이 포함된 실행 컨텍스트(Execution Context)에 따라 Global Environment Record 와 일반 Function 환경에서의 Environment Record 으로 구분할 수 있으며 담고 있는 데이터에 대한 속성 또한 달라진다. 해당 Record 타입의 구조는 실행 컨텍스트의 영역을 불문하고 아래의 레코드 타입을 갖는다: Environment Record Object Environment Record Declarative Environment Record 2.2.1 Object Environment Recordwith 문과 같이 식별자(Identifier)를 특정 객체의 속성으로 취급할때 사용되며, 이를 위해 binding Object라는 속성으로 특정 객체를 가리킨다. 현재 레코드는 Environment Record를 상속한 서브 클래스이다. 전역(Global) 실행 컨텍스트의 Object Environment Record (in Environment Record) 는 브라우저 환경의 경우 전역 객체로서 window 객체를 저장한다. 따라서 일반적인 함수(Function) 실행 컨텍스트와 다르게 Object, Array, Function과 같은 built-in global 객체와 전역 코드에서의 함수/변수 선언에 의해 생성된 모든 식별자 정보를 저장하며 찾을 수 있다. (이는 함수 실행 컨텍스트의 Environment Record와 다른 점이다.) 2.2.2 Declarative Environment Record이름에서 알 수 있듯이 변수 선언, 함수 선언, catch 절과 같은 문법요소의 효과 와 같은 정보를 정의하기 위해 사용된다. 즉, 식별자(Indentifier) 정보를 해당 레코드 타입에서 찾을 수 있다는 말이다. 함수 코드에 대한 lexical environment는 해당 레코드 타입을 포함하며 하위 레코드 타입으로는 아래와 같다. Declarative Environment Record Function Environment Record Module Environment Record 전역(Global) 실행 컨텍스트의 Declarative Environment Record (in Environment Record) 는 함수(Function) 실행 컨텍스트의 Declarative Environment Record와 다르게 전역 코드에서 object Environment Record에 포함되지 않은 식별자 정보만 보유한다. 왜냐하면 하단 전역 환경에서의 object Environment Record가 해당 레코드의 역할을 가져가 버렸기 때문이다. 3. Variable EnvironmentLexicalEnvironment 와 funtion, 변수 식별자가 binding 되는 점을 포함해 동일하다. VariableEnvironment 또한 Lexical Environment이다. 그러나 만들어진 변수 선언 및 함수 선언에 대해 바인딩을 유지한다. LexicalEnvironment는 코드 실행 중에 실행 컨텍스트 내에서 변경될 수 있지만 VariableEnvironment는 항상 값을 유지한다. LexicalEnvironment는 일시적으로 LexicalEnvironment 하위에 새로운 환경을 가리킵니다. 이 새로운 환경은 임시 바인딩을 보유합니다. 그리고 임시 범위를 벗어나면 VariableEnvironment가 참조하고 있는 값으로 LexicalEnvironment를 복구합니다. ES6 에서 LexicalEnvironment와 VariableEnvironment 둘의 차이점은 전자가 함수 선언과 변수 (let과 const)의 바인딩을 저장하고 후자는 변수 var 만 저장한다. 4. 정리 - 실행 컨텍스트의 구조실행 컨텍스트 하위 구조1234ExecutionContext &#x3D; &#123; LexicalEnvironment &#x3D; &lt;ref. to LexicalEnvironment in memory&gt;, VariableEnvironment &#x3D; &lt;ref. to VariableEnvironment in memory&gt;&#125; Lexical Environment 구조1234567891011Lexical Environment &#x3D; &#123; Outer Environment Reference, Environment Record: &#123; Object Environment Record, Declarative Environment Record: &#123; Function Environment Record, Module Environment Record &#125;, This Binding &#125;&#125; Variable Environment 구조12345678EnvironmentRecord: &#123; Outer Environment Reference, Environment Record: &#123; Object Environment Record, Declarative Environment Record, This Binding &#125;&#125; 여기까지 ES5 이전과 이후의 실행 컨텍스트(Execution Context)의 변화와 구조에 대해 알아봤습니다. 다음 포스트에서는 실제 예제를 가지고 위의 실행 컨텍스트 구조가 어떻게 형성되고 실행되는지 알아보겠습니다. 참조 Understanding Execution Context and Execution Stack in Javascript Executable Code and Execution Contexts - ecma-262 from ECMAScript [Javascript] Execution Context와 Lexical Environment - https://iamsjy17.github.io [JS] 자바스크립트의 The Execution Context (실행 컨텍스트) 와 Hoisting (호이스팅) - https://velog.io/@imacoolgirlyo 자바스크립트 함수 (3) - Lexical Environment - meetup.toast.com 자바스크립트의 스코프와 클로저 - meetup.toast.com 변수의 유효범위와 클로저 - https://ko.javascript.info","categories":[{"name":"Programming","slug":"Programming","permalink":"https://joontae-kim.github.io/categories/Programming/"},{"name":"Javascript","slug":"Programming/Javascript","permalink":"https://joontae-kim.github.io/categories/Programming/Javascript/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://joontae-kim.github.io/tags/javascript/"},{"name":"javascript engine","slug":"javascript-engine","permalink":"https://joontae-kim.github.io/tags/javascript-engine/"},{"name":"execution context","slug":"execution-context","permalink":"https://joontae-kim.github.io/tags/execution-context/"},{"name":"execution","slug":"execution","permalink":"https://joontae-kim.github.io/tags/execution/"},{"name":"context","slug":"context","permalink":"https://joontae-kim.github.io/tags/context/"}]},{"title":"Dev To Read","slug":"Blog-to-read","date":"2020-10-13T17:40:15.000Z","updated":"2020-11-03T10:39:52.677Z","comments":true,"path":"2020/10/14/Blog-to-read/","link":"","permalink":"https://joontae-kim.github.io/2020/10/14/Blog-to-read/","excerpt":"","text":"Blog To Read In Dev Blocking-NonBlocking-Synchronous-Asynchronous https://homoefficio.github.io/2017/02/19/Blocking-NonBlocking-Synchronous-Asynchronous/ GET이냐 POST냐 그것이 문제로다 https://homoefficio.github.io/2019/12/25/GET%EC%9D%B4%EB%83%90-POST%EB%83%90-%EA%B7%B8%EA%B2%83%EC%9D%B4-%EB%AC%B8%EC%A0%9C%EB%A1%9C%EB%8B%A4/ 객체 지향 프로그래밍과 메시징 https://homoefficio.github.io/2019/07/04/%EA%B0%9D%EC%B2%B4-%EC%A7%80%ED%96%A5-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D%EA%B3%BC-%EB%A9%94%EC%8B%9C%EC%A7%95/ Back to the Essence - Concurrency vs Parallelism https://homoefficio.github.io/2019/02/02/Back-to-the-Essence-Concurrency-vs-Parallelism/ Client-Side Rendering (CSR) https://advancedweb.dev/client-side-rendering Cracking The Frontend interview, Part 4: Javascript https://advancedweb.dev/frontend-interview-part-4-javascript Intro to ES6 https://andrew.hedges.name/es6/ Introducing the new features that ECMAScript 2016 (ES7) adds to JavaScript https://www.freecodecamp.org/news/ecmascript-2016-es7-features-86903c5cab70/ 2020년 상반기 회고 https://medium.com/@pks2974/2020%EB%85%84-%EC%83%81%EB%B0%98%EA%B8%B0-%ED%9A%8C%EA%B3%A0-6db69bd77bfe 동기식 처리 모델 vs 비동기식 처리 모델 https://poiemaweb.com/js-async [Web] Web Server와 WAS의 차이와 웹 서비스 구조 https://gmlwjd9405.github.io/2018/10/27/webserver-vs-was.html What are Node, NPM, NVM, Yarn, Babel, Webpack and Loader https://medium.com/@imsabitaneupane/what-are-node-npm-nvm-yarn-babel-webpack-and-loader-347f10a9a5cf","categories":[{"name":"Blog","slug":"Blog","permalink":"https://joontae-kim.github.io/categories/Blog/"},{"name":"Blog To Read","slug":"Blog/Blog-To-Read","permalink":"https://joontae-kim.github.io/categories/Blog/Blog-To-Read/"}],"tags":[]},{"title":"자바스크립트 실행 컨텍스트(Execution Context)","slug":"excution-context","date":"2020-10-12T07:25:31.000Z","updated":"2021-07-23T05:51:34.810Z","comments":true,"path":"2020/10/12/excution-context/","link":"","permalink":"https://joontae-kim.github.io/2020/10/12/excution-context/","excerpt":"","text":"기본적으로 Front-End 개발자라면 Javascript를 통해 각종 기능을 개발하고 그 안에는 UI 제어, 사용자 데이터 처리 또는 연산 그리고 서버와의 데이터 통신 등이 있을것이다. 그렇다면 이러한 기능들은 Javascript 엔진에서는 어떤 환경에서 어떻게 실행되는것일까? 그 중심에는 이번에 다룰 Javascript의 핵심원리인 실행 컨텍스트(Execution Context)가 있으며 Scope, Hoisting, this, function, closure 등의 동작원리를 담고 있는 총체적 개념이라고 할 수 있다. 그렇다면 실행 컨텍스트란 무엇이며, 어떠한 구조로 이루어져 있고, 어떻게 작동하는지 알아보자. 실행 컨텍스트 (Execution Context)서두에서 말했듯이 실행 컨텍스트 란 Javascript의 핵심원리로서, 실행 가능한 코드를 형상화 하고 구분하는 추상적인 개념으로 코드가 실행되고 있는 구역 또는 범위 라고 정의할 수 있다. Javascript 엔진은 코드를 실행하기 위해 여러가지 정보를 알고 있어야 하며 다음에 얘기할 실행 컨텍스트의 유형에 따라서 달라질 수 있음을 기억하고 있어야 한다. Variable: 전역 변수, 지역 변수, 매개 변수, 객체의 프로퍼티 Argument: 인자 객체 Scope: 변수의 유효범위 This 위와 같이 실행에 필요한 정보를 형상화하고 구분하기 위해서 JS 엔진은 실행 컨텍스트를 물리적 객체의 형태로 관리한다. 실행 컨텍스트의 유형실행 구역 또는 범위에 따라 실행 컨텍스트의 유형을 구분할 수 있음 전역 컨텍스트 (Global Execution Context) 함수 컨텍스트 (Functional Execution Context) Eval 함수 컨텍스트 (Eval Function Execution Context) 전역 실행 컨텍스트 (Global Execution Context)실행 컨텍스트의 가장 기초가 되는 구간 또는 범위로, 함수 구간 안에서 실행되는 코드가 아니라면 대부분 전역 컨텍스트 안에서 실행된다. 전역 컨텍스트에서는 두 가지 작업이 발생된다. window 객체인 전역 컨텍스트 생성 this 를 전역 객체로 할당 함수 실행 컨텍스트 (Functional Execution Context)함수가 실행될때마다 해당 함수의 실행 컨텍스트가 생성된다. 즉, 호출 이 발생될때마다 각 함수의 함수 컨텍스트가 생성되는 것이다. Eval 함수 실행 컨텍스트 (Eval Function Execution Context)eval 함수 또한 함수 컨텍스트와 동일하게 실행 컨텍스트를 갖지만 많이 사용하지 않는 함수이며 지양해야할 기능이므로 생략하겠다. 실행 컨텍스트의 생성과 실행 관리실행 컨텍스트의 생성 및 실행을 이해하기 위해서는 실행 스택(Execution Stack) 과 제어권(Control) 에 대한 개념을 숙지해야한다. 먼저 호출 스택(Execution Stack) 이란 다른 언어 또는 파트에서도 나오는 호출 스택(Call Stack) 과 같은 LIFO (Last In, First Out) 의 자료구조로 코드 또는 함수가 실행되면서 생성되는 각각의 실행 컨텍스트를 저장하는 구조적 집합체 이다. Javascript 엔진이 script 태그를 만나면, 실행 가능한 코드로 제어권(control) 이 이동하면 논리적 스택 구조를 가지는 빈 실행 컨텍스트 스택이 생성 제어권 이 전역 코드로 이동하면 전역 실행 컨텍스트 가 생성되며 비어있는 컨텍스트 스택에 push 그리고 전역환경에서 함수를 호출하면 제어권 이 함수 코드로 이동하면서 호출된 함수의 함수 컨텍스트 가 생성 및 실행 스택에 push. 즉, 스택의 가장 마지막 순서로 삽입됨 Javascript 엔진은 실행 스택 에서 가장 상단에 있는 실행 컨텍스트 부터 실행 각 실행 컨텍스트 가 종료되고 나면 실행 스택 에서 제거 (pop) 되고, LIFO의 순서에 맞춰서 제어권이 이동한다. 아래의 예제를 보자우리는 main.js 라는 javascript file을 갖고 있으며 script 태그를 통해 첨부했다고 가정하자. 1234567891011121314151617// 전역 contextvar a = 1;var b = 2;function sum () &#123; // sum 함수 context var c = 3; var d = a + b + c; function print () &#123; // print 함수 context console.log(d) &#125; print();&#125;sum() main.js 가 로드되면서 Javascript 엔진은 실행 스택 을 아래와 같이 분석 및 구분할 것이며 이는 그림 [실행 스택 예시] 와 같을 것이다. (초기 컨텍스트 스택 순서는 생략) 전역 컨텍스트가 호출되면서 전역 실행 컨텍스트가 실행 스택에 push 되고 sum 함수가 호출 및 실행되면서 sum 함수의 함수 실행 컨텍스트가 실행 스택에 push print 함수가 호출 및 실행되면서 print 함수의 함수 실행 컨텍스트를 실행 스택에 push. 그리고 실행이 끝나면 print 함수의 함수 실행 컨텍스트는 pop (제거) sum 함수의 실행 또한 완료되며 함수 실행 컨텍스트가 pop (제거) 전역 실행 컨텍스트 만 남게된다. 여기까지 실행 컨텍스트는 무엇이며 그 유형과 Javascript 엔진이 실행 컨텍스트를 어떻게 생성하고 관리하는지 알아보았습니다. 다음 포스팅에서는 실행 컨텍스트에 대한 구조와 예시에 대해 다뤄보도록 하겠습니다. 참조 Understanding Execution Context and Execution Stack in Javascript Executable Code and Execution Contexts - ecma-262 from ECMAScript [Javascript] Execution Context와 Lexical Environment - https://iamsjy17.github.io [JS] 자바스크립트의 The Execution Context (실행 컨텍스트) 와 Hoisting (호이스팅) - https://velog.io/@imacoolgirlyo 자바스크립트 함수 (3) - Lexical Environment - meetup.toast.com 자바스크립트의 스코프와 클로저 - meetup.toast.com","categories":[{"name":"Programming","slug":"Programming","permalink":"https://joontae-kim.github.io/categories/Programming/"},{"name":"Javascript","slug":"Programming/Javascript","permalink":"https://joontae-kim.github.io/categories/Programming/Javascript/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://joontae-kim.github.io/tags/javascript/"},{"name":"javascript engine","slug":"javascript-engine","permalink":"https://joontae-kim.github.io/tags/javascript-engine/"},{"name":"execution context","slug":"execution-context","permalink":"https://joontae-kim.github.io/tags/execution-context/"},{"name":"execution","slug":"execution","permalink":"https://joontae-kim.github.io/tags/execution/"},{"name":"context","slug":"context","permalink":"https://joontae-kim.github.io/tags/context/"}]},{"title":"데이터 유형 (type)","slug":"javascript-types-intro","date":"2020-10-10T20:16:20.000Z","updated":"2020-10-11T17:43:06.704Z","comments":true,"path":"2020/10/11/javascript-types-intro/","link":"","permalink":"https://joontae-kim.github.io/2020/10/11/javascript-types-intro/","excerpt":"","text":"프로그래밍 언어에서 자료형(types) 또는 데이터 타입(data type) 이란 숫자형(정수형, 실수형), 논리값(Boolean), 문자(String) 등의 데이터를 식별하는 분류 (indentifier) 로서, 해당 자료형에 대한 가능한 값, 해당 자료형에서 수행을 마칠 수 있는 명령들, 데이터의 의미, 값의 저장하는 방식을 결정한다. 이렇듯 자료형이란 개발자가 특정 기능 또는 함수 내에서 어떤 형태의 데이터를 다룰 것이며 이를 통해 가능한 작업은 어떤 것인지 정의할 수 있는 역할을 한다. 그렇다면 Javascript의 데이터 타입(Type)에는 무엇이 있을까? 프로그래밍에서의 자료 자료형의 구성 변수들이 가질 수 있는 값의 범위/크기 및 연산 가능한 형태와 규칙 값의 집합/범위/크기 및 이 값에 적용가능한 연산에 따라 다르게 규정 자료형의 구분 원시형 또는 기본형 (Primitive Type) 또는 내장 자료형 (Built-in Type) 시스템/컴파일러/인터프리터 등이 직접 제공 및 직접 해석 가능한 데이터 타입 정수 및 실수형, 논리값(Boolean), 문자형(String) 등 단순한 구조의 타입 파생 자료형 (Derived Type) 원시형 또는 타 유형의 데이터로부터 또는 개발자에 의해 유도된 구조화된 데이터 타입 문자열, 배열, 레코드, 리스트 등의 데이터 타입 참조형 (Reference Type) 변수 선언과 메모리 생성이 분리되는 데이터 타입 배열 참조형, 클래스 참조형 등의 데이터 타입 정적 타입 언어 vs 동적 타입 언어 Javascript 개발자라면 모두들 변수의 type에 의해 힘들었던 경험들이 있었을 것이다. Java 개발자인 친구 또한 Javascript를 공부하면서 변수의 특성에 대해 “형 지정도 없고, 됐다고 해도 쉽게 바뀐다.”라는 의미에서 약간 변태 같다고 했었다… 그렇다면 이러한 성질을 뭐라고 할까? 정적 타입 언어와 동적 타입 언어의 차이는 데이터 타입 결정하는 시기 라고 할 수 있다. 정적 언어: 컴파일 시에 결정. C, C#, C++, Java 등의 언어가 있음 장점: 컴파일 시 타입에 대한 정보를 결정하기 때문에 런타임 시 속도가 빠름 컴파일 시 타입에 대한 검증을 하기 때문에 타입 안정성 높음 단점 변수의 타입이 이미 컴파일 이전에 정해지기 때문에 변수의 활용성이 떨어짐 동적 언어: 런타임(실행) 시에 결정 Perl, Ruby, Python, PHP, JavaScript 등의 언어가 있음 장점: 런타임 시 까지 변수의 타입을 선언하지 않아도 되 활용 유연성이 높음 개발자 입장에서 변수의 타입 선언 걱정없이 빠르게 구현 및 이용 가능 단점 예상치 못한 타입이 지정되어 TypeError 또는 예상치 못한 처리에러가 날 수 있음 참고 자료형 원시 값 Pass By Value / Pass By Reference 자바스크립트의 변수, 연산자, 타입의 종료 정적언어(타입)과 동적언어(타입) 동적타입 vs 정적타입 Data and Structure types","categories":[{"name":"Programming","slug":"Programming","permalink":"https://joontae-kim.github.io/categories/Programming/"},{"name":"Basic","slug":"Programming/Basic","permalink":"https://joontae-kim.github.io/categories/Programming/Basic/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://joontae-kim.github.io/tags/javascript/"},{"name":"type","slug":"type","permalink":"https://joontae-kim.github.io/tags/type/"},{"name":"types","slug":"types","permalink":"https://joontae-kim.github.io/tags/types/"}]},{"title":"변수, 스코프 그리고 호이스팅 in Javascript","slug":"javascript-hoisting-closure","date":"2020-10-09T04:10:52.000Z","updated":"2020-10-19T19:20:22.077Z","comments":true,"path":"2020/10/09/javascript-hoisting-closure/","link":"","permalink":"https://joontae-kim.github.io/2020/10/09/javascript-hoisting-closure/","excerpt":"","text":"직전 3개의 포스트는 사실 Javascript의 스코프와 호이스팅을 더 잘 이해하기 위한 Javascipt 엔진의 함수와 변수를 처리하는 실행 컨텍스트에 대해 공부해봤습니다. 사실 이전 (블로그를 리뉴얼하기 전에도) 다룬적 있지만 사실 그땐 음.. 이해했다기 보단 그저 암기를 했다고 생각했습니다. 그렇다면… 이번에는 잘 이해할 수 있을지 궁금합니다. 이번 주제는 공부하면서 참고했던 Tania Rascia 의 Understanding Variables, Scope, and Hoisting in JavaScript 를 번역하고 정리해보는 것으로 진행해보겠습니다. 2018년 2월에 게재되었다고 하지만 구독 횟수?가 무려 143.4k 이다… 변수, 스코프, 호이스팅 이해하기소개변수 (Variables) 는 많은 프로그래밍 언어에서 기초적인 부분이며 초보 코더(coder)들이 배워야할 첫번째이자 가장 중요한 개념이다. Javascript에는 변수의 이름을 지을때 따라야하는 몇가지 규칙 뿐만 아니라 많은 다양한 속성들이 있다. Javascript에서 변수를 선언하기 위해 사용되는 키워드로는 var, let 그리고 const 가 있으며 각 키워드들은 코드가 변수를 다르게 해석하도록 영향을 끼친다. 이 튜토리얼은 변수는 무엇이며, 선언과 변수명 정하는 법 그리고 var, let 그리고 const 의 차이점을 면밀히 살펴볼 것입니다. 또한, 호이스팅의 효과와 변수의 동작에 대한 전역 그리고 지역 스코프에 대한 중요성도 살펴볼 것입니다. 변수 이해하기 변수(variable) 란 값을 저장하기 위해 사용되는 이름을 가진 컨테이너이며, 여러번 참조할지 모르는 일부 정보를 나중에 사용하거나 수정하기 위해 변수 안에 저장할 수 있습니다. Javascript에서 변수에 포함된 값은 숫자, 문자열 또는 객체를 포함하는 특정 JavaScript 데아이터 타입 이 될 수 있습니다. 오늘날 Javascript의 바탕이 되는 ECMAScript 2015 (ES6) 언어 스펙 이전에는 오직 var 키워드를 사용하는 것이 변수를 선언하는 유일한 방법이었습니다. 결과적으로 대부분의 낡은 코드와 학습 리소스들은 오직 var 만을 사용할 것입니다. 우리는 “var, let, and const의 차이점” 섹션 에서 var, let 그리고 const 키워드의 차이점을 살펴보겠습니다. 변수 자체의 개념을 설명하기 위해서 우리는 var 을 사용할 수 있습니다. 아래의 예제어서 우리는 변수를 선언할 것 이고, 값을 할당할 것 입니다. 12// 문자열 값 Sammy를 username 식별자에 할당합니다.var username = &quot;sammy_shark&quot;; 위 문장은 몇 가지 부분으로 구성되어 있습니다: var 키워드를 사용한 변수 선언 username 변수 이름 (또는 식별자(identifier)) = 문법으로 표현되는 할당 식별자 할당된 값, sammy_shark 현재 코드상에서 우리는 username 을 사용할 수 있습니다. Javascript는 문자열 값 sammy_shark 을 나타내는 ``username` 을 기억할 것입니다. 1234// 변수가 값과 동일한지 확인해봅시다if (username === &quot;sammy_shark&quot;) &#123; console.log(true);&#125; 12// Outputtrue 이전에 언급했던 것처럼, 변수는 Javascript 데이터 타입으로 나타낼 수 있습니다. 예와 같이 우리는 문자열(String), 숫자(Number), 객체(Object), 논리값(Boolean) 그리고 null 값으로 변수를 선언할 수 있습니다. 1234567// 다양한 변수 할당var name = &quot;Sammy&quot;;var spartans = 300;var kingdoms = [ &quot;mammals&quot;, &quot;birds&quot;, &quot;fish&quot; ];var poem = &#123; roses: &quot;red&quot;, violets: &quot;blue&quot; &#125;;var success = true;var nothing = null; 우리는 console.log 을 사용해 특정 변수에 담긴 값을 볼 수 있습니다. 12// spartans 변수를 console에 전송console.log(spartans); 12// Output300 변수는 추후에 접근하거나 수정할 수 있는 메모리에 데이터를 저장하고, 또한 새로운 값으로 재할당하거 지정할 수도 있습니다. 아래의 간단한 예제는 비밀번호를 변수에 저장하고 업데이트 하는 방법을 설명합니다. 1234567// password 변수에 값을 할당var password = &quot;hunter2&quot;;// 새로운 값을 변수 값에 재할당password = &quot;hunter3&quot;;console.log(password); 12// Output&#x27;hunter3&#x27; 변수 이름짓기변수 이름은 JavaScript에서 식별자 (identifier) 로 알려져있습니다. Understanding Syntax and Code Structure in JavaScript 에서 식별자 이름 짓기에 대한 몇 가지 규칙에 대해 논했으며, 아래와 같이 요약할 수 있습니다: 변수 이름은 오직 문자(a-z), 숫자(0-9), 달러 기호($) 그리고 언더스코어(_) 변수 이름은 어떠한 빈칸(tab 또는 space)도 포함할 수 없습니다. 숫자로 변수 이름을 시작할 수 없습니다. 변수 이름으로 사용할 수 없는 몇 가지 예약어 가 있습니다. 변수 이름은 대소문자를 구분합니다. 또한, JavaScript는 var 또는 let 으로 선언된 함수 또는 변수의 이름에 카멜 케이스(camel case, 때때론 camelCase)를 사용하는 규칙이 있습니다. 이것은 첫번째 글자는 소문자이고 그 이후의 글자는 공백없이 모든 후속 단어의 첫글자를 대문자로 쓰는 관행입니다. 상수(constant)가 아닌 대부분의 변수는 몇 가지 예외와 함께 이 규칙을 따라야합니다. const 키워드로 선언된 상수(constant)인 변수의 이름은 전형적으로 모두 대문자로 작성합니다. 배워야 할 규칙들이 많아보이겠지만, 이와 같은 관습들은 유효하고 규칙에 맞는 변수 이름을 작성하기 위한 제 2의 본성이 매우 빠르게 될 것입니다. var, let, and const 차이점JavaScript는 변수를 선언하기 위해 언어의 복잡성을 더하는 세개의 다른 키워드가 있습니다. 3개의 키워드 차이점은 스코프(scope), 호이스팅(hoisting) 그리고 재할당(reassignment)에 바탕을 두고 있습니다. Keyword Scope Hoisting Can Be Reassigned Can Be Redeclared var Function scope Yes Yes Yes let Block scope No Yes No const Block scope No No No 여러분은 자신의 프로그램에 세 가지중 어떤 것을 사용해야만 하는지 궁금해할지도 모릅니다. 흔히, 받아들여지는 관행은 가능하 한 const 를, 반복문과 재할당의 경우에는 let 를 사용하도록 하는 것입니다. 일반적으로, var 은 작동하고 있는 레거시 코드 외부에서 피할 수 있습니다. Variable Scope (변수 스코프)JavaScript에서 Scope 는 JavaScript에게 변수 접근성을 결정하는 코드의 현재 컨텍스트를 참조합니다. 스코프에는 두가지 타입으로, 지역(local) 과 전역(global) 이 있습니다. Global variables : 블록 밖에 선언된 변수 Local variables : 블록 안에 선언된 변수 아래 예제처럼, 우리는 전역 변수를 생성할 수 있다. 12// 전역변수 초기화var creature = &quot;wolf&quot;; 우리는 변수가 재할당 가능하다고 배웠습니다. 지역 변수를 사용함으로써 우리는 원래 값을 변경하거나 재할당 없이 외부 스코프에 있는 변수와 같은 이름으로 새로운 변수를 생성할 수 있습니다. 아래 예제에서 우리는 전역 species 변수를 생성했고, 함수 안에 같은 이름으로 지역 변수가 또 있습니다. 이 코드를 콘솔에 전송함으로써 우리는 변수의 값이 스코프에 따라 어떻게 다르며, 원래 값은 변하지 않는다는 것을 볼 수 있습니다. 12345678910111213// Initialize a global variablevar species = &quot;human&quot;;function transform() &#123; // Initialize a local, function-scoped variable var species = &quot;werewolf&quot;; console.log(species);&#125;// Log the global and local variableconsole.log(species);transform();console.log(species); 1234// Outputhumanwerewolfhuman 예제에서, 지역 변수는 함수 스코프(function-scoped) 이다. var 키워드로 선언된 변수들은 구분된 스코프를 가짐으로써 변수들이 함수를 인지한다는 의미에서 항상 함수 스코프이다. 따라서, 이러한 지역적 스코프 변수는 전역 스코프에서 접근할 수 없다. 하지만 새로운 키워드인 let 과 const 는 블록 스코프(block-scoped) 인데, 함수 블록, if 구문 그리고 for 과 while 반복문을 포함한 특정 종류의 블록으로 생성된 새로운 지역 스코프를 의미한다. 함수 스코프(function-scoped)와 블로 스코프(block-scoped) 내 변수의 차이를 형상화하기 위해서 let 을 사용해 if 블록 안에 새로운 변수를 할당할 것 입니다. 123456789101112var fullMoon = true;// Initialize a global variablelet species = &quot;human&quot;;if (fullMoon) &#123; // Initialize a block-scoped variable let species = &quot;werewolf&quot;; console.log(`It is a full moon. Lupin is currently a $&#123;species&#125;.`);&#125;console.log(`It is not a full moon. Lupin is currently a $&#123;species&#125;.`); 123// OutputIt is a full moon. Lupin is currently a werewolf.It is not a full moon. Lupin is currently a human. 위 예에서 보듯이, species 변수는 전역적으로 하나의 값(human)만, 지역적으로 werewolf 라는 다른 값을 가집니다. 만약 우리가 var 을 사용했다면, 다른 결과를 만들 것입니다. 12345678910// Use var to initialize a variablevar species = &quot;human&quot;;if (fullMoon) &#123; // Attempt to create a new variable in a block var species = &quot;werewolf&quot;; console.log(`It is a full moon. Lupin is currently a $&#123;species&#125;.`);&#125;console.log(`It is not a full moon. Lupin is currently a $&#123;species&#125;.`); 123// OutputIt is a full moon. Lupin is currently a werewolf.It is not a full moon. Lupin is currently a werewolf. 결과적으로, 전역 변수와 블록 스코프 변수 둘다 werewolf 라는 같은 값으로 끝났습니다. 이것은 var 로 새로운 지역 변수를 생성하는 것 대신에, 같은 스코프안에서 같은 변수에 재할당했기 때문입니다. var 은 if 조건문을 다른 부분으로 즉, 새로운 스코프로 인식하지 않습니다. 의도치 않게 변수 값을 덮어쓰는 것과 같은 코드를 덜 생산하기 위해, 일반적으로 블록 스코프로 변수를 선언하기를 추천합니다. Hoisting (호이스팅)지금까지 대부분의 예제에서 우리는 변수를 선언하기 위해 var 을 사용했었고, 값으로 초기화 했습니다. 선언과 초기화 이후에 우리는 값을 접근하거나 재할당할 수 있습니다. 만약 우리가 변수가 선언되고 초기화되기 전에 사용하려고 시도한다면, 이것은 undefined 를 반환할 것입니다. 12345// 변수가 선언되기 전에 사용 시도console.log(x);// 변수 할당var x = 100; 12// Outputundefined 그러나, 만약 우리가 var 키워드를 생략했다면, 우리는 더이상 변수를 선언할 수 없으며 오직 초기화만 할 수 있을 것입니다. 이것은 ReferenceError 를 반환할 것이고 스크립트의 실행을 중단합니다. 12345// Attempt to use a variable before declaring itconsole.log(x);// Variable assignment without varx = 100; 12// OutputReferenceError: x is not defined 이런 이유는 호이스팅(hoisting) 으로, 변수와 함수 선언을 해당 스코프의 가장 위로 옮기는 Javascript의 동작입니다. 초기화가 아닌 실제 선언만 끌어올려지기(hoist) 때문에 첫 번째 예제의 값은 undefined 를 반환합니다. 이 개념을 더 확실하게 설명하기 위해, Javascript가 실제로 어떻게 해석하는지 아래의 코드에 작성해보았습니다. 12345678// 우리가 작성한 코드console.log(x);var x = 100;// JavaScript가 해석한 방법var x;console.log(x);x = 100; JavaScript는 스크립트를 실행하기 전에 변수로써 x 를 메모리에 저장한다. 정의되기 전에 여전히 x 를 호출하기 때문에 결과는 100 아닌 undefined 이다. 하지만, ReferenceError 가 발생하지 않고 스크립트가 중단된다. 비록 var 키워드가 실제로 var 의 위치를 변경하지는 않았지만, hoisting의 작동 장식에 대한 유용한 코드입니다. 그러나 이 코드를 작성한 프로그래머가 x의 결과값이 undefined 일때, true 일 것이라고 예상하기 때문에, 이러한 동작은 이슈를 유발할 수 있습니다. 또한 다음 예제에서 우리는 호이스팅이 예상치 못한 결과를 어떻게 유발할 수 있는지 볼 수 있습니다. 123456789101112// 전역 스코프에 변수 x 초기화var x = 100;function hoist() &#123; // 코드 결과에 아무런 영향을 주지 않아야하는 조건문 if (false) &#123; var x = 200; &#125; console.log(x);&#125;hoist(); 12// Outputundefined 이 예제에서, 우리는 전역적으로 x 에 100 이 되도록 선언했습니다. if 선언문에 따라 x 는 200 으로 변할수도 있었지만 그 조건문이 false 이기 때문에 x 의 값에 영향을 주지 못했습니다. 대신에 x 는 hoist() 함수의 가장 꼭대기로 끌어올려지고, 값은 undefined 가 됐습니다. 이러한 예상치 못한 작동의 유형은 잠재적으로 프로그램에 버그들을 유발할 수 있습니다. let과 const는 블록 스코프(block-scoped)이기 때문에, 아래와 같이 이러한 문법에서는 끌어올려지지 않을 것입니다. 123456789101112// Initialize x in the global scopelet x = true;function hoist() &#123; // Initialize x in the function scope if (3 === 4) &#123; let x = false; &#125; console.log(x);&#125;hoist(); 12// Outputtrue var 로 가능한 변수 중복 선언은 let 과 const 에서는 에러를 던질 것입니다. 12345// var 으로 선언된 변수 덮어쓰기 시도var x = 1;var x = 2;console.log(x); 12// Output2 12345// let 으로 선언된 변수 덮어쓰기 시도let y = 1;let y = 2;console.log(y); 12// OutputUncaught SyntaxError: Identifier &#x27;y&#x27; has already been declared 요약하자면, var 로 도입된 변수는 메모리에 변수 선언을 저장하는 Javascript 메커니즘인 호이스팅에 의해 영향을 잠재적으로 받게 됩니다. 이러한 메커니즘은 정의되지 않은 변수가 생길 수 있습니다. let 과 const 의 도입은 변수를 선언하기 전 사용하려고 하거나 한번 이상 선언하려고 할때 에러를 던짐으로써 이러한 이슈를 해결해줍니다. Constants (상수)많은 프로그래밍 언어는 값을 수정하거나 변경할 수 없는 상수 (constant) 라는 기능이 있습니다. Javascript에서 const 식별자는 상수(Constants) 이후에 따라서 만들어졌으며, const 에 할당된 값은 재할당할 수 없습니다. 모든 const 식별자 대문자로 작성하는 것이 일반적인 규범이며 다른 변수 값과 쉽게 구별할 수 있도록 표시합니다. 아래의 예제에서, 우리는 const 키워드로 상수로써 SPECIES 변수를 초기화했고, 변수를 재할당하려고 할때 결과가 에러일 것입니다. 1234567// const에 값 할당const SPECIES = &quot;human&quot;;// 값 재할당 시도SPECIES = &quot;werewolf&quot;;console.log(SPECIES); 12// OutputUncaught TypeError: Assignment to constant variable. const 값은 재할당할 수 없기 때문에, 선언과 초기화가 동시에 될 필요가 있거나 에러를 던질 것입니다. 1234// const 초기화 없이 선언const TODO;console.log(TODO); 12// OutputUncaught SyntaxError: Missing initializer in const declaration 프로그래밍에서 변경할 수 있는 변수는 mutable (변경 가능한 또는 변하기 쉬운) 인 반면에, 변경할 수 없는 값들은 immutable(불변의) 로 알려져 있습니다. 비록 const 값은 재할당할 수 없지만, const 로 선언된 객체의 속성을 수정하는 것은 변경 가능(mutable)하다. 12345678910// CAR 객체에 두개의 속성 생성const CAR = &#123; color: &quot;blue&quot;, price: 15000&#125;// CAR 속성 수정CAR.price = 20000;console.log(CAR); 12// Output&#123; color: &#x27;blue&#x27;, price: 20000 &#125; 상수(Constants)는 프로젝트에서 미래의 여러분 자신과 다른 개발자들에게 변수가 재할당될 수 없는 의도를 명확히 하는데 유용합니다. 만약 미래에 변수가 수정될지도 모른다고 예상한다면, 여러분은 대신에 let 을 사용해 변수를 선언하기를 원할 것입니다. Conclusion튜토리얼에서, 우리는 변수는 무엇이며 변수명 짓기의 규칙과 변수값을 할당하는 법에 대해 살펴봤으며 또한, 스코프(scope) 와 호이스팅(hoisting), var 키워드의 몇가지 한계 뿐만 아니라 let 과 const 가 var 키워드에 의한 이슈들을 해결하는 방법에 대해서도 학습해봤습니다. 번역을 마치며이상 Javascript의 변수와 지역/전역 스코프에 따른 변수 처리 그리고 변수를 선언하기 위한 var, let 그리고 const 키워드의 차이와 각 선언 키워드의 스코프에 대해서 배워봤습니다. 다음으로는 ko.javascript.info의 closure 파트의 연습문제를 풀어보며 Javascript의 lexical Environment, 스코프, 호이스팅 그리고 var, let, const 에 대해 복습해보도록 하겠습니다. 본 포스트는 Tania Rascia 의 Understanding Variables, Scope, and Hoisting in JavaScript 를 번역했음을 알려드립니다.","categories":[{"name":"Programming","slug":"Programming","permalink":"https://joontae-kim.github.io/categories/Programming/"},{"name":"Javascript","slug":"Programming/Javascript","permalink":"https://joontae-kim.github.io/categories/Programming/Javascript/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://joontae-kim.github.io/tags/javascript/"},{"name":"Variable","slug":"Variable","permalink":"https://joontae-kim.github.io/tags/Variable/"},{"name":"Hoisting","slug":"Hoisting","permalink":"https://joontae-kim.github.io/tags/Hoisting/"},{"name":"Scope","slug":"Scope","permalink":"https://joontae-kim.github.io/tags/Scope/"}]},{"title":"javascript types","slug":"javascript-types","date":"2020-10-08T17:02:43.000Z","updated":"2021-07-22T07:09:26.663Z","comments":true,"path":"2020/10/09/javascript-types/","link":"","permalink":"https://joontae-kim.github.io/2020/10/09/javascript-types/","excerpt":"","text":"프로그래밍 언어에서 자료형(types) 또는 데이터 타입(data type) 이란 숫자형(정수형, 실수형), 논리값(Boolean), 문자(String) 등의 데이터를 식별하는 분류 (indentifier) 로서, 해당 자료형에 대한 가능한 값, 해당 자료형에서 수행을 마칠 수 있는 명령들, 데이터의 의미, 값의 저장하는 방식을 결정한다. 이렇듯 자료형이란 개발자가 특정 기능 또는 함수 내에서 어떤 형태의 데이터를 다룰 것이며 이를 통해 가능한 작업은 어떤 것인지 정의할 수 있는 역할을 한다. 그렇다면 Javascript의 데이터 타입(Type)에는 무엇이 있을까? Javascript의 Data Type 분류Javascript의 데이터 형태 분류는 기본적으로 Primitives(원시형 또는 기본형) / Reference (참조형) 으로 나뉜다. Primitives Type (원시형 또는 기본형) 단 하나의 값만 가질 수 있음 변수에 할당될 때 스택 메모리 상에 고정된 크기로 저장 모든 원시 값은 불변 (immutable)의 성질로 변형 불가 즉, 원시값을 교체할 수는 있지만, 직접 변형할 수는 없음 1234567891011121314// 문자열 메서드는 문자열을 변형하지 않음var bar = &quot;baz&quot;;console.log(bar); // bazbar.toUpperCase();console.log(bar); // baz// 배열 메소드는 배열을 변형함var foo = [];console.log(foo); // []foo.push(&quot;plugh&quot;);console.log(foo); // [&quot;plugh&quot;]// 할당은 원시 값에 새로운 값을 부여 (변형이 아님)bar = bar.toUpperCase(); // BAZ 객체가 아니면서 메서드도 가지지 않는 데이터 null의 경우, 겉보기엔 원시 값처럼 보이는 있지만, 사실 Object 이며, 모든 구조화된 자료형은 prototype chain 에 따라 null의 자손이다. 대부분의 경우, 원시 값은 언어 구현체의 가장 저수준(low level) 에서 나타남. 원시 값 자체와, 원시값을 할당한 변수를 혼동하지 않는 것이 중요! 변수: 새로운 값을 다시 할당 가능 원시값: 객체, 배열, 함수와 달리 변형 불가능 값에 의한 전달 (pass-by-value) 방식으로 전달 Reference Type (참조형) 객체는 데이터와 그 데이터에 관련한 동작(절차, 방법, 기능)을 모두 포함할 수 있는 개념적 존재 즉, Property와 Method를 포함할 수 있는 독립적 주체이자 복합적 구조의 데이터 데이터가 동적 바인딩 되므로 실행중에도 그 값이 변동될 수 있으며, 선언될때 이미 크기가 정해져 있지 않음 JavaScript는 객체 기반의 스크립트 언어로써 JavaScript를 이루고 있는 거의 모든 것이 객체이다. 원시 타입을 제외한 나머지 값들(배열, 함수, 정규표현식 등)은 모두 객체이다. 참조 타입은 변수의 값이 저장된 메모리 블럭의 주소를 가지고 있고 자바스크립트 엔진이 변수가 가지고 있는 메모리 주소를 이용해서 변수의 값에 접근한다. 변수에 할당이 될 때 값이 직접 해당 변수에 저장될 수 없으며 변수에는 데이터에 대한 참조만 저장 변수의 값이 저장된 힙 메모리의 주소값을 저장 객체와 함수 는 언어의 다른 기본 요소임. 객체 =&gt; 값을 위한 컨테이너 함수 =&gt; 어플리케이션이 수행할 수 있는 절차 (procedure) 참조에 의한 전달 (pass-by-reference) 방식으로 전달 Pass by Value VS Pass by ReferencePass by Value먼저, Pass by Value를 살펴보면, Function은 인수로써 변수값을 직접 전달받아 호출한다. 함수 내에서 인수를 변경하는 것은 함수 밖에 있는 변수에 영향을 끼치지 않는다. Javascript는 항상 값에 의한 전달 이므로 변수값을 변경해도 기본 요소(문자열 또는 숫자)가 변경되지 않는다. 12345678910111213141516171819202122232425function callByValue(varOne, varTwo) &#123; console.log(&quot;Inside Call by Value Method&quot;); varOne = 100; varTwo = 200; console.log(&quot;varOne =&quot; + varOne +&quot;varTwo =&quot; +varTwo); &#125;let varOne = 10; let varTwo = 20;console.log(&quot;Before Call by Value Method&quot;); console.log(&quot;varOne =&quot; + varOne +&quot;varTwo =&quot; +varTwo); callByValue(varOne, varTwo) console.log(&quot;After Call by Value Method&quot;); console.log(&quot;varOne =&quot; + varOne +&quot;varTwo =&quot; +varTwo); output will be : --------------- Before Call by Value Method varOne =10 varTwo =20 Inside Call by Value Method varOne =100 varTwo =200 After Call by Value Method varOne =10 varTwo =20 그러나, 변수가 배열(Array)을 포함한 객체(Object)를 참조할때는 값은 객체에 대한 참조값이다. Pass by ReferencePass by Reference를 살펴보면, Function은 인자로써 전달받은 변수의 참조나 주소(reference/address)를 호출한다. 함수 내에서 인자를 변경하는 것은 함수 밖에 있는 인자에 영향을 끼친다. Javascript 객체와 배열은 참조에 의한 전달을 따른다. 그러나 만약 우리가 메서드에 인자로써 객체 또는 배열을 전달한다면 객체의 값을 변경할 수 있는 가능성이 생긴다. Primitives and Reference Type 분류가장 기본적인 분류법으로 ECMAScript 표준에는 7가지 type으로 정의한다. Primitives: 5가지 타입 Boolean null undefined Number Symbol (ECMAScript 6에 신규 추가됨) Reference: 1가지 타입, 값이 저장된 주소값을 할당 Object Object 타입의 데이터 종류: Array, Map, Set, WeakMap, WeakSet, Date 등 Object와 Function typeof Object =&gt; object 반환 typeof function =&gt; function 반환 Primitive Type (원시형 데이터)Boolean논리적 데이터 유형으로, true 와 false 리터럴 값만 가질 수 있음. null일반적으로 존재하지 않거나 유효하지 않은 object를 의미하며 의도적으로 비어있는 값을 나타내기 위해서도 사용할 수 있다. 그리고 Javascript에서는 대소문자를 구분하므로 Null 또는 NULL과는 다르다. undefined변수 선언 후 값을 할당하지 않은 혹은 주어짖 않은 인수에 자동 할당된다. 그리고 동등 연산자(==)와 일치 연산자(===)로 비교할 때 그 결과값이 다르므로 주의해야 한다. Number정수, 부동 소수점, 복식 또는 대수와 같은 데이터 타입이 존재하는 다른 언어들과 다르게, Javascript 에서는 숫자 데이터 타입을 64비트 부동소수점 으로 표현한다. 즉, 정수만을 표현하기 위한 특별한 자료형은 없다. 그리고 Number 타입에는 세 가지 유의미한 상징적 값들이 있는데 이는 +/-Infinity 와 Nan 이다. Nan 은 전역 스코프 변수로써 숫자가 아님 을 의미하며, Nan을 반환하는 다섯 가지 종료로는 아래와 같다. 숫자로서 읽을 수 없음 (parseInt(&quot;어쩌구&quot;), Number(undefined)) 결과가 허수인 수학 계산식 (Math.sqrt(-1)) 피연산자가 NaN (7 ** NaN) 정의할 수 없는 계산식 (0 * Infinity) 문자열을 포함하면서 덧셈이 아닌 계산식 (&quot;가&quot; / 3) StringJavascript에서 문자열은 페이지 인코딩 방식과 상관없이 항상 UTF-16 형식을 따르며 String 객체는 문자열 원시값을 둘러싼 wrapper 객체이다. SymbolECMAScript 2015에서 추가된 Symbol은 인스턴스가 고유하고 불변의 값을 할당할때 사용하는 데이터 타입으로, Symbol 의 값은 “Symbol 값(value)” 로서 참조될 수 있다. Javascript 런타임 환경에서 Symbol 값은 고유하고 불변의 값을 생산하기 위해 Symbol 함수가 선언하여 동적으로 생성된다. 1234567// 동일한 description으로 선언된 두개의 symbol이 있다.let Sym1 = Symbol(&quot;Sym&quot;)let Sym2 = Symbol(&quot;Sym&quot;) console.log(Sym1 === Sym2) // returns &quot;false&quot;// 동일한 description으로 많은 symbol을 생성하더라도 서로 다르기 때문에// Symbol은 고유한 성질을 보장한다. Reference TypeObject에 대한 내용은 워낙 방대하므로 추후 포스팅으로 자세히 다뤄 보도록 하겠습니다. 참고 자료형 - ko.wikipedia.org 원시 값 - developer.mozilla.org/en-US 자바스크립트의 자료형 - developer.mozilla.org/ko Pass By Value / Pass By Reference - kkumalog.tistory.com 자바스크립트의 변수, 연산자, 타입의 종료 - gmlwjd9405.github.io 정적언어(타입)과 동적언어(타입) - itmining.tistory.com 동적타입 vs 정적타입 - blog.naver.com/tkandrea92 Data and Structure types - developer.mozilla.org/en-US JavaScript - 데이터 타입(Data Type)에 대해 알아보자 - velog.io/@surim014 [Javascript] Pass By Value And Pass By Reference In JavaScript - by Raghuraman Kesavan","categories":[{"name":"Programming","slug":"Programming","permalink":"https://joontae-kim.github.io/categories/Programming/"},{"name":"Javascript","slug":"Programming/Javascript","permalink":"https://joontae-kim.github.io/categories/Programming/Javascript/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://joontae-kim.github.io/tags/javascript/"},{"name":"type","slug":"type","permalink":"https://joontae-kim.github.io/tags/type/"},{"name":"types","slug":"types","permalink":"https://joontae-kim.github.io/tags/types/"}]},{"title":"javascript 작동원리","slug":"javascript-operation","date":"2020-10-08T16:39:50.000Z","updated":"2020-10-09T04:03:32.106Z","comments":true,"path":"2020/10/09/javascript-operation/","link":"","permalink":"https://joontae-kim.github.io/2020/10/09/javascript-operation/","excerpt":"","text":"Javascript는 Java, C, Python 등의 언어와 다르게 싱글 스레드 기반의 언어로써 한번에 단 하나의 작업만을 처리할 수 있다. 즉, 비동기 처리 언어라는 것이다. 그러난 이는 Javascript 엔진에 국한된 얘기이다. 응? 무슨 소리인가? Javascript는 비동기 언어지만 이건 Javascript 엔진에 국한된 얘기라니? 실제로 Javascript를 구동시키기 위한 런타임 환경에는 Javascript Engine과 Web APIs, Envent Loop, Callback Queue가 존재하며 전체 런타임 환경에서 보면 동기 작동의 상황이 펼쳐지기도 한다. Javascript Engine가장 대표적인 Javascript Engine으로 구글에서 개발한 V8은 Chrome과 Node.js에서 사용한다. 아래의 사진은 V8 엔진의 구조도를 간단히 나타내고 있다. 위 사진과 같이 V8 엔진은 Memory Heap과 Call Stack으로 구성되어 있으며 정의는 아래와 같다. Memory Heap : 메모리 할당이 일어나는 곳으로서 구조화되지 않은 넓은 메모리 영역을 지칭 Call Stack : 코드 실행에 따라 호출 스택이 쌓이는 곳 or 하나의 작업을 완료하기 위해 제공되는 환경 호출 스택의 각 단계를 *스택 프레임(Stack Frame)*이라 한다. 서두에서 언급한 “Javascript는 … 싱글 스레드 기반의 언어로써 …” 에서의 싱글 스레드란 위에서 언급한 Call Stack을 의미한 것이었다. 따라서 한 번에 한 작업만 처리! 아래의 코드를 통해 Call Stack이 어떻게 작동하는지 보자. 12345678function multiply(x, y) &#123; return x * y;&#125;function printSquare(x) &#123; var s = multiply(x, x); console.log(s);&#125;printSquare(5); 위 코드을 보면 printSquare(5) 가 호출되고 내부 실행 컨택스트인multiply(x,x)와 console.log가 차례대로 호출 및 실행 종료된 후printSquare(5) 가 종료되며 Call Stack이 빈다. 이는 Javascript의 Run to Completion이라고 하는데 하나의 함수가 실행되면 이 함수의 실행이 끝날때 까지 다른 어떤 작업도 중간에 끼어들지 못한다는 의미이다. 또한, 너무 많은 callback function이나 loop 문을 작동시키면 과도한 Task가 호출 스택에 쌓이게 되어 최대 허용치를 넘기게 되는데 이때 출력되는 에러가 바로 Uncaught RangeError: Macimum call stack size exceeded 이다. 보통 만 개 정도의 Task를 Call Stack에 쌓을 수 (같은 의미로 함수를 만 번 정도 호출할 수 있다는 의미) 있다는 의미로 위 에러가 발생했을시 function call 을 디버깅해봐야 한다. 그렇다면 서두에서 언급한 비동기적 상황 이란 무엇인가? 예를 들면 setTimeout이나 XMLHttpRequest 와 같은 비동기 호출 event 이다. 이러한 비동기 호출은 JS Engine이 아닌 Web API 영역에서 담당하는데 먼저 브라우저에서 Javascript가 작동하는 전체 환경을 보자. JS Engine과 Web APIs 이외에 Event Loop와 Task Queue가 있는데 이 두 요소가 Web APIs에서 제공하는 함수는 Call Stack에서 비동기로 처리하지만 비동기 작업 후의 callback function은 Task Queue로 담기게 된다. 자세한 설명은 아래에서 이어하겠습니다. 브라우저 환경에서 Javascirpt를 구동시키기 위해서는 JS Engine 뿐만 아니라 Web APIs, Task Queue가 있으며 실제 자바스크립트가 구동되는 환경(브라우저, Node.js등)에서는 주로 여러 개의 스레드가 사용된다. 이러한 구동 환경이 단일 호출 스택을 사용하는 자바 스크립트 엔진과 상호 연동하기 위해 사용하는 장치가 바로 ‘이벤트 루프’ 이다. Event Loop와 Task Queue를 설명하기 위해 Ajax 통신을 생각해보자. 서버로부터 데이터를 요청하기 위해 Request를 요청하며 Response를 받기 위한 callback function이 있다고 가정해보자. 그렇다면 위 브라우저 환경에 따라 설명해보면 Ajax get 요청은 Call Stack에서 비동기로 처리한 후 Web APIs가 동작하는 별도의 환경에서 실행되어 완료된 후에는 Response를 받기 위한 callback function을 Task Queue에 push되어 Call Stack에서 Task가 모두 종료되어 빈 상태가 될까지 기다린 후 Event Loop에 의해 다시 Call Stack에 push되어 처리됩니다. 이러한 구동방식으로 자바스크립트는 이벤트 기반 동시성(Concurrency) 모델을 제공합니다. 이벤트 루프의 동작을 시각적으로 보시기 원하신다면 http://latentflip.com/loupe/ 를 보시기 바랍니다. 정리하자면, Task Queue: 말 그대로 콜백 함수들이 대기하는 큐(FIFO) 형태의 배열 모든 비동기 API들은 작업이 완료되면 콜백 함수를 태스크 큐에 추가한다. Event Loop: (함수)호출 스택이 비워질 때마다 큐에서 콜백 함수를 꺼내와서 실행하는 역할을 함 ‘현재 실행중인 태스크가 없을 때’(주로 호출 스택이 비워졌을 때) 태스크 큐의 첫 번째 태스크를 꺼내와 실행한다. 언제나 그렇듯이, 함수를 호출하면 그 함수의 사용을 위한 새로운 스택 프레임이 생선된다. 위와 같은 구조적 동작 덕분에 JS Engine은 싱글 쓰레드 기반의 비동기 작업이 보장받지만 반대로 싱글 쓰레드 기반의 Javascript 작동 원리의 단점 이 발생하기도 합니다. 바로 Run-to-completion 과 Event Loop 때문이다. 만약 콜스택 내 함수의 수행시간이 길어져 Task Queue의 콜백 함수들이 수행되지도 못하거나 과도한 콜백 함수들이 연속적으로 수행될 경우 브라우저에서는 아무것도 할 수 없습니다. 이게 바로 블록킹 이 된다고 하는 것입니다. 이럴 경우 브라우저는 장시간 응답이 없을 수 있으며 에러를 일으켜 사용자에게 페이지를 닫을지 물어보기도 합니다. 이와 상황에서의 해결책이 바로 비동기 콜백(Asynchronous callbacks) 입니다. 참조 mozila MDN web docs - Javascript Introduction 객체지향 프로그래밍이란 객체 지향 언어의 두가지 줄기 자바스크립트 엔진 자바스크립트와 이벤트 루프 자바스크립트의 동작원리: 엔진, 런타임, 호출 스택 자바스크립트는 어떻게 작동하는가: 엔진, 런타임, 콜스택 개관 자바스크립트는 어떻게 작동하는가: V8 엔진의 내부 + 최적화된 코드를 작성을 위한 다섯 가지 팁 Concurrency model and Event Loop 웹에서 자바스크립트 구동 환경 자바스크립트 비동기가 되는 원리 호출 스택과 이벤트 루프 Javascript 동작 원리 자바스크립트 동시성 모델과 이벤트 루프 [번역] 바보들을 위한 자바스크립트 엔진 가이드","categories":[{"name":"Programming","slug":"Programming","permalink":"https://joontae-kim.github.io/categories/Programming/"},{"name":"Javascript","slug":"Programming/Javascript","permalink":"https://joontae-kim.github.io/categories/Programming/Javascript/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://joontae-kim.github.io/tags/javascript/"},{"name":"javascript engine","slug":"javascript-engine","permalink":"https://joontae-kim.github.io/tags/javascript-engine/"}]},{"title":"ECMAScript 6 (ECMAScript 2015)","slug":"ES6","date":"2020-10-06T10:41:18.000Z","updated":"2020-10-08T16:26:41.081Z","comments":true,"path":"2020/10/06/ES6/","link":"","permalink":"https://joontae-kim.github.io/2020/10/06/ES6/","excerpt":"","text":"이전 포스트 ECMAScript와 Babel 에서 ECMAScript 2015+ 의 Javascript 코드를 런타임 환경에 적용하기 위해서는 그에 맞는 버전으로 호환시켜줘야 하며 이를 위한 툴체인으로 Babel 이라는 것이 있다는 것까지 정리해보았습니다. 이번 포스트에서는 그렇다면 ECMAScript 2015에 어떤 syntax가 추가되었는지 까지 알아보는 시간을 가져보려합니다. 이번 주제를 위해 다양한 포스팅을 읽었고 그 중 principal 한 사이트를 번역하는 것이 도움이 될 것 같아 lukehoban 의 es6features 를 번역 했습니다. ECMAScript 6 git.io/es6featuresIntroductionECMAScript 2015 또는 ECMAScript 6는 ECMAScript 표준의 가장 최신 버전입니다. ES6는 2009년 ES5가 표준화된 이후 중대한 업데이트이자 첫번째 업데이트입니다. 주요 Javascript 엔진에서 이러한 기능의 구현은 현재 진행 중입니다. ECMAScript 6 언어의 전체 사양은 ES6 표준을 참조하세요. ES6는 다음의 새로운 기능을 포함합니다. arrows classes enhanced object literals template strings destructuring default + rest + spread let + const iterators + for..of generators unicode modules module loaders map + set + weakmap + weakset proxies symbols subclassable built-ins promises math + number + string + array + object APIs binary and octal literals reflect api tail calls ECMAScript 6 기능Arrows화살표는 =&gt; 문법을 사용하는 함수 단축어이며 문법적으로 C#, Java 8 and CoffeeScript에 있는 관련된 기능과 유사하다. 그들은 함수 구문 블록 본문 뿐만 아니라 함수식의 값을 반환하는 구문 본문 둘다 지원한다. 함수와 달리 화살표는 주변 코드와 동일한 ‘lexical this‘를 공유한다. 123456789101112131415161718192021222324252627282930313233343536// Expression bodiesvar odds = evens.map(v =&gt; v + 1); // [1, 3, 5, 7, 9]var nums = evens.map((v, i) =&gt; v + i); // [0, 3, 6, 9, 12]var pairs = evens.map(v =&gt; (&#123;even: v, odd: v + 1&#125;));/*pairs&#x27;s value[ &#123;even: 0, odd: 1&#125; &#123;even: 2, odd: 3&#125; &#123;even: 4, odd: 5&#125; &#123;even: 6, odd: 7&#125; &#123;even: 8, odd: 9&#125;]*/// Statement bodiesnums.forEach(v =&gt; &#123; if (v % 5 === 0) fives.push(v);&#125;);// [0, 0, 0]// Lexical thisvar bob = &#123; _name: &quot;Bob&quot;, _friends: [], printFriends() &#123; this._friends.forEach(f =&gt; console.log(this._name + &quot; knows &quot; + f)); &#125;&#125;// bob._friends.push(&#x27;karl&#x27;, &#x27;Tom&#x27;)// bob.printFriends()// &gt; Bob knows karl// &gt; Bob knows Tom 자세한 정보: MDN Arrow Functions 클래스 (Classes)ES6 클래스는 prototype 기반의 OO 패턴을 넘어 직관적이다. 단일의 편리한 선언적 폼을 갖는다는 것은 클래스 패턴을 더 쉽게 이용할 수 있도록 하며 상호운용성을 독려한다. 클래스는 prototype 기반의 상속(inheritance), super call, instance and static methods and constructors을 지원한다. 1234567891011121314151617181920212223class SkinnedMesh extends THREE.Mesh &#123; constructor(geometry, materials) &#123; super(geometry, materials); this.idMatrix = SkinnedMesh.defaultMatrix(); this.bones = []; this.boneMatrices = []; //... &#125; update(camera) &#123; //... super.update(); &#125; get boneCount() &#123; return this.bones.length; &#125; set matrixType(matrixType) &#123; this.idMatrix = SkinnedMesh[matrixType](); &#125; static defaultMatrix() &#123; return new THREE.Matrix4(); &#125;&#125; 더 자세한 정보: MDN Classes 강화된 객체 리터럴 (Enhanced Object Literals)객체 리터럴은 생성 시 prototype 설정, foo: foo 할당에 대한 약축, 메서드 정의, super calls 생성 그리고 함수식으로 속성 이름을 계산하는 것을 지원하도록 확장됩니다. 또한, 이러한 것들은 객체 리터럴과 클래스 선언을 더 가깝게 만들고, 객체 지향 디자인에서 동일한 편의성을 활용할 수 있게 합니다. 12345678910111213var obj = &#123; // __proto__ __proto__: theProtoObj, // Shorthand for ‘handler: handler’ handler, // Methods toString() &#123; // Super calls return &quot;d &quot; + super.toString(); &#125;, // Computed (dynamic) property names [ &#x27;prop_&#x27; + (() =&gt; 42)() ]: 42&#125;; 자세한 정보: MDN Grammar and types: Object literals 템플릿 문자열(Template Strings)템플릿 문자열은 더 직관적으로 문자열을 구성하도록 하며 Perl, Python 그리고 이외의 언어에서 문자열 보간 기능(string interpolation features)과 유사합니다. 선택적으로, 문자 구성을 커스터마이징하거나 인젝션(Injection) 공격을 피하기 위해 또는 문자 컨텐츠에서 높은 수준의 데이터 구조를 구성하기 위해 태그를 추가할 수 있습니다. 1234567891011121314151617// Basic literal string creation`In JavaScript &#x27;\\n&#x27; is a line-feed.`// Multiline strings`In JavaScript this is not legal.`// String interpolationvar name = &quot;Bob&quot;, time = &quot;today&quot;;`Hello $&#123;name&#125;, how are you $&#123;time&#125;?`// Construct an HTTP request prefix is used to interpret the replacements and constructionPOST`http://foo.org/bar?a=$&#123;a&#125;&amp;b=$&#123;b&#125; Content-Type: application/json X-Credentials: $&#123;credentials&#125; &#123; &quot;foo&quot;: $&#123;foo&#125;, &quot;bar&quot;: $&#123;bar&#125;&#125;`(myOnReadyStateChangeHandler); 자세한 정보: MDN Template Strings Destructuring (비구조화)배열이나 객체의 매칭을 지원하는 비구조화는 패턴 매칭을 통해 바인딩할 수 있도록 하며, 표준 객체 조회 foo[&quot;bar&quot;] 와 유사한 비구조화는 찾을 수 없는 경우, undefined 값을 생성하는 fail-soft 입니다. 12345678910111213141516171819202122232425262728293031// list matchingvar [a, , b] = [1,2,3];// a = 1// b = 3// Add Custom function function getASTNode () &#123; return &#123;op: 1, lhs: &#123;op: 2&#125;, rhs: 3&#125;&#125;// object matchingvar &#123; op: a, lhs: &#123; op: b &#125;, rhs: c &#125; = getASTNode()// object matching shorthand// binds `op`, `lhs` and `rhs` in scopevar &#123;op, lhs, rhs&#125; = getASTNode()// Can be used in parameter positionfunction g(&#123;name: x&#125;) &#123; console.log(x);&#125;g(&#123;name: 5&#125;) // 5// Fail-soft destructuringvar [a] = [];a === undefined; // ture// Fail-soft destructuring with defaultsvar [a = 1] = [];a === 1; // ture 더 자세한 정보: MDN Destructuring assignment Default 파라미터 + Rest 파라미터 + Spread 연산자Default 파라미터란 현재 실행중인 함수가 평가하는 기본 파라미터 값이며 함수 호출에서 배열을 연속적 인수(argurement)로 변환해고, 후행(trailing) 파라미터를 배열에 바인딩합니다. Rest 파라미터는 인수(argurements)에 대한 필요성을 대체하고, 일반적인 경우들을 보다 직접적으로 다룹니다. 1234567// Default Parameterfunction f(x, y=12) &#123; // y is 12 if not passed (or passed as undefined) return x + y;&#125;f(3) == 15// true 12345678// Rest Parameterfunction f(x, ...y) &#123; // y is an Array // y is [&quot;hello&quot;, true] return x * y.length;&#125;f(3, &quot;hello&quot;, true) == 6// true 1234567// Spread Operatorfunction f(x, y, z) &#123; return x + y + z;&#125;// Pass each elem of array as argumentf(...[1,2,3]) == 6// true 자세한 정보: Default parameters, Rest parameters, Spread Operator Let + Const블럭 범위의 바인딩을 구성하며 let 은 새로운 var , const 는 상수입니다. 정적 제한은 할당 전에 사용을 방지합니다. 12345678910111213function f() &#123; &#123; let x; &#123; // okay, block scoped name const x = &quot;sneaky&quot;; // error, const x = &quot;foo&quot;; &#125; // error, already declared in block let x = &quot;inner&quot;; &#125;&#125; 자세한 정보: let statement, const statement Iterators + For..OfIterator objects는 CLR IEnumerable 또는 Java Iterable과 유사한 커스텀 반복문(iteration)을 가능하게 합니다. for..in 을 for..of 를 사용한 사용자가 정의한 반복기 기반의 반복문으로 일반화합니다. 배열을 구현할 필요가 없으며 LINQ와 같은 지연(lazy) 디자인 패턴이 사용 가능하다. 123456789101112131415161718let fibonacci = &#123; [Symbol.iterator]() &#123; let pre = 0, cur = 1; return &#123; next() &#123; [pre, cur] = [cur, pre + cur]; return &#123; done: false, value: cur &#125; &#125; &#125; &#125;&#125;for (var n of fibonacci) &#123; // truncate the sequence at 1000 if (n &gt; 1000) break; console.log(n);&#125; 반복문은 이와 같은 duck 타입 인터페이스에 기초합니다. (오직 설명을 위해 TypeScript을 사용합니다.) 12345678910interface IteratorResult &#123; done: boolean; value: any;&#125;interface Iterator &#123; next(): IteratorResult;&#125;interface Iterable &#123; [Symbol.iterator](): Iterator&#125; 자세한 정보: MDN for…of GeneratorsGenerator는 function* and yield 를 사용해 반복기 작성을 단순화 하고, 함수는 Generator 인스턴스를 반환하는 function *로써 선언됩니다.. Generator는 추가적인 next 와 throw를 포함하는 반복기의 서브타입(subtype)이며, Generator 안에서 다시 돌아가기 위한 값이 될 수 있다. 그러나 yield 는 값을 반환하기 위한 또는 던지기(throw) 하기 위한 수식 양식(form) 입니다. 주의: 또한 async 프로그래밍과 같이 await 도 사용 가능합니다. ES7의 await 제안을 봅시다. 123456789101112131415161718var fibonacci = &#123; [Symbol.iterator]: function*() &#123; var pre = 0, cur = 1; for (;;) &#123; var temp = pre; pre = cur; cur += temp; yield cur; &#125; &#125;&#125;for (var n of fibonacci) &#123; // truncate the sequence at 1000 if (n &gt; 1000) break; console.log(n);&#125; Generator 인터페이스는 (오직 설명을 위한 TypeScript type syntax를 사용했다): 1234interface Generator extends Iterator &#123; next(value?: any): IteratorResult; throw(exception: any);&#125; 자세한 정보: MDN Iteration protocols 유니코드(Unicode)문자열에서 새로운 유니코드 리터럴 폼과 코드 포인트를 다루기 위한 새로운 RegExp u 모드 뿐만 아니라 21bit 코드 포인트 레벨에서 문자열을 처리하기 위한 새로운 API 를 포함하는 모든 유니코드를 지원하기 위한 논-블로킹 추가입니다. 이러한 추가는 Javascipt에서 세계적인 어플리케이션 구축을 지원합니다. 12345678910111213141516// same as ES5.1&quot;𠮷&quot;.length == 2// new RegExp behaviour, opt-in ‘u’&quot;𠮷&quot;.match(/./u)[0].length == 2// new form&quot;\\u&#123;20BB7&#125;&quot;==&quot;𠮷&quot;==&quot;\\uD842\\uDFB7&quot;// new String ops&quot;𠮷&quot;.codePointAt(0) == 0x20BB7// for-of iterates code pointsfor(var c of &quot;𠮷&quot;) &#123; console.log(c);&#125; 자세한 정보: MDN RegExp.prototype.unicode Modules컴포넌트 정의를 위한 모듈을 위한 언어 수준에서 지원하며 인기있는 Javascript 모듈 로더(AMD, CommonJS)가 패턴을 코드화합니다. 런타임 실행은 호스트가 정의한 기본 로더에 의해 정의되고, 암시적 비동기 모델입니다. - 요청된 모듈들이 처리되고 사용가능해질 때까지 어떠한 코드도 실행되지 않는다. 12345// lib/math.jsexport function sum(x, y) &#123; return x + y;&#125;export var pi = 3.141593; 123// app.jsimport * as math from &quot;lib/math&quot;;alert(&quot;2π = &quot; + math.sum(math.pi, math.pi)); 123// otherApp.jsimport &#123;sum, pi&#125; from &quot;lib/math&quot;;alert(&quot;2π = &quot; + sum(pi, pi)); 몇 가지 추가적인 기능으로는 export default 과 export *이 있다. 123456// lib/mathplusplus.jsexport * from &quot;lib/math&quot;;export var e = 2.71828182846;export default function(x) &#123; return Math.log(x);&#125; 123// app.jsimport ln, &#123;pi, e&#125; from &quot;lib/mathplusplus&quot;;alert(&quot;2π = &quot; + ln(e)*pi*2); 자세한 정보: import statement, export statement Module LoadersModule Loader가 지원하는 것들: 동적 로딩 (Dynamic loading) 상태 격리 (State isolation) 글로벌 네임스페이스 격리 (Global namespace isolation) 컴파일 훅 (Compilation hooks) 중첩된 가상화 (Nested virtualization) 기본 모듈 로더가 구성되어 있을 수 있으며 새로운 로더가 격리 또는 제한된 실행구문 안에서 코드를 불러오고 평가할 수 있도록 구성될수 있습니다. 123456789101112131415// Dynamic loading – ‘System’ is default loaderSystem.import(&#x27;lib/math&#x27;).then(function(m) &#123; alert(&quot;2π = &quot; + m.sum(m.pi, m.pi));&#125;);// Create execution sandboxes – new Loadersvar loader = new Loader(&#123; global: fixup(window) // replace ‘console.log’&#125;);loader.eval(&quot;console.log(&#x27;hello world!&#x27;);&quot;);// Directly manipulate module cacheSystem.get(&#x27;jquery&#x27;);System.set(&#x27;jquery&#x27;, Module(&#123;$: $&#125;)); // WARNING: not yet finalized Map + Set + WeakMap + WeakSet공통된 알고리즘을 위한 효율적인 데이터 구조이며 WeakMaps은 누수(leak)로부터 자유로운 object-key 구조의 side tables을 제공합니다. 1234567891011121314151617181920212223// Setsvar s = new Set(); // Set(0) &#123;&#125;s.add(&quot;hello&quot;).add(&quot;goodbye&quot;).add(&quot;hello&quot;); // Set(2) &#123;&quot;hello&quot;, &quot;goodbye&quot;&#125;s.size === 2; // trues.has(&quot;hello&quot;) === true; // true// Mapsvar m = new Map(); // Map(0) &#123;&#125;m.set(&quot;hello&quot;, 42); // Map(1) &#123;&quot;hello&quot; =&gt; 42&#125;m.set(&quot;s&quot;, 34); // Map(2) &#123;&quot;hello&quot; =&gt; 42, &quot;s&quot; =&gt; 34&#125;m.get(&quot;s&quot;) == 34; // true// Weak Mapsvar wm = new WeakMap(); // WeakMap &#123;&#125;wm.set(&#123; extra: 42 &#125;, 42);// WeakMap &#123;&#123;…&#125; =&gt; 42&#125; [[Entries]]0: &#123;Object =&gt; 42&#125;__proto__: WeakMapwm.size === undefined // true/ Weak Setsvar ws = new WeakSet(); // WeakSet &#123;&#125;ws.add(&#123; data: 42 &#125;);// Because the added object has no other references, it will not be held in the set 자세한 정보: Map, Set, WeakMap, WeakSet ProxiesProxy는 호스트 객체에 사용 가능한 모든 동작 범위를 가진 객체를 생성할 수 있다. 가로채기(interception), 객체 가상화(object virtualization), 로깅/프로파일링(logging/profiling) 등에 대해 사용할 수 있습니다. 12345678910// Proxying a normal objectvar target = &#123;&#125;;var handler = &#123; get: function (receiver, name) &#123; return `Hello, $&#123;name&#125;!`; &#125;&#125;;var p = new Proxy(target, handler);p.world === &#x27;Hello, world!&#x27;; // true 12345678910// Proxying a function objectvar target = function () &#123; return &#x27;I am the target&#x27;; &#125;;var handler = &#123; apply: function (receiver, ...args) &#123; return &#x27;I am the proxy&#x27;; &#125;&#125;;var p = new Proxy(target, handler);p() === &#x27;I am the proxy&#x27;; // true 모든 런타임 수준의 메타 작업을 사용 가능한 트랩이 있다. 1234567891011121314151617var handler =&#123; get:..., set:..., has:..., deleteProperty:..., apply:..., construct:..., getOwnPropertyDescriptor:..., defineProperty:..., getPrototypeOf:..., setPrototypeOf:..., enumerate:..., ownKeys:..., preventExtensions:..., isExtensible:...&#125; 자세한 정보: MDN Proxy SymbolsSymbol은 객체 상태에 접근 제어를 가능하게 하며 속성에 (ES5에서와 같이 ) string 또는 symbol로 키를 지정할 수 있습니다. Symbol은 새로운 원시(primitive) 타입입니다. 선택적으로 description 파라미터를 디버깅에서 사용합니다. - 속성의 일부분은 아닙니다. Symbol은 고유하지만 Object.getOwnPropertySymbols 와 같은 reflection 기능을 통해 노출되기 때문에 비공개가 아니다. 1234567891011121314151617181920var MyClass = (function() &#123; // module scoped symbol var key = Symbol(&quot;key&quot;); function MyClass(privateData) &#123; this[key] = privateData; &#125; MyClass.prototype = &#123; doStuff: function() &#123; ... this[key] ... &#125; &#125;; return MyClass;&#125;)();var c = new MyClass(&quot;hello&quot;)c[&quot;key&quot;] === undefined 자세한 정보: MDN Symbol Subclassable Built-insES6에서는 Array, Date 그리고 DOM Element 와 같은 내장 기능(built-in)을 서브클래싱할 수 있으며 현재 Ctor 라는 이름의 함수에 대한 객체 구조는 두가지 측면으로 사용한다. 특정 행위를 설치하기 위한 Ctor[@@create]를 객체에 배치하기 위해 호출한다. 새로운 인스턴스에 초기화하기 위한 constructor를 선언한다. 알려진 @@create symbol은 symbol.create 를 통해 사용가능하고, 내장 기능들은 현재 암죽적으로 스스로의 @@create를 노출합니다. 1234567891011121314151617181920// Pseudo-code of Arrayclass Array &#123; constructor(...args) &#123; /* ... */ &#125; static [Symbol.create]() &#123; // Install special [[DefineOwnProperty]] // to magically update &#x27;length&#x27; &#125;&#125;// User code of Array subclassclass MyArray extends Array &#123; constructor(...args) &#123; super(...args); &#125;&#125;// Two-phase &#x27;new&#x27;:// 1) Call @@create to allocate object// 2) Invoke constructor on new instancevar arr = new MyArray();arr[1] = 12;arr.length == 2 Math + Number + String + Array + Object APIs핵심적인 수학 라이브러리, 배열, 변환 헬퍼, 문자열 헬퍼 그리고 복사를 위한 Object.assign를 포함해 많은 새로운 라이브러리 추가. 12345678910111213141516171819202122Number.EPSILONNumber.isInteger(Infinity) // falseNumber.isNaN(&quot;NaN&quot;) // falseMath.acosh(3) // 1.762747174039086Math.hypot(3, 4) // 5Math.imul(Math.pow(2, 32) - 1, Math.pow(2, 32) - 2) // 2&quot;abcde&quot;.includes(&quot;cd&quot;) // true&quot;abc&quot;.repeat(3) // &quot;abcabcabc&quot;Array.from(document.querySelectorAll(&#x27;*&#x27;)) // Returns a real ArrayArray.of(1, 2, 3) // Similar to new Array(...), but without special one-arg behavior[0, 0, 0].fill(7, 1) // [0,7,7][1, 2, 3].find(x =&gt; x == 3) // 3[1, 2, 3].findIndex(x =&gt; x == 2) // 1[1, 2, 3, 4, 5].copyWithin(3, 0) // [1, 2, 3, 1, 2][&quot;a&quot;, &quot;b&quot;, &quot;c&quot;].entries() // iterator [0, &quot;a&quot;], [1,&quot;b&quot;], [2,&quot;c&quot;][&quot;a&quot;, &quot;b&quot;, &quot;c&quot;].keys() // iterator 0, 1, 2[&quot;a&quot;, &quot;b&quot;, &quot;c&quot;].values() // iterator &quot;a&quot;, &quot;b&quot;, &quot;c&quot;Object.assign(Point, &#123; origin: new Point(0,0) &#125;) 자세한 정보: Number, Math, Array.from, Array.of, Array.prototype.copyWithin, Object.assign Binary and Octal Literalsbinary(2진법)의 (b) 와 octal(8진법)의 (o)에 대해 두 개의 새로운 숫자 리터럴 폼이 추가되었다. 120b111110111 === 503 // true0o767 === 503 // true PromisesPromise는 비동기 프로그래밍 라이브러리이며 미래에 가능하도록 하는 일급 표현(representation)이며, 현존하는 많은 Javascript 라이브러리에서 사용되고 있다. 12345678910111213function timeout(duration = 0) &#123; return new Promise((resolve, reject) =&gt; &#123; setTimeout(resolve, duration); &#125;)&#125;var p = timeout(1000).then(() =&gt; &#123; return timeout(2000);&#125;).then(() =&gt; &#123; throw new Error(&quot;hmm&quot;);&#125;).catch(err =&gt; &#123; return Promise.all([timeout(100), timeout(200)]);&#125;) 자세한 정보: MDN Promise Reflect API객체에 대한 런타임 수준의 메타 작업을 노출하는 전체 reflection API. Reflect API는 실제로 Proxy API의 반대이고, proxy 트랩으로서 같은 메타 작업에 따르는 콜들은 만들도록 해준다. 12345678910111213141516171819const duck = &#123; name: &#x27;Maurice&#x27;, color: &#x27;white&#x27;, greeting: function() &#123; console.log(`Quaaaack! My name is $&#123;this.name&#125;`); &#125;&#125;Reflect.has(duck, &#x27;color&#x27;);// trueReflect.has(duck, &#x27;haircut&#x27;);// falseReflect.ownKeys(duck);// [ &quot;name&quot;, &quot;color&quot;, &quot;greeting&quot; ]Reflect.set(duck, &#x27;eyes&#x27;, &#x27;black&#x27;);// returns &quot;true&quot; if successful// &quot;duck&quot; now contains the property &quot;eyes: &#x27;black&#x27;&quot; 자세한 정보: MDN Reflect Tail Callstail 포지션의 콜(call)은 스택이 무제한으로 증가하지 않도록 보장합니다. 무제한 입력에 대한 재귀 알고리즘을 안전하게 만듭니다. 123456789function factorial(n, acc = 1) &#123; &#x27;use strict&#x27;; if (n &lt;= 1) return acc; return factorial(n - 1, n * acc);&#125;// Stack overflow in most implementations today,// but safe on arbitrary inputs in ES6factorial(100000)","categories":[{"name":"Programming","slug":"Programming","permalink":"https://joontae-kim.github.io/categories/Programming/"},{"name":"Javascript","slug":"Programming/Javascript","permalink":"https://joontae-kim.github.io/categories/Programming/Javascript/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://joontae-kim.github.io/tags/javascript/"},{"name":"ECMAScript","slug":"ECMAScript","permalink":"https://joontae-kim.github.io/tags/ECMAScript/"},{"name":"ECMAScript 2015","slug":"ECMAScript-2015","permalink":"https://joontae-kim.github.io/tags/ECMAScript-2015/"},{"name":"ES6","slug":"ES6","permalink":"https://joontae-kim.github.io/tags/ES6/"},{"name":"ECMAScript 6","slug":"ECMAScript-6","permalink":"https://joontae-kim.github.io/tags/ECMAScript-6/"},{"name":"ES2015","slug":"ES2015","permalink":"https://joontae-kim.github.io/tags/ES2015/"}]},{"title":"ECMAScript와 Babel","slug":"Babel","date":"2020-10-05T16:52:32.000Z","updated":"2020-10-06T17:03:28.054Z","comments":true,"path":"2020/10/06/Babel/","link":"","permalink":"https://joontae-kim.github.io/2020/10/06/Babel/","excerpt":"","text":"이전 포스트 ECMAScript란? 까지는 Javascript의 탄생과 Javascript 표준화를 위한 ECMAScript 그리고 각 Version에 대해 알아봤습니다. 현재까지 ES10(ECMAScript 2019) 까지 발표되었으며 Javascript에서 할 수 있는 작업들이 늘어나고 있음을 느낄 수 있었다. 그러나 이를 구동시키기 위한 런타임 환경인 브라우저가 모든 버전을 해석(인터프리트) 할 수 없으며 그에 따라 개발자는 브라우저가 이해하고 해석할 수 있는 버전 으로 Javascript의 수준을 낮춰야만 한다. 그렇다면… 기능을 포기해야 할까? 아니라면 복잡한 기능을 직접 개발하는 우회적 방법을 써야할까? 그래서 나온것이 BABEL 이라는 Javascript compiler 다. 본 포스트에서는 Babel에 대한 구조적 설명보다는 브라우저에서 ECMASCript 2015+ 의 코드를 실행시키기 위한 Tool로써의 의미와 ECMASCript 2015에 대해 다루도록 하겠습니다. Babel, Complier? Transpiler?블로그를 쓰기 위해 먼저 짚고 넘어갈 부분이 생겼다. Babel은 Complier인가 Transpiler인가? 공식 사이트에 가보면 분명 Babel is Javascript Compiler 라고 써있지만… 여기저기 개발자 블로그를 들어가보면 트랜스파일러라고 하는 분들이 많았다. 왜일까….? Is Babel a compiler or transpiler? 에 따르면, 먼저 Compiler와 Transpiler에 대해 알아보자. Compiler 란고수준의 프로그래밍 언어로 작성된 코드를 object code, bytecode, machine code와 같은 저수준의 언어를 변환하는 도구라고 한다. Transpiler 란source-to-source compiler 또는 transcompiler라고도 불려지고, 고수준의 언어들 사이에서 소스코드를 변환하는 도구이며 결과 코드는 여전히 인간이 읽을 수 있다. 위 정의만 봤을때는 Babel은 Compiler보단 Transpiler에 가깝다. 정확히는 source-to-source compiler 에 가깝다. 좀더 번역해보자. 바벨은 현재와 이전의 브라우저 환경에서 ECMAScript 2015 이상의 코드를 이전 버전과 호환되는 JavaScript 버전으로 변환하는데에 사용하는 주요한 JavaScript 툴체인(toolchain) 이며, 브라우저 지원을 기다리지 않고 지금 당장 새로운 문법을 사용할 수 있도록 문법 변환기(syntax transformers)를 통해 JavaScript의 최신 버전을 지원하고, JSX 문법을 변환할 수 있다. 즉, Babel 은 위에서 정리했던 Compiler의 기능보다는 Transpiler 의 기능에 가까우며 최신 문법으로 작성된 Javascript 코드를 ES5 또는 그 이하의 문법으로 변환시켜주며 실행에 있어서도 문제없이 작동하도록 도와주는 역할을 한다고 정의할 수 있다. ECMAScript 2015+그렇다면 ECMAScript 2015 에는 무엇이 추가되었으며 ES 6, 7, 9 에는 무엇이 추가되었을까? 이 주제는 작지 않으므로 따로 포스팅하겠습니다. 참고 Is Babel a compiler or transpiler? What is Babel? Learn ES2015 바벨(Babel 7) 기본 사용법 - daleseo.com Source-to-source_compiler - en.wikipedia 용어 설명 저수준(low-level language) 언어추상화에 대한 프로그래밍 컨셉이 거의 없거나 전혀 제공하지 않고, 실제 머신 지도에 가까운 언어이다. 예를 들어, assembly, machine code, and bytecode가 있다. 고수준(high-level language) 언어지금까지 활동중인 고 수준의 언어에는 Python, Visual Basic, Delphi, Perl, PHP, ECMAScript, Ruby, C#, Java 그리고 그 밖의 많은 언어들이 포함된다.","categories":[{"name":"Programming","slug":"Programming","permalink":"https://joontae-kim.github.io/categories/Programming/"},{"name":"Javascript","slug":"Programming/Javascript","permalink":"https://joontae-kim.github.io/categories/Programming/Javascript/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://joontae-kim.github.io/tags/javascript/"},{"name":"ECMAScript","slug":"ECMAScript","permalink":"https://joontae-kim.github.io/tags/ECMAScript/"},{"name":"Babel","slug":"Babel","permalink":"https://joontae-kim.github.io/tags/Babel/"}]},{"title":"ECMAScript란?","slug":"ECMAScript","date":"2020-10-04T09:39:51.000Z","updated":"2020-10-05T16:56:05.113Z","comments":true,"path":"2020/10/04/ECMAScript/","link":"","permalink":"https://joontae-kim.github.io/2020/10/04/ECMAScript/","excerpt":"","text":"자바스크립트를 공부하고 개발하다보면 ES5, ES6와 같은 ECMAScript에 대해 접할때가 많고, 면접을 볼때도 프로젝트를 개발할때 어떤 버전을 사용했으며 왜 사용했는지 그리고 이전 버전 그리고 다음 버전과의 차이는 무엇인지 질문 받은 경험이 있어 중간중간 공부할때가 있었는데 이참에 구체적으로 정리해볼려고 한다. 브라우저 엔진과 종류각 브라우저는 Javascript를 구동하기 위한 엔진을 갖고 있으며 이를 ‘자바스크립트 가상 머신’이라 한다. Chrom , Opera - V8 Firefox - SpiderMonky IE - Trident 및 Chakar Microsoft Edge - ChakraCore Safari - Nitro 및 SquirrelFish ECMAScript란?Javascript의 첫번째 포스트인 자바스크립트란? 의 표준화를 위한 작업, ECMAScript와 Javascript 에서 언급했듯이 ECMAScript는 각 브라우저 개발사들의 Javscript 엔진이 다르고 그에 따른 사용자들의 크로스 브라우징 이슈와 Javscript의 파편화를 방지하기 위한 Javascript 표준화에서 시작됐다. ECMAScript 정의 ECMA-262 문서에 따르면, ECMAScript (또는 ES) 는 ECMA 인터네셔널에 의해 표준화 된 범용 프로그래밍 언어로써, 서로 다른 웹 브라우저들에서 웹 페이지의 상호운용성을 보장하기 위한 Javscript 표준이다. 즉, ECMA-262 는 표준의 이름이고, ECMAScript (또는 ES) 는 ECMA-262라는 표준에서 정의된 프로그래밍 언어라는 것입니다. 쉽게 말해, 아래와 같이 비유할 수 있을거 같다. ECMA 인터네셔널 = 표준원 ECMA-262 = 표준어 ECMAScript = 표준어를 따르는 언어 ECMAScript와 JavascriptJavascript는 ECMAScript 사양을 준수하는 범용 스크립트 언어라고 할 수 있으며 적절한 비유를 찾았고 공부하면서 둘의 관계를 잘 표현한 문장?이 아닐까 싶다. ECMAScript는 스크립팅 언어를 어떻게 만들어야 하는지를 설명하는 일종의 설명서라고 생각하면 되고, JavaScript는 ECMAScript의 사양을 바탕으로 만들어진 언어인 것이다. @JunimoECMAScript와 Javascript의 차이점 Javascript 문서(Document) vs ECMAScript 명세(Specification) 본 챕터는 mdn의 javascript 소개 문서의 한 챕터로서, 다루면 좋을것 같아 추가해봅니다. ECMAScript 명세는 ECMAScript 구현을 위한 요구사항의 집합으로 ECMAScript 구현이나 브라우저 엔진에서 표준을 따르는 언어의 기능을 구현하려고 할때 유용합니다. ECMAScript 명세는 스크립트 프로그래머를 돕기 위한 것이 아니며 스크립트 작성을 위한 정보는 JavaScript 문서를 사용하세요. ECMAScript 명세는 JavaScript 프로그래머에게 익숙하지 않을 수 있는 용어와 문법을 사용합니다. 언어의 기술이 ECMAScript와 다를 수 있지만, 언어 그 자체는 같습니다. 그리고 JavaScript는 ECMAScript 명세에 서술된 모든 기능을 지원합니다. JavaScript 문서는 JavaScript 프로그래머를 위한 적절한 언어의 측면을 설명합니다. ECMAScript 버전보통 ECMAScript의 버전을 말할때는 ES + (Standard Number) 의 포맷으로 얘기하며 Standard Number는 (표준화된 해의 끝자리 + 1)로, 2015년에 제정된 ESCMScript 2015의 경우 ES6 라고 부른다. ECMA-262는 현재 제 10판까지 출판되었으며 역사는 아래와 같다. 위 내역을 통해 알 수 있는것은 2009년 ES5는 현재 Javascript의 기본적 문법과 기능으로 추정할 수 있으며 2015년 ES6를 기준으로 본격적으로 많은 기능과 문법들이 추가되기 시작했다. ES6 이후의 추가된 기능과 문법 ES5 (2009) 일반적으로 (구형 브라우저를 제외한) 모든 런타임에서 지원한다고 가정할 수 있는 Javascript의 기본 버전 Added forEach, map, filter, reduce, some, every in Array Methods Object getter &amp; setter Added stricter standards to strict mode JSON ES6 / ES2015 Standard Modules — import and export Standardised Promises Classes &amp; Inheritance Block-scoped variables — letand const Template Literals Object destructing into variables Generator functions Map and Set data structures Internationalisation for Strings, Numbers and Dates via Intl API Arrow Function ES7 / ES2016 Array.prototype.includes() Numeric exponent (power of) operator ** ES8 / ES2017 Async / Await Functions Object.entries, Object.values Methods String padding functions Allow Trailing commas to function expression arguement ES9 / ES2018 Object Rest/Spread const obj = &#123; ...props &#125;; Asynchronous Iteration for await (...) &#123; Promise finally() function Regular expression enhancements (lookbehind, named groups) ES10 / ES2019 Object.fromEntries flat, flatMap Symbol.description optional catch ES2015/ES6 를 기준으로 수많은 편리한 메서드와 문법들이 추가되었고 개발자들은 보다 점차 높은 수준의 Javascript를 구사할 수 있게 되었으며 사용자들 또한 높은 수준의 기능들을 경험할 수 있게 되었다. 그러나 개발자들에겐 한가지 높은 장벽이 있었으니 그것은 바로 사용자의 런타임 환경인 브라우저 였다. ECMAScript가 업데이트가 되고 브라우저 개발사들이 자신들의 JS 엔진을 업그레이드 한다할지라도 그것은 사용자에게 필수적인 것이 아닐수 있으며 굳이 노력해야할 부분은 아니다. 그리하여 ECMAScript에 아무리 좋은 문법이 추가되어도 사용자 환경 때문에 사용하지 못하는 상황이 발생하며 이러한 문제점을 극복하기 위해 탄생한 것이 바로 Babel 이다. 참고 ECMA스크립트 - en.wikipedia.org 자바스크립트 언어 자료 JavaScript와 ECMAScript는 무슨 차이점이 있을까? What major new features were in each JavaScript version? What version should I target? - by Russell in medium","categories":[{"name":"Programming","slug":"Programming","permalink":"https://joontae-kim.github.io/categories/Programming/"},{"name":"Javascript","slug":"Programming/Javascript","permalink":"https://joontae-kim.github.io/categories/Programming/Javascript/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://joontae-kim.github.io/tags/javascript/"},{"name":"ECMAScript","slug":"ECMAScript","permalink":"https://joontae-kim.github.io/tags/ECMAScript/"}]},{"title":"자바스크립트란?","slug":"with-javascript","date":"2020-10-02T17:06:39.000Z","updated":"2020-10-05T10:07:07.354Z","comments":true,"path":"2020/10/03/with-javascript/","link":"","permalink":"https://joontae-kim.github.io/2020/10/03/with-javascript/","excerpt":"","text":"여러 프로젝트를 개발하면서 Javascript를 사용해왔고 그렇게 3년이 지나고 어느새 5년이라는 시간이 지났다. 그럼에도 불구하고 아직까지 Javascript에 대해 설명하려면 “어렵지만, 쉬운” 언어라는 말이 먼저 나오고, 공부를 하면 할수록 “내가 알고 있는것이 맞는가?”, “얼마나 알아야 기본은 아는것일까?”라는 당혹감?에 빠져 있었다. 그래서 이참에 내가 사용해왔고 알아왔던 Javascript에 대해 더 알아보려고 한다. 그리고 친해져보려고 한다. Javascript의 탄생 Javascript의 시작은 미국의 넷스케이프 커뮤니케이션스(Netscape Communications)가 1994년 말 출시한 모자이크 넷스케이프가 1990년대에 주된 웹 브라우저로 자리잡기 시작하자 웹이 더 동적으로 변화할 필요을 느끼며 이를 위한 글루 언어(glue language) 개발을 위해 브렌던 아이크를 영입하고 개발한 언어가 지금의 Javascript이다. 사실 Javascript는 개발 당시 모카(Mocha)라는 이름으로 불려졌다. 그러나 1995년 9월 넷스케이프 내비게이터 2.0 브라우저의 베타 릴리스 때는 라이브스크립트(LiveScript)로 바뀌었고 그해 12월 넷스케이프 내비게이터 2.0 베타 3 릴리스 때 우리가 알고 있는 Javascript라는 이름으로 정식 채택되었다. 개발에 대해 모르거나 시작하는 사람들이 대게 햇갈려하는 Java와 Javascript의 혼란은 넷스케이프가 당시 인기있는 웹 프로그래밍 언어로서 자바스크립트를 내밀기 위한 것으로 마케팅적인 선택으로 보여진다. 그러나 기술적으론 Javascript와 Java는 객체 모델을 갖는다는 거외에는 근본적으로 다르다. 표준화를 위한 작업, ECMAScript와 JavascriptJavascript의 동적 웹 페이지 조작이 흥행하자 Microsoft는 자신들의 브라우저인 Internet Explerer를 지원하기 위해 J스크립트를 개발했고 1996년 8월에 출시된 인터넷 익스플로러 브라우저 3.0부터 적용하기 시작합니다. 이는 경쟁적 위치를 선점하며 자신들의 브라우저에서만 동작하는 기능들을 추가하기 시작했다는 것을 의미하며 크로스 브라우징 이슈의 말초가 된다. 즉, Javascript의 파편화가 시작된 것이다. 이러한 현상은 Javascript의 발전을 저해하며 사용자들이 공통된 경험을 누리지 못하는 불편을 야기했다. 바로 이러한 점을 해소하기 위해 만들어진 것이 ECMAScript 그리고 ECMA-262 로, Javascript의 표준 명세서로써 프로그래밍 언어의 타입, 값, 객체와 프로퍼티, 함수, 빌트인 객체 등 핵심 문법(core syntax) 을 규정하며 브라우저 제조사는 이를 준수하여 브라우저 내장 자바스크립트 엔진을 구현해야 한다. (ECMAScript에 대한 자세한 내용은 추후 포스팅하겠습니다) Javascript의 발전JavaScript는 XMLHttpRequest, JSON, Ajax과 같은 기술들이 개발됨에 따라 버튼의 클릭에 따른 UI 변경, Form 유효성 검증과 같은 단순한 작업에서 XMLHttpRequest의 브라우저(IE5) 도입에 따른서버와 브라우저 간의 비동기 데이터 통신을 시작으로 활용 가능성이 넓어지기 시작했다. 1999년, XMLHttpRequest API가 IE5에 도입됨 2001년, 더글러스 크락포드가 자바스크립트의 기존 텍스트 형식의 데이터 저장을 ‘JSON(Javascript Object Notation)’이라는 객체 문법의 구조화된 문자기 반의 표준 포맷을 개발 2005년, Ajax를 이용해 구글이 구글Maps를 소개. 불필요한 렌더링을 줄이며 서버로부터 필요한 데이터만을 요청해 갱신이 필요한 부분만 리렌더링하는 방식을 선보임 2006년, jQuery의 등장으로 핸들링 하기 어려웠던 DOM의 한계를 극복했으며 크로스 브라우징 이슈가 해결됨 2008년, 구글이 크롬 웹브라우저 함께 V8이라는 자바스크립트 엔진 발표하면서 보다 웹 어플리케이션 또한 데스크톱 어플리케이션과 유사한 사용자 경험을 제공할 수 있게 됨 2009년, Node.js 라는 Server-side에서도 활용할 수 있는 Javascript가 개발됨에 따라 Client-side에 한정된 Javascript의 영역을 확대함 Javascript의 정의와 특징Javascript는 “웹 브라우저에서 실행되는 유일한 클라이언트 사이드 프로그래밍 언어” 로써 쉽게 배우고, 빠르게 개발할 수 있다는 강력한 장점을 제공하지만 Javascript의 성격과 패러다임 그리고 어떤 기능적 특징을 갖고 있는지 이해하는 것은 여간 어려운 것이 아니다. 왜냐하면 기본 문법은 C, Java와 유사하고 프로토타입 기반의 상속은 Self에서, 일급 함수의 개념은 Scheme에서 차용하였듯 기존의 프로그래밍 언어에서 많은 영향을 받았기 때문이다. 프로토타입 기반, 다중 패러다임 스크립트 언어이며, 동적이고 명령어, 객체 지향, 함수 프로그래밍 스타일을 지원한다. JavaScript란 무엇인가?developer.mozilla.org/ko/docs/Web/JavaScript/About Javascript의 정의Javascript는 가벼운 인터프리터 또는 JIT 컴파일 프로그래밍 언어로 prototype 기반의 객체 지향 패러다임을 바탕으로 하는 인터프리터 언어이자 기존의 웹 브라우저 뿐만이 아니라 서버사이드에서도 작동하는 크로스 플랫폼 언어이다. Javascript의 특징 일급 함수 사용 Scheme의 일급 함수 개념을 차용했으며 이를 통해 고차 함수(high order function) 가 가능하다. 즉, Javascript의 Array Method 중 each, filter, map과 같은 함수의 인자로 함수를 받는 형태를 말한다. 가벼운 인터프리터 또는 JIT 컴파일 프로그래밍 언어 Javascript는 인터프리터 언어로서 브라우저에서 동작하기 전에 다른 컴파일러를 통해 코드를 변환할 필요가 없으며 코드가 위에서 아래로 순차적으로 실행되고 결과를 즉시 반환한다. 모던 웹 브라우저에 JIT 컴파일러(Just In Time Compiler)가 내장되어 실행 시점에서 인터프리트 방식으로 기계어 코드를 생성하면서 그 코드를 캐싱하여, 같은 함수가 여러 번 불릴 때 매번 기계어 코드를 생성하는 것을 방지한다. 프로토타입 기반의 객체 지향 언어 클래스가 없으며 클래스 기반 언어에서 상속을 사용하는 것과 다르게 객체를 원형으로 하여 복제의 과정을 통해 객체의 동작 방식을 다시 사용할 수 있다. 이는 클래스 기반 프로그래밍 언어인 Java와도 다른 점이다. 객체 생성 시에 클래스로부터 그 내용을 상속받아서 객체를 만드는 것이 아니라, 객체로부터 그 특성을 복제하여 새로운 객체를 생성하기 때문에 런타임 중에도 객체의 속성과 값을 추가하거나 변경하고, 삭제까지 가능합니다. 명령형(imperative), 함수형(functional)을 지원하는 다중 패러다임 스크립트 언어 동적이고 명령어, 객체 지향, 함수 프로그래밍 스타일을 지원 Javascript는 다른 언어들과 다르게 변수, 매개변수 및 함수의 반환 값의 타입을 명시적으로 지정하지 않아도 된다는 특징을 가지며 이는 프로토타입 기반 모델이 동적 상속을 제공하기 때문이다. 따라서 함수는 객체의 속성이나 타입이 느슨하게 지정된채 실행되는 메소드가 될 수 있다. 절차지향 (procedural) 언어와 객체지향 (object oriented) 언어 두가지 형태로 개발 가능함 참고 자바스크립트 - wikipedia.org 자바스크립트 Guide 소개 - mdn 자바스크립트란? - ko.javascript.info ECMA스크립트 - wikipedia.org 자바스크립트란? - poiemaweb es6 compatibility table - compat-table Javascript 버전별 표준 ECMAScript - en.wikipedia.org XMLHttpRequest - en.wikipedia.org 자바스크립트의 역사 - edu.goorm.io 프로토타입 기반 프로그래밍 - wikipedia.org 절차지향 vs 객체지향 JIT 컴파일 - wikipedia.org","categories":[{"name":"Programming","slug":"Programming","permalink":"https://joontae-kim.github.io/categories/Programming/"},{"name":"Javascript","slug":"Programming/Javascript","permalink":"https://joontae-kim.github.io/categories/Programming/Javascript/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://joontae-kim.github.io/tags/javascript/"}]},{"title":"01. javascript","slug":"node-all-in-one-javascript-1","date":"2020-10-01T08:07:32.000Z","updated":"2020-10-01T11:13:58.120Z","comments":true,"path":"2020/10/01/node-all-in-one-javascript-1/","link":"","permalink":"https://joontae-kim.github.io/2020/10/01/node-all-in-one-javascript-1/","excerpt":"","text":"01. Javascript 란 브라우저를 제어하기 위한 넷스케이프에서 개발한 언어 사용자의 클릭, 계산기 등의 이벤트 조작에 대응하기 위한 언어 자바스크립트의 확대 Ajax 활용 (구글맵) 디버깅툴의 발전 파이어폭스의 콘솔로그 크롬의 V8 엔진 개발 V8 엔진 기반의 서버 사이드 javascript 개발 Node.js 여러 플랫폼에서 js 기반의 환경 조성 Desktop, IOT 등에서 변수형 js는 동적언어이므로 자료형을 선언할 필요가 없음 기본 자료형과 객체(Object) 두가지로 나뉨 기본자료형 설명 Boolean 논리적 요소 (true / false) Null 객체 값이 존재하지 않는다는 의미 Undefined 값을 할당하지 않음 Number 숫자형 String 문자형 Symblo ECMAScript 6에서 추가, 유일하고 변경 불가 02. 배열 배열도 기본 자료형 중에 하나 예제: [&#39;안녕&#39;, &#39;Node.js&#39;, 55, &#39;Hello&#39;] 위와 같이, 문자형과 숫자형이 섞여있든 요소에 대한 자료형이 통일되지 않아도 되는 구조 배열에는 인덱싱이라는게 있음 예제의 &#39;안녕&#39;을 기준으로 인덱싱이 0 이 되며 차례대로 1,2,3 …. 배열의 인덱싱을 통해 overwrite 가능 example[0] = &#39;Hi&#39; 03. 반복문 대표적으로 for, while, do-while 문이 있음 for 문 123for (var i = 0; i&lt;10; i++) &#123; // .....&#125; while 문 12345var i = 0 // 초기화 조건while (i &lt; 10) &#123; // ..... i = i+1;&#125; do .. while 문 12345var i = 0;do &#123; // ..... i = i + 1;&#125; while (i &lt; 5) while 문과 do ... while 문의 차이는 while 의 조건문을 언제 시작하느냐 do ... while 의 경우 일단 do &#123; ... &#125; 문을 실행한 뒤 while 문을 실행 04. 함수1234567891011121314151617// Car 라는 틀(prototype) 생성function Car (a, b, c) &#123; // function의 member 선언 // this는 public 변수 this.name = a; this.color = b; // var 등 함수내에서 선언된 변수들은 private 변수라 함. var move = c&#125;// 객체 생성 , 변수 a는 Car의 인스턴스var a = new Car(&#x27;현대&#x27;, &#x27;노랑&#x27;, &#x27;전진&#x27;);console.log(a.name)// 현대console.log(a.color)// 노랑console.log(a.move)// undefined =&gt; 왜냐하면 private 변수로 선언되었기 때문 05. 프로토타입 js는 프로토타입 기반 언어이다. 예제 123456function Car (a, b, c) &#123; // function의 member 선언 // this는 public 변수 this.name = a; this.color = b;&#125; 12// 객체 생성 , 변수 a는 Car의 인스턴스var a = new Car(&#x27;현대&#x27;, &#x27;노랑&#x27;); 자바스크립트는 Car 에 프로토타입 이라는 것이 있음 프로토타입을 기준으로 객체. 즉, 인스턴스를 생성 예제 1234567Car.prototype.move = function () &#123; // Car의 prototype에 접근해 함수를 추가 console.log(this.name + &#x27;차이고&#x27;+ this.name + &#x27;색이다&#x27;)&#125;a.move()// 현대차이고 노랑색입니다. 1234567Car.prototype.move = function () &#123; // Car의 prototype에 접근해 함수를 추가 console.log(this.name + &#x27;차이고&#x27;+ this.name + &#x27;색이다&#x27;)&#125;a.move()// 현대차이고 노랑색입니다. 예제 12345678910111213var a = [1, 3, 5, 7, 9]// 배열의 prototype에 접근해 커스텀 함수 추가Array.prototype.print = function () &#123; for (var i=0;i &lt; this.length; i++) &#123; console.log(this[i]) &#125;&#125;a.print()// 1// 3// 5// 7// 9 보충해서 볼것 변수형 프로토타입 함수 선언식과 표현식","categories":[{"name":"course","slug":"course","permalink":"https://joontae-kim.github.io/categories/course/"},{"name":"node_all_in_one","slug":"course/node-all-in-one","permalink":"https://joontae-kim.github.io/categories/course/node-all-in-one/"}],"tags":[{"name":"course,javascript","slug":"course-javascript","permalink":"https://joontae-kim.github.io/tags/course-javascript/"}]},{"title":"Hexo로 글 작성하기","slug":"hexo-writing","date":"2020-09-29T12:16:43.000Z","updated":"2020-10-01T07:40:40.849Z","comments":true,"path":"2020/09/29/hexo-writing/","link":"","permalink":"https://joontae-kim.github.io/2020/09/29/hexo-writing/","excerpt":"","text":"Hexo는 간단하고 파워풀한 프레임워크로써, 마크다운 문법을 통해 포스트를 작성하면 theme와 함께 정적 웹사이트를 만들 수 있습니다. 설치와 설정 그리고 theme 등 공식문서를 잘 읽어보면 더 유용한 기능들이 많으며 이번 포스팅에서는 Hexo 명령어를 통해서 글 작성하는 법 즉, 포스트를 생성하고 배포하는 법을 다뤄보겠습니다. 명령어12hexo new [layout] &lt;title&gt;hexo new &lt;title&gt; // layout을 생략할 경우 default_layout으로 새로운 마크다운 파일이 생성됨. Hexo 에서 새 포스트나 페이지를 생성하기 위한 명령어로 기본 layout 은 post 이지만 블로그의 _config.yml 에서 default_layout 을 변경하면 기본 생성 layout 유형이 바뀝니다. LayoutHexo에서는 아래와 같이 3개의 기본 레이아웃을 제공하며 생성된 파일들은 서로 다른 경로에 저장됩니다. 종류 정의 생성 경로 post 블로그에 바로 발행 가능한 레이아웃 source/_posts draft post 처럼 바로 게시하지 않고 작성할 수 있는 초안 source/_drafts page post 처럼 하나의 게시물이 아닌 하나의 페이지를 생성 source Scaffold - 레이아웃 파일 생성포스트 생성 시 Hexo는 scaffolds 폴더 내의 적당한 파일을 기반으로 구성하며 기본적으로 각 레이아웃 이름의 마크다운 문서 이름을 참고한다. 예를 들어 hexo new post &quot;newPost&quot; 라는 명령어는 scaffolds/post 파일의 placeholder를 사용하여 새로운 마크다운 문서를 생성할 수 있습니다. 예를 들어, scaffolds/post.md 파일이 아래와 같다면, hexo new post &quot;newPost&quot; 를 통해 newPost.md 가 생성된 12345title: &#123;&#123; title &#125;&#125;categories: &#123;&#123; categories &#125;&#125;tags: &#123;&#123; tags &#125;&#125;date: &#123;&#123; date &#125;&#125;thumbnail: &#123;&#123; thumbnail &#125;&#125; 파일의 placeholder 는 아래와 같이 채워진다. 즉, 레이아웃에 따른 common yaml 포맷 또는 placeholder가 있다면 scaffolds의 레이아웃 폴더에 기재함으로써 편리하고 공통의 포맷을 유지할 수 있다. 123456title: newPostdate: 2020-09-29 21:16:43subtitle: categories:tags:thumbnail: Draft에 대해서위에서 설명했듯이 Draft는 바로 게시하지 않고 작성할 수 있는 초안입니다. Draft를 사용하며 편리했던 점은 연속으로 게시해야 되는 포스트를 한번에 작성한 후 순차적으로 게시해야 할때 hexo publish (파일 이름) 명령어로 하나씩 Post로 발행해 배포하면 된다는 점입니다. 아래는 제가 설정했던 Draft 관련 설정과 명령어 입니다. Draft를 기본 레이아웃으로 변경하기_config.yml에서 # Writing이라는 주석처리된 섹션에서 default_layout 필드를 초기값인 post에서 draft로 변경하면 됩니다. 로컬 서버에서 Draft 문서 띄우기작성 중인 Draft 문서를 확인할 수 있는데 아래와 같이 --draft 옵션을 주면 로컬 서버에서도 확인할 수 있습니다. 1hexo server --draft Draft 발행하기Draft 작성이 완료되었다면 이제 발행해야 하는데 아래의 순서와 같이 진행하면 된다. Draft 문서를 Post 레이아웃으로 변환하기사실 변환이라고 대단한건 아니고 그저 _drafts 디렉토리에서 _posts 디렉토리로 이동하면서 작성일시가 추가되는 것이 전부이다. 1hexo publish (Draft 이름) 배포하기아래 명령어를 통해 배포 가능하다. 1hexo deploy 또는 hexo g -d","categories":[{"name":"Blog","slug":"Blog","permalink":"https://joontae-kim.github.io/categories/Blog/"},{"name":"Hexo","slug":"Blog/Hexo","permalink":"https://joontae-kim.github.io/categories/Blog/Hexo/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://joontae-kim.github.io/tags/Hexo/"},{"name":"Blog","slug":"Blog","permalink":"https://joontae-kim.github.io/tags/Blog/"},{"name":"draft","slug":"draft","permalink":"https://joontae-kim.github.io/tags/draft/"}]},{"title":"Critical Rendering Path","slug":"critical-rendering-path","date":"2020-09-26T17:50:58.000Z","updated":"2021-09-30T10:47:18.635Z","comments":true,"path":"2020/09/27/critical-rendering-path/","link":"","permalink":"https://joontae-kim.github.io/2020/09/27/critical-rendering-path/","excerpt":"","text":"본 글은 mdn web docs의 Critical Rendering Path를 번역한 글입니다. 현재 작성일자(2020년 9월 27일) 기준으로 아직 한글로 번역되지 않아 본 번역 포스팅을 완료하면 해당 페이지를 한국어로 옮겨놓을 예정입니다. 수정 및 보완사항이 있다면 본 포스팅 하단 댓글에 작성 부탁드립니다. 브라우저 작동 원리 또는 렌더링에 관해 공부하고, 포스팅하고 싶은 마음이 있었는데 mdn에 좋은 게시물이 많이 있었고 그중 몇 가지를 연재로 번역하면서 공부해보는 시간을 가져볼려고 합니다. 연재할 MDN docs Populating the page: how browsers work Critical rendering path 중요 렌더링 경로중요 렌더링 경로 (Critical Rendering Path)는 브라우저가 HTML, CSS, Javascipt를 화면에 픽셀로 변화하는 일련의 단계를 말하며 이를 최적화하는 것은 렌더링 성능을 향상시킵니다. 중요 렌더링 경로는 Document Object Model (DOM), CSS Object Model (CSSOM), 렌더 트리 그리고 레이아웃을 포함합니다. 도큐먼트 오브젝트 모델은 HTML을 분석함으로써 만들어집니다. HTML은 Javascript를 요청할 수 있으며, 이 경우 DOM 이 변경될 수 있습니다. HTML은 차례대로 CSS 오브젝트 모델을 만들기 위한 스타일에 대한 요청을 만들거나 포함합니다. 브라우저 엔진은 이 두가지를 결합하여 렌더 트리를 생성하며 레이아웃은 페이지의 모든 것에 대한 크기와 위치를 결정합니다. 일단 레이아웃이 결정되면 화면에 픽셀을 그립니다. 중요 렌더링 경로 최적화는 첫번째 렌더링의 시간을 개선시킵니다. 중요 렌더링 경로를 이해하고, 최적화 하는 것은 뛰어난 사용자 상호작용을 보장하며 버벅거림을 피할 수 있도록 하고, 1초당 60 프레임에 리플로우와 리페인트가 발생할 수 있도록 하는데 중요합니다. CRP 이해하기웹 성능은 서버의 요청과 응답, 로딩, 스크립팅, 렌더링, 레이아웃 그리고 화면에 픽셀 그리기를 포함합니다. 웹 페이지 또는 어플리케이션에 대한 요청은 HTML 요청으로 시작됩니다. 서버는 응답 헤더 또는 데이터로 HTML을 반환합니다. 그리고 나서 브라우저는 HTML을 분석하고 수신된 바이츠를 DOM 트리로 변환하기 시작합니다. 브라우저는 스타일시트, 스크립트 또는 포함된 이미지 참조인 외부 자원에 대한 링크를 찾을때마다 요청을 시작합니다. 불러온 에셋을 다룰 때까지 나머지 HTML을 분석하는 작업하는 일부 요청은 중단되며 차단됩니다. 브라우저는 CSS 오브젝트 모델을 구축하는 작업이 끝날때까지 요청을 만들고 DOM을 생성하는 HTML을 계속해서 분석합니다. DOM과 CSSOM이 완료되면 브라우저는 렌더 트리를 생성하고 보여지는 컨텐츠를 위해 스타일을 계산합니다. 렌더트리가 완료된 후 모든 렌더 트리 요소들에 대한 위치와 크기가 정의된 레이아웃이 만들어집니다. 일단 완료되면 레이지는 렌더링되거나 또는 화면에 ‘그려집니다(painted)’. Document Object ModelDOM 구성은 점진적으로 증가합니다. HTML 응답은 토큰으로, 토큰은 노드로, 노드는 DOM 트리로 변환됩니다.1개의 DOM 노드는 시작태그 토큰으로 시작해서 끝태그 토큰으로 끝납니다. 노드들은 HTML 요소에 대한 모두 연관성 있는 정보를 포함하고 있습니다. 그 정보는 토큰을 통해 설명됩니다. 노드들은 토큰의 위계서열을 기반으로 DOM 트리안에 연결됩니다. 만약 또 다른 시작태그와 끝태그의 묶음이 한 세트의 시작태그와 끝태그 사이에 있다면, 여러분은 DOM 트리의 위계서열을 정의하는 방법으로 노드 안에 노드를 가지게 됩니다. 많은 수의 노드는 중요 렌더링 경로에서 다음의 이벤트를 더 오래 발생시킬 것입니다. 측정하세요! 몇 개의 추가 노드는 차이를 만들지 않지만 전염은 버벅거림을 유발할 수 있습니다. CSS Object ModelDOM은 페이지의 모든 컨텐츠를 포함하고, CSSOM은 DOM을 스타일링 하기 위한 페이지의 모든 스타일 정보를 포함합니다. CSSOM은 DOM과 유사하지만 다릅니다. DOM의 구조는 점진적으로 증가하는 반면에 CSSOM은 그렇지 않습니다. CSS는 렌더링을 막습니다: 브라우저는 모든 CSS를 처리하고 수신할때까지 페이지 렌더링을 막습니다. CSS는 규칙을 덮어쓸수 있기 때문에 렌더링을 막습니다. 그러므로 CSSOM이 완료될때까지 콘텐츠를 렌더링 할 수 없습니다. CSS는 유효한 토크들은 인식하기 위해 스스로 규칙 세트를 가지고 있습니다. CSS의 C가 ‘Cascade(종속 또는 폭포)’라는 의미를 기억해두세요. CSS 규칙은 아래로 종속됩니다. 분석기는 토큰을 노드로 변환할때, 하위 노드가 스타일을 상속합니다. 연속적인 규칙들이 이전의 규칙들에 덮어쓰여질 수 있기 때문에, 증감 처리 기술은 HTML 처럼 CSS에 적용되지는 않습니다. CSS 개체 모델은 CSS를 분석할 때 빌드되지만 나중에 분석되 덮어쓸 스타일들은 화면에 렌더링 할 수 없기 때문에 완전히 분석될 때까지 렌더 트리를 생성하는데 사용할 수 없습니다. 선택자 성능 측면에서, 덜 구체적인 선택자는 더 구체적인 선택자보다 더 빠릅니다. 예를 들어, 브라우저가 .foo 찾을때, .foo &#123;&#125; 는 .bar .foo &#123;&#125; 보다 빠릅니다. 왜냐하면 두번째 시나리오에서, .foo 가 부모 객체인 .bar 를 가지고 있는지 확인하기 위해 DOM을 거슬러 올라가기 때문입니다. 더 구체적인 태그는 브라우저에게 더 많은 작업을 요구하지만 이러한 패널티는 최적화 할 가치가 없습니다. 만약 CSS 분석 시간을 측정한다면, 브라우저들이 정말 빠르다는 것에 놀랄 것입니다. 규칙이 구체적일수록 DOM 트리 안에서 더 많은 노드들은 지나야 하기 때문에 더 높은 비용이 듭니다. 그러나 추가적인 비용은 일반적으로 최소입니다. 첫번째는 측정입니다. 필요할때 최적화하세요. 특정 짓는 것은 쉬운 일이 아닙니다. CSS 측면에서, 선택자 성능 최적화와 개선은 오직 microsecond 밖에 되지 않될 것입니다. 축소화와 미디어 쿼리를 사용함으로써 지연된 CSS를 논-블로킹 요청으로 분리하는 것과 같은 CSS 최적화를 위한 다른 방법이 있습니다. 렌더 트리렌터 트리는 콘텐츠와 스타일 둘다 캡쳐합니다. DOM과 CSSOM 트리는 렌더 트리에 결합됩니다. 렌더 트리를 구성하기 위해 브라우저는 DOM 트리의 root에서 시작해 모든 노드는 확인하면서 어떤 CSS 규칙들을 첨부할지 결정합니다. 렌더 트리는 오직 보여지는 콘텐츠만은 캡쳐합니다. (일반적으로) 헤드 섹션은 보여지는 정보를 포함하고 있지 않으므로 렌더트리 안에 포함되지 않습니다. 만약 요소에 display: none 이 적용되어 있다면, 해당 요소 또는 하위 요소는 포함되지 않습니다. 레이아웃일단 렌더 트리가 생성되고 나면, 레이아웃은 가능해지며 화면의 크기에 의존합니다. 레이아웃 단계는 요소들이 페이지에서 배치되는 위치와 방법, 각 요소의 너비와 높이 그리고 서로 관련된 위치를 결정합니다. 요소의 너비는 무엇일까요? 정의에 따르면, 블럭 수준의 요소들은 그 부모 너비의 기본 너비값의 100% 입니다. 50%의 너비를 갖는 요소는 부모 요소의 절반일 것입니다. 비록 그렇게 정의되어 있지 않더라고, body 는 뷰포트 너비의 100%를 의미하는 너비 입니다. 디바이스의 너비는 레이아웃에 영향을 미칩니다. 뷰포트 메타 태그는 레이아웃에 영향을 미치는 뷰포트 레이아웃의 너비로 정의합니다. 이 태그 없다면, 브라우저는 뷰포트 기본값을 사용합니다. 브라우저의 full screen 기본값은 일반적으로 960px 입니다. 기본적으로 브라우저의 full screen에서, 스마트폰의 브라우저와 같은 너비는 &lt;meta name=&quot;Viewport&quot; content=&quot;width=device-witdh&quot;&gt; 로 세팅함으로써 기본 뷰포트 너비 대신에 디바이스의 너비를 사용합니다. 디바이스 너비는 사용자가 디비이스를 가로(landscapre) 또는 세로(portrait) 모드 사이로 돌릴때마다 바뀝니다. 레이아웃은 디바이스가 회전하거나 브라우저의 사이즈가 조정될 때마다 발생합니다. 레이아웃 성능은 DOM의 영향을 받습니다. 노드의 수가 많을수록 레이아웃은 더 길어지며 스크롤링 또는 다른 애니메이션들이 필요하다면 레이아웃에 쟁크(jank)를 일으키는 병목현상이 발생할 수 있습니다. 로딩 또는 방향 전환에 20ms 정도 밀릴 수 있지만 애니메이션 또는 스크롤에 쟁크(jank) 유발할 수 있습니다. 노드에 박스 모델 업데이트, 콘텐츠 대체 그리고 노드 추가와 같은 수정은 언제든지 렌더 트리를 수정할 수 있으며 레이아웃을 형성합니다. 레이아웃 이벤드의 반복과 형성시간을 줄이기 위해서 일괄 업데이트 해야하고, 박스 모델 속성을 애니메이션화 하지 말아야 합니다. 페인트마자믹 단계는 화면에 픽셀을 그리는 것입니다. 일단 렌더 트리가 생성되고 레이아웃나 나타나기 시작하면, 화면에 픽셀을 그릴수 있습니다. 로드시, 전체 화면을 그립니다. 그 후에는 브라우저가 필요한 최소 영역만을 다시 그리도록 최적화되어 있기 때문에 영향을 받는 영역만을 화면에 다시 그립니다. 그리는 시간은 렌터 트리에 적용되는 업데이트의 종류가 무엇있냐에 따라 달라집니다. 페인팅인 매우 빠르게 진행되는 과정이기 때문에 성능 향상에 집중해야 하는 가장 큰 영향있는 부분이 아닐 수 있지만, 애니메이션 프레임 소요시간을 측정할때, 레이아웃과 리페인트 시간을 모두 고려하는 것이 중요합니다. 각 노드에 적용된 스타일은 페인트 시간을 증가시키지만 페인트 시간을 0.001ms 증가시키는 스타일을 제거하는 것은 여러분의 최적화 비용이 매우 커지는 것을 막지 못할 수 있습니다. 첫째는 측정하는 것을 기억하고, 최적화 우선순위를 정해야할지 말지를 결정해야 합니다. CRP 최적화자원 로드 순서를 관리하고, 파일 사이즈를 줄이며 어떤 자원을 먼저 로드할지 정함으로써 페이지 로드 속도를 개선하세요. 성능 팁으로는 1) 자원 다운로드를 연기함으로써 중요 자원들의 수를 최소화하기 , 2) 각 요청에 대한 파일 사이즈에 따라 필수적인 요청 횟수 최적하하기, 3) 다운받을 중요 에셋의 우선순위를 정함으로써 중요 자원 불러오는 순서 최적화하고, 중요 경로 길이 최소화하기","categories":[{"name":"Study","slug":"Study","permalink":"https://joontae-kim.github.io/categories/Study/"},{"name":"Browser","slug":"Study/Browser","permalink":"https://joontae-kim.github.io/categories/Study/Browser/"}],"tags":[{"name":"mdn","slug":"mdn","permalink":"https://joontae-kim.github.io/tags/mdn/"},{"name":"Browser","slug":"Browser","permalink":"https://joontae-kim.github.io/tags/Browser/"},{"name":"Rendering","slug":"Rendering","permalink":"https://joontae-kim.github.io/tags/Rendering/"},{"name":"Critical Rendering path","slug":"Critical-Rendering-path","permalink":"https://joontae-kim.github.io/tags/Critical-Rendering-path/"}]},{"title":"페이지 채우기: 브라우저가 작동하는 방법 - 2","slug":"browser-work-2","date":"2020-09-25T10:14:46.000Z","updated":"2021-09-30T10:47:00.069Z","comments":true,"path":"2020/09/25/browser-work-2/","link":"","permalink":"https://joontae-kim.github.io/2020/09/25/browser-work-2/","excerpt":"","text":"본 글은 mdn web docs의 Populating the page: how browsers work를 번역한 글입니다. 현재 작성일자(2020년 9월 25일) 기준으로 아직 한글로 번역되지 않아 본 번역 포스팅을 완료하면 해당 페이지를 한국어로 옮겨놓을 예정입니다. 수정 및 보완사항이 있다면 본 포스팅 하단 댓글에 작성 부탁드립니다. 브라우저 작동 원리 또는 렌더링에 관해 공부하고, 포스팅하고 싶은 마음이 있었는데 mdn에 좋은 게시물이 많이 있었고 그중 몇 가지를 연재로 번역하면서 공부해보는 시간을 가져볼려고 합니다. 연재할 MDN docs Populating the page: how browsers work Critical rendering path 페이지 채우기: 브라우저 작동원리사용자들은 컨텐츠가 빠르게 로드되고 상호작용이 부드러운 웹 경험을 원합니다. 그러므로 개발자들은 이 두가지 목표를 성취하기 위해서 노력해야만 합니다. 성능과 감지된 성능을 개선하는 방법을 이해하기 위해서는 브라우저가 어떻게 동작하는지 이해하는 것이 도움을 줄 수 있습니다. 파싱 (Parsing)일단 브라우저가 첫번째 데이터 청크를 받고나면, 받은 정보를 분석하기 시작합니다. Parsing 은 네트워크를 통해 전송된 데이터를 DOM 과 CSSOM 으로 변환해야할 단계이며, 렌더러가 화면에 페이지를 그리는데 사용됩니다. DOM은 브라우저의 마크업을 내부적으로 표현한 것입니다. 또한, 외부적으론 Javascript에서 다양한 API들을 통해 재생산될 수도 있습니다. 비록 요청된 페이지의 HTML 사이즈가 초기 14KB 패킷보다 훨씬 클지라도, 브라우저는 분석을 시작할 것이며 데이터를 기반으로 경험을 렌더링하려고 시도할 것입니다. 웹 퍼포먼스 최적화가 중요한 이유는 브라우저가 페이지 또는 적어도 페이지의 템플릿(첫 번째 렌더링에 필요한 CSS와 HTML)을 렌더링하기 위해 필요한 모든 것을 초기 14kb 안에 포함해야 하기 때문입니다. 그러나 화면에 어떠한 것이든 렌더링하기 전에 HTML, CSS 그리고 Javascript를 분석해야만 합니다. DOM 트리 구성하기(Building the DOM tree)우리는 중요 렌더링 경로 에 5 단계로 설명해놨습니다. 첫 번째 단계로 HTML 마크업을 처리하고 DOM 트리를 구성하는 것입니다. HTML 파싱은 tokenization 과 트리 구조를 포함합니다. HTML 토큰은 속성(attribute) 이름과 값 뿐만 아니라 태크의 시작과 끝을 포함하고 있습니다. 만약 도큐먼트(document)가 잘 짜여져 있다면, 파싱은 간단하고 더 빠르게 될 것입니다. 분석기(Parser)는 도큐먼트 내에 도큐먼트 트리로 구성되어진 토큰 처리된 input을 분석합니다. DOM 트리는 도큐먼트의 컨텐츠를 설명합니다. &lt;html&gt; 요소는 첫번째 태그이자 도큐먼트 트리의 root 노드이며 다른 태그들 사이에서 관계성과 위계구조를 반영해줍니다. 다른 태그들 사이에 중첩된 태그들은 자식 노드들입니다. DOM 노드의 수가 많을수록 DOM 트리를 구조화하는 시간은 더 소요됩니다. 분석기가 이미지와 같은 비차단(non-blocking) 자원을 찾으면 브라우저는 이 자원을 요청하고 계속해서 분석합니다. 파싱은 CSS file을 만났을때도 계속되지만 특히 async 또는 defer 속성이 없는 &lt;script&gt; 태그를 만났을 경우에는 렌더링을 멈추고 HTML 파싱을 중단합니다. 비록 브라우저의 프리로드(preload) 스캐너가 이 과정을 가속화하지만 과도한 스크립트는 여전히 심각한 병목현상이 될 수 있습니다. Preload scanner브라우저가 DOM 트리를 구성하는 동안, 이 프로세스는 메인 스레드에서 발생합니다. 이 현상 때문에 Preload scanner 는 사용 가능한 콘텐츠를 분석하고 CSS, Javascript 그리고 웹 폰트와 같은 선순위의 자원을 요청합니다. Preload scanner 덕분에 우리는 분석기가 선순위의 자원을 요청하기 위해 외부 자원에 대한 참조를 찾을때까지 대기하고 있지 않습니다. 메인 HTML 분석기가 요청된 에셋에 도달할 때에는 이미 전송중이거나 또는 이미 다운로드 되었을 수 있도록 백그라운드에서 자원을 획득할 것입니다. Preload scanner의 최적화는 차단시간을 줄여줍니다. 1234&lt;link rel=&quot;stylesheet&quot; src=&quot;styles.css&quot;/&gt;&lt;script src=&quot;myscript.js&quot; async&gt;&lt;/script&gt;&lt;img src=&quot;myimage.jpg&quot; alt=&quot;image description&quot;/&gt;&lt;script src=&quot;anotherscript.js&quot; async&gt;&lt;/script&gt; 이와 같이, 메인 스레드가 HTML, CSS를 분석하는 동안 Preload scanner는 스크립트와 이미지를 검색할 것이고 다운로드 받기 시작할 것입니다. 스크립트가 DOM 트리 구성 프로세스를 막지 않도록 보장하기 위해, 만약 Javascript 파싱 또는 실행 순서가 중요하지 않다면 async 또는 defer 속성을 추가해야 합니다. CSS를 받기 위해 대기하는 것은 HTML 분석 또는 다운로딩은 막지 않지만 Javascript는 종종 HTML 요소에서 CSS 속성을 조회하는데 영향을 끼치기 때문에 막습니다. CSSOM 구성하기중요 렌더링 경로의 두번째 단계는 CSS를 처리하고 CSSOM 트리를 구성하는 것입니다. DOM과 CSSOM은 둘다 트리 구조로, CSS object model은 DOM과 유사합니다. 이 둘은 독립적인 데이터 구조이며 브라우저는 CSS 규칙을 이해할 수 있고 작동할 수 있는 스타일 맵으로 변환합니다. 브라우저는 CSS의 각 규칙 세트를 거치면서 CSS 선택자를 기반으로 부모, 자식 그리고 형제 관계에 있는 노드의 트리를 만듭니다. HTML도 마찬가지로, 브라우저는 수신된 CSS 규칙을 무언가를 작업할 수 있는 것으로 변환해야 합니다. 따라서, HTML-to-object 프로세스를 반복하지만 CSS 또한 반복합니다. CSSOM 트리는 유저 에이전트 스타일시트의 스타일을 포함합니다. 브라우저는 노드에 적용가능한 가장 일반적인 규칙으로 시작하고 보다 구체적인 규칙을 적용함으로써 계산된 스타일을 반복적으로 재조정합니다. 다르게 말해, 속성값은 계단식을 표현됩니다. CSSOM 구축은 매우 매우 빠르고 현재 개발자 도구에서 단일 색상으로 표시되지 않습니다. 대신 개발자 도구의 “보정된 \u001d스타일”은 CSS를 분석하고, CSSOM 트리를 구축하며 회귀적으로 처리된 스타일을 계산하기 위한 모든 시간을 보여줍니다. CSSOM을 만드는 시간이 일반적으로 한개의 DNS 조회를 위해 걸리는 시간보다 덜 걸리기 때문에 웹 퍼포먼스 최적화의 측면에서는 더 쉽다. 다른 프로세스들자바스크립트 컴\u001d파일CSS가 분석되고, CSSOM이 만들어지는 동안 자바스크립 파일을 포함한 다른 에셋들을 다운로드하고 있을 것입니다.(preload scanner 덕분에). 자바스크립트는 해석되고, 변환되며 분석한 후 실행됩니다. 스크립트는 추상적인 문법 트리안에서 분석되고 몇몇의 브라우저 엔진들은 Abstract Syntax Tree(추상적 문법 트리) 를 가지고 있으며 이를 인터프리터 안으로 전달하여 메인 쓰레드에서 실행할 바이트 코드를 출력합니다. 접근성 트리 구성하기브라우저는 또한 보조 장치가 콘텐츠를 분석하고 해석하기 위해 사용되는 접근성 트리를 구성합니다. 접근성 오브젝트 모델(The accessibility object model, AOM)은 DOM의 시멘틱 버전과 같습니다. 브라우저는 DOM이 업데이트 될때 접근성 트리도 업데이트 합니다. 접근성 트리는 보조 기술 그 자체로는 수정할 수 없다. AOM이 구성될떄, 콘텐츠는 screen reader에서 접근할 수 없습니다. 렌더(Render)렌더링 단계는 스타일, 레이아웃, 그리기 그리고 경우에 따라서 합성(compositing)하는 것을 포함합니다. 파싱 단계에서 생성된 CSSOM과 DOM 트리들은 렌더 트리에서 결합되며, 렌더 크리는 표시되는 모든 요소의 레이아웃을 처리하는데 사용되며 화면을 그립니다. 몇 가지 경우에 따라서, 콘텐츠를 그들 스스로의 레이어로 승격하고 합성할 수 있으며 CPU 대신 GPU에서 화면의 일부를 그림으로써 메인 스레드를 확보하여 성능을 향상시킬 수 있습니다. 스타일주요 렌더링 경로의 세번째 단계는 렌더 트리 안에서 DOM과 CSSOM을 결합하는 것입니다. 계산된 스타일 트리 또는 렌더 트리 구조는 각각의 표시되는 노드를 가로지르는 DOM 트리의 root로 시작됩니다. &lt;head&gt; 와 같은 보여지지 않는 태그들과 이 자식 노드들 그리고 유저 에이전트 스타일시트에서 찾아볼수 있는 script &#123; display: none; &#125; 와 같이 display: none 으로 설정되어 있는 특정 노드들은 그들은 렌더된 결과물로써 나타나지 않을것이기 때문에 렌더 트리에 포함되지 않습니다. visibility: hidden 가 적용된 노드들은 공간을 차지함으로써 렌더 트리안에 포함됩니다. 우리는 유저 에이전트 기본값을 덮어쓰기 위한 어떠한 지시사항도 주지 않으므로, 위의 코드 예제에서 script 노드는 렌더 트리에 포함되지 않을 것입니다. 각각의 표시되는 노드들은 적용되는 CSSOM 규칙을 가지고 있습니다. 렌더 트리는 계산된 스타일과 컨텐츠와 함께 표시되는 모든 노드들을 보유하고 있습니다. DOM 트리 안에서 표시되는 모든 노드에 모든 관련 스타일들을 일치시키고, CSS cascade 를 기반으로 계산된 스타일들을 결정합니다. 레이아웃주요 렌더링 경로의 네번째 단계는 각 노드의 위치를 계산하기 위해 렌더 트리에서 레이아웃을 작동시키는 것입니다. 레이아웃 은 너비, 높이 그리고 렌더 트리 안에서 모든 노드들의 위치를 결정하는 과정이며 페이지 안에서 각 오브젝트의 크기와 위치에 대한 결정도 추가됩니다. 리플로우 페이지의 특정 부분 또는 전체 도큐먼트의 어떤 연속적인 크기와 위치에 대한 결정입니다. 일단 렌터 트리가 구성되나면 레이아웃이 시작됩니다. 렌더 트리는 (심지어 보이지 않을지라도) 각 노드들의 계산된 스타일들에 따라 어떤 노드들을 배치할지 인식하지만 각 노드의 차원이나 위치는 아닙니다. 각 오브젝트의 정확한 사이즈나 위치를 결정하기 위해서 브라우저는 렌더 트리의 root에서 시작하며 순회합니다. 웹 페이지 상에서 대부분의 것들은 상자입니다. 디바이스와 데스크탑의 기본 설정이 다르면 뷰포트 크기가 무제한으로 달라질 수 있습니다. 이 단계에선 뷰포트 크기를 고려하여 브라우저가 화면에 표시되는 다양한 상자의 크기를 결정합니다. 뷰포트의 크기를 기준으로 하여 일반적으로 레이아웃은 본문에서 시작하여 각 요소의 박스 모델 속성들에 따라 본문의 모든 하위 자식의 치수를 나열하고, 이미지와 같이 치수를 알지 못하는 대체될 요소를 위해 플레이스홀더 공간을 제공합니다. 노드들의 크기와 위치가 처음으로 결정되면 레이아웃 (layout) 이라고 부른다. 노드 사이와 위치에 대한 연속적인 재계산을 리플로우 (reflow) 라고 부른다. 예를 들어, 초기 레이아웃은 이미지를 불러오기 전에 발생한다고 할 수 있다. 왜냐하면 우리는 이미지의 크기를 결정할 수 없기 때문에, 일단 이미지의 사이즈를 알았을때 리플로우 될 것입니다. 페인트주요 렌더링 경로의 마지막 단계로 화면에서 first meaningful paint 라 불리는 첫번째 현상으로, 각 노드들을 그리는 것입니다. 페인팅 또는 레스터화 단계에서 브라우저는 레이아웃 단계에서 처리된 각 박스를 실제 픽셀로 변환합니다. 페인팅은 화면에서 텍스트, 색깔, 선, 그림자 그리고 버튼이나 이미지와 같은 대체되는 요소들을 포함하는 보여지는 모든 요소를 그리는 것을 포함합니다. 브라우저는 이것을 매우 빠르게 할 필요가 있습니다. 부드러운 스크롤링과 애니메이션을 보장하기 위해서 리플로우와 페인트에 따라 스타일 계산을 포함해 메인 스레드가 담당하는 모든 것이 브라우저에서 16.67ms 미만으로 처리되어야만 한다. 2048 X 1536 크기에서는, iPad는 스크린에 페인트 하기 위해서 3,145,000 이상의 픽셀을 가지고 있으며 매우 빨리 페인트 되어야 하는 많은 픽셀입니다. 리페인팅이 초기 페인트보다 훨씬 빠르게 끝내는 것을 보장하기 위해 일반적으로 스크린에 그리는 것을 몇개의 레이어로 나누고 이를 위해 컴포지팅(compositing)이 필수적입니다. 페인팅은 레이아웃 트리의 요소를 레이어로 나눌 수 있으며 콘텐츠를 CPU의 메인 스레드가 아닌 GPU의 레이어로 승격하면 페인트 및 리페인트 성능이 향상됩니다. 레이어를 인스턴스화 하는 특정 특성과 요소가 있으며 이는 &lt;video&gt; 와 &lt;canvas&gt;, 그리고 CSS 속성 중 opacity 또는 3D transform, will-change 그리고 몇 안되는 다른 요소들을 포함합니다. 이러한 노드는 하위 항목이 위의 이유 중 하나 (또는 그 이상)로 인해 자체 레이어를 필요로하지 않는 한 하위 항목과 함께 자체 레이어에 페인팅됩니다. 레이어들은 성능을 개선하지만 메모리 관리에 있어서는 비용이 따릅니다. 따라서, 웹 성능 최적화 전략의 한 부분으로써 과도하게 사용하지 말아야만 한다. 컴포지팅도큐먼트의 섹션들이 서로 겹쳐서 서로 다른 레이어에서 그려질 때, 컴포지팅은 화면상에서 올바른 순서로 그려지고 콘텐츠가 올바르게 렌더링 되도록 보장하는 것이 필수적입니다. 페이지가 에셋들을 계속해서 불러옴으로써 리플로우가 발생될 수 있다(예제에서 늦게 도착한 이미지를 다시 호출하기 위해). 리플로우는 리페인팅과 리컴포지 하도록 합니다. 만약 우리가 이미지의 크기를 정했다면, 리플로우는 필요하지 않을 것이며 오직 리페인팅될 필요가 있는 레이어를 리페인팅할 것이며 필요할 경우 합성할 수 있습니다. 그러나 우리는 이미지 크기를 포함하고 있지 않습니다! 그 이미지가 서버에서 받았을때 렌더링 과정은 레이아웃 스텝 다시 돌아가고 다시 시작한다. 상호운용성일단 메인 쓰레드가 페이지 그리기를 완료하면, 여러분은 “모든 것”을 갖췄다고 생각했겠지만, 꼭 그런것만은 아닙니다. 만약 불러오기에 정확하게는 지연되고 오직 onload 이벤트에 후에 실행되는 자바스크립트를 포함하고 있을 경우, 메인 스레드는 바빠지고 스크롤링, 터치 그리고 다른 상호작용은 불가능해질지도 모른다. Time to Interactive (TTI)는 페이지가 상호작용할때 DNS 조회와 SSL 연결에 의한 첫번째 요청에서 First Contentful Paint 이후로 50ms 안에 즉시 페이지가 상호작용할때 까지의 시간을 측정한 것입니다. 만약 메인 스레드가 분석, 컴파일링 그리고 자바스크립트 실행까지 담당하고 있다면 이것은 가능하지 않으며 (50ms 미만으로) 제때에 사용자 상호작용에 반응할 수 없습니다. 예를 들어, 아마 이미지가 빠르게 로드 되었다 할지라도, anotherscript.js 파일은 2MB이고 사용자의 네트워크 연결은 느려졌다. 이러한 경우 사용자는 페이지를 매우 빠르게 볼수 있었겠지만 스크립트가 다운로드 될때까지 잰크(jank) 없이는 스크롤할 수 없을 것이고, 좋지 못한 사용자 경험이 됩니다. WebPageTest 예제에서 설명하듯 메인 스레드를 차지하는 것을 피해야 합니다. 이 예제의 DOM 콘텐츠 로드 과정은 1.5 초 이상 소요됐고 메인 스레드는 전체 시간동안 가득 찼으며 스크린 탭 또는 클릭 이벤트에 반응하지 않습니다.","categories":[{"name":"Study","slug":"Study","permalink":"https://joontae-kim.github.io/categories/Study/"},{"name":"Browser","slug":"Study/Browser","permalink":"https://joontae-kim.github.io/categories/Study/Browser/"}],"tags":[{"name":"mdn","slug":"mdn","permalink":"https://joontae-kim.github.io/tags/mdn/"},{"name":"Browser","slug":"Browser","permalink":"https://joontae-kim.github.io/tags/Browser/"}]},{"title":"페이지 채우기: 브라우저가 작동하는 방법 - 1","slug":"browser-work","date":"2020-09-25T06:54:56.000Z","updated":"2021-09-30T10:47:09.391Z","comments":true,"path":"2020/09/25/browser-work/","link":"","permalink":"https://joontae-kim.github.io/2020/09/25/browser-work/","excerpt":"","text":"본 글은 mdn web docs의 Populating the page: how browsers work를 번역한 글입니다. 현재 작성일자(2020년 9월 25일) 기준으로 아직 한글로 번역되지 않아 본 번역 포스팅을 완료하면 해당 페이지를 한국어로 옮겨놓을 예정입니다. 수정 및 보완사항이 있다면 본 포스팅 하단 댓글에 작성 부탁드립니다. 브라우저 작동 원리 또는 렌더링에 관해 공부하고, 포스팅하고 싶은 마음이 있었는데 mdn에 좋은 게시물이 많이 있었고 그중 몇 가지를 연재로 번역하면서 공부해보는 시간을 가져볼려고 합니다. 연재할 MDN docs Populating the page: how browsers work Critical rendering path 페이지 채우기: 브라우저 작동원리사용자들은 컨텐츠가 빠르게 로드되고 상호작용이 부드러운 웹 경험을 원합니다. 그러므로 개발자들은 이 두가지 목표를 성취하기 위해서 노력해야만 합니다. 성능과 감지된 성능을 개선하는 방법을 이해하기 위해서는 브라우저가 어떻게 동작하는지 이해하는 것이 도움을 줄 수 있습니다. 개요빠른 사이트들은 더 나은 사용자 경험을 제공한다. 사용자들은 컨텐츠와 함께 빠르게 로드되고 상호작용이 부드러운 웹 경험을 예상하고 바랍니다. 웹 퍼포먼스에서 두가지 주요한 이슈로는 지연시간(latency)에서 경험하게 될 이슈와 브라우저가 단일 쓰레드로서 갖는 주요한 사실에서 갖는 이슈들입니다. 지연시간은 빠른 로드를 보장하기 위해 극복해야하는 우리의 주요한 위협입니다. 로드을 빠르게 하기 위해 개발자의 목표로는 가능하 한 빠르게 또는 적어도 보기에 매우 빠른 속도로 요청된 정보를 보내는 것을 포함함니다. 네트워크 지연은 바이트(bytes)를 무선에서 컴퓨터로 전송하는 시간을 얘기합니다. 웹 퍼포먼스는 가능한 한 빠르게 페이지 로드가 될 수 있도록 우리가 해야만 하는 가능한 빠르게 되도록 우리가 해야 하는 것입니다. 대부분은 브라우저들은 단일 쓰레드로 간주됩니다. 부드러운 상호작용을 위해 개발자들의 목표는 부드러운 스크롤링에서부터 터치에 반응하는 것까지 효율적인 사이트 상호작용을 보장하는 것입니다. 렌더링 시간의 핵심은 우리가 부여한 모든 작업을 메인 쓰레드가 완료할 수 있도록 보장하는 것과 항상 사용자 상호작용에 대처할 수 있도록 하는것입니다. 웹 퍼포먼스는 브라우저의 단일 쓰레드의 성질을 이해하고, 메인 쓰레드의 업무를 부드러운 렌더링과 상호작용에 즉시 반응할 수 있도록 보장하기 위해 가능한 그리고 적절한 범위내로 최소화함으로써 개선할 수 있습니다. 네비게이션네비게이션은 웹 페이지 로딩에 있어서 첫번째 단계입니다. 언제든지 사용자가 주소바에 URL을 입력함으로써 페이지를 요청할때, 링크를 클릭할때, 폼을 제출하거나 다른 행동을 취할때마다 발생합니다. 웹 퍼포먼스의 첫번째 목표는 탐색이 완료되는 시간을 최소화 하는 것입니다. 이상적인 조건에서는 이건 보통 오래 걸리지 않지만 지연시간과 인터넷 접속 속도는 지연을 야기할 수 있는 적입니다. DNS 조회웹 페이지를 탐색하는 첫번째 단계는 페이지에 배치되어 있는 자산(asset)들이 어디에 있는지 찾는 것입니다. 여러분이 https://example.com 를 탐색한다면, HTML 페이지는 93.184.216.34 라는 IP 주소에 서버를 두고 있을것입니다. 만약 여러분이 이 사이트를 절대로 방문하지 않았었다면, DNS 조회는 반드시 발생해야만 합니다. 여러분의 브라우저는 차례대로 IP 주소에 의해 반응하기 위해 최종적으로 네임서버에 지정된 DNS 조회를 요청할 것입니다. 이러한 초기 요청 이후, IP는 지속적인 요청 속도를 올리기 위해서 네임서버로 다시 접속하는 대신 캐시로부터 IP 주소를 획득함으로써 한동안 캐시될 것입니다. DNS 조회는 보통 페이지 로드를 위해 호스트네임 당 오직 한번만 수행될 필요가 있습니다. 하지만 DNS 조회는 요청된 페이지 참조의 각각의 유일한 호스트네임을 위해 완료되야만 합니다. 만약 당신의 폰트, 이미지, 스크립트, 광고 그리고 메트릭스 등 모든 것들이 다른 호스트네임을 갖고 있다면, DNS 조회는 각각의 것들을 위해 이루어져야 합니다. 이러한 작업은 특히 모바일 네트워크 환경에서 성능에 있어서 문제를 유발할 수 있습니다. 사용자가 모바일 네트워크 환경에 있다면, 각각의 DNS 조회는 권한이 있는 DNS 서버에 도달하기 위해 휴대전화에서 기지국까지 가야만 합니다. 휴대전화, 기지국 그리고 네임서버 간의 거리는 막대한 지연시간을 추가합니다. TCP 핸드쉐이크 (TCP Handshake)일단 IP 주소를 알고 있다면, 브라우저는 TCP three-way handshake 를 통해 서버 연결을 설정합니다. 이러한 메커니즘은 두개의 엔터티가 소통하기 위한 설계입니다–브라우저와 서버의 경우에– 종종 HTTPS 를 거쳐 네트워크 TCP 소켓 연결의 매개변수(parameter)를 협상할 수 있습니다. TCP’s three way handshaking 기술은 종종 “SYN-SYN-ACK”(또는 더 정확하게는 SYN, SYN-ACK, ACK)이라고 부릅니다. 왜냐하면 그리고 시작하기 위해 두 컴퓨터 사이에서 TCP 세션을 시작하고 협상하기 위해 TCP에 의해 전송된 세가지 메시지가 있기 때문입니다. 즉, 세가지 이상의 메시지들이 각각의 서버 사이에서 오고 간다는 것을 의미하며 해당 요청은 아직 완료되지 않았다는 것입니다. TLS 협상HTTPS를 통해 설정된 안전한 연결을 위해서 또 다른 “Handshake”이 필요합니다. 이 Handshake 또는 TLS Negotiation은 통신을 암호화하고, 서버를 식별하며 데이터의 전송이 실질적으로 이루어지기 전에 제때 안전한 연결(secure connection)이 설정되도록 사용할 암호(cipher)를 결정합니다. 이러한 작업들은 요청된 콘텐츠가 실제로 전송되기 전에 서버에 3회 이상의 왕복을 요구합니다. 통신을 보안화하는것이 페이지 로드에 시간을 추가하는 반면에, 브라우저와 웹 서버 사이에 전송된 데이터가 서드 파티(third party)에 의해 암호 해독이 될수 없으므로 보안화된 연결(secure connection)의 시간지연 비용은 가치있다. 8번의 왕복 이후에 브라우저는 최종적으로 요청을 완료할 수 있다. 응답일단 우리가 웹 서버와 접근을 설정하고 있다면 , 브라우저는 유저를 대신해 초기 HTTP GET request 를 전송합니다. 웹사이트의 경우 HTML 파일이 대부분 입니다. 일단 웹 서버가 요청을 받으면, 관련 응답(response) 헤더와 HTML 콘텐츠를 응답할 것입니다. 1234567891011121314151617&lt;!doctype HTML&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;/&gt; &lt;title&gt;My simple page&lt;/title&gt; &lt;link rel=&quot;stylesheet&quot; src=&quot;styles.css&quot;/&gt; &lt;script src=&quot;myscript.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;h1 class=&quot;heading&quot;&gt;My Page&lt;/h1&gt; &lt;p&gt;A paragraph with a &lt;a href=&quot;https://example.com/about&quot;&gt;link&lt;/a&gt;&lt;/p&gt; &lt;div&gt; &lt;img src=&quot;myimage.jpg&quot; alt=&quot;image description&quot;/&gt; &lt;/div&gt; &lt;script src=&quot;anotherscript.js&quot;&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 초기 요청에 대한 응답은 획득한 데이터의 첫번째 바이트를 포함하고 있습니다. Time to First Byte (TTFB)는 사용자가 요청한 시간(링크를 클릭함으로써)과 HTML의 첫번째 패킷의 수신 사이의 시간입니다. 첫번째 콘텐츠의 청크는 보통 데이터의 14kb 입니다. 위 예제에서, 요청은 확실히 14Kb 미만이지만 다음에서 언급할 분석(parsing) 중에는 브라우저가 링크를 찾을때까지 연결된 리소스는 요청되지 않습니다. TCP Slow Start / 14kb rule첫번째 응답 패킷은 14kb 일것입니다. 이건 네트워크 연결 속도의 균형을 잡기위한 알고리즘인 TCP slow start 의 일부분입니다. Slow Start는 네트워크의 최대 대역폭이 결정될때까지 전송되는 데이터의 양을 점진적으로 증가시킵니다. 초기 패킷의 수신 이후에 TCP slow start 에서, 서버는 다음 패킷를 약 28kb 까지 두배로 키웁니다. 미리 지정된 스레드홀드에 도달하거나 정체가 발생할때까지 후속 패킷의 크기는 증가할 것입니다. 만약 여러분이 초기 페이지 로드에 대한 14kb 규칙을 들은적이 있다면, TCP Slow Start는 초기 응답이 14kb인 이유이기도 하며 웹 퍼포먼스 최적화가 이러한 초기 14kb 응답을 염두에 두고 최적화에 초점을 맞춰야하는 이유이기도 합니다. TCP slow start는 혼잡을 피하기 위한 네트워크 수용능력을 위해 점진적으로 전송 속도를 알맞게 구성합니다. 혼잡 관리서버가 TCP 패킷에 데이터를 보낼때, 사용자의 클라이언트는 승인 또는 ACK를 반환하여 전달을 확인합니다. 이 연결은 하드웨어와 네트워크 조건에 따라 제한된 수용력을 가지고 있다. 만약 서버가 매우 빠르게 매우 많은 패킷을 보낸다면, 그들은 멈출것입니다. 즉, 인식하지 못할것입니다. 서버는 이것을 분실된 ACK(missing ACKs)로 등록합니다. 혼잡 관리 알고리즘(Congestion control algorithms)은 전송된 패킷과 ACK의 흐름을 사용하여 전송 속도를 결정합니다. mdn 원본 페이지의 콘텐츠가 너무 길다고 판단되어 DOM과 CSSSOM에 대한 내용을 다룰 Parsing 부분은 ‘페이지 채우기: 브라우저가 작동하는 방법 - 2’ 에서 다루겠습니다.","categories":[{"name":"Study","slug":"Study","permalink":"https://joontae-kim.github.io/categories/Study/"},{"name":"Browser","slug":"Study/Browser","permalink":"https://joontae-kim.github.io/categories/Study/Browser/"}],"tags":[{"name":"mdn","slug":"mdn","permalink":"https://joontae-kim.github.io/tags/mdn/"},{"name":"Browser","slug":"Browser","permalink":"https://joontae-kim.github.io/tags/Browser/"}]},{"title":"assignment","slug":"assignment","date":"2020-09-24T16:32:27.000Z","updated":"2020-10-25T09:41:52.431Z","comments":true,"path":"2020/09/25/assignment/","link":"","permalink":"https://joontae-kim.github.io/2020/09/25/assignment/","excerpt":"","text":"Private Assignment Post google analytics &amp; console 연동하기 https://futurecreator.github.io/2016/06/15/hexo-google-site-search-console-analytics/ https://github.com/ppoffice/hexo-theme-hueman/wiki/Plugins#google-analytics https://futurecreator.github.io/2016/06/17/google-search-how-to-work/ Hexo Generator Alias https://simhyejin.github.io/2016/06/30/hexo-generator-alias/ https://github.com/hexojs/hexo-generator-alias Hexo Server Auto Restart https://hexo.io/docs/commands#server https://januszhou.github.io/2016/10/19/auto-restart-hexo-server/ script in package.json Javascript - execution contexts http://dmitrysoshnikov.com/ecmascript/chapter-1-execution-contexts/ https://dailyworker.github.io/fundamental-JS-ES6/ https://velog.io/@imacoolgirlyo/JS-%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8%EC%9D%98-Hoisting-The-Execution-Context-%ED%98%B8%EC%9D%B4%EC%8A%A4%ED%8C%85-%EC%8B%A4%ED%96%89-%EC%BB%A8%ED%85%8D%EC%8A%A4%ED%8A%B8-6bjsmmlmgy https://baeharam.github.io/posts/javascript/jsexecution-context/ Javascript - closure","categories":[{"name":"assignment","slug":"assignment","permalink":"https://joontae-kim.github.io/categories/assignment/"}],"tags":[{"name":"assignment","slug":"assignment","permalink":"https://joontae-kim.github.io/tags/assignment/"}]},{"title":"seo-friendly - Again Hello","slug":"seo-friendly","date":"2020-09-24T06:51:47.000Z","updated":"2020-09-29T12:48:02.975Z","comments":true,"path":"2020/09/24/seo-friendly/","link":"","permalink":"https://joontae-kim.github.io/2020/09/24/seo-friendly/","excerpt":"","text":"자. 이번 포스팅은 Github 블로그의 검색엔진 최적화에 대해 다뤄보도록 하겠습니다. hexo plugin 에는 SEO 작업을 위해 아래와 같은 plugin이 존재하고 저는 제가 필요로 하는 몇가지만 세팅해봤습니다. hexo-generator-feed hexo-generator-seo-friendly-sitemap hexo-generator-robotstxt hexo-auto-canonical 그럼 오늘도 시작해봅시다! 1. hexo-generator-feedhexo-generator-feed는 Atom 1.0 또는 RSS 2.0 형식의 feed를 생성해주는 자동 생성해주는 Plugin으로 Atom, RSS 그리고 Feed의 의미는 대략 아래와 같다. Feed는 자주 업데이트되는 디지털 컨텐츠를 사용자에게 제공하는데 사용하는 문서 포멧으로 배포를 목적으로 Feed를생성함으로써 Syndicate(배급) 및 Publish(출판) 한다. Feed는 읽거나 Subscribe(구독)한다. 다양한 형식으로 Feed가 제공될 수 있으나 일반적으로 RSS 2.0, ATOM 1.0, RSS 1.0이 사용된다. @네이버블로그_G1Softm.blog.naver.com/PostView.nhn?blogId=estern&logNo=110145610169&proxyReferer=https:%2F%2Fwww.google.com%2F 일단 설치해봅니다.1npm install hexo-generator-feed --save 설정 문제 없이 설치가 완료됐다면 블로그 디렉토리 root level에 있는 _config.yml 에 아래와 같이 세팅해보겠습니다. 123456789# RSS, ATOM auto generatorfeed: type: - atom - rss2 path: - atom.xml - rss2.xml limit: 20 위 설정들은 아래와 같고 hexo generate 명령어를 통해 publish 해주면 public 폴더안에 다음의 이미지와 같이 생성되는 것을 확인하실 수 있을겁니다. (git ignore 상태라 파일이름이 흐린점 양해부탁 드립니다.) - type: 생성할 feed 유형 - path: feed 파일을 생성할 위치 _(generate 될때의 디렉토리 기준 )_ - limit: 각 feed 유형에 담길 content의 개수 ⚠️ 그리고 여기서 주의할 점이 만약 블로그 디렉토리 root level에 있는 _config.yml 에서 아래 사진과 같이 자신으 github blog url 로 설정해주지 않으면 feed xml 파일이 생성될때 최초 설정값인 http://example.com 을 참조해서 xml content url을 생성합니다. 그러므로 제가 설정한 아래와 같이 자신의 블로그 url 변경해주셔야 합니다. 2. hexo-generator-seo-friendly-sitemap구글이나 네이버 검색엔진이 블로그의 전체적인 구조를 알 수 있도록 하려면 사이트맵 XML 파일을 제출해야 하는데 deploy 할때마다 sitemap.xml 을 생성해주는 plugin입니다. 설치1npm install hexo-generator-seo-friendly-sitemap --save 설정12sitemap: path: sitemap.xml 기본 옵션 구성은 위와 같으며 sitemap 생성시 페이지, 포스트, 카테고리, 태그에 대한 내용까지 생성해주며, 별도로 생성하고 싶지 않은 부분이 있다면 아래와 같이 설정할 수 있습니다. 1234sitemap: path: sitemap.xml tag: false category: false 3. hexo-generator-robotstxtrobots.txt 또한 sitemap.xml 과 같이 SEO에 있어서 기본적인 부분입니다. 간략히 의미와 역할에 대해 짚고가자면, robots.txt 는 웹사이트에 대한 검색엔진 로봇들의 접근을 조절해주고 제어해주는 역할, 그리고 로봇들에게 웹사이트의 사이트맵이 어디 있는지 알려주는 역할을 합니다. 주의하실 점은 여기서 말하는 사이트 맵은 수집 로봇을 위한 XML 사이트 맵을 말하며, 웹사이트의 메뉴 전체를 보여주는 사이트 맵을 의마하는 것은 아닙니다. robots.txt 파일을 설정하지 않으면 구글, 네이버 등 각종 검색엔진 로봇들이 웹사이트에서 찾을 수 있는 모든 정보를 크롤링하여 검색엔진 검색결과에 노출시킵니다. 만약 웹사이트 내 특정 페이지가 검색엔진에 노출되지 않기를 바란다면 robots.txt파일을 설정하여 이를 제어할 수 있습니다. @Robots.txt와 Sitemap.xml 알아보기 G1Softwww.twinword.co.kr/blog/basic-technical-seo 이제 robot.txt 에 대한 설정에 대해 보자면 기본적으로 아래의 값들을 이용해 수집 허용 또는 비허용을 설정할 수 있습니다. User-agent Allow Disallow robots.txt 규칙 예제 다른 검색엔진의 로봇에 대하여 수집을 허용하지 않고 네이버 검색로봇만 수집 허용으로 설정합니다. 1234User-agent: *Disallow: &#x2F;User-agent: YetiAllow: &#x2F; 모든 검색엔진의 로봇에 대하여 수집 허용으로 설정합니다. 12User-agent: *Allow: &#x2F; 사이트의 루트 페이지만 수집 허용으로 설정합니다. 123User-agent: *Disallow: &#x2F;Allow: &#x2F;$ 관리자 페이지, 개인 정보 페이지와 같이 검색로봇 방문을 허용하면 안 되는 웹 페이지는 수집 비허용으로 설정해주세요. 아래 예제는 네이버 검색로봇에게 /private-image, /private-video 등은 수집하면 안 된다고 알려줍니다. 12User-agent: YetiDisallow: &#x2F;private*&#x2F; 모든 검색로봇에게 사이트의 모든 페이지에 대하여 수집을 허용하지 않는다고 알려줍니다. 이 예제는 사이트의 어떠한 페이지도 수집 대상에 포함되지 않으므로 권장하지 않습니다. 12User-agent: *Disallow: &#x2F; sitemap.xml 지정내 사이트에 있는 페이지들의 목록이 담겨있는 sitemap.xml의 위치를 robots.txt에 기록해서 검색 로봇이 내 사이트의 콘텐츠를 더 잘 수집할 수 있도록 도울 수 있습니다. 123User-agent: *Allow: &#x2F;Sitemap: http:&#x2F;&#x2F;www.example.com&#x2F;sitemap.xml 자 이제 설치를 해봅시다.1npm install hexo-generator-robotstxt --save 설정먼저 블로그 디렉토리 root level에 있는 _config.yml 의 plugins에 hexo-generator-robotstxt 를 추가해 활성해주고 robots.txt 를 생성할때 참고할 속성들을 그 밑에 추가해줍니다. 1234robotstxt: useragent: &quot;*&quot; allow: sitemap: &#x2F;sitemap.xml 4. hexo-auto-canonicalhexo로 만들어진 블로그의 SEO를 위한 표준 링크(canonical link)를 HEAD 태그 내에 삽입해주는 plugin 입니다. 설치1npm install --save hexo-auto-canonical 설정hueman 테마의 경우 themes/hueman/layout/common/head.ejs 안에 아래의 코드를 삽입하면 됩니다. 참조 https://github.com/ppoffice/hexo-theme-hueman/wiki/Installation https://alleyful.github.io/2019/08/10/tools/hexo/hexo-guide-03/ https://futurecreator.github.io/2016/06/23/search-engine-optimization-hexo-plugins/ https://www.twinword.co.kr/blog/basic-technical-seo/ https://searchadvisor.naver.com/guide/seo-basic-robots https://github.com/HyunSeob/hexo-auto-canonical","categories":[{"name":"Blog","slug":"Blog","permalink":"https://joontae-kim.github.io/categories/Blog/"},{"name":"Hexo","slug":"Blog/Hexo","permalink":"https://joontae-kim.github.io/categories/Blog/Hexo/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://joontae-kim.github.io/tags/Hexo/"},{"name":"Blog","slug":"Blog","permalink":"https://joontae-kim.github.io/tags/Blog/"},{"name":"SEO","slug":"SEO","permalink":"https://joontae-kim.github.io/tags/SEO/"}]},{"title":"Change theme - Again Hello","slug":"change-theme","date":"2020-09-23T17:09:20.000Z","updated":"2020-09-29T12:48:42.536Z","comments":true,"path":"2020/09/24/change-theme/","link":"","permalink":"https://joontae-kim.github.io/2020/09/24/change-theme/","excerpt":"","text":"먼저 theme를 바꾸는 작업을 어렵지 않았습니다. hexo cli를 통해 생성된 모든 블로그 폴더내에는 theme 라는 폴더를 가지고 있고 이 안에 변경할 theme를 내려받으면 됩니다. 1git clone https:&#x2F;&#x2F;github.com&#x2F;ppoffice&#x2F;hexo-theme-hueman.git themes&#x2F;hueman 그리고 블로그의 theme를 변경하려면 블로그 디렉토리의 root level에 있는 _config.yml 에서 theme를 hueman으로 변경한 다음 hueman 디렉토리에서 theme 환경설정을 위해 _config.yml.example 파일을 복붙 해서 _config.yml 을 생성해줍니다. 그럼 아래와 같이 두개 가 생성됩니다. blog 를 위한 _config.yml theme/hueman 을 위한 _config.yml 이제 테마가 잘 연결되었는지 확인! theme는 항상 느끼는거지만 고르는게 어려웠고, 그보다 더 어려웠던건 역시 Setting…개발하다보면 항상 Setup과 Setting 이 오래걸리고 복잡해서 시간을 많이 잡아먹는거 같다. 일단 hueman 의 공식문서를 참고해보면 기본적으로 menu와 customize 로 구분한다. 먼저 메뉴 란 블로그에 접속했을때 유저가 직접적으로 접근할 수 있는 네비게이션바와 같은 역할로 hueman 디렉토리 레벨에서의 _config.yml에서 추가 및 삭제할 수 있다. 12345678# Menusmenu: Home: / # Delete this row if you don&#x27;t want categories in your header nav bar # Categories: About: /about/index.html+ GitHub: https://github.com # 주소는 절대주소 또는 상대주소 모두 사용할 수 있다. theme 커스터마이징을 해보자. 공식문서 를 통해 확인해보면 Logo, Theme Color, Sidebar 등등 여러 가지를 수정할 수 있다고 합니다. 먼저 검색 기능을 시작으로 몇 가지만 수정해보도록 하겠습니다. 검색기능위 메뉴바 이미지의 우측에 보면 검색 기능을 확인할 수 있습니다. 기본적으로 Insight Search 기능을 제공해주고, 활용하기 위해서는 아래의 plugin을 설치한 후 hueman 디렉토리 레벨의 _config.yml 에서 검색기능을 설정되있는지 확인 또는 활성화해줘야 합니다. 1npm install -S hexo-generator-json-content 12345# Searchsearch: insight: true swiftype: baidu: false 로고로고는 사실 있어도 되고 없어도 되지만 일단 블로그의 명패 같은 역할이니 간단하게라도 만들어서 넣어보는것도 좋을거 같습니다. 일단 저는 여기서 약간 헷갈린것이 logo의 파일 위치와 크기였는 themes/hueman -&gt; source -&gt; css -&gt; images 위치에 있으며 대체할 logo 이미지도 같은 위치에 저장 후 url을 수정해주면 될거 같습니다. width와 height는 로고의 위치와 크기를 잡기 위한 약간의 삽질이 필요합니다. 1234logo: width: 165 height: 60 url: images/logo-header.png 썸네일블로그 내에서 포스트의 썸네일을 사용할지 말지를 정할 수 있습니다. 마찬가지로 hueman 디렉토리 레벨의 _config.yml 에서 수정 가능합니다. 썸네일을 활성화 했을경우 post의 front-matter에 추가함으로써 해당 포스트의 thumbnail으로 작동합니다. 123title: Hello Worlddate: 2013/7/13 20:46:25+ thumbnail: https://example.com/image.jpg 위젯위젯 또한 hueman 디렉토리 레벨의 _config.yml에서 수정가능하다. 1234567widgets: - recent_posts # 최근 포스트 - category # 카테고리 - archive # 어카이브 - tag # 태그 - tagcloud # 태그클라우드. 사용된 태그들을 빈도수에 따라 구름처럼 표시 - links # 링크 disqusgithub 블로그에 댓글 기능을 제공하기 위해서 대표적인 서비스인 disqus 를 세팅해줍니다. 먼저 계정이 없다면 계정을 생성합니다. GET STARTED 버튼을 클릭한 후 hueman 디렉토리 레벨의 _config.yml 에서 disqus 에 입력하기 위한 short_name 으로 블로그 이름 설정합니다. (자세한 과정은 https://simhyejin.github.io/2016/06/24/hexo-themes/ 에서 Disqus 파트 참조) 12345# Commentcomment: disqus: [example_short_name] # enter disqus shortname here duoshuo: # enter duoshuo shortname here youyan: # enter youyan uid here 이상으로 hueman 테마를 사용하면서 기본적으로 갖춰볼만한 설정들을 모두 했고, 다음으로는 구글에서 잘 검색되도록 하기위한 세팅들을 다뤄보겠습니다. 참조 https://github.com/ppoffice/hexo-theme-hueman/wiki/Installation https://simhyejin.github.io/2016/06/24/hexo-themes/ https://simhyejin.github.io/2016/06/24/hexo-themes/","categories":[{"name":"Blog","slug":"Blog","permalink":"https://joontae-kim.github.io/categories/Blog/"},{"name":"Hexo","slug":"Blog/Hexo","permalink":"https://joontae-kim.github.io/categories/Blog/Hexo/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://joontae-kim.github.io/tags/Hexo/"},{"name":"Theme","slug":"Theme","permalink":"https://joontae-kim.github.io/tags/Theme/"}]},{"title":"Again Hello","slug":"Again-Hello","date":"2020-09-23T07:49:07.000Z","updated":"2020-09-29T12:50:28.211Z","comments":true,"path":"2020/09/23/Again-Hello/","link":"","permalink":"https://joontae-kim.github.io/2020/09/23/Again-Hello/","excerpt":"","text":"고민고민 끝에 GitHub 블로그를 Renewal 해버리게 되었다.개인플젝 개발을 마무리하고 블로그에 공부할것 &amp; 공부했던 것들을 정리해야지 했지만 아무리 봐도 이전에 수정하다가 실패한 clean-blog theme 스타일 때문에 거슬려서 이참에 theme를 변경했다. 아니 아예 갈아엎었고, 백업 환경까지 구성했습니다. 작업을 하면서도 의구심이 들었다. “괜히 일만 더 키우는게 아닐까?”, “이럴 시간에 공부한거 정리하던가 강의 들으면서 정리하는게 낫지 않을까?”. 하지만 그래도 다 하고보니 개운해서 다행이다. 그렇다면 어디서부터 어디까지 갈아엎은걸까? 나중에 위해서라도 또는 다른 분들을 위해서라도 정리해보겠습니다. Renewal 범위 theme 변경 clean-blog -&gt; hueman hueman 테마 커스터마이징 blog root &amp; theme 백업하기 (형상관리 by github) About 페이지 만들기 구글 Analytics &amp; Search Console 등록하기 blog 파일 in root 수정시 hexo server 자동 재시작하기 사실 위의 과정은 구글에서 검색해보면 좋은 포스팅들이 많고 잘 따라해보면 쉽지만… 막상 따라하다보면 이게 이걸 말하는건가 싶은 점이 있어서 날 위해 그리고 앞으로 하실 분들을 위해 정리해보려고 합니다.","categories":[{"name":"Blog","slug":"Blog","permalink":"https://joontae-kim.github.io/categories/Blog/"},{"name":"Hexo","slug":"Blog/Hexo","permalink":"https://joontae-kim.github.io/categories/Blog/Hexo/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://joontae-kim.github.io/tags/Hexo/"},{"name":"Renewal","slug":"Renewal","permalink":"https://joontae-kim.github.io/tags/Renewal/"},{"name":"Theme","slug":"Theme","permalink":"https://joontae-kim.github.io/tags/Theme/"}]},{"title":"Hello World","slug":"hello-world","date":"2020-09-22T10:51:30.861Z","updated":"2020-09-29T12:51:00.912Z","comments":true,"path":"2020/09/22/hello-world/","link":"","permalink":"https://joontae-kim.github.io/2020/09/22/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[{"name":"Blog","slug":"Blog","permalink":"https://joontae-kim.github.io/categories/Blog/"},{"name":"Hexo","slug":"Blog/Hexo","permalink":"https://joontae-kim.github.io/categories/Blog/Hexo/"}],"tags":[{"name":"Hello World","slug":"Hello-World","permalink":"https://joontae-kim.github.io/tags/Hello-World/"}]}],"categories":[{"name":"Blog","slug":"Blog","permalink":"https://joontae-kim.github.io/categories/Blog/"},{"name":"Job","slug":"Blog/Job","permalink":"https://joontae-kim.github.io/categories/Blog/Job/"},{"name":"Programming","slug":"Programming","permalink":"https://joontae-kim.github.io/categories/Programming/"},{"name":"nuxt","slug":"Programming/nuxt","permalink":"https://joontae-kim.github.io/categories/Programming/nuxt/"},{"name":"Algorithm","slug":"Programming/Algorithm","permalink":"https://joontae-kim.github.io/categories/Programming/Algorithm/"},{"name":"Javascript","slug":"Programming/Javascript","permalink":"https://joontae-kim.github.io/categories/Programming/Javascript/"},{"name":"Study","slug":"Study","permalink":"https://joontae-kim.github.io/categories/Study/"},{"name":"Rendering","slug":"Study/Rendering","permalink":"https://joontae-kim.github.io/categories/Study/Rendering/"},{"name":"Webpack","slug":"Study/Webpack","permalink":"https://joontae-kim.github.io/categories/Study/Webpack/"},{"name":"Blog To Read","slug":"Blog/Blog-To-Read","permalink":"https://joontae-kim.github.io/categories/Blog/Blog-To-Read/"},{"name":"Basic","slug":"Programming/Basic","permalink":"https://joontae-kim.github.io/categories/Programming/Basic/"},{"name":"course","slug":"course","permalink":"https://joontae-kim.github.io/categories/course/"},{"name":"node_all_in_one","slug":"course/node-all-in-one","permalink":"https://joontae-kim.github.io/categories/course/node-all-in-one/"},{"name":"Hexo","slug":"Blog/Hexo","permalink":"https://joontae-kim.github.io/categories/Blog/Hexo/"},{"name":"Browser","slug":"Study/Browser","permalink":"https://joontae-kim.github.io/categories/Study/Browser/"},{"name":"assignment","slug":"assignment","permalink":"https://joontae-kim.github.io/categories/assignment/"}],"tags":[{"name":"Front-end","slug":"Front-end","permalink":"https://joontae-kim.github.io/tags/Front-end/"},{"name":"Interview","slug":"Interview","permalink":"https://joontae-kim.github.io/tags/Interview/"},{"name":"Job","slug":"Job","permalink":"https://joontae-kim.github.io/tags/Job/"},{"name":"Javascript","slug":"Javascript","permalink":"https://joontae-kim.github.io/tags/Javascript/"},{"name":"vue.js","slug":"vue-js","permalink":"https://joontae-kim.github.io/tags/vue-js/"},{"name":"nuxt.js","slug":"nuxt-js","permalink":"https://joontae-kim.github.io/tags/nuxt-js/"},{"name":"nuxt","slug":"nuxt","permalink":"https://joontae-kim.github.io/tags/nuxt/"},{"name":"data fetching","slug":"data-fetching","permalink":"https://joontae-kim.github.io/tags/data-fetching/"},{"name":"vue","slug":"vue","permalink":"https://joontae-kim.github.io/tags/vue/"},{"name":"project","slug":"project","permalink":"https://joontae-kim.github.io/tags/project/"},{"name":"portfolio","slug":"portfolio","permalink":"https://joontae-kim.github.io/tags/portfolio/"},{"name":"bootstrap","slug":"bootstrap","permalink":"https://joontae-kim.github.io/tags/bootstrap/"},{"name":"bootstrap-vue","slug":"bootstrap-vue","permalink":"https://joontae-kim.github.io/tags/bootstrap-vue/"},{"name":"layout","slug":"layout","permalink":"https://joontae-kim.github.io/tags/layout/"},{"name":"Algorithm","slug":"Algorithm","permalink":"https://joontae-kim.github.io/tags/Algorithm/"},{"name":"알고리즘","slug":"알고리즘","permalink":"https://joontae-kim.github.io/tags/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/"},{"name":"data structure","slug":"data-structure","permalink":"https://joontae-kim.github.io/tags/data-structure/"},{"name":"data","slug":"data","permalink":"https://joontae-kim.github.io/tags/data/"},{"name":"structure","slug":"structure","permalink":"https://joontae-kim.github.io/tags/structure/"},{"name":"자료 구조","slug":"자료-구조","permalink":"https://joontae-kim.github.io/tags/%EC%9E%90%EB%A3%8C-%EA%B5%AC%EC%A1%B0/"},{"name":"Queue","slug":"Queue","permalink":"https://joontae-kim.github.io/tags/Queue/"},{"name":"큐","slug":"큐","permalink":"https://joontae-kim.github.io/tags/%ED%81%90/"},{"name":"linked list","slug":"linked-list","permalink":"https://joontae-kim.github.io/tags/linked-list/"},{"name":"링크드 리스트","slug":"링크드-리스트","permalink":"https://joontae-kim.github.io/tags/%EB%A7%81%ED%81%AC%EB%93%9C-%EB%A6%AC%EC%8A%A4%ED%8A%B8/"},{"name":"big-O","slug":"big-O","permalink":"https://joontae-kim.github.io/tags/big-O/"},{"name":"time complexity","slug":"time-complexity","permalink":"https://joontae-kim.github.io/tags/time-complexity/"},{"name":"빅오","slug":"빅오","permalink":"https://joontae-kim.github.io/tags/%EB%B9%85%EC%98%A4/"},{"name":"시간 복잡도","slug":"시간-복잡도","permalink":"https://joontae-kim.github.io/tags/%EC%8B%9C%EA%B0%84-%EB%B3%B5%EC%9E%A1%EB%8F%84/"},{"name":"javascript","slug":"javascript","permalink":"https://joontae-kim.github.io/tags/javascript/"},{"name":"oop","slug":"oop","permalink":"https://joontae-kim.github.io/tags/oop/"},{"name":"prototype","slug":"prototype","permalink":"https://joontae-kim.github.io/tags/prototype/"},{"name":"object","slug":"object","permalink":"https://joontae-kim.github.io/tags/object/"},{"name":"프로토타입","slug":"프로토타입","permalink":"https://joontae-kim.github.io/tags/%ED%94%84%EB%A1%9C%ED%86%A0%ED%83%80%EC%9E%85/"},{"name":"new","slug":"new","permalink":"https://joontae-kim.github.io/tags/new/"},{"name":"contructor","slug":"contructor","permalink":"https://joontae-kim.github.io/tags/contructor/"},{"name":"new 생성자","slug":"new-생성자","permalink":"https://joontae-kim.github.io/tags/new-%EC%83%9D%EC%84%B1%EC%9E%90/"},{"name":"lifecycle","slug":"lifecycle","permalink":"https://joontae-kim.github.io/tags/lifecycle/"},{"name":"nuxt lifecycle","slug":"nuxt-lifecycle","permalink":"https://joontae-kim.github.io/tags/nuxt-lifecycle/"},{"name":"Rendering","slug":"Rendering","permalink":"https://joontae-kim.github.io/tags/Rendering/"},{"name":"CSR","slug":"CSR","permalink":"https://joontae-kim.github.io/tags/CSR/"},{"name":"SSR","slug":"SSR","permalink":"https://joontae-kim.github.io/tags/SSR/"},{"name":"Client Side Rendering","slug":"Client-Side-Rendering","permalink":"https://joontae-kim.github.io/tags/Client-Side-Rendering/"},{"name":"Server Side Rendering","slug":"Server-Side-Rendering","permalink":"https://joontae-kim.github.io/tags/Server-Side-Rendering/"},{"name":"webpack","slug":"webpack","permalink":"https://joontae-kim.github.io/tags/webpack/"},{"name":"CompressionWebpackPlugin","slug":"CompressionWebpackPlugin","permalink":"https://joontae-kim.github.io/tags/CompressionWebpackPlugin/"},{"name":"compression","slug":"compression","permalink":"https://joontae-kim.github.io/tags/compression/"},{"name":"asset","slug":"asset","permalink":"https://joontae-kim.github.io/tags/asset/"},{"name":"image","slug":"image","permalink":"https://joontae-kim.github.io/tags/image/"},{"name":"lecture","slug":"lecture","permalink":"https://joontae-kim.github.io/tags/lecture/"},{"name":"reference","slug":"reference","permalink":"https://joontae-kim.github.io/tags/reference/"},{"name":"자바스크립트","slug":"자바스크립트","permalink":"https://joontae-kim.github.io/tags/%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8/"},{"name":"Network","slug":"Network","permalink":"https://joontae-kim.github.io/tags/Network/"},{"name":"object-oriented-javascript","slug":"object-oriented-javascript","permalink":"https://joontae-kim.github.io/tags/object-oriented-javascript/"},{"name":"Object","slug":"Object","permalink":"https://joontae-kim.github.io/tags/Object/"},{"name":"function","slug":"function","permalink":"https://joontae-kim.github.io/tags/function/"},{"name":"arrow function","slug":"arrow-function","permalink":"https://joontae-kim.github.io/tags/arrow-function/"},{"name":"javascript engine","slug":"javascript-engine","permalink":"https://joontae-kim.github.io/tags/javascript-engine/"},{"name":"execution context","slug":"execution-context","permalink":"https://joontae-kim.github.io/tags/execution-context/"},{"name":"execution","slug":"execution","permalink":"https://joontae-kim.github.io/tags/execution/"},{"name":"context","slug":"context","permalink":"https://joontae-kim.github.io/tags/context/"},{"name":"type","slug":"type","permalink":"https://joontae-kim.github.io/tags/type/"},{"name":"types","slug":"types","permalink":"https://joontae-kim.github.io/tags/types/"},{"name":"Variable","slug":"Variable","permalink":"https://joontae-kim.github.io/tags/Variable/"},{"name":"Hoisting","slug":"Hoisting","permalink":"https://joontae-kim.github.io/tags/Hoisting/"},{"name":"Scope","slug":"Scope","permalink":"https://joontae-kim.github.io/tags/Scope/"},{"name":"ECMAScript","slug":"ECMAScript","permalink":"https://joontae-kim.github.io/tags/ECMAScript/"},{"name":"ECMAScript 2015","slug":"ECMAScript-2015","permalink":"https://joontae-kim.github.io/tags/ECMAScript-2015/"},{"name":"ES6","slug":"ES6","permalink":"https://joontae-kim.github.io/tags/ES6/"},{"name":"ECMAScript 6","slug":"ECMAScript-6","permalink":"https://joontae-kim.github.io/tags/ECMAScript-6/"},{"name":"ES2015","slug":"ES2015","permalink":"https://joontae-kim.github.io/tags/ES2015/"},{"name":"Babel","slug":"Babel","permalink":"https://joontae-kim.github.io/tags/Babel/"},{"name":"course,javascript","slug":"course-javascript","permalink":"https://joontae-kim.github.io/tags/course-javascript/"},{"name":"Hexo","slug":"Hexo","permalink":"https://joontae-kim.github.io/tags/Hexo/"},{"name":"Blog","slug":"Blog","permalink":"https://joontae-kim.github.io/tags/Blog/"},{"name":"draft","slug":"draft","permalink":"https://joontae-kim.github.io/tags/draft/"},{"name":"mdn","slug":"mdn","permalink":"https://joontae-kim.github.io/tags/mdn/"},{"name":"Browser","slug":"Browser","permalink":"https://joontae-kim.github.io/tags/Browser/"},{"name":"Critical Rendering path","slug":"Critical-Rendering-path","permalink":"https://joontae-kim.github.io/tags/Critical-Rendering-path/"},{"name":"assignment","slug":"assignment","permalink":"https://joontae-kim.github.io/tags/assignment/"},{"name":"SEO","slug":"SEO","permalink":"https://joontae-kim.github.io/tags/SEO/"},{"name":"Theme","slug":"Theme","permalink":"https://joontae-kim.github.io/tags/Theme/"},{"name":"Renewal","slug":"Renewal","permalink":"https://joontae-kim.github.io/tags/Renewal/"},{"name":"Hello World","slug":"Hello-World","permalink":"https://joontae-kim.github.io/tags/Hello-World/"}]}